 Hey, this is Marcus with BittWare and I have an A10PL4 board. It's got an Intel Arria 10 FPGA, and I want to show you how we can use this FPGA board to accelerate a find and replace function hundreds or even thousands of times faster than on a CPU. Now you've probably heard that although FPGAs have excellent acceleration potential--they're very difficult to program. In fact, you may have heard that you really need your own FPGA developer to create whatever application that you need. But these days there are other options as well. There are platforms and frameworks to allow you to use an application without having to do FPGA programming yourself. One example of that we're going to see today is in a find and replace accelerator. So this one is called Hyper FiRe and let me show you first of all the hardware that we're going to run. So this is the server we'll run on. This is at TeraBox 1000S. It's a 1U server; very good for development. We've got our A10PL4 already inside. This actually has room for a double-slot FPGA board as well. And this server also has a Xeon E3 processor. So this is our hardware setup, and so let's now start looking at the demo. So let me just take a minute to explain the application that we're going to be running in this demo. So this is a find and replace accelerator called Hyper FiRe and it's part of a search IP core called Axonerve from the company Nagase. Now normally with an IP core you'd be responsible for bringing your own FPGA development to make it work. But as I mentioned, today we have options such as platforms and frameworks if we want to avoid that development to cost or time. So here we're going to be using the quick play platform by Accelize. So, let's see how it works. So as I mentioned Hyper FiRe is a find and replace accelerator. So this is going to be my input. I've got this text file with a DNA sequence. So all of these letters are going to be replaced. So that's my input file and then the find and replace input is here. So for each three-letter DNA sequence, it's going to replace it over here with an amino acid. So let's run it first on the CPU. So now it's running 64 find and replace lines on the CPU and that's about a seven megabyte file on the input. Okay, so it finished so you can see on my output all of those DNA groups-- the codons--have been replaced by the correct amino acid. So that's my output and we can see it took 8.7 seconds on this Xeon E3 CPU. Now, let me run it on the FPGA. So it actually already ran. It only took 58 milliseconds which is about a 17th of a second So if you think about that: 58 milliseconds versus 8.7 seconds... ...that's about 150 times faster on the FPGA So now let's change the data set, and find and replace, to see a little bit more of how this works So in this demo, I have a text file with the complete works of Shakespeare. So this is about a five megabyte file ...complete works of Shakespeare...and what we're going to find and replace is... ...on this file here. So instead of 64 find and replace commands we're going to run 500. So we're doing a simple translation for 500 different words and let's run that first on a CPU. So again, keep in mind the file size of the input hasn't changed a lot It went from seven megabytes to five, but the difference is we're running it on five hundred find/replace terms instead of the 64. So we need a fast-forward a bit actually for the CPU. We're going to let it run here. Okay, so now I'm finished. We have our find and replace complete on the CPU and let's look at how long it took. So a little over 27 seconds. Alright, so let's run the same thing on the FPGA. And again it's done. So this time on the FPGA... ...it took actually less time than before. So it was 58 milliseconds before. Now it's running at 54 milliseconds. But essentially the same amount of time. That reduction is probably from the seven megabytes to five megabytes. But again, we're talking about hundreds of times faster than the CPU. So that was using 500 find and replace terms, let's try it 2,500. So it's taking the same 5 megabyte input, but now we're replacing 2500 lines so the CPU has started on that and again, we're gonna have to fast forward. Okay, so the CPU completed and let's see how long it took. So that was two minutes and 24 seconds or around 144 seconds. So now let's run the same on the FPGA. Okay, so we ran it on the FPGA and just like before we ran it in 54 milliseconds. So despite the fact that the CPU took a lot longer because there was 2,500 find and replace terms, 2,500 replaced terms didn't make a bit of difference to the FPGA because again you're working with parallelism. So 500 search terms 2,500 search terms doesn't matter. It's still 54 milliseconds. So relative from the FPGA to the CPU, it's actually thousands of times faster for this particular demo. So now I want to show you one more demo and we're going to change the input file this time. It's still going to be Shakespeare, but we've copied the works of Shakespeare 250 times. So instead of a 5 megabyte file, we have a 1.4 gigabyte file. Now again, we're going to run 2,500 find and replace terms. But because this is such a large file the CPU is going to take hours and hours to do this, so we're only going to run it on the FPGA. So as our input file grows the FPGA does take longer. But because of the parallelism, it doesn't really matter how many find and replace terms you have from one to 2,500 in this case So now we're done. So the larger file actually took 13.8 seconds on the FPGA. But again--compared to the CPU, the CPU would take hours to get this data set done. So again--thousands of times faster when you're running it on this FPGA. So let me summarize what we've just seen. So we were using the Hyper FiRe application, which is part of the Axonerve IP core from Nagase. But instead of having to develop our own FPGA code to interface to that we use the Accelize QuickPlay platform, which was already set up for this Hyper FiRe application and a range of other applications. Now QuickPlay allows Accelize to develop their own applications using software-defined FPGA development. And, of course, on the hardware side We were running our BittWare A10PL4 board which has an Intel Arria 10 FPGA and our TeraBox 1U--the 1000S--server. So for more information about these FPGA boards from BittWare, visit BittWare.com. For more information about the applications from Accelize visit Accelize.com, and thank you for watching. 