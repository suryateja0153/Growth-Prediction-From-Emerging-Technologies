 Researchers in quantum information often use a simplified diagram in order to talk about surface codes. It can be a little bit difficult for people who are beginners in the field to know exactly what is being discussed  in terms of the number of physical qubits, the number of logical qubits and the distance of a surface code given the diagram alone. So, we are going over the calculation  method quickly just to see how everything works. Now to start from the very basics, let's recall that X times Z is equal to minus Z times X, where X and Z are the two by two Pauli matrices that we have been discussing throughout the course. We can very quickly, and if you are not following along don’t worry about it, we can define stabilizer codes to be a set of code states Psi in the code C, such that S times Psi is equal to Psi for every operator s in a big S, which is a set of stabilizer operators. So, we say that s stabilizes Psi because Psi is the plus 1 eigenstate of s, for all of the little s’s in this big group of s’s. And that is nice, and you can do a lot of classically efficient computations with this, but the really nice property is that this allows you to detect errors. Let's assume that first of each of these s’s is going to be some multiqubit Pauli operator, and that E, an error that may or may not occurred, is also a multiqubit Pauli operator. What happens if we try to measure S and there is an E here that anticomuttes with S, the same way X does with Z. If you go through this math for some  specific example or if you do it, in general, using only the fact that E times S is equal to minus S times E and that E squared, like al multiqubit Pauli's, is the identity. You will end up getting minus 1. Now if this error had not occurred, not producing the state E Psi, but rather Psi this would be plus 1. And this means that as long as we are working with the stabilizer code, errors are going to have a physically measurable effect on the system. So, how do we make a surface code? We begin with a square array of qubits that we layout here, and then we start defining stabilizers. Here is a weight two stabilizer of the form Z Z on these two qubits. We have a weight four stabilizer of the form X X X X on these four. And similarly, local stabilizers are defined all over the lattice. This arrangement of stabilizers and data qubits becomes this surface code picture. And typically, people will include a little legend to let you know which of these letters corresponds to which of these colors because it is not clear a priority. So, here I have used black tiles to host Z stabilizers and I have used white tiles to host X stabilizers. Here we can see the weight two  stabilizers that are going around the perimeter and the weight four stabilizers that are on the interior. The logical operators for this code run all the way over one side of the square or the other. Depending on which color is which you might have different logical operators on different sides, but here the logical Z operator runs down the right side of the tile and the logical X operator runs across the top. And they are both weight three because we are dealing with a three by three square. How do you calculate n, k, and d for a surface code? n is simply the length in the x-direction times the length in the z-direction. So, in this case, it is 3 times 3, which is 9. An important thing to remember is not to count the number of squares that are in a row, but rather the number of qubits that are in arow. So, here we have 9 total. k, the number of logical qubits is always 1 for these codes. There are some ways to get k not to be 1, but they are too advanced to cover in this course. And d, the code distance, is the minimum side length of this square. Which is either lx or lz, whichever smaller the minimum. And in this case that is 3. So, as you can see, square tiles are nice when error rates are equal, and you want to have an equal distance for both X and Z logical operators. 