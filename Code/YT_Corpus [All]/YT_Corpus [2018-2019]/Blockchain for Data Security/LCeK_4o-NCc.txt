 [Music] all right so welcome and this lecture we're gonna cover ouroboros proof of steak we're gonna start from the origins of the protocol and then take it to roberto Sprouse which we present this year and then to the next evolution of the protocol which sees Ouroboros Genesis let me start with the concept of a robust transaction ledger which is the problem that pecan protocol solves so the formalization of the of the problem was itself like an interesting question which was something that we tackled a few years ago already now this was work that was with one kuroneko's leonardo's that was the first formal definition of the objective of a robust transaction ledger now this work which you can find it here basically set out a crisp model and an objective that a ledger protocol has to meet and after that worked it was a number of other papers that took that model and improved it in a number of ways and I'll just mention it through a few of them that came out of the years afterwards mainly the definitions were further refined partial synchrony was considered and finally there was a composable definition that was presented just in the summer last year at crypto so what does it take to realize the ledger so realizing the letter is something that us you can expect it can be achieved by Bitcoin Bitcoin itself the Bitcoin protocol was the inspiration for defining this problem nevertheless this solution also I should say came out in retrospect at least somewhat unexpected the problem itself was never considered in this setting the problem of consensus or the problem of having a ledger of that type that Bitcoin solves so you might actually if you look at the theoretical results in its ability systems literature you might even consider that result as impossible even though that we knew that the barrier without using some type of public infrastructure was one third of the number of parties that might be malicious and Bitcoin was achieving that but with a threshold that was going close to 50% so despite this remarkable feature of the protocol to provide us consensus in this setting there are significant scalability and energy efficiency disadvantages that the protocol has so the clear question came to be once we have this and we understand the problem that the protocol solves is it possible to realize it in a more efficient way without fundamentally compromising any of the basic assumptions and the features of the objective that the protocol tries to solve so proof of stake was an idea that early on by the Bitcoin community was considered as an alternative and in the Bitcoin forum were many discussions about how it might be feasible to use that in place of proof of work which is in the case of Bitcoin so a little bit of background about what is proof of stake now if you look at the way that the blocks in protocol works in Bitcoin it's a little bit like an election so what happens is that the next entity that is going to produce the block and it's going to be added to the blockchain is elected and in some sense is elected with probability proportional to its hashing power so basically the more hassle power you have the more chances you have of being elected and produced the next block now collisions so to speak may occur the system is the centralized there is no coordination between the parties that are running the protocol and the protocol itself is designed to be able to absorb such collisions to absorb such a momentary temporary disagreements between the parties so all that is fundamentally based on this concept of proof of work so modifying this is what proof of stake is about so using stake which is a virtual resource instead of housing power which is a physical resource is at the core of the POS idea so well in powa proof of work we're going to have the set of stakeholders being the miners in some sense this will be substituted by those that have stake which is reported in the ledger and once we have this then we have to come up with a randomized process that is capable of emulating basically the same election idea that naturally comes in the proof-of-work domain so this idea proved to be very powerful and motivated a number of people to propose a lot of protocols for implementing the proof of stake concept so there are two fundamental approaches here that you can consider proof of stake the one is a proof of state blockchain where basically what you try to do is think in the same way that the Bitcoin blockchain works and use proof of stake in a way that does not jeopardize any of the features that the proof-of-work protocol provides an examples of these protocols is roberto's the protocol I'll be talking about today snow white next and a number of others the other approach is based on classical piddling fault tolerant protocols which can somehow be upgraded to operate in the POS setting and an example of that is Al Gore and so both approaches are POS since what what is important here is that participation in the protocol is based on your stake as that stake is reported in the ledger so POS didn't come without his controversy there was an early folklore idea that was discussed among many people that were working in the Bitcoin space that POS block chains are fundamentally impossible to work and the main deficiencies or vulnerability that people were pointing at where can be pointed can be summarized in these costly simulation vulnerability that the POS has intrinsically and the ability of attackers to mount what's called long-range attacks let me just explain in a bit more detail what are those so of course the simulation basically suggests that in the absence of proof of work proof of stake after roll is a proof of a virtual resource there is nothing that prevents you from doing this over and over perhaps in parallel multiple times so a fundamental difference between a proof of work based block 10 in a POS based blockchain is the fact that in the proof of work case the all parties they have to commit to a certain protocol execution and advance that execution or using their proof of work algorithm that's not the case in POS and it's not the case because it's really cost less or nearly cost less to execute the POS protocol thus in principle the adversary has really literally nothing at stake and is capable of advancing multiple different executions of the protocol so that it finds one that is the most favorable and that could lead to what has been called like a long range attack so basically in a long range attack you have a victim node that tries to distinguish between two or ten of the histories which are furnished by the network without having access to recent information and recent information here is key I mean if you are constantly online you have a good understanding about what is communicated in the network nevertheless imagine that you join the network after a big here toes or basically you're just a new node that doesn't have any other information about what was going on and in that case you face the bootstrapping problem how do you are you able to synchronize with the right blockchain without having any recent information so just understand how this counts like in practice so here is just a visual depiction of this bootstrapping from Genesis problem where you have the Genesis block let's say you have a new party and the new party now tries to find what is the right history he doesn't have any information about the protocol until at least the for further search you can even say the Genesis block and now you have the honest parties which are providing this blockchain that you see at the top and then you have the adversary that is providing the blockchain at the bottom so what we want is that a new party presumably honest would like to join the top version of the history the only information the new party has is the Genesis block and he's faced with that decision so how does this work in the proof-of-work world so what happens in the proof-of-work world is that what you can prove is that the main chain the part the chain as maintained by the honest parties is going to have the most blocks or to be more precise is going to have an aggregate difficulty which is higher than the alternative chain so basically the other celebration will be substantially shorter counting difficulty is length and that will enable the party to just connect to the correct blockchain so this is a very powerful idea and you see in some sense relies intrinsically on the fact that this is a long blockchain represents aggregate proof of work and the resources of the honest parties are assumed to be in strict majority so basically the majority of the hashing power is with the parties that follow the protocol while the adversary is in the minority of the hashing power clearly this argument would not work if things were otherwise and there was an adversary that has the majority of us in power so this setting suggests the following model for understanding how blocks and protocols operate which we call dynamic availability so dynamic availability is a setting where we analyze a block protocol that suggests an environment that parties will join and leave at will there is a number of offline and online parties that dynamically change over time they may lose clock synchronization they may lose their network connection and there will be no a priori knowledge of the participation at any given time so the blockchain setting is dynamic availability is what people would like these protocols to work on so we have to see how proof-of-work compares to proof of stake with respect to dynamic availability so let's see compare for example the Bitcoin protocol with a POS blockchain or a POS BFT protocol now in terms of setup assumptions there is a first difference a Bitcoin protocol uses a common random string as it is frequently called in the cryptographic literature or basically the Genesis block contains a random string and that is common and shared by all the parties around the protocol on the other hand in the case of a POS blockchain and or POS beef dip Oracle what we assume as a starting point is a public key directory so in both cases this is a Sirte sumption and the difference lies on the fact that the common random string is basically can just be a string in the sky something that is random unpredictable to the moment it appears and everybody agrees on that whereas the public key directory basically it is what it is is basically a set of keys that have been accumulated and they provide the route of trust of the system so this is a fundamental difference between powa POS and this is something that is going to remain so this is like something that typifies let's say the proof of work concept and the POS concept nevertheless in both cases this is a setup assumption and as long as we're capable of somehow ensuring that this setup assumption is there then the whole protocol is is going to be hopefully safe after that long range attacks though how do they deal with long range attacks so in the case of Bitcoin and a proof-of-work based blockchain the longest chain rule is sufficient for the same reason I told you so basically a party that is bootstrapping from Genesis and potentially faces a long range attack I will just follow the blockchain that has the biggest number of blocks or the highest difficulty and it will be can be shown that it connects to the right blockchain unfortunately what happens in the POS domain things are not as simple so there are a number of assumptions that people have used to deal with long range attacks and you will see that many of them are not quite satisfactory mostly is that the longest chain rule for example that is used in POS blockchain is not sufficient and what is frequently assumed by these papers essentially all POS papers in one way or another is what we can call a local moving Check Point so essentially the parties are assumed to not diverge to any alternative blockchain compared to the history they have so they have basically a recent block that they trust and they just remain that perhaps that's a block that has naturally evolved because they are online all the time or it's a block that they heard from another node in the sense that requirement means that if you are not online all the time you will have no way of having such recent informations at local checkpoint and thus someone will have to provide you that and that would be basically an assumption that when you are initialized in such a POS blockchain you'll have to get some trusted information now this is fundamentally different from the pows setting at least in all these previous protocols another requirement is to have key evolving signatures which is something that doesn't exist in pure W but it is something that we know cryptographically how to design if we look at the same question at the POS B of T case we also want key evolving signatures but now a different requirement can up what happens in the BFD case is essentially that the nodes that are running the protocol agree on all blocks that means that you do not have Forks because every time that you produce a block there is sufficient agreement about that so you do not have to resolve such type of collisions or disagreements that we were having to deal with in the prop 10 setting nevertheless in order to run such protocols you'll have to have a good understanding of what is the level of participation so this points to this deficiency is that you see are described in this slide so while dynamic availability is feasible in the pows setting using only the Genesis block and the POS blocked in setting rejoining parties would need a somewhat recent block whereas in the POS PFD setting parties will need to know participation level at all times in history and these are both strong requirements that hurt this general setting of dynamic availability that APO W proof-of-work paste blocks ain't like Bitcoin works so in summary POS blockchain so far they need to have additional advice to do this bootstrapping from Genesis information the longest chain rule in itself is insufficient while POS BFT the level of actual participation needs to be known throughout so and the reason as I mentioned it that this BFT protocols they have to rely on these counting decisions that need accurate estimates of participation so all this is the motivation for the new version of the robots protocol that we call uroboros genesis so the new version of the protocol is exactly dealing with this problem of dynamic availability and the intention is to see whether it is feasible to produce a POS blockchain that is capable of natively working in the same setting as Bitcoin so the robber of Tennessee purple is a new milestone in the line of Roberto Spears based blockchains the protocol is based on Boris brows which will be presented in Europe 2018 and the robe Boris protocol which was presented in 2017 and crypto the main novel feature is that we design a new change selection rule that enables parties to bootstrap from Genesis so let's take a step back and see how the robots protocol works so the protocol was designed together with a formal proof that realized the functionality of a robust transaction ledger and that's one of the fundamental distinctions that was put in place in the design of the protocol so we designed the protocol together with a proof that the protocol is capable of realizing a disability ledger the proof strategy involves properties of the underlying box and data structure and these are properties that are shared with a Bitcoin proof-of-work analysis common prefix chain quality and chain growth these are the fundamental properties that previous work has identified as the important building blocks for arguing security for blocks and protocols the analysis pairs the owners parties against an adversary that controls a malicious coalition of parties that is in the minority in terms of stake and furthermore the adversary has complete network dominance in the sense that is capable of delaying messages and acting after all the owners parties the assumption that is done flow for the network is that messages are eventually delivered so there is an upper bound in the delay of the network which is not known to the participant that within which parties will actually receive messages so it's not possible to stifle information from being propagated in the network so the design of all robots protocols follows this structured staged approach that comes as follows first the protocol is an initial analysis is performed in a setting where state is static so it's basically like we freeze the stake of everyone and we see how the protocol works then we use randomness randomness source which you can think otherwise unspecified like a randomness beacon that at regular intervals emits a predictable value and we show how we can basically bootstrap the protocol they base the stage one protocol that is static stake to a setting where stake is allowed to move and evolve over time and then finally at stage three we'll show how it's possible to remove the assumption of the beacon and using cryptography or some type of cryptographic implementation show how the protocol itself can emulate the beacon so here's an example of the static state segment or how it might advance so what you see here is a sequence of blocks that are produced in time starting from the leftmost side where we have a Genesis block let's say that's b0 that you see on the left side of this of the screen and then moving on the time moves forward to the right what happens is that every moment in time every heartbeat of the protocol there is a certain party that is identified and is capable of producing one of the blocks so that assumption is happening for most of the moments in the protocol but there will be also moments by design that will also be silent for example this is what you see in the fourth in the fourth time moment in that sequence in that time window here what happens and when you are elected to produce a block then you issue a block using essentially just a digital signature and that is distributed to the other parties that are running the protocol now that block is connected to the previous block that an entity knows if there are points in time within the protocol model we call them slots so if there are slots where nobody is elected then this by definition is going to be a silent slot but there might be also slot where multiple parties are elected at the same time the election process itself is based on a randomized process which initially it is seeded by the Genesis block so this is how the first segment of the protocol let's say advanced and if you also want to think about it this is the first few moments of protocol execution conflicts are bound to occur and the protocol uses a simple longest chain rule to choose what is the correct history so once we have this in place here is how the evolving stage of the protocol will take place which uses a randomness beacon that regularly emits unpredictable values so what you have is a sequence of blocks that are produced in the static setting where basically stake is assumed to be frozen and then what happens is that the beacon value is merged and in some sense refreshes the randomness that will produce the next segment now what happens is that during that time the stake that is assumed to provide the safety of the protocol is assumed to be frozen but the real stake is not assumed to be frozen and it's possible to flow arbitrarily between the participants what we do is that when we are about to go to the onset of the next stage of the protocol which in our technology is called an epoch their protocol looks at the stake as it has of volved in the first epic and then creates the steak that will provide the safety of the second netbook and this is what happens and now you would go into that recursively in an indefinite cycle there is another basic list they call a distribution that has evolved from the first step of guaranteeing the safety of the second epoch and the protocol advances in this fashion when we are ready for the next epoch again we look at the ledger collect the stakeholders produce the next round on this value and so forth finally in some cryptographic fashion we need to show how the Bitcoin itself can be implemented so let's look take a dive to be deeper and see how the security analysis works if you look at the protocol execution as I described it you can think of a string that we call a characteristic string every heartbeat every moment in time can be assigned one of three values zero means if the parties that follow the protocol on that slot one is when the adversarial coalition controls that slot and the next sign bottom means that nobody controls that slot so this is a type of a random sequence that is produced based on this election process that the protocol is utilizing so let's see how a possible protocol execution can go what happens is that little graphs like the one that I'm presenting here and we call them Forks naturally emerged from such characteristic strings so let's examine how this comes to be so here on the Left we have the Genesis block and that's in a sense the root of this of this tree like graph what happened at time 1 there was an honest party that produced block 1 now observe that the next is silent and now let's examine what happens when the next honest party is activated which is at slot number five so the adversary served block free to that honest party and thus the honest party at slot five abandoned the block that was produced by party one and adopted an extended a different one that happens because the adversary enjoying network dominance and delivering blocks in advance is capable of delivering its own blockchain which extends from slot three the Genesis block to the party at slot five let's see what happened at seven here is another honest party at seven that is served by the adversary to block number six that block number six extends one and last the chain at extended by party five is abandoned party eight observe here what what happens here is a situation where you have honest parties at five and seven but party eight chooses to extend the block one what happened here is that the adversary could exploit network delay and have party eight receive the block produced by party one without seeing the blocks produced by parties five and seven so here is a situation where network delay puts the adversary at an advantage finally as the adversary moves on we have an extension of the block from party eight by an adversarial party at position 12 and finally adversary search block 12 - the honest party that extended up slot 14 what happens now in this picture is the following we've managed to take a protocol execution and substitute it with this tree like graph this tree like graph emerges naturally from the randomized process that uses the characteristics drink the nice feature of this is that we can study now the properties of these discrete structures in order to understand the security of the protocol how can we show eventually that the protocol converges to a single history because this is what is the fundamental question so drawing from Bitcoin analysis what happens is that random walks play a fundamental role and a one-dimensional random walk actually is is what you can find at the core of the security analysis of Bitcoin so this random walk you can think of it as follows imagine that there are the bad guys and the good guys every time that the bad guys find a proof-of-work you can imagine that there is this random walk advancing upwards let's say they're equal at the beginning starting for instance from the Genesis block and then the parties that follow the adversary the adversarial coalition will advance this proof of work upwards with a certain probability which is how much they can find the proof of work at the same time the good guys will pull the random walk downwards whenever hopefully they play produce a block it turns out that this is not quite the case what happens is that indeed there is a pool of this random walk downwards every time almost every time the honest parties find a proof of work the reason that this probability is gamma a not equal to alpha with the probability that honest parties found the proof of work is the fact that honest parties pay the price of being decentralized and here this paying the price of being decentralized you can see by the fact that gamma is approximately alpha minus alpha square where alpha square is the probability of two or more honest parties colliding around the same time and producing a block together so we cannot use these moments if you want still if we make the assumption and the fundamental assumption that is done in papers that analyze the security of Bitcoin is that if gamma is strictly bigger than better this random walk is going to get a strong pull downwards and the onus parties will win so here is an inspiration from the analysis of Bitcoin so now the question is can we apply this logic to the POS setting unfortunately winning a block for the honest parties does not necessarily constitute they move to the left in the random walk and the main reason actually is what we cite at the beginning costless simulation so the adversary may reuse an opportunity to issue a block in multiple paths of the fork exactly because this costs him nothing so you can have bad situations like the one demonstrated in this graph below and that's like a pathological execution of the protocol will basically see what happens the adversary just owns three out of the total eight blocks which are shown here and still is capable in producing a situation that completely forks the blockchain despite the fact that he is in the minority in terms of ownership of slots what happens is the reason of costly simulation slot 3 & 4 are can be used in two separate block chains without the adversary actually having to pay twice for that and that's the fundamental issue of how costly simulation comes here and spoils the analysis or if you want the proof logic that was used in the case of Bitcoin nevertheless what we've shown is that is possible to overcome that but we need a more complex analysis the complex analysis that we did in the Ouroboros lines of papers uses the following features and studies these graph structures that represent the protocol execution there are three important quantities that are relevant when you study a protocol execution like this one every part that you see in the execution will have these quantities measured the first one we call it gap the gap is we look at a certain path in the execution and we say how far it is from the leading one that's the gap concept the reserve concept on the other hand says if we look at a certain path how many slots are still at the full control of the adversary and the adversary might use them to advance that path forward in that particular case for the top path you see there is three slots and finally if you see you subtract gap from reserve to say how what is the reach of that specific path so that path here has reached minus one which represents the fact that it's a bit too short by one to win over the leading path so if we are in such a situation and you are an honest node that follows longest chain rule you will not be able to fool by the adversary and adopt and adopt the top branch you will follow using longest chain rule the branch that was extended by player at slot nine a similar situation happens with the lowest branch and then at the end if we look at the whole execution we look at two concepts the first one we call it reach which is the maximum reach across all times and the other we call it margin which basically says what is the second best disjoint reach what we would like is that the margin is always below zero that would be a setting like in this particular one that the adversary will not be able to fool an honest party that tries to connect in this protocol execution in any owners party that connecting that particular execution is going to go and extend the slot that was the block that was produced by the party at slot 9 so recent margin are the two fundamental quantities that are interesting when we analyze these protocol executions and we can show that the adversary will win if and only if the margin which is the second best disjoint reach of a certain protocol execution is at least zero what is interesting now is that these two quantities together define a random walk which is even though more complex that the random walk we analyzed in the case of Bitcoin it still has some good features that we can exploit to prove security so here is how the random walk is defined so it's a two-dimensional random walk and what happens is the following reach a margin when the adversary wins the slot they advance forward so basically both of the quantities they go +1 so that's like they stand out one-dimensional behavior the adversary wins the slot or wins a block then things are towards its favor on the other hand when did virtually loses a slot things are more nuanced the one-dimensional behavior would suggest that we just go minus 1 so what you see in the third branch here of this equation but that's not what happens in fact reads and Mart's and decrements only you in one of the possible cases but what happens is that first of all reach will never drop below zero and that's by definition but what happens very interestingly from the adversarial point of view is that the adversary can prevent the margin from going negative by sacrificing reach so essentially what happens is that the adversary can make margin stick to zero by using the quota if you want that he has accumulate in terms of reach this completely describes the random walk and here is a picture of it so what you see in this picture is how now the probabilistic process that the characteristics things suggest in the protocol will induce a random walk in this region margin quantities what happens is that the adversary wins when you go when he gets a slot and now you and when the adversary wins you see a move of the random walk towards the upper-right of this diagram that's the better moves that you see here and now you see what happens with the gamma moves the gamma moves is when basically the the honest part is win a slot and this gamma is a similar parameter to the one we've seen the Bitcoin analysis now when you are in the upper right and you get a gamma transition what happens is that initially you can follow the same one-dimensional behavior so better goes upwards to the right and gamma pulls leftmost to the bottom nevertheless when we have the situation that margin hits zero it's possible for the adversary to prevent the margin from going zero and as we saw in the previous slide sacrifice reach to maintain the margin to be nonzero so somehow the adversary has a little pool to prevent this random walk from escaping to minus infinity as it happened before but nevertheless what we have still be able to show is that despite the fact that this random walk is more complex that the one inhabits in Bitcoin we can still prove that the random walk will escape to minus infinity in the case of margin and that means that the longest saying rule is is going to enable the parties to converge to the same protocol history so this gives you the picture of what was happening before robbers genesis was was suggested the new change selection rule take this idea of longest chain and deals with long-range attacks so all the analysis which we've seen so far essentially deals with short-range concerns and up to this case this analysis completely covers us nevertheless for long-range comparisons where it sends diverts let's say from more than K blocks for K is the security parameters we have to use a different rule to select the right chain and here is the novel change selection rule which I'll explain to you with this diagram that we have design for Ouroboros Genesis so when you have going back to this bootstrapping from Genesis question which is the fundamental question that a node that joins the network would like to resolve you're dealing with the choice as you see in the right you have to change that you have to do and they are forking at a certain point now if this fork is kind of recent that's like a short-range attack if you want or a disagreement between nodes that was just produced naturally because of network conditions then the longest chain rule will apply on the other hand if the fork is bigger than K blocks the following plenitude type of rule is used we go to the moment where the chains diverge and then shortly thereafter we isolate a certain region of blocks and we see in this region which is defined in the time domain which of the two chains is more dense and that's the plenitude rule the party is going to follow that saying that is denser in the time domain despite the fact that that chain might have a multitude number of blocks later on so this is how the plenitude rule works so what is interesting about this is that this rule is still quite simple to implement it's still a quite simple rule and enhances the longest chain rule in a way that is still quite easy to program so what's the intuition the intuition and what we proved in the protocol is that if the majority of parties follow the protocol then at any sufficiently long time segments the corresponding chain of the honest parties world will be denser especially after a fork so adversarial block chains will be shortly after the divergence point will exhibit a less dense block distribution and we can use that rule to determine what is the right block chain to connect to so going back and remembering the picture I showed you before about what was happening before POWs POS what robbers genesis does is that it changes the way that a POS protocol can operate in a dynamic availability environment and does away with the requirement that you need to know a recent block in order to connect to the right history of the protocol so here is the biggest advance that the robbers genesis protocol offers and for the first time we can say now that POS block chains can operate in the same dynamic availability setting that we know the Bitcoin proof of work based blockchain to operate so this was a very quick overview of Robert Genesis there is more to come in row burrows research and I'll just mention very quickly some of the research streams that you'll be hearing soon and follow our following up on the work that we're doing now importantly the incentive structure and delegation stake pools of the protocol is a work that we'll be releasing soon site change software updates and ecosystem sustainability is another important research direction that is also coming up smart contracts and domain-specific languages for these POS block chains a permission version of the robust blockchain is is also underway and finally looking at how POS blockchains char dinners can be scalable in the most general term of more general term of the of scalable sense is something that is also on our plate so with this thank you for your attention and I look forward to telling you more about our research in a coming video [Applause] [Music] [Music] you 