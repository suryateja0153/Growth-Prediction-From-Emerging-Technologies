 hello everybody and thank you for joining in this session I'm going to be talking to you about how graphs can help you approach your data lineage projects so what are we going to cover why is data lineage important and some of the challenges that we face implementing it a brief introduction to the property graph database why and how graph databases are great fit for supporting and being a part of your data lineage projects and a high-level example of how we might go about linking data so why do we care about data lineage data lineage is an important component in many projects and programs of work it helps to define the rules about how our master data is being created processed and used it helps us to understand what our data is being exchanged what data is being exchanged and consumed we want to make sure that reports and insights who desert derived from business intelligence is not being created from stell corrupt or wrong data much of the reddit or compliances organizations need to attend to such as GDP are have data lineage components as a core part of their being and so forth essentially all of these examples are more we need to understand the data journey from its source to destination we want to know how the data is being used and how it transforms we also want to try and cut down on unnecessary data duplications and inaccuracies and so on and there are a number of challenges that we face when we look to implement data lineage for example the business definition and the actual physical implementation can look very very different the data that we're looking at can be federated from different sources and coming from different applications across the estate we may be extracting data transforming it transporting it and consuming it across myriad of different systems often it can be that the field names that we'd expect and the field names that are actually being used are different we can be looking at poor standards across our state there may be complexities as well in determining the original data sources and the copies where they come from and we'll have other issue calendars as well such as different levels of structured data being passed around different sources and so forth so we take on board these challenges and typically a lot of work will be taking place to make sense in this data and what's flame for an organization and I suspect these these two images here will be familiar to a lot of you who have tackled these sorts of problems where we'll do a lot of mapping in some kind of a spreadsheet to describe what's going on and we'll have a beta model as well talking about the interactions with this data however when we've done this we want to put this data in some kind of system and typically this would be a traditional relational database and we start to have some challenges around this so we need to have some assumptions some hypotheses about the data and how it's going to be mapped and joined together so some of this will come an input from this data model but some assumptions will also have to make to pull them together so we've done this we've got some thinking about how these elements are going to join and more likely than not we'll have done some kind of normalizing or trying to link down the data and we're then going to try and join all this data together to get some kind of a view of how it's all linked together and this means we're going to have some companies computationally expensive joins to do as we have to do lookup across multiple tables and do with these Cartesian joins to link it and once we've done all of this how do we start to figure out all the pendants --is on one field so for example we may have identified that we've got a number of different customer identifiers for a customer so how do we start to look at the dependencies across all of those and again we have to start making some hypotheses around this to be able to be able to work out what these joins might be so at this point I want to provide a high-level introduction to a property graph database of which near 4 J is 1 to help describe how a graph database can help us with some of these challenges so what we've got here are notes and these nodes are objects in the graph they are our units to the information and these can be labelled so here we have two nodes that been labeled as a person node and here we've got a know that's been linked as a carload we also have relationships and these effectively show how nodes are connected to each other so for example here we have a love relationship between these two nodes and here for example we have a drives relationship between these two cars and we specified direction at the time of right and direction matters if we want the direction to matter in relationship and last but not least we have got properties and we can apply properties to both nodes and relationships and these are name value pairs that can be applied and something I'd like to show here is with properties you only need to put property on if there is a box into place so in this example here we've got this node and there is a property of Twitter whereas on this node here there isn't a Twitter account so it's not placed on so another thing I'd like to touch on as well is data modeling in the graph and basically when we come to modeling in a data model the process is very similar to the journey would take if we were doing any other modeling for a data project however the key difference is that when we've when we're looking at the domain and we start to describe it this is pretty much where we stop so effectively the model that would take away and start building against is going to closely match the domain that we're looking to model and this means that we get to build out our solution faster but we also have flexibility in the model to iterate adapt and change it so for example when we start to identify that we have a new note that we need to add in or new relationship type we can add that in the model rather than having to think about how we're going to destruct it and rebuild it again so we've we've described the anatomy of the property graph database we've touched on very briefly how we go about modeling in one so now I want to talk about some of the differences under the hood that's happening with the graph database like near for J and the relational database so first thing I want to mention is the joins one writes and this first key element in near for J is that near for J treats a relationship as a first-class citizen so how the data is connected is just as important as the data itself and under the hood how this is manifested is as soon as we identify that there is a relationship between two notes so for example the customer note here and the first note first name note here we create this joint and this joint is created at the time of riots and this means we can forget about how we might want a hypothesis have drop how units and information or joins we take advantage of the fact of not having to remember it all know or try to figure that out so that we take for granted another element of this is we have this sort of a - all right of you and what I mean by this is if we have our unit of information say customer here and we want to use it in a different context or repeat it someplace else we don't need to create duplicate of that node we don't need to repeat it or any kind of action like that all we need to do instead is we just leverage another relationship of it so we get this - normalized view where we don't have any data duplication we also have a flexible data model and as I hinted at this earlier as when we get new information and our knowledge of our domain increases and improves we can easily extend and adapt our data model to represent this without having to significantly rework on what so just as an example here if we discovered for system eight here there was a process said that we wanted to apply we could add pressure said and extend the relationship in that just as an example and also it's easy to query our graph with cipher which is near for J's graph query language and I'm going to show you some examples of this later so let's introduce our high-level example for this session and here we have a situation where we're looking to understand customer and in this scenario we have this businesses organization and everybody in the organization has this agreed definition of a customer so for example here I've got the legal one of the u.s. legal definitions for a customer so everybody in the organization is great yeah this is what customer is and we've also agreed as an organization that these are the attributes or some of the attributes that we agrees customer and this is common across the organization so fantastic we have this definition here however what the physical customer data looks like can be very different to the agreed view in your organization and there can be number of reasons for this but you may have multiple copies of the information due to legacy applications or for performance reasons we need to have this data cache locally there may have been mergers and acquisitions and so forth so there'll be a number of reasons why we have this data and again for the same reasons we may not have standardization across field names we may not have standardization across how that data is processed and so forth and in our example here we have this situation where we have three systems we've identified that have customer data and as you can see that we've got different field names and so forth going on there so now we're going to map this we've got our business brief definition where everybody understands and knows what it looks like and we've got our physical data on the other side which is reality of what data is flowing between and you know actually fulfilling the capabilities that we need in the business and what we're going to do in a simple example here is effectively we've got our a golf model of what this is going to look like so here we've got our business term or customer and we talked about how it contains our attributes that we agreed to the name email address and so forth and in here we start to look at the databases we've identify it's where the data is put the tables and the table fields and effectively what we're going to do as we step through is we've got our customers we've got our business term here customer and then what we would do we're building this out we would create all the attributes the business defined attributes for our business define customer and we connect them out with the relationships and then what we can do is we can take our information from our physical data sources so here we've got our databases and then we know that these are tables that sit on these databases are going to correct these relationships between them we've been got the physical attributes the fields on the tables that contain this information so again we show how they are linked back to these tables that are linked on these databases and in last but not least here we are connecting our physical fields with the sort of desirable fields that we would like them to be called and we join it and very easily we join this and again we have these join them right and we're going to show you an example of how we can quickly query from customer and find out what databases customer sits on without necessarily needing to know this implementation detail and some of you may have spotted as well that we have this situation where we had on one of our tables that we had an F name and s name filled that provided name and we may want to apply some kind of transformation to say that this Plus this will give you this and again it's very easy for us to modify our data model to take advantage of this and be able to describe this so straight away not only are we describing how our business definition our domain knowledge links the actual physical beta but we can also start to draw how we are going to transform parts of the data and what is that journey of that data to create that so another thing I want to touch on now to show you an example of this how might we go about asking some implementation agnostic questions so what do I mean by this so I want to be able to ask questions where I I know this and I have a common view of what this looks like and I understand these definitions and I may want to ask some questions about my data but I don't really want to be worrying about how my business attribute is going to join to field I have my business attribute is related to a database and so forth I want to be able to forget about that and because we have these drones them right we can do this and so for example if I wanted to ask a question such as what databases contain customer data is an example so let's say I have some kind of gdpr requests or such has come up where I need to be able to describe where all of my customer data lives I don't want to be worrying about what are the different table names and the different naming conventions that have come across my organization I want to be able to ask something simple like well I know what customers we as a business have defined what customer is and I want to be able to use that point a nice example here we're using an example cipher query and what were effectively saying is here's my start point so here's my business term customer and what I want to know is what databases customer customer data sets and again here I'm stepping away from the implementation implementation detail of all the different fields and attributes I might have for customer I'm saying well I need to know customer data and I knew this and effectively what I'm doing here and this is our syntax that we use for relationships and effectively what I'm saying here with this pattern is starts at this point here business term loan customers to start here my endpoint is here so it's databases now I don't know how many steps I need to take here but I know the direction of my relationships in this way so go from starting from at least one hop up to ten hops and the star basically says is variable and then 10 here is limit just keep going through and is and when you hit all of the databases where we have a start point of business term customer please return them back and here we use the assumption that name is our property for the database name here it's a very strict word so we've not had to worry about the implementation detail of the different fields or transformations and things we needed to go across to get to our source of our customer data how about going the other way so I've got this I've got this field in table field of email address so it comes off a table in a certain database so I know I've got a point here and I'm wanting to understand for example where where is this field being used what business attributes are coming into it so for example we have a business term of customer and a business attribute of email but what for example if we've got a business term of order and we decided what to link email on that and so forth so going in the opposite direction so I'm specifying my start point here of the field name being email address I want to find out all of the business attributes that it links to so again I'm taking advantage of the direction of the of the relationship and effectively we're going to we're going to push that back and again we're using this pattern of not worrying about all of the different transformations or links or filtering that I've gone through to get back that information and just one more example so let's say for example I want to know all of the different fields that contain a customer's name so again same idea I want I've got this I understand my business name of customer and from this business to a customer I want to look at the customers name so again we're doing the same sort of idea and I've shown you three examples of the similar process where we're leveraging the fact that we created these joins at the time of riots so we're not having to hypothesize about how our different elements are joined we take advantage of the fact that we did that joining as soon as we put that information into the database and now we can leverage it to ask patterns and these are very very simple examples and we can extend these out to start looking at rings to start looking at sizing and so forth so it's extremely powerful so in summary data lineage is a core component in many projects and we've looked at some of the high-level challenges faced in implementing it we've also covered about how neo4j can assist in overcoming some of these challenges through being able to easily model the data and adapt it as required by having these joins at the time of Rights we can move away from hypothesizing how data might be connected and instead just ask how it's connected and we've briefly shown how cipher allows us to query real data without having to worry about how it's wired and with that thank you very much for joining me today 