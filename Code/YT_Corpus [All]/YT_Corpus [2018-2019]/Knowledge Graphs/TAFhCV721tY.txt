 [Music] welcome to this lecture in the last lecture we were discussing about the path testing and we said that in path testing we need all linearly independent paths to be exercised by the test suit then only we can say that the test suit achieves path coverage but we said that to define linearly independent paths and path we need to be able to draw the control flow graph of the problem and we are discussing how to draw the control flow graph of the program and then we said that number the statements and then each number becomes a node and we need to draw the edges among the nodes and we were discussing about a systematic technique about how to draw the control flow graph and we said that there are three types of statements in any program the sequence selection and iteration if we know how to represent the edges for these three types of statements then we should be able to draw the control flow graph for any program now let us see how to draw the edges for these three types of statements first let us look at sequence type of statement this is an example of sequence type of statement and here the control just flows from one statement to the other in sequence so this is the easiest of all three types of statements and we have numbered this one and two and we just draw the edge so in the control flow occurs from statement 1 to statement 2 now let us look at a selection type statement if a greater than B then C equal to 3 else see equal to five so this is the statement and then the subsequent statement is C is equal to C into C so this is the selection statement that follows the sequence statement based on the outcome of the decision here the control transfers either 2 2 or 2 3 but after 2 & 3 complete two or three complete the control goes to the next statement in sequence so drawn that one to either 2 or 3 and then from both T 2 and 3 control comes to 4 so this also easy to draw now let's look at iteration type of statement so this is a while loop and here if the while condition is true then it enters the loop and statement2 will be executed but if the while condition is false it goes out of the loop and goes to the next statement in sequence but the only thing to mark here is that each time it completes a loop the control comes back to check what's the outcome of the decision only when the decision becomes false it comes to the next statement the decision never transfers from 3 to 4 but from 3 it always goes back to 1 well the decision is evaluated and only if it is false it comes to 4 so the same thing we have represented here if the decision is true enters the loop 1 2 3 and it compulsorily transfers to 1 to check what is the outcome of that and if it is true again it look continues the loop and only when evaluates to false goes to the next statement so if you draw edge between 3 & 4 that will be erroneous many who start to draw control flow graphs make that mistake they draw an edge between 3 & 4 but see here that control does not transfer from 3 to 4 but it goes back to 1 where the decision is taken and only when it is false the control transfers to fourth now once we draw the control flow graph we can define a path a path is any node and edge sequence from the start node to a terminal node of the control flow graph for this example from 1 we can have a path 1 to 3 and then for another may be 1 2 3 1 2 3 4 so several paths are possible given a program and also there can be several terminal nodes in a program because there may be return statements and so on the all paths criterion says that in presence of loops the number of paths can be infinite or very large the reason for that is that for given this kind of a loop we can have one two three four one two three one two three four one two three one two three one two three three times and four and so on all are all qualify as paths so we can say that in presence of loops the number of paths becomes infinite and therefore if you are trying to achieve all paths criterion it will be very difficult even if we know how many what is the maximum number of iterations that can occur here but sometimes we cannot determine for example it might be that while true repeat so all path criterion even though it is a strong criterion but then it's impractical because we don't know how many paths are required and the paths are can be extremely large from this consideration that all path criterion is not a practical criterion the linearly independent path was defined the linearly independent path is defined as a path belongs to the set of linearly independent paths if it introduced at least one new edge which is not included in any other independent path so one two three four will be a independent path linear linearly but but one two three one two three four will not because it does not cover any new edge not covered by the previous test case that is one two three four so the same edges are repeating and get excluded by linearly independent path given a control flow graph finding a linearly independent path for very very simple programs we can easily find it but for complicated programs it becomes extremely difficult for example if I draw a graph like this so just for this finding the number of independent paths is non-trivial and just remember that the number of statements can be 100 and the number of edges can be let's say 150 and then even if you spend a month trying to find out what is the number of linearly independent paths you may still be struggling at the end of the month so just from visual inspection trying to compute lung linearly independent path set is an extremely complicated task for non-trivial programs McCabe based on graph theoretical results he could find the number of linearly independent paths in a straightforward manner rather than trying to count all the linearly independent paths he used graph theoretic results and it's extremely simple to use his result to find the number of linearly independent paths in a program and that provides a practical way of determining the maximum number of test cases required for the basis path testing so the set of linearly independent paths are also called as basis paths and that is the reason mccabe's cyclomatic metric is an important metric for any program let us see how to compute the McCabe's metric given a control flow graph the McCabe's metric is defined as VG G is the graph and VG is the metric which is the number of edges in the graph minus the number of nodes plus 1 here the number of edges is one two three four four edges and there are four nodes four so four minus four plus two is equal to 2 so the maquette metric for a control flow graph for a loop a writer native statement is to given any complex control flow graph we can just compute the number of edges the number of nodes and then we can just use the formula e minus n plus 2 and get the cyclomatic complexity value this is also easily automated because given a graph we can easily compute the number of nodes and the number of edges and then compute the McCabe's metric let's take this example so for this program we find that the number of ages it's seven number of nodes is six you can count and then plus 2 which is 3 there are alternate definitions of the cyclomatic complexity we can visually examine the number of bounded areas and hard one and that also will give the cyclomatic complexity for example for the same one same control flow graph we can find the number of bounded areas so this is a bounded area this is a bounded area and this is a bounded area so 2 plus 1 number of bounded areas plus 1 so 2 plus 1 is 3 and this is easy to compute from a visual examination of the CFG the other one II - n + 1 e - n plus 2 so that's easy to compute using a computer program so here the number of bounded areas are two and two plus one is three and that's the cyclomatic complexity we might also compute e minus n plus two which will also give the same result the McCabe's metric provides a quantitative measure of the testing difficulty because if the McCabe's metric is 15 that means there are 15 basis paths are linearly independent paths and we need 15 test cases so the McCabe's metric value provides the difficulty level of testing and also the reliability because that many paths are there and we might miss bugs and that also corresponds to the reliability computing the bounded areas is easy from a visual inspection and the e - n + 2 formula is easy to compute using a computer program but one thing we must remember that it provides a bound on the number of test cases to be designed we can test even more test cases but the problem is that knowing the number of test cases required does not make it any easier to derive the test cases because if we say that there are 15 linearly independent paths but then how do you identify those paths we know that there are 15 but then identifying those 15 is extremely tough problem so one way is that we keep on testing and see if a new edge is covered by a test case which was not covered by earlier test cases then we say that a new linearly independent path is being executed and we can count the number of linearly independent paths and you can find the percentages of linearly independent paths that have been executed so in that the tester proposes an initial set of test data and then use a dynamic program analyzer which counts the number of linearly independent paths being executed and then it displays the percentage of linearly independent paths that have been covered and that gives the path coverage metric but can we derive the test cases for very trivial programs yes if there are one or two control statements and so on become CG but if there are dozens of control statements becomes extremely difficult to derive the test cases for this example we see that there are three linearly independent paths one occurs when it enters in it executes the statement 3 and the other one when it executes the statement 4 and we can check that two test cases should be able to cover all the linearly independent paths here even though the maquis metric is 3 that's an upper bound and we might need two or three test cases we'll design test cases to achieve path coverage but just need to mention one shortcut here to count the number of linearly independent paths other than drawing the CFG counting the number of edges number of nodes and performing a minus n by 2 e minus n by 2 e minus n plus 2 or computing the number of bounded areas plus 1 the other method is look through the program statement whenever you find a decision statement count it number of decision statements plus 1 so that is also equal to the McCabe's metric let me repeat again to be able to easily compute the McCabe's metric look through the program code whenever you encounter a decision statement like Y leaf etcetera count it and then add one that will also be equal to e minus n plus 2 or number of in the pounded areas plus one so for the previous program we can we have number of independent paths three and we can use three test cases for achieving the path coverage the cyclomatic complexity metric other than giving an estimate of the number of linearly independent paths it has several other applications it correlates with the number of errors existing in the code after testing it correlates with the time required to correct an error and it correlates with time required to understand the program you might ask why there is a correlation between the mackins metric and these three issues it's not hard to make out why it is so remember that McCabe's metric gives the number of paths in the program and to understand the program you need to trace all the paths so if there are independent paths to be able to understand this behavior of the program you need to check that from the output how do you dress to the input so all paths you have to check in the code and see how the control it gets the values and so on and that's the reason why the understanding difficulty correlates well with the McCabe's metric and that's also the reason because to be able to correct the error you need to understand the program and therefore it correlates with the cyclomatic metric and similar is the error existing in the code the cyclomatic complexity corresponds to the difficulty of understanding a program and therefore we say that it indicates the psychological complexity of a program or the structural complexity of a program normally the companies require their programmers to keep the cyclomatic complexity to a reasonable value and of course if you think of it it means that every function should have only a few loops and decision statements many organizations require that programmers should not write functions having more than ten cyclomatic complexity because otherwise the complexity of understanding debugging becomes extremely large so we saw that the cyclomatic complexity metric has many applications and we saw how to measure the cyclomatic metric for a program and we saw the applications of the cyclomatic metric it indicates the difficulty level of testing the program the difficulty level of understanding the program it correlates with the final reliability of the program and so on and we saw that the cyclomatic metric is important many organisations restricted to ten or so for a unit and it is called as a structural complexity metric and or the psychological complexity metric the structural metric is a more popular term that is used now let us look at another test technique it is a wide bus box test technique called as the data flow testing and then look at the mutation testing but before that a small quiz here what do you mean by coverage based testing we had seen that coverage based testing implies that certain program elements should be executed by the test suit and a measure the extent to which the program elements are executed by test case and that we give a percentage coverage achieved and the elements can be the statements the control transfer edges and so on paths and so on now what are the different types of coverage testing that we discussed we discussed statement coverage we discussed decision coverage the basic condition coverage condition decision coverage mc/dc coverage multiple condition coverage and then the path coverage how is a specific coverage based testing carried out we saw that designing test cases for coverage based testing is non-trivial except for extremely small programs and therefore the test cases are designed and as they are executed possibly random distresses random values and as they're executed the dynamic analyzer tool keeps track of what is the path coverage achieved and keep on giving input until the path coverage becomes acceptable alerts but one thing need to mention here is that 100% path coverage may not be achievable for non-trivial programs because there can be infeasible paths what do you understand by fault base testing there's the next question in a fault base testing we introduce faults into the program and run the test cases and see if those faults are getting detected and the way to introduce fault is called as mutation each time you introduce a fault we call it as a mutation of the program and then four on the mutated program we run the test cases and see if the test cases are able to detect the fault that we have introduced give an example of a fault based testing so mutation testing is an example of a fault based testing where at the end of this lecture we'll stop here and will discuss about the dataflow mutation testing in the next lecture thank you 