 my name is Chris Scott acre I'm the software development manager for Scripps Asset Management Group with me today is Brant Baymen who is the most senior software engineer and the leader of the team that helped us get to graff originally we'll be talking today about how we use neo and have used neo to federate digital asset management systems so you might not know Scripps Networks but you probably know our brands so we are not Cisco we're not Linksys we're actually HGTV DIY Food Network Cooking Channel and this is sort of the beginning of the problem so when you think about traditional television you think about shows and series and episodes and maybe even different versions of those episodes and if you want to get a little technical video segments so the time that's spliced in between commercials it actually seems pretty simple here's a fairly elementary model of what that looks like but the actual problem is a little different so you start adding in real-life ideas like brands and channels and talents and production organizations and distribution rights and all of a sudden your simple little model turns into something that's not quite so simple and that unfortunately is only the start of the problem because that's one digital asset management system that's video right we're actually talking about production production management like distribution rights agreements licensing agreements the actual video closed caption files still imagery audio files and recipes because after all it's the Food Channel I'm not even gonna talk about this because we don't have a ton of time everybody know this point two point integration is an anti-pattern you shouldn't do it and guess what when your digital asset management systems are a collection of sass and cots and homegrown from a practical standpoint it's not even manageable right it's from a schedule perspective you can't even coordinate all the changes for the systems that you don't control in a way that actually allows you to meet your business deadlines so we sort of settled on this model um it's pretty familiar to anyone who's ever done anything right it's a hub-and-spoke model we have these digital asset management systems that are sitting at the edge of this of the wheel and then we have the scripts asset registry that's in the middle sort of managing the relationships between them all it does is it's the authority of source on the relationships and our key identifier z' across these systems so the next question is what do we use for this this asset registry right we could have used a relational model but you know in the second or third slide if that's one damn that's one digital asset management system you can only imagine what all of them together and there's not six there's really more like ten and you have different concept definitions in each of them as well so you have different roles for recipes than you do for video and so it because it gets even worse the other problem is we don't do the kinds of queries that relational databases are good at we're not asking for what are the lists of shows or show me all the recipes that have cumin in on or or that sort of thing well we're asking for arts what are the relationships what recipes are associated with this this Food Channel show this episode are there images what are the people that are associated with this some are authors of the recipe some are participants in the episode some of the hosts what are the production companies that's those are the kinds of questions that we are and our businesses interested in answering every day our first attempt at this was a while ago in fact it was before the no sequel movement and our first attempted this used an LDAP database it handled very large data sets had extremely fast reads but we have some challenges we had some operational challenges in terms of failover and I'm sorry we had some operational challenges in terms of failover and more dramatically we had some business challenges because the business was changing but we didn't have a lot of schema flexibility in the LDAP database so we're going from a world where we have what we call a linear schedule right we have something that's on at 8 and then something that's on at 9 and this repeats itself for every brand we have to video-on-demand subscriber video on-demand what we call nonlinear distribution which is stuff that doesn't have a fixed schedule that can be played anytime and then again after that business revolution we have the next which is social snapchat Facebook Pinterest micro networks like genius TV genius kitchen so the whole model about the show and the series in the episode it doesn't really work anymore it works some of the time but not all the time and we were having a difficult time adapting our ldap schema to account for this so our reboot on this which was about three years ago as 2014 was actually used a graph database to model these relationships and specifically neo we needed new asset types like short form and social to be able to be added easily we needed new relationships collections of short forms that chain that share different aspect or shared the same root concept but different aspect ratios to be able to be related in ways that we never could with linear distribution and we needed to be able to easily and quickly query that relationship data so that's that's the why on how we got to where we're going today we tried a couple of different models a couple of different iterations and where we wound up was in a graph now I'm going to turn it over to Brent and Brent's going to talk to you about a little bit about what the graph looks like thank you Chris as Chris mentioned my name is Brent bayman I'm a senior software engineer and technical lead on the project at Scripps Networks where we where we did this so let's let's talk about our graph a little bit so we don't have a particularly large graph it I would say it's medium-sized in terms of graph back in 2014 we started out with about 10 million nodes today we have about 43 million nodes our read the right ratio is about 400 to 1 so we do a lot of reading out of this you can see our our transaction volume there is about 3,000 requests a minute not particularly high and we peak at about 8,000 requests a minute so in this time span between 2014 and 2017 we grew a little more than four times and the important thing about this what neopor fete neo4j has provided us is our query times have been constant just above two milliseconds per request from 10 million nodes to 43 million nodes so we run our graph in AWS this is sort of the topology here of it we have a cluster of three in H a mode the database is on running on EBS volumes on on ec2 instances that are m4 2x cells these are fairly moderately sized machines with 32 gig of ram we have 8 gig JVM heap and a 20 gig page cache and that gives us a little room to grow because we've got about a 17 gig footprint on disk of the database interestingly here we actually run to load balancers in front of this both pointing at all three nodes but utilizing the h.a endpoints on the on the graph database to tell us which one is the master and which ones are the slaves because we direct all of our rights to the master and we direct all of our reads to the slave so this is this is the metal model of our graph so you know you go back and you look at the model that Chris showed earlier in one of the first few slides this is huge er diagram this is it we have assets they relate to one another and in one of several different ways or many of several different ways those assets have instances you can think of instances as some representation of the asset the asset is a piece of intellectual property the instance is a file that represents that piece of intellectual property so maybe it's a maybe it's an mp4 video maybe it's a XML recipe or a PDF recipe or a JPEG image and we track the location of where that file lives globally so it might live on premise in our headquarters in Knoxville Tennessee it might be on a storage system in the UK it might be an Amazon glacier or in an s3 bucket so here's a small snippet of our graph at first you might look at that and think it looks just as confusing as that er diagram into a point this is true however what you're looking at here is actual data not a model right so we're gonna zoom in on three different sections here and talk about what what's happening and to Chris's point we we have multiple dams and we're relating assets across a dam so these these nodes are coming from different dams registering them in so the first one here is broadcast video so we have a linear scheduling model where we air things at you know 8 o'clock 9 o'clock 10 o'clock the first on the top left there you'll see is this show so this might be one of your favorite shows like fixer-upper or house hunters and there are seasons or we call them series associated with that so maybe this is the the first season or the third season or whatever that's part of that show and down to the bottom right a little bit in the middle there you see an episode so this is one episode of that particular season and that season has segments so you can see these are related on this part chain all the way through because a season is part of the show an episode is part of a series and segments are part of episodes overtime what we ended up doing is creating versions of episodes so it wasn't just an SD network anymore right HD came out and we started leveraging our episodes for more purposes we want to shave 30 seconds off to move it from HDTV to DIY and put more advertising in them or condense them for use on other platforms so we started you see this incoming relationship into that middle episode a version relationship so any given episode may have many versions and our existing system but what we were noticing over time is that well we I want an inventory of our episode sure I want to know what I can license internationally or what's available for use on a given platform but my numbers are off right so I'm trying to get utilization of my episode because I have five copies of the same episode that are slightly different from one another so over time we introduced this concept of an abstract episode and it's really just there to group all of the different versions and give us something that we can license internationally or that we can count distinctly and having a this would have been difficult in our LDAP model because it would have been a schema change all those relationship types were a schema change every time I added one the ability to dynamically add relationships based on business need is the real power that we get out of this the second section of this sub graph illustrates some recipes right so there's four recipes stacked there in the middle that top recipe has a couple instances this is probably a an XML version and a PDF version of this recipe and it's showing that those are located in an s3 bucket and you see there's a reference relationship between that abstract episode on the left and the recipes in the middle so this is giving us the ability to track what recipes are related to what episode the third one here is just showing us yet another dam in this same picture these green boxes are our assets our green circles are our assets the blue circles are instances of those assets and these would all also relate into either concrete episodes or abstract episodes or potentially shows in series as well so I mentioned the ability to create dynamic relationships as the business changes so we saw in that in that first sub graph linear content so for a very long time we were a cable network right we we aired things linearly but the world's changing right people aren't turning on the TV and watching it you know whatever is on I'm watching right I go I do i IV video on-demand now I I go on social networks and I watch clips of video so we're really shifting from this linear model to what we call a nonlinear model so I can I can effectively watch that video whenever I want depending on what platform it's available on and we we produce content now not strictly for for our linear networks we're producing it distinctly for those nonlinear channels so in this case on the left there you see an episode and there's two segments of that episode and you see a nonlinear video there in the middle that's derived from two different segments so maybe I'm taking the first two segments of an episode or pieces of those segments and I'm making another video for use on another distribution channel and you see there's a there's a part relationship there this is this nonlinear video was part of those segments on the right side you see two more episodes and you see two more nonlinear videos but those aren't parts those are reference relationships so this allows us to define what is the intent of this relationship so this nonlinear video is related to this episode because it references it in some way this is probably some kind of outtake from the production company some bloopers or something like that that were that were we're storing the video because we want to keep it and leverage it because everything is monetizable in the middle there's a nonlinear video but it's not related to any episode and this is our our platform now for uniquely creating content that didn't come from an episode that we aired on a linear network and you can see that these things are then grouped in at the top and the bottom there into collections so I can create collections of our episodes or collections of our nonlinear videos and I can basically create a skew out of that and I can sell that to to to some partner or deliver that to a Hulu or Apple or any of our other nonlinear partners so one of the one of the key aspects we get out of neo4j we talked about the nodes and relationships there and that's what I like to consider the the right abstraction for the problem we're trying to solve right when I when I think about how our assets are related to one another I think about them in terms of a graph this assets related to that asset what I don't want to do is try to model that relationally and think okay so that's a record in that in the asset table and there's this cross reference table and if that primary key is related to that primary key that means they're related and and so on and so forth so I get the right level of abstraction when I think about the problem when I'm querying and then I get this level of simplicity right so it's a cipher query language gives us this very terse syntax that's very very expressive and really means what I what I'm trying to what I'm trying to say so on the top right is an example query that we have so we have an internal application that plays our videos we have what we call video proxies they're low res copies in the same aspect ratio with the same timing as our episodic or nonlinear content and that video player needs to be able to you know play the various segments of that video so people can QC that video or people can can you know sort of browse through it looking for particular content so that top right query we're basically saying they give me the asset that has our squid that's our scripts identifier find me all the segments of it through the part relationship find me all the instances of type frame accurate proxy and find me all of those that are located in our EDM s3 cache it's just a system that we have where we work we're caching things so it's basically pulling back the URLs for those locations and we're feeding those into a video player it's very very simple query on the bottom left is another representation of something we might do where when we deliver video to a company like Hulu or Apple or Google we're contractually obligated to deliver more than just the video right if there's recipes associated that we might be sending the recipes or photos of the talents or you know music cue sheets or you name it lots of production deliverables come in that are just related content so that basically traverses down through all the parts that are related to any particular asset this might be a show level or a season we're delivering or a single episode traverse all the way through that finding all the things that are related up to ten levels deep because we don't typically go deeper than that and filter that by any asset types or instance types that we might be contractually obligated to deliver bundle all that together and send it out so in summary our business has a collection of dams we use the Best of Breed approach across those dams so sometimes that's custom development sometimes it's cots sometimes it's a SAS system but the systems weren't orthogonal they needed to interact and the business demanded interrelationships between those dams for therefore their different use cases we had operational challenges that led us away from certain types of systems and drove us towards a graph model and we settled in nicely with neo4j and the OPA J provides us modeling flexibility and simplicity and really the performance that we could get out of neo4j also helped us out a lot so all I've got finished a little bit early today but guess time for some questions if anybody has any No okay thank you very much [Applause] 