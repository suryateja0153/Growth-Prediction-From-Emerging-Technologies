 my name is Maxim RZ that's my giant head over there I'm a new fridge a field engineer and what I do is I blog about neo4j there's 141 blog post like Maxim much they come all kinds of crazy things you can do with neo4j some of the stuff is fairly trivial some of its more advanced but I have really bad memory so what I do is I just blog about everything so if you want to know everything I know go back to the first blog post from 2012 and read your way forward and then you'll know everything I know it's really easy you can find me on Twitter at Maxim RZ and then on github.com I host most of my code most of it is open-source and MIT license so you're free to grab it and borrow and steal it and do whatever you want with it most of it is kind of proof of concepts that's what I do for a living I go to different customer sites and I have a week to help somebody build a proof of concept to solve a problem if I can't solve it in a week then you have a really big problem or I just sucked that week but anyway so this talk is about three quarters of my experience when you have a Jay as a user for eight years and an employee for six half of it as technical half of it that is just me rambling and 95% of it doesn't really matter okay what matters is that you go home thinking about graphs and you hear it graph Connect graphs should be top of mind but you have to kind of drink the kool-aid become a graph person get into graphs may be part of your lifestyle and kind of forget all the other bad databases that exist out that's that's our goal anyway so let's talk about what are we talking about so we are talking about a property graph model right this is where things start we don't have tables we don't have columns we don't have rows we don't have foreign keys all we have is these little objects floating around in space connected to each other by relationships their relationships have to be directed and have to have a type so you here you have Mary drives the car the car doesn't drive Mary right that would be weird and then Mary loves James James loves Mary but that doesn't have to be the case right Mary could love Cynthia or Ashley or somebody else and then the properties can be different so we have two nodes that look like they're people notes or user nodes but James has a Twitter property Mary does not and that's perfectly valid right that's perfectly fine which is a good thing and a bad thing I'll explain a little bit later on and then the other thing to notice is that the relationships also have properties okay this is a break from the triple store RDF model where relationships don't have any properties in a property graph they do that's kind of what they call that and then the only thing we kind of added is labels so node can have one or more labels let's say this is the kind of note that it is they're optional but nowadays almost everyone has at least one label on a note and that's all you get so you have to build everything basically use this now your relationships can only have two notes right not you don't have hyper edges so you can build hyper edges using nodes and relationships but just remember two nodes alright so if you come from a sequel background this is what you probably already know right tables you have a customer that has an address okay great I have a customer table I have an address table I can connect them together with a foreign key everybody's happy but that's not the real world all right a customer can change an address oh I know so now I have to have a pointer going the other way from the address table to the customer table but I want address I can have multiple customers and one customer can have multiple addresses so it gets a little messy and then what do you do you have a join table so in this case we have a customer address table that points both ways it has practically no value except the foreign keys where points do and most relationships in the real world become many-to-many relationships there's no kind of way around it eventually you'll get that one user that one special case and boom you have to go many-to-many all right now if you want to query how this data is related you have to perform some kind of join right left join a right join in a joint some kind of join needs to happen which is fine there's the way been doing it for thirty plus years in sequel the problem is that every time you want to know how things are connected you have to execute that joint and what that really means is you have to find those foreign keys see where they're connected and kind of follow them through right so how do you find the key in a relational database well you have to use an index and if your database people have done their job properly everything should be indexed nicely and you have this be tree in there be true some magical data structure right it's a log and data structure which means as you did I grows by 10 your speed only slows down by 2 which means you can get pretty big for you have problems but the problem is we got there we got this big data thing like a dozen years ago now and it caused so many problems that you have this big data more searching for keys and you get slower and slower performance and the more joins you have to do the more lookups for keys you have to do the worst thing is getting you start screaming at your database to go faster and that's what usually when you come to know sequel so the folks at u4j they took the same data you had and they just gave it a slightly different layout come on I guess so we realize we don't care who the next person is if all you care about which commerce systematics attended I don't care what the next person is I don't care what other conferences that exists in the tables all I care about is their relationships or doing things so its data is still there we just don't need tables to handle this we just have these notes kind of floating around in space through these relationships but we're gonna do something with those relationships as well are we gonna get rid of them the joint tables rather into relationships one of the things we always say is the relational database is even though they're called relational can't really handle relationships which is like what does not make any sense well it's kind of the wrong model right they as you add more and more relationships to your relational database it gets more and more complex and it starts looking crazy and if sometimes you walk into a DBA room or developer room you look at the side and they have this ginormous erd diagram that's like the whole wall and you're supposed to understand what's going on with that and it's insane where did you write then you have this de created performance again as you did it grows or the number of joins girl you've tried to do a a table join you know 15 20 30 levels deep forget it it's not gonna have a good time also we all say it's the wrong language so sequel built so many years ago was built around the knee of sets and set theory not graph theory so IB data feels and smells and tastes like a graph using sequel and it's kind of the wrong thing don't get me wrong stick was great if you have nothing but tabular data and then it's not very flexible and what that means is that you have to know your schema before you even add any data right you have to know that this this field is a barque r32 and that field is along and that field it's a dull one you have to know what these things are before you even write any to it and if one user has a property that it's a long Gila one cannot be a double dealer one cannot be a strength you'll have to be exactly the same evening of this any alright so to kind of fight these problems the bunch of vendors got together under the moniker of no sequel alright so you have four major categories it's much more but you do the four big ones right sorry I'm from the bottom we kept the key value stores this is Redis and react and a few others and they they did something really simple it's a listen joins are a problem do you know what we can do we're gonna get rid of them we're not gonna have them we're gonna key you get a value you want to join something you're on your own buddy alright so they actually they fix the joint problem that way they get the column families so they did something different it's a listen we're gonna pre join everything for you right we're gonna duplicate the crap on your data you're gonna buy a hundred service from us we're gonna make lots of money alright so you end up with thousand servers at Apple running Cassandra and crap like that document databases say the whole lots of horrible yet we have a better idea we're gonna take everything we know but an object and squish it all together into this nice little blob and Jason which is fine unless you want to know how these documents are talking to each other are connected to each other then you have a bit of a problem and then you have the grab database category it would say hey guys we're gonna do something a little bit different we're going to take relationships we're gonna make them first-class citizens we're actually going to make them real we're gonna store them on disk keep them up in memory they're gonna be physical real things you know in our data yeah now the the bottom three category is talking with stores column stores and key value stores typically are not acid they are not transactional although the big change was this year announced that they had become a proper asset database whether that's 100% legit remains to be seen but at least they decided to make that shift they realize that asset was important and they added that to their product all right and most of these once again can't really handle a ship very well well let's continue so what's our secret sauce okay no it's not this our secret sauce is this slide and if you're gonna pay attention to me at all for this forty minutes this is the time to do it so put your phones down and give me like two or three minutes and if you have no idea what graphs are about or new this is this is the thing to remember right how this thing actually works now this is not a perfect physical description of how it works this is a slight distraction but basically what you have is two giant arrays one array of nodes one of your relationships every record and the in the array is a fixed size record so you're actually looking at one single node you're looking at one single relationship on the screen cap every node knows what types of relationships are connected to it right so let's say we're looking at a social network and you have to be a node one so the node knows they has friends relationship and that happens to be type one so we want to get all their friends we can go to the type 1 relationship we can ignore the type 2 it ignore the type 3 type 2 could be like their likes type 3 it could be like where they live or whatever else right and then every relationship type has two lists one of incoming and one of outgoing these are lists that contain relationship IDs or basically relationship pointers and if I can get my mouse to to appear here because I want to I want to show it because I don't have a laser pointer all those things so we start at node 1 and we go to type 1 our friends we go in the outgoing direction we get to this R 1 I want points to the relationship array so let's say it's relationship 5 so we jump to relationship spot 5 on the relationship of ring let me say we came from node 1 that was a start node what is their end node and it could be node 1 million fantastic so now we jump to node 1 million and we asked for some key value pair from them right so the user name the email address or whatever property they they have over here and then we go into R 2 and we do the same thing we jump with so K we came from about 1 what's the end node now is no 12 we jump to no 12 we get the key value store and we're basically spin-spin-spin to the data structure until you run out of the list and then you have all the person's friends what's nice about this though is every type list here is stored by node right so whether you have a thousand people in your graph or a billion people in your graph getting your 150 friends cost exactly the same you jump to the the node you care about you Traverse 150 relationships you're done doesn't matter how big the data gets and a couple of tricks in your vajayjay write your queries so it takes advantage of this so it doesn't care how big the data gate all he cares about is what you're looking at and that's it right that's the trick we pay a price though the joins I dine on creation every time you create a relationship what happens we go to the first note and we say hey we're gonna add an item to your list and it's going to be in the outgoing direction so we go to the edge show that and we add one there then we go to the node with the lationship was coming in - we go to the list of incoming and we said we're gonna add an entry over here so we see that spot twice right and then we go to the actual relationship object and then we save the relationship object pointing to the starter and pointing to the unknown and then some properties if it has any so we cost us you know three instead of one to add a relationship to neo4j versus in a relational database you go to the join table or you got an entry with two numbers in it oh you're done right so that's kind of like the price we pay but you get the joints for free and it's an O one right everything is done by an array so there's no hashing there's no lookups there's no indexing everything is done directly by o1 access looking at the next array because these relationships they just or an ID which points to the record really really simple that's the thing if you get this you understand when you four days fast regardless of size it's just a matter of traversing relationships using a race no magic to it you can build this in a weekend and have your own graph database if you like really I know because I wrote a few but anyway let's continue on what this gives you is very fast queries for some use cases not for everything right some of the things we're good at some things were terrible that you wouldn't you know take a minivan and put it on NASCAR track it's a bad idea but the same time you wouldn't go shopping for groceries with a Corvette alright it's a bad idea so this looks like about some bad queries yeah imagine you have this data where you have every actor in Hollywood and you have a high property for everyone and you want to say what is the average height of all the actors in Hollywood well that's a terrible query for neo4j why because we have to jump around from random node to random node King for those actors right because the first note could be an actor the second note could be a movie the third note could be a commercial that the fourth can be a play who knows you got to go find the next note and obviously you might have a label that tells you what the actors are you still gotta jump around quite a bit and then you have to find the height property some actors may have the high property as the first property some actors may have the high property as the last property because any node can have any number of properties and it could be in any order whatsoever so that's gonna cost us a lot more than a relational database that can just go to the the actor table and do a scan or a column store they can just go in the height go across and be done with it right so better query for Cassandra than anything else for example but if you wanted to know how these actors were connected to each other but the movies that they were in like 60 PS Kevin Bacon then that's a perfect worry for us right same data different use case different query some things are good at some things are bad doesn't mean we can't do it I'm just telling you we're not the optimal way of doing it and if you care about performance you want to take that into account but let's continue on a little bit of truth because a lot of the things you see is a little hype but you gotta we gotta realize it's a right tool for the right job okay now it all works as long as you can reimagine your data as a graph all right and you have to look at your data and say is this data a graph does it smell this is look does it taste like a graph if so I grab there is my work right you will get better performance if you're looking for relationships not just the sets of data but the relationships in the data we have Seifer that was built for graphs so it's really easy to explain or describe what you're trying to do with something like cypher and if you can't do it with cypher you can do it with Java you can do it with gremlin you can do it with other languages that exist that you can plop into an ear for Jam and then the fourth thing we say when you're four days that it's flexible and consistent what that means is that you can add data on the fly you can add a node that's user with some properties and they'll take it and you'll figure out oh this is a string okay great this is a number okay great our story does that and the next one happens to be a user and let's say the height property for one was a number and the height property for the second was a string who cares I'll just store it as whatever you give it there's no schema it's a schema option all in a way so lets you do this kind of craziness don't obviously let your developers have different types for properties as bad but the database itself doesn't care you can go crazy and its really good for proof of concepts when you have a greenfield idea you're not even sure what you're gonna build just keep adding data to it and see what happens right but it's consistent because we have transactions real transactions you can start transaction you can make a thousand changes to the graph all over the place at the end the site to commit or rollback or 1,000 changes just like your relational database all right now this is where things get weird if you know third normal form or traditional relational database modeling you need to kind of unlearn a few things of course there's the normal way of doing it and we always tell people this first lie we told today that graphs are whiteboard friendly okay yes if you want to go slow but if you want to go fast you have to get a little more creative so let's talk about some models that are not took web or friendly so some models are easy like here's two we have a person Tom Hanks who acted in a movie another person who acted in the same movie and then we have the characters that they played in those movies as properties of their relationship okay their properties of their relationship now if you wanted to know who played James Bond then this is a terrible model for that query because there's no cookie no quick way to get to it instead you have to rip out the actor or the character rather and turn that into a separate node find the James Bond character and then figure out who played that character and why movies they were in so the models and the queries have to align it's not like they're normal form where this is the right way to model things and we'll just figure out what the queries are later you have to build it from both sides you have to build it from there you have from the queries you're gonna be asking and kind of mash the two together to get the right answer and I'll go quickly to another example on how to model flight data okay flight Airlines going from place to place so you can model it like this we have an airport name of the code flying it to another Airport and I'm gonna code and we'll stick everything about the flight in the relationship perfectly legitimate way but let's say I want to build a flight search engine and I want to say I want to fly from New York to Chicago tomorrow then this is a horrible model for that because I have to look at the JFK Airport all the flights for the whole year look for the ones that are tomorrow and find me the ones that are going to Chicago and then no that's not forever bad idea I don't think we can do is we can kind of break that out and say you know what flight doesn't really belong as a relationship it feels more like a node let's go ahead and make it a node let me so the airport has a flight and the flight has a destination and we'll stick all the properties in there okay things got better but didn't get any faster in fact you actually got worse okay now we have to jump to two so what do we do you have to get creative you see listen the airport really has days right people are gonna be searching by date so we can take the upper model and say the airport has days and on this day has flights so now instead of looking at maybe three hundred thousand flights in a year I can look at a thousand flights in a single day like that made my query better because now I have to look at less of the graph there from a query is gonna go faster but we can do better than this what I think we can do in an graphs is instead of having this has day relationship we can actually put a date as a relationship type which is insane but that's not a problem for you for you so now we can go from the airport through this date relationship directly to the airport day so we can even skip looking at the 365 days we can go directly there which is nice but that doesn't really buy me much it only buys me 365 relationships what I can do is I can get rid of the airport altogether and say I have an airport day that has a code so it's JFK - whatever date it is so for every airport I'll have many of these Airport days one one per day and then connect things that ways kind of simplify my model okay that's weird I were you showing you like four different ways to model the same data they're getting weirder and weirder let's keep going and get a little more creative right so we could do this the airport day has flights you know a thousand flights but maybe only has a hundred destinations right maybe has twenty flights to Chicago so we can do is we can create a destination node and say this Airport day has a destination to Chicago and then that no it has only 20 flights so now I have to look at less of the graph to get the answer so my query is gonna go faster by creating this destination node out of thin air but I can get even more creative I can say well forget that I have the airport day I'm gonna create a relationship type that has the code of the airport environment so now this Airport day is going to look at the Ord flight go out that direction and get to the flight and they kind of continue on from there so I can skip looking at any flights that go to any destination that are not Ord by using this model right so we're actually promoting a property of their relationship or in this case a property of the node way over there forward so we can skip looking at part of the graph that we don't really care about and you wouldn't get here right you wouldn't get here unless you understood this slide why are we doing this because every node knows what types of relationships are connected to it so if we tell it go out the or D flight relationship we can skip everything else we don't have to care about it right so now we're looking at 20 flights it's gonna be incredibly fast versus looking at thousand flights in a day or 300 thousand flights in that in a year that's the trick one of the tricks anyway there's a few more the thing to understand though is you know there is no spoon there is no right way well hold on there's no yes there's no right way to model data in a graph there's plenty of wrong ways to model data integral there's no right way all right and the third normal form way that you learned you have to unlearn you to get that out of your head and say I'm gonna get creative I'm gonna find a proper solution by changing the data a little bit right you have that power go ahead and use it you can get pretty creative out there all right now if you think that's insane take a look at what the folks from our roll entertainment have done this is a presentation from a graphic connect three or four years ago where Peter Olson came along and said hey listen we have a very complex data model this is the fantasy world where anything can happen right people go back into the past into the future they have alternate timelines all kinds of wacky things happen how do you model that right and they figured out how to do it in year four J using hyper edges which is another advanced concept that I don't recommend too much unless you have to have it and then this is the place to learn from anything but an hour-long presentation fantastic if you haven't seen it take a look I'll teach you everything to know about modeling complex domains and if they can model the fantasy world you can model the real world right if you're dealing with oil wheels or so servers or routers or switches or people or whatever let's say we world that's gonna be easy I'm practice stuff that they're doing all right a little more modeling just to drive you guys a little crazy right building a newsfeed like so you want to clone Twitter you want to build your own Twitter how would you do something like this in a graphing you Jam okay now the way it's done today is whenever you write a tweet that tweet gets replicated out to all of your followers so you have 100 followers it's not a big deal you have 10 million followers it's gonna be a bit of a problem and if you ever tried to edit a tweet you realize you can't there's no way to edit a tweet that's kind of weird right because that's the way Twitter was built you just can't do it in a graph you can write so if you were to build a Twitter using a key value store or an object database you do the same thing you'd push out all these updates into someone's timeline over and over again you'll be basically multiplying your data to all these people right and you buy lots of servers and you make a vendor rich that's great but that's not how we work in the afternoon now you can model with data like this we have a user that follows a user right and they post something so if I want to figure out what someone wrote I can just go to the followers relationship see what they're posting and I have my post right away I don't have to have this post be duplicated into my timeline I can just read it neo4j is optimized for reads right this is fairly easy to to get there but the problem with this model is that day one is gonna be fantastic day two I'm gonna have more posts and I have to filter out the post from yesterday because I only want to see what's new and then a year from now I have to filter out all the posts that happened in the last 364 days because all I want is the new stuff so what do we do well change the model we added we take the the date of when the post occurred when we promoted it into the relationship type so now we can go find me all the people that I follow and tell me how they post anything today or yesterday and then get me the list of posts of the stuff they wrote today or yesterday and then do it a little order by and sort and my query is only as big as one day's worth of postings for the people that I follow right so it could be five years from now it could be one day from now it doesn't matter the query is always gonna take the I'm on a time and that's the other trick in the everyday if you can write your queries by taking advantage of the data model so that your queries are linear they scale regardless of how big your data gets then you can always expect that same 10 millisecond response time because it's a big litigate that's fantastic or you can forget about worrying about okay my index is gonna get bigger my query is gonna get slower what do I do forget it this is always gonna be the same time same speed it's just fast just fantastic but you have to get a little creative in order to make it happen and there's more tricks I'm teaching a modeling class tomorrow so if you're in that I'll show you this and some other crazier things that are available out there but let's continue oh and this is the more complex model and if you're really bored I wrote the twelve part series on how to build a dating site that follows a different model because people can talk to each other and you have conversations anyway similar ideas on that are out there all right now I mentioned the every node knows how many you know what types of relations are connected to it every node it also knows how connected it is to the rest of the graph the idea is it knows how many degrees it has so I have a node with a degree of 100 it knows it has a hundred relationships but not only that it knows it by type and by direction so I can say how many outgoing friends relationships do you have how many incoming likes relationships do you have it knows that data because it's staring right in the data model so it's nice we go to ask that question and say hey if I don't want to unfollow two people for example find the one that has the least amount of followers find that person then unfollow them versus having to traverse and look for all of it it just kind of nice it's more of an advanced topic now that was ugly that was like Java right what happened to cypher we're talking about separate nowadays not this java crap well we we come from you know that de for G at the end of neo4j spoiler means Java right so it comes from this Java kind of a background where started life as an embedded Java library and if you are so inclined if you're a Java developer you can pop in your for day as the library into your app and have direct connection to the database and it has a little API that you can learn in about a day there's not much you can do right start transaction you get a note and then you get that notes properties or you traverse the relationship and then you get the properties of the relationship or you go to the next node and you do it again there's not a lot to do it's really easy to learn now if you're not a devil developer don't worry we have cyber for that this is kind of what it look like if you do in Java right turn transaction we find a user and then we say traverse the friends relationship find me all the friends of this user get me other properties throw that into a list and bring it back it's not hard and these things are fairly easy now if you don't like Java code okay that's fine but I am I used to be I used to be a ruby developer since I joined you over Jay I had to become a Java developer so I hold my nose when I code but it's sorry if I can do it you can do it all right then we have the traversal API originally pi is insane I don't recommend learning this without a few drinks in you because it's how we used to describe how to traverse a graph before we had cipher right so it's a little wonky it's really powerful but it takes some getting used to and we have also bi-directional traversals which are even worse to get your rap rap you know you head around we have classes for this stuff and it's out there yeah it starts out simple like hey I want to go depth first or breadth first I want to go out these relationships but not those and then for these particularly shapes I want to go in this direction but not that direction I want to go five levels deep and no more than five levels deep okay whatever you want to do I'll go ahead and run it for you but you're better off starting off with something like Saffir which is easy to learn maybe no sequel already this is a no-brainer and most people can look at cypher even without taking a class and I understand what we're trying to say alright this is looking all crazy but here's a person named dan who loves a person named and we have nodes we have relationships we have connections freely tradable this is a boring though I'm gonna show you some better examples here's another one here's a complex one and there's another magic trick that's the star the star means keep going so we're going to start with John dozer boss right we're gonna find John Doe in the graph we're gonna say I want you to find everyone you manage three levels deep that star means keep going so keep going up to three layers deep and you'll notice a zero in front of it the zero means include yourself now the boss and everyone he reports to our code the subs and then for each sub find out how many people they manage am i calling these guys reports and I'm gonna take the count of their reports I don't like the name of the person and they counted the report so I can figure out you know your whole aura basically in one little tiny query and you're done so the sequel query on the other side is it's a bit of a mess right now if you have to go for let your team private lawyers the tenure is deep probably crazy vertically-integrated your company is doesn't matter just change the number and you're done versus the thing you'd have to do in the sequel queries cry in order to write that tell me your deep query and then if for the best of both worlds you can mix it to so if you are a devil developer you can actually take Java crap put it into a sore procedure and then expose it as cipher and then you can just run the cipher query and it's all happy so you can do both alright it's like what some use cases what are the big ones out there is understanding your users right whether you're looking at building knowledge graphs using customer 360 kind of understanding what they're doing what they're up to what's going on so you can build nicer things on it and if you want to learn from the experts there's a class that these guys taught it's on YouTube there's I got four hours and for part one and four hours for part two so you want to go to sleep this is nice way to do it but they basically talk about understanding user behavior and looking at recommendations and fraud which is kind of nice so how do you understand what's normal what your regular users are doing right and which you're not so regular users are doing when it's suspicious behavior that's out there in the graph and then how to split the two how to understand what's normal what is abnormal so we can kind of prevent something bad from happening first you have to understand users right does your little girl like Rambo well you don't know until you actually look at them because maybe they do maybe they do like Rambo maybe just look up them right you can look at demographics like age and look at gender and can try to dissect your user base and see what they're about you know we do some some random looking at data here too little girls like movies that other little girls like and we do some some counting and we say yes yeah they usually do but the men 25 to 34 in the red arrow or the least like little girls from two minds I'm a team because they're like different kinds of movies so let's say you're building the next Netflix you're not going to show someone who's a brand new user the same list of movies to recommend you can ask them a couple of questions hey by the way what's your age and what's your gender and with that I can give you a better personalized experience then if I just give you everything and try to wait until you tell me what you like in order to get there I'm gonna skip a little bit of this because yeah for time but basically here's what little girls might like Toy Story Toy Story - stuff like that one man twenty five two three four my like different kind of movie star wars and red community so right away by just knowing two things about your users you can take that out look at the rest of user base and provide them a better personalized experience until you learn more about them and then you can drop demographics and look at individual users on what they're up to right but the graph can be useful things like predicting edges right all these people are connected they're all friends you're probably friends with them too you probably know them you probably know this person right what movie should you watch well if everyone that has the same viewing habits has watched a movie then actually probably watch the movie so we can predict that that's the next edge that's gonna happen in the graph you can also predict ratings what ratings should I give a movie well I can look at what other people have rated that movie kind of subtract the two and figure out what I might look at and rate that movie as well alright and then we can do things like clustering a community detection figure out groups of users that you may have in your system you're going skip some of this could be a short but all thing to remember is that recommendations and fraud detection are two sides of the same coin in a recommendation engine you're looking for a relationship that is not exist you can predict a new relationship in front of detection you're doing the opposite you're saying find me the relationships that should not exist in the graph these two people are using the same credit card the same IP address the same device the same sort of security number something is wrong right looking for those relationships I should not exist so if you look at fraud you wanna model user behavior now the the obvious fraud sticks out like the ones on the top right oh yeah that's obviously fraud right it's harder to do is it it's finding the ones that are pretending to be users right that the long vertical line that kind of feel into normal user behavior that's a little wonky that'll be harder to find so let's build a quick recommendation engine in like five seconds if your whites Toy Story you want to be recommended a bug's life right kids movies but if you watch a bug's life you do not want to be recommended to Human Centipede so how do we do this imagine you have a data model that looks like this where you have a person who rated movie and we have a title and he'll be John Ross the jammers are a collection so movie could be a romantic comedy drama sports movie on or whatever what kinds of thing it could be an animated to come here an anime that's a drama alright and people rated it give it a 1 to 10 whether they really loved it or really hated the movie so without a really simple data model we can build a recommendation in yeah here it is here's a little cipher hopefully you guys can be to the bottom it's color coded right so what are the top 25 movies that I haven't seen for the same genres as Toy Story they were given high ratings by women under 35 who liked Toy Story so we start with the movie Toy Story we see P 2 is who rated this this movie and we're gonna see the movies that they have rated and we call them unseen right where the rating that they gave to a story is a 9 or 10 and they're rating that they gave to the unseen movies a 9 or 10 and the person's gender is female and their age is less than 35 right what they watched movie so the Toy Story genres are the same as the unseen genre so the same kind of movie and my household which is myself Jane Doe and James Dean none of us have rated or watched this unseen movie take the 20 top 25 matches for this pattern order them by the sending account and give them to me and this is a you know a line recommendation engine that's looking at user behaviors using looking at cursory sticks of the movie catcher six of the users who are using for the rating it's pretty insane and it's eight lines of code and you can show this to your boss and be like look here's a recommendation engine it's not some crazy complicated hey I think whatever is this a lines of code right it's understandable you can you can say this is what we recommended these movies to you because this is what we predicted where says a black box model like you end up with unknown answer and you can get fancier you can you can build similarity scores between people and say hey these people have same viewing habits so we're gonna weigh them highly and say they watch a movie you're probably going to watch what they watch because you have the same kind of behavior and this is that crazy query but it's still like ten lines of code doing KNN recommendation in the air for Jay where we first find people who are similar to you and then we use those people to figure out what they have watched you haven't yet and then we'll recommend that to you I'm not gonna go through it but that's the the idea there and then new feature is used so for indirect relationships right for example on one side you have people who are looking for jobs and the right hand side you have jobs they're looking for people but they're not looking directly for each other and said you have a person who lives in a location you have a job that has some requirements and the person who has those requirements met right so here's your Safra query we started off with the user here's max he lives in some location and he has some skills in that location there are jobs that have some requirements where max has something that the job requires so I have at least one thing that the job requires so they're skilled now it's and the requirement notes are really the same notes and I can find that with this query so it's kind of a circular match I want to have that it's okay find me everything that max has to the job requires those are my matching skills find me everything the job requires those are my required skills and then do something really funny look at this filter it says find me the skills that max does not have the job requires and show them to me that's missing so it's a partial subgraph match and then give me an order by and give me the top ten and what this gives us is a little drop-down or a little list looks like this hey if the first job you're 100% match right you know these skills you can apply to that job and get that job because your perfect candidate the sick one you're missing CSS because nobody puts CSS on the resume you just hit the plus button I get to add it to your profile and now you match for the second job the third job requires that you know Java right so you click the plus button and lie through your interview and hope for the best all right so we can't prevent that from happening but at least we can give you a list of what you can match and then from there cruder side they can see given all the candidates who's the best candidate for the tuition and who should you ask to apply as well if no one matches there's some kind of threshold that you may have set anyway there's a whole bunch of use cases graph search type stuff that you can do I think I ran our taxes like an hour presentation on 40 minutes it's all posted online on slideshow that calm you if you're really interested the point is though learn this slide I understand it sleep with it you know in your pillow and have it come through your brain if you get it then you'll understand neo4j I understand why it's fast you understand how to model data you understand how to write your queries to make them fast and you'll know everything I know and thank you very much [Applause] 