 So, welcome to Building Serverless applications with Azure Function. My name is Yochay Kiriaty, I'm a Program Manager working with Azure. I've been working with Azure, Azure App Service, Azure websites if you're familiar with for the last five, six years. So I've been with the project pretty much from the first day. And about ten months ago, we started Azure Functions. So it's very exciting and that's why I'm here. My team blog a lot on MSDN, on microsoft.com, on the App Service team. If you want to follow me on Twitter, sometimes we have some interesting conversations about Functions or App Service or cloud in general, Serverless. And that's my email, if anybody wants more personal touch. All right, so we'll talk about hey, what's Serverless? Then we'll see how Azure Functions, introduction to Azure Functions that basically is Serverless compute. And then we'll explore some actual customers, real-world examples, such as stuff that's happening with Azure Function. At this point I would like to ask who is using Azure Function already? I got two people, okay. You might get bored from the little first 20 minutes, but everybody else may not. So, this is the point we're actually gonna tell everybody if you want to follow up with the demos, you can pull up your laptops and go here. I will show you what's in here real quick. A-K-A, TryFunctions. Right? Right, you'll end up here. If you have an Azure account, you can just go to the portal. If you don't have an Azure account, get one, but if you don't have one and you actually want to follow up for the first couple of demos you can definitely do it through here. So I'll let you guys set up with this. And I hope you're not going to get too much distracted with everything else. So let's move. We'll set up the stage. We'll talk a little bit about the different compute options in Azure. Or kind of, how do we see them? So let's say your app is a car. Most of you probably own a car. So the analogy we're trying to make is basically for owning a car versus using taxi or Uber services, versus renting a car. With respect to IaaS, which are VMs, Uber which is basically SaaS application, or Platform as a Service, which is what app services doing or function is doing, which is kind of renting a car. And that's kind of the idea, the idea is that if you own a car, you need to buy it, finance it, maintenance, change oil every now and then, do all that kind of stuff. You go all the way to the side, if you use Uber basically you just use it. Maybe you're paying a premium for that instance of time but you don't have any responsibilities. If you drive a car, if you rent a car basically you can rent it when you need it and get it and then return it. You do need to fill up gas for example, but you don't do anything on the maintenance, don't care for financing the car and stuff like that. That's kind of the analogy. Be more specific and go into a little bit more details, this is basically just a question of trade off in between what do you want to do. How much control do you want slash need versus how much do you want to be more productive or less bothered with actually managing infrastructure? So if you're On-Premise, you'll do everything, the entire stack. When you move to IS, VM, VM skill set, basically, the cloud provider will give you all the instruction but you still need to manage the O/S, patch the O/S, bring up the middle word, run fine. And all this is even before getting to the application. And then comes Platform as a Service which basically allow you to just write your code or manage your code to a certain degree, without any of the other interaction. And SasS is basically just a service. All right. So with that in mind, Azure App Service provides a fully managed platform. And within that we got Web apps, Mobile apps and API apps, we have Azure App Service, Azure websites for quite some time. Anybody is using Azure App Service as a websites, a little bit more, okay, better, cool, that's good. So, Azure Function basically runs on top of Azure websites. So a lot of the stuff I'm gonna show you for those who raised their hand I hope you're gonna be familiar with. All right, cool. So why Serverless? There is a single slide, but I'm saying hey why do I need to talk for five minutes in a single slide when I can do basically enough of animation in between. So before we had the Cloud, if you wanted to run something, basically, you need to have physical servers somewhere and you basically build your application and data on top of that. Usually, those were either On-Premise or in Co-Lo. And then you'll be able to connect to internally and externally, whatever you want to do with it. With that, basically, before the cloud, there was a gazillion of questions that you need to basically answer when you come to provide such a solution. Stuff like, where do I buy the servers? How long does it take to build, to provision the servers? Anything from physical access, electricity, networking, backup, a bunch of questions. Quite messy, but this is so 1990s, I guess. Anyway, after that, came IaaS, right? Where we actually go ahead and get a VM in the cloud, for our cloud provider. And with that, a lot of the question basically go away. So how long does it take provision the server? It really doesn't take any long to provision the server because you basically get it within a couple of minutes on the cloud provider. What happen if there is a server, hardware failure? Well again, you don't really care because basically you'll be migrated probably automatically to a different server. And then you can see, question about physical access, question about backup. All of those questions kind of go away because you don't really owned infrastructure anymore, which is good. Then comes PaaS, and with PaaS we actually can eliminate even more questions, right? Using the app service or website, those who raised their hands, know that basically, you don't really choose the OS, because we've already provisioned it for you. You don't manage the OS, you don't need to patch the OS or anything like that. You don't need to purchase servers, you don't need to package anything on the server, unless your own code and any binaries basically or something that you want to bring with you. Because we manage the entire infrastructure for you. We manage code deployment for you, we deploy it across multiple server, not just one. If you have ten virtual machine VM skill set or IS that you actually need to manage them, then you need to go ahead and deploy through each one of them, there's automation, but you need to do it. With Platform as a Service, all of this is being managed for you. And there is more, basically. But even that, you still have several questions like around basically how many servers do I need, utilization, when do I scale up, down, all of that. And the platform does take care of that for you. But we can even take a step forward introduce Serverless. And with Serverless basically we take away the questions of how many servers, what's the size of the servers and the server utilization. Because basically Serverless means we'll give you as much computer you need when you need it. And then the only question that remains is basically how do I scale my app. And with the Serverless in particular it's not necessarily about scaling as much as architecting for Serverless. And we'll see some examples during the presentation. All right, so what is Serverless? Basically Serverless is an abstraction of servers. As you've seen, Azure App Service is a fully managed platform. We basically hide all the infrastructure behind, and you don't really care for anything that your application runs on top. You shouldn't. If you do, then we need to have a conversation whether Serverless meets your need or not. It's Event-driven/instant scale, this is very important. Basically it means that it reacts to event, and we'll see some examples. And when there is events we'll basically give a computer run, and if there are a lot of events like many, many events we'll give you a lot of computer run. But when there are no events, we basically take away and you have no computer that you need to use. And that introduces a sub-second billing because you pay only for the time your code runs. So you don't need to renting advanced servers and keep them somewhere or in the Cloud. Or whether they are being used or not. Not even a single server and only when there are event to be processed basically we'll kick in your application, your functions, and you will be billed only for that time frame. What does this give us basically? It reduces our devops by a lot. Doesn't mean it eliminate them, there's no such thing as eliminating devops. But it reduces and allows you to basically just focus on the business logic. You now can focus specifically on what you need to do on the task at hand. There are no more managing of VM infrastructure other than understanding how it works, how to deploy. Basically you write your code, I can show you several ways to do it. And then it runs when it runs. And all of this reduces time to market, faster informations, all that jazz, which is good, I guess. Okay, so been talking for about ten minutes, let's see if we can get to some demos after this slide. So here comes Azure Functions which is Serverless. Azure Fuctions is a Serverless compute, event based Serverless compute. You can develop with JavaScript, targeting nodes, C#. We added F# recently, it's not on the slide, basically there are additional languages I'll show you in the demos. And the cool thing about it you can also run them locally, which is kind of nice. And there is an interesting aspect of binding into other services, whether they're Azure services, or they're external services, and it's easier just to show a demo more than talk about that. So, with that in mind, let's actually see a demo. This is where I encourage people to try and follow up, so this is a trial, but I'm gonna go here, I'm gonna go to my actually function. So this is my portal, I already created a function, because it takes about 30 seconds, and I didn't want us to like twiddle our thumbs and figure out what to do here. So, this is an empty function. So, if you go on the plus sign really quick, and create Azure functions. You'll see give it a name, a subscription. There is consumption plan on app service plan. We'll touch it in a second. Once you create it, as I said, think about 30 seconds, then you basically have a function up ready. Once you have a function up ready, once you log into it, you see the screen which is very similar to the screen. And I see a few laptops, I hope you are following. And basically, what we're gonna do is just create the new function, and as you can see, they're multiple language options here. We'll start with just say JavaScript. Just for the sake of it, and we'll use HTTP trigger to show thing can work. Let's call this number one, because we'll have multiple, let's leave everything else for default, and hit the create. This will basically now create a function within that function F. And as soon as it finish loading, then I would like to show you how it looks like. So basically, this is it, this is all that it took to create an HTTP end point working in the cloud. I'm gonna do this, so it would be a little bit easier for us to follow. Zoom in a little bit, okay. Cool, so basically, this is it. This is the endpoint for the app. And it basically says here, I need to pass a name, and if you look at the codes specifically, you can see, is the font okay? Can the guys at the back see anything, yes, no?  No.  No, let's see if this works so another thing [INAUDIBLE] hopefully, better? Yeah, okay. Terms I see sometimes. Okay, so basically, the JavaScript code, anybody would note express app knows this, it's familiar with the code, sorry, with the structure at least. You can see it requests a query parameter. If not, then it basically returns 400, so basically, let's add a query and name equal Chicago, because we're in Chicago. Hello Chicago, yay. Click, that's how it is. Let's say, let's change it a little bit. Welcome to Chicago, and then we're going to add here Tech Summit, actually 2017. Hit the Save button. Go here, Refresh, and that's it. And this is how easy it is to create a function endpoint in Azure function, that everybody can touch it now, and work it out. And you can imagine what else you can do with this, and I'm gonna walk through some of that in a second basically, okay? So, okay, let's go back to the slides. What we've seen is in Azure function, we have triggers and binding, and essentially, a trigger is something that invokes your function, as I said, function is event driven. So, it triggers the event that invoke your functions, we have seen the HTTP one. Could be REST, or Webhook, in terms of options. We got scheduling, which is a timer basically, and you can trigger off a multiple few Azure services like Storage, Queues and Blob, and even Hub, and Storage Bluff. And we are adding more and more into the triggers. Essentially, any trigger in Azure function is basically and input binding. As you can see, there are multiple output bindings that we can use, and this is just a partial list. You'll see actually more when we go through the demo, which allows you an easy way to interact with those services. Okay, so let's go quickly through the programming model, then see a demo of the binding that will make it a little bit easier and simpler. So, function programming model has a nice programming model. Very easy to follow and use. We've seen this code, it's almost identical. This line is a little bit different. So basically, what we've seen is we have a trigger, as I mentioned. And there are multiple triggers. And we'll see a queue trigger in the next demo. And once we have a trigger, we have context. And then context basically represent in this, for JavaScript, represents both the input and the output. And you can see here is, I use it as an input with bindings, and I use it, as well for the output for the return value. And then I have bindings. And bindings are those things that basically help me communicate, and work with other Azure services, or other third-party services, without really need to know how to work with those services. Specifically, in this example, as you can see, binding basically a JSON object that is declarative, which means break them into a DevOps and prioritize them, and do a bunch of stuff. You can see there is a input, direction input for HTTP trigger, this is my trigger, there is output, which is returned, this is fine. And you can see here, there is an input parameter and this is specifically for Azure storage, a defined table, a name which is actually Azure storage table name. This is the input parameter to work with. And then you can see here it's a connection, it's not really a connection string. Where is the mouse? Every connection string is appointed to environment verbal that list the connection string. And the cool thing about it is here it's binding the input table dot name. And I do not need to know how to use Azure Storage SDK to actually get to the table, cool? All right, we'll see example to make your lives easier. With C#, it's basically similar, but the C# binding model is a little bit better, stronger than the rest of the languages. And basically, because this is best of four jobs if you're familiar, but there is a slide about that later. So okay, there's a trigger, there's multiple inputs that we can have, and within C# function, looks like any regular functions, right? You would expect to have input parameters in your function to be able to work with in your code. That's exactly what we're giving you. We're giving you InputTable, in this case, which is IQueryable. This will allow you to iterate, and you can see here there's a specific class I can work with. All of this happen automatically within the binding, to allow you to basically work with the binding and with the data, as you would expect with any regular function. Obviously, output parameters are available binding the again. And you can see, I can work here with the code, and work with the, work with the input binding, and just use code, as you would expect. Okay, so let me just see how things are actually working. And for that, we're gonna go back to this application, and what I'm gonna do here is this. So, before we turn in, and now I'm gonna do a the following, and I'm writing in JavaScript. But the next function will be C#, so no worries if anybody doesn't like JavaScript, by the way, I don't, but a lot of people do, so. So, let's create an object called foo. And basically, what we're gonna do is we're gonna go for query names, so we're gonna go for request query, and we're hopefully gonna have a foo object on top of that. And if we basically don't have one, then we're just gonna, I'm just gonna create a default to basically say foo is empty. Okay, and obviously, here comes bar as expected. So, the same treatment with bar. Here goes bar, and basically, I'm gonna say bar is empty. And now I want to basically take this message, and put it in an Azure queue. To do that, I'm gonna do one more thing. And I'll do it now. So, I'll go to the Integrate tab over here. Integrate tab is, I'll show you really quick behind the scene. This is the JSON that we've seen. And the UX view is basically just a nice editor to work with bindings, just to make life a little bit easier. So as you can see, I have a trigger HTTP. I haven't, I don't have any inputs right now. I didn't define any inputs. And I have an output which is HTTP as well. I can add another output. And this time, as you can see, there are a few output options here. There are a few output options here. Azure Service, Blob Storage, Queue Service Bus Table is mobile. You can see external third-party like SendGrid and Twilio, which we'll see a little bit later, the Bot Framework and so forth. So, this is behind the scene, though all the bindings are extendable. We are working on a model that everybody can contribute, but for now, we're just adding services on our own. For this demo, we'll choose basically Azure Storage Queue. Go ahead and select. And once I select, I drop here, and this is a parameter I'm gonna work with. We're just gonna copy it. We are gonna create, we're gonna write to a queue as the storage queue called, outputqueue, we're not gonna change anything. If you can put any name here that you want which is valid as the storage queue name. If it doesn't exists, the system will create it for you. There is a connection string here with every Azure function we create. Basically, we create storage account, so just gonna use that as well. Gonna hit the save. Some cool things about this interface is you can see here there's a little plus where the documentation. A few tricks first, you can get your storage information here. But this actually tells you how to use the [INAUDIBLE] just like a quick reference. Okay, back to the demo. So the only thing we need to do here now is basically say context, and .bindings. And the name that we have copied, and I will say message equal this, and that's it. And this is basically writing message to Azure queue. No sdk, you'll need to know how to work with other queue and how things works behind the scenes. I hit save. We go here real quick. We'll refresh and that's it, we have one item in the queue. Great! You can't really know or believe, but trust me it's there. And I'll show you in a second anyhow. Now instead of going ahead here and writing, adding all the parameters, we have some cool stuff you can do. There's a task tab over here, and if you're familiar with Postman it's like Postman but basically helps really simple API's. You can choose the different methods that you have here. Those are the query parameters. You can add queries, so obviously we need to add, sorry we need to add name. We're gonna leave it with Chicago just for good luck. We have foom, which is great. We'll just call, this is. You know the rest, right? You can with this is a great demo. This is where you supposed to laugh, at least a little bit. And then I can highlight my logs for real quick. I will clear them this is because me trying to zoom in strange thing happening on the portal we can try to do this, it didn't help. And we run it, basically it runs here the information is successful there, again is in the queue. You guys need to believe me but instead of you just believing me I can show you a few things first. You can pop in through Azure storage queue. Ours is storage explorer. If you're familiar it's excellent. I think I'm running on this one. Queue should have two queues here, here is one, and here are the two items. You definitely can see the two sides. I'll try to zoom in. You can see, the first one is empty and the other one is bar and demo which we expect, so we know it's there. Let's see how easy it is to get out of there. So let's create a new function, this time we'll call it C#. We'll go with the queue trigger function, we'll call it demo2 just because we can. We copy this. Doesn't matter, all right. And as you'll see here hopefully, really quick on the logs. You'd be able to see that we are already dequeueing. We're suppose to dequeue items right now. Ta da, nope, failed. Looking in the wrong place. Three, five, eight. And the queue item is not the right queue. We're looking for out queue. So basically like this. Out queue. Save. Hopefully, this will save today. Ta da! Here are the items. Really quick. You can see here foo is empty. And here is foo. This is a great demo. All right, this is where we clap. No?  [APPLAUSE]  You really don't have to play along with me. Seriously.  [LAUGH].  Okay, but we are not done. We can do some cool stuff because now we are in C#, and C# allows you to do some nice cool things. So let's go with public class Poco, right. As you would expect. And let's create public string called foo, obviously with get and set. The same thing with bar. So far so good. So the next thing I'm gonna do is I'm basically gonna take Poco and instead of just working with strings here, I'm gonna actually do it with a class. Again, as you would expect when you write real code. Well real code, this is real code, sorry ignore that. Okay, bad, bad me. So this is Poco, and what happened is the binding will actually take and will try to do the conversion, and we can see. I mean obviously you can experiment with it to be able to see if things go sideways or not. I'm gonna clear the logs for real quick. I'm gonna save. And saving, you'll see that actually ran compilation. And compile success, to every time we actually run compilation because it's C# and if there are errors you're able to see the errors. And we are improving this interface, so you'll actually be able to see better results or easier to work with the compilation process. And as I mentioned we have Visual Studio tools and CLIs. If we have time I'll show the demo, just an introduction but it's there and there are videos. So we can definitely work in that and you can run this locally, we'll see it in second. Okay, so Poco. So run a Poco, run a number and this is from a different application, and this point basically we gonna go here, and run this. You'll see that it has got printed. But this is basically kind of funny printing. Because I don't have anything here. So we can basically go ahead and create public override string ToString(). I'll create something like this.foo + horrible code but for demo works this.bar. Okay, we just save and again go here. Compiled. Failed. Why did it fail?  [INAUDIBLE]  See, thank you, guys. All right. I'll hid this And here it is, four is empty, and bar is empty as expected, so let's go ahead here. And again, I can add the names and all that, which is great. But basically, query parameters are working fine, but there is additional actually other stuff you can do like API routes. So let's go to integrate them here on the trigger which is HTTP. If I scroll down a little bit, there are a few parameters here like the request parameters you can change if you want. You can choose specific method as you can see, like and this is where it allows you to actually create a real API interface. You can change authorization, we have multiple keys, you can change and work with them. We're not gonna to change any of the defaults right now. What I am gonna do is basically just edit route, and I'm just gonna add slash foo and have a Parometer and slash barin Parometer. And as soon as I save this. If I go to the develop you'll see that basically this endpoint now is changed. How I have my API would actually look foo and bar, and so forth. And this is rather cool because the curly braces for foo and bar will actually give me the object itself that I can work with. As again, as you would expect when you go ahead and write code and I never remember my heart what I need to write, so I look at my notes. Okay, binding data. So basically, what we're going to do is we're gonna. This is not as standard as we would like. So basically, the object hangs from context.bindingData. And from here, everything is basically the same. So we go just the same thing. Instead of [INAUDIBLE]. On the [INAUDIBLE] parameters we just go with the binding data because we do the binding for you, so we intercept the route, extend it, and translate it, and basically augment it into this. And now you have those parameters right here. We're gonna stick with outer names as well, just to make it easier. So we're gonna go here real quick, copy it. This one does require a little bit of massaging. So here is foo. Cool, and then this is demo, demo X, and name.  You got two names.  I got two names? I already have a name? Perfect. Good, so I don't need anything else. All right, even better. Ta-da. This did not- well, it looks like-  You forgot to save it.  There's multiple of those, sorry. I forgot to save it?  Yeah.  Really? It shouldn't explode though, but I think I just made a copy mistake on here, so I'll do it again. Okay, now I don't have name, it's supposed to have name. Let's add name. You guys are really helping me, so this is cool, thank you. Cool. Demo hopefully. Ta-da, yay! Yep, so this works as expected, kinda. Go to the Develop tab and this is called Demo. And I can do more. I can actually go here and says, instead of a string let's make it a int, I'll hit the Save button. I'll go over here, run this again. And now it's gonna explode with an exception obviously as you would expect. And the exception says, hey, we can't parse because whatever you pass is not an integer. So you can see the power of how this thing can work. And how powerful this thing can be with respect of quickly iterating building, this is just an API, put it in the queue and do something with it. Towards the end I'll show you a little bit of more interesting example that you guys can participate in. And later I'll show you definitely a bunch of customer examples, and I hope it will go well. So, this was Chaining Queues. So what do we got? We got basically the serverless aspect, right? On running code, I didn't create the server. I didn't deploy anything, and it runs, and it works. So this is where servers compute obstruct all the compute. However, the binding as you've seen obstruct additional layer from you, right. I don't think in this case I just work with Queue, there's another demo I'll show you how to work with document to be, but that's it. I know there is a Queue behind the scene, but I don't know how to work with the Queue, I don't need to use the Azure SDK to work with the Queue. So, there's a lot of scenarios when just abstraction saves a lot of time and makes you a lot more productive. So how this thing work, basically? So Azure Functions Architecture, I'll go quickly on that. But the reason I'm showing this slide is just to understand what the different layers, but actually talk to the fact that we've been building this infrastructure for basically six years give or take. So the app service infrastructure, the bottom line is the thing that runs your Azure website and Azure App Service. And if you have a mobile application, it's doing the same thing, if you have mobile backend. And if you have an API app it's the same thing. On top of that, we have the web jobs, web jobs calling an extension. Web job is being a solution that we have been pushing for three years. It's a very used feature in Azure app service. Basically it's allowed to run acting processing, background processing. And this is the runtime or the heart of the thing that runs functions. Extensions allow you to do all the triggering, the runtime on top of that. This guy is basically the host run, the dynamic of where you can write your application and do all the magic, languages. And you get code and config on top of it. You get the idea. Lot more documentation, if you're really interested. The nice thing about the whole thing, it's completely open source. So the entire Azure Function stack, after the core fabric basically, up to this little thing over here at the bottom is Open Source. Sorry, so if you go to GitHub as your functions, and this is it, this is the project and it's out there in the clear. Everybody can work it out. You can see there are additional repos here like the runtime, the command line interface which allow you to run functions locally and debug them. The portal itself is open source. All the templating around that, we have ability to file issues. We accept external contribution. Sorry, so far we have about 20 external contributors that are not Microsoft. Obviously the main contributor to this repost is our team. Beyond that we have externals and if you have any issues with documentation or anything like that, you can easily go ahead, file issues. As you can see there are bunch of stuff happening recently. And those are the additional repost that we have, this is actually about, this is the SDK itself and so forth. So, you get the idea? Open source, nice community, everybody can work on it. Okay, so really quick about scaling Azure functions. Azure, App Service offers Dedicated and Consumption tiers. The App Service regular model, offered to you free and shared, which are multi-tenant, basic, standard, and premium which gives you your own infrastructure. Your own VMs basically behind the scene. But you need to set how many VMs you want and how to autoscale them and all of that. You pay for those VMs whether you use them or not. And it shows it said it's your responsibility to scale. On the consumption which is what I created on Azure, on where I created this app. Basically, you pay only for the number of execution. And the platform will scale you as needed. And basically how it works is there's a new unit called gigabyte per second and basically number of execution times the memory that you are using. So this little app that we have seen probably uses what? Maybe 150, 200 megabyte and it runs for fractions of seconds. And the unit here, the gigabyte per second is $0 and 4 zeros and then an 8 or 16 or something like that. So anyway, it's ridiculous, ridiculously low. And you pay only when actually you're doing work. So that's kind of a good thing. All right. So with that in mind, what I want to show you know is a little bit more interesting demo, in terms of how you can integrate non Azure services with Azure services, a little bit more complex example. Yeah, let's show you the demo, and then we'll do the interactive piece to it. So for that, I think I'm gonna go over here. All right, so what I have here is a demo I wrote. I created everything in the portal. It was okay, definitely the next one I'm gonna use the tools, a lot easier to work than the portal. But as you can see, you can create quite some extensive code coverage in here and a bunch of stuff. So, what this thing is doing is this. I got an HTTP trigger here which basically is a hook. The demo as you guys will pick up your cellphones, send an SMS and basically to Twilio service. And Twilio calls this function with the payload. It takes the payload, I do something with the payload, basically I break it apart. I composed a new message, I get all the information that I want. And then I serve it to a queue. Cool? That's it, and then a response basically to Twillio saying, don't reply to the SMS. Okay, the next step is I'm gonna run sentiment analysis on those stuff. So, few things to look in this and this is where I actually want you to pay attention. So, what do we got? You can see #r here for referencing an existing assemble. Newtonsoft JSON is actually something we bring on the platform so you can just use it. You can see her unloading additional class, shared labors. I'll show you where those shared libraries in a second. You can see here I'm just regular using Newtonsoft for JSON and then I'm using Project Oxford, which is Microsoft Cognitive Services. I use Cognitive Services to do that sentiment analysis on the string of the text. It's a queue message, remember we pushed in the queue. And I'm gonna get the actual object, cuz I know exactly what I put in. And then I'm running, this is a pattern that we are looking to adopt and maybe create a default tri-catch for the operations, so you can actually manage and handle errors. And again, everything is so you need to handle that on your own. Basically this function goes ahead and do work for me. Sentiment document is from the project Oxford, it's that reference assembly. I'm gonna create a request. Basically, I'm gonna show you, let's read it right now. This is an environment variable, I'm gonna get the key. I don't wanna put the key in the code obviously so if I go to Function setting real quick. Service editor, we'll see the configuration. So again, if you're familiar with Azure App Service, this is not new. What you see here is a configuration for app settings and you can see a good bunch of settings here. Some of them are default like that storage information for the function, the variety time of function all of that. But here you can see, I have two variables that I have defined, basically as a reference to hold the secrets, because I don't wanna put the secrets in code. And within the binding, what we do is basically just reference those, which is exactly what we're doing. Sorry. Here. All right and then basically, I just go ahead and run the sentiment analysis, get the score, move on. And then I'm gonna do a send response. Send response, I wanted to show another thing. Actually, no. Wait I have to do a show it here first. Sorry, sorry, sorry. So sentiment analysis uses ProjectOxford. ProjectOxofrd is not deployed by default on the runtime. What we have here is a the ability, basically, to define project with a project JSON, again, standard. This is like an entry. This is basically, again, how we define to bring in additional references. So this is going to Nougat, and we'll get your package. Again, we'll do it automatically for you as soon as we detect the project. So you can bring any Nuget package, you can bring your own assemblies. You can load, all of that works just great. Let's actually go back to the code. And I can load shared assemblies. The shared assemblies are also something cool. If you go to your app setting, there is something called App Service Editor. And App Service Editor is something that again we had for quite some time. It's basically an online editor that will allow you to show your entire application. As you can see there is, under WWWROOT you have all the functions that are being defined. Like the web hook that we have just seen for example, and so forth. And if we scroll all the way to the bottom, you can see my shared, sorry, you can see my shared folder with my actual classes that I use. So this is just a class definition so everybody can use, and a simple utility to get the environment variable. All the environment variable app settings are basically being set as an environment variable. Okay, this is going too deep for a introduction. Let's just go real quick. So the send response is another cool thing cuz I'm using Twilio. And you can see I'm using #r Twilio, and not referencing anything. I don't have a Nuget package here. And the reason I don't have that is because specifically for Twilio, we added them as a binding. And you can see I got Twilio here as a binding. There's some information on the Twilio account, SID and setting, these are the parameters. I don't have to fill all the information, I actually overwrites this phone number from Redland. And I also have a DocumentDB because I can push this information into DocumentDB. So now what I'm going to do is I'm gonna go back to Develop. Show the log, and the clear, around here. And I'm gonna tell you guys to pull up your phones, right? A real life demo, high stakes and tell you to send here what do you think, what do you feel. What do you think about Azure functions, what you feel about this demo, this session, this day, and let's see what happens. Maybe I should do this before showing the demos, but anyway, we'll see. Let's see how this goes. You can see it looks like, feeling great. This is good. I guess, so more information coming in. This is cool. All right, so you can see the logs are coming. You will also get response I hope, right? Who gets response back? Only one, two? I hope all of you get, what's the number? Sorry, what's the number? Here is the number again. It's a local number, right? I just created today, I don't know. All right, so two more seconds. Got it, so. As I said I pushed stuff into doc DB, and doc DB is pretty cool. And what we're gonna do here now is gonna just a real quick query. Actually see, let's say, we're gonna take one of the guys that actually had good comments. Otherwise, why even bother? [LAUGH] What do you want? [INAUDIBLE] All right so this is it. I think these first few are mine, maybe. Cool, demo, yeah, yeah, these are more. These are you guys. Thank you, thank you this is good. As you can see the data coming in, IDs that I created. Doc DB allowed me to augment certain information or certainly factor in the second, but it's really cool. Your is on point. Thank you, thank you. And you can see all of that, so this is cool. Scale, all of you got this information and this is again no servers behind the scene. I haven't literally didn't manage anything, other than just create some JavaScript code. The very simple select for this and a little bit of code over there. If you want I can run, like, this one, the whole thing. And as you see basically, this is like everything. So I'm saving a lot of information as you can see. Who sent the information, phone number, what did you get from the data, all the data, timestamps, all the original data and all this information? I got everybody's phone number now, I can bug you [LAUGH] not really. All right, I think we've seen that this is good, we're doing good on time. So you've seen this demo and this is awesome. So now what I want to show you is basically use the next, let's say, 10, 20 minutes to talk about Serverless patterns, some real world examples, and show you some actual customer with the building. And then we can have any kind of conversation if you want. Cool, so first scenario we're gonna look is hey, something happened or someone magical way placed a file in the blob storage. And basically you want to a function to pick it up. And this example this demo of animation we take it, we break down the CSV, we put it in the database, in storage table. Doesn't really matter. And we run some analytics on top of it, all right. So the example I'm gonna show you is a person called Troy Hunt, Microsoft MVP, good friend. Basically he's a security guy, he has a security site. And his good buddies are trying to hack it all the time. And basically needs to protect against DDOS. And it's a kinda game, weak sick game they are playing, I'm not sure. So basically what they're trying to do is trying to protect against DDOS. And the thing he's going to do is dynamically configure CloudFlare, he has CloudFlare in front of his website. And he already has an existing application running. So it's Azure website, it runs, got DDOS. He identified that he has a little bit logic in his API. Basically he put a queue with the IP to block. That message is being picked up by Azure Functions, and basically just configure CloudFlare. And on the regular time basically he has ability to go ahead and queue. The thinking is not really about the architectures, the concept of, if he, before he had Serverless, he needs to work it out, he need to set up a VM or a Container or an Azure WebJobs, if you're running app service. And then he needs to build, patch and deploy and manage if it's VMs, but instead even in the WebJobs, he needs to build and deploy. Need to monitor that, who knows if it's actually running or not. And all of this is even before using Azure SDK to do the, to talk to, put the item on the queue, rerun it from the queue, he needs to manage the CloudFare credentials obviously and then use our CloudFlare APIs. When Serverless, so you take a bunch of the stuff that you need to do, right. You basically just focus on hey the CloudFlare credential are as you've seen like in App, I think, Server easy to manage them. You don't need to write code to manage them is the thing, and then you need to use the CloudFlare API which is expected. All right, so what we learn for this is you have a function, you want to do one thing and he actually kept it very precise. Read from the queue, configure CloudFlare as a separate API to actually go ahead and clean up. Okay, next item is basically to have a Timer Based Processing. So we have basically something that happens every in this illustration 15 minutes, go ahead and find and clean invalid data and clean table. All right, fair enough. So we have AccuWeather. AccuWeather is a company providing weather services, they're basically using Azure across multiple data services. Data centers sorry, regions, and what they want to do is replicate logs from one data center to another. Doing that at the same time they want to actually analyze the logs, they're always doing that, and take action if there is interesting data in the logs. So the way they chose to do it is rather cool. FTP and they have a timer-based function that basically go ahead and download files from FTP. Push that into a Blob, single function, the single thing. So good practice. Different function triggers from Blob. So as soon as detected there is a Blob item, it will run and go ahead, get the data, put it into storage. Then run this information on Stream Analytics because there's a lot of data over there. And then again different function will detect abnormal behavior from the stream itself. So that's cool. And again if you look at the same thing here, very similar to what I need to do in this case is an FTP and Azure SDK. But it's pretty much same thing so if you had to do a bunch of stuff before now you need to do a lot lot less, right? You still need to use FTP library and manage credential to get the file but that's about that. So that's not bad, in terms of reducing responsibilities, codes and all that. The last thing about this example is what we learn, and this is getting a little bit deep into how Azure Function works, but it's valuable information. So when you download an FTP, when you access the FTP, want to download the content, you could be facing a very large file or a lot of data. And just by actually being downloaded you could go over the five minutes mark that we have for Azure Function. So Azure Function I neglect to mention, it runs for five minutes. We'll increase that, right now it's just five but doesn't really matter. The bottom line even if I give you an hour, I wouldn't recommend running for an hour for the following reason, and the thing is that if you have a function that needs to run for an hour what happen if it fails on the 53rd minute? Then, you need to run again so you're almost running for two hours. Let's say you will be able, instead of that because this is a problem that you can actually split, share, whatever you want to call it, you will have a function that would read the metadata of the FTP and then run some very basic algorithm. In this case, it just did it by a single folder and basically Queue, put sorry, queue message in an Azure queue which will then trigger a function. But you'll put many queues for many folders, and we will trigger many functions for you to run at the same time. Each one will go and copy its own folder or small folder or portion of the data basically. And then, once everything is being done and set and done into the blog storage. Or one by one, it doesn't really matter. You basically replicated data and put it in storage and so forth. This way, if you fail, you fail in a single segment. Let's say, five minutes, then you basically run for five or six minutes all of them. And then, you need to run just more those will fail. Makes sense? So you share the information. Or share the work, this is basically debatching of processing. Very standard in serverless publication. A better example, you might have seen this. You basically query for a database, you have 10,000 rows. Now, you need to go and send emails to 10,000 people or SMS's, whatever. Usually what we did is we did it for each loop. If we are smart or if we are a more advanced developer we might even use thread pool and undos for each, we will just queue items in the thread pool and let that go but it's still in the single process. So instead of that thinking of you're gonna put 10,000 queue items and then all of the sudden the back end system will just scare like crazy, clean up all these items as soon as possible. Much more faster, much more reliable. So functions real quick, with that in mind functions should quit as quickly as possible for that kind of purposes. I think reuse more reliable, and so forth. This is an interesting scenario and I'm gonna show you a demo for this. Basically, you have stream of data, whatever the stream is doesn't really matter, just stream like devices, we're gonna shore Twitter in a second but doesn't matter you have a string of data. You basically take a function that take the stream take the data do some transformation and just push it forward to the next layer which is a database in this case so anything else is weird. So with this we have a Power BI assistant team to my team basically what they wanted to do is create some sort of example of how can you use Power BI to do some analytics like marketing campaign analytics anything like that. So the task we wanted to do is to collect tweets, analyze the tweets, and display the information in a rich way. And the way they choose to do it is as followed. Basically, tweets are being collected through the logic app. And with the Twilio connector, we'll see it in a sec. Then basically this triggers Azure Functions to go ahead and take the tweet information and just break it and short it and do whatever he needs to do with it, make some analysis, put it into a database. And on top of that they Power BI to basically display the data. Cool. So let's see it in action. This is this. So this is the Azure resource group that is responsible for this wonderful thing that we're gonna see in a second. You can see there is the logic up here. There is the function. There is the database. The database and the server. This standard basically how we use a SQL Azure for the data. There's a Tweeter connection here. And the storage account is for the function. So if we really go into logic app, this is really a simple logic app. Where you can see it runs. It runs all the time. It just runs now. Earlier, it collects tweets, and I'll show you really quick how does it look. It's a very simple logic app, basically there is a Twitter connector, and then just push it into a function. And if I look at the Twitter connection, I'm just looking for serverless, or whatever minimally run everything three minutes. If there are more tweets, it will run more. And you can see here, basically, I'm connected to Twitter with the connection, with a Twitter connection. I'll show you really quick how it looks. If I add a step here, you can add connections. And you can see Azure logic apps come with a really long list of connectors. Really long, really long [LAUGH] list of connectors, Twitter is one of them. You can see there are Microsoft connectors, but there are a lot of non-Microsoft services, what are yeah a bunch on services. And it's cool, because this is managed API that Microsoft has, also you can look at API management, any other logic cap or any functions that you have. So that's ran and I'll show you the output. So I'm gonna show you actually the function itself. So this is the function and these guys decided to implement the function with Python and it's great. Because it shows that Python can run and other functions but other than that it doesn't help because I don't speak Python. And here it is and you can see basically that literally directly connecting it to the database, they're doing some lists, some analysis. You can see they're actually running the sentiment directly in this code versus using cognitive services again they're choice is just a sample bunch of code here. The thing is that every time the function run these ones the analysis put information in database and then what we get is a very rich display that come with Power BI, as you can see here and this is just showing basically strobilus is right here in the middle in terms of term. And these are the people that are actually talking about and there are different clusters of terms and speakers, people that tweet and so forth. So Twitter has become very popular lately. So imagine what you can do with this tool. You can do other stuff, there are, you can pivot here, overview for whatever reason, I'm not even sure what it means. But you have different authors and different hashtags. You can see all the data and information. 50% unique Twitter. This is how many tweets are in there. And I've been collecting this since basically early October. There's the sentiment analysis that they are running on the server list. 0 is like, 50% because there's negative as well. So you can see more people are positive, which is good kind of. So we're good right here. Okay, anyway. You see I have no idea. This is just like cool Power BI demo. But the nice thing about it is this is how the thing works. So let's think about what they need to do before serverless. And the list is quite long. So obviously other than the box for running servers they need to connect to Twitter, they need to use the Twitter API and SDK to get the data. They need to analyze the tweets, they need to build rich client. If I would ask anyone in this room to do it two years ago, you need to do all of that. And will be a multi week project probably. Today and as you've seen, you can use sentiment analysis from cognitive services and then you can build your own. The only thing you need to do is analyze the tweets because we have for the connectors, you get the data, you analyze it quick, you push it into a database and you need to build a Power BI view which is basically just drag and drop a bunch of stuff. Obviously you need to build a data model, but that's a given. All right, next. So yes, this functions is from this. Functions should be stateless because the Twitter connector is nice. But tweets get rid with it and sometimes it fails, and so you need to manage your own item. That will be near functioning to be it's own item Python be able to handle where a sender sends multiple messages because there's never a guarantee there will be only one message delivery. Almost in any system. And definitely with Azure Functions, it's the same and again every function is crossing paths and running from the other. So it's on your responsibility to manage that. So last example of customers, we have customers called Plexure. And Plexure, it's a digital marketing company basically and they have build this platform, to basically do geomarketing. Developer build with SDK application, deploy it from the device or any other swarm of event, as you can see here, from web, from wearables, from point of sale, and so forth. So imagine you drive, your working through, your driving through a certain area, you get a push notification saying, hey, there is a sale or there is free lunch over there or whatever. And they use a lot of other services across the board, steaming thinks takes all the data over here. The use functions and actually use Logic Cap as well. This is actually the old logo of Logic Cap. A small starship, rocket. I just wanna show you what they're doing and how and maybe it will be cool. So this is Plexure, actually got a Immune account which is nice of them. And what I want to show is this, imagine this is a scenario for when you go into supermarkets, You take a cart, we put a tracer on the cart, so it will actually follow you, so as you go along the supermarket, you know exactly where you have been, how long have you been in each aisle, what are you looking at, give or take. And then when you come to the registry to do the checkout, if you use your loyalty card or whatever, they know who you are. So in that case, what they do is basically they're gonna analyze your cart, and provide you with other options. Saying, hey, you bought steak, but you didn't bring wine or something like that, right? All right, so the way it works is if I look into one of those work flows, it's the workflow that they have defined. Behind the scene, this is actually translating to actual Azure logic app, behind the scene. They just completely obfuscate it from their customers. And you can see here a point of sale cart analysis. You can see information passing in and through if you guys would work with logic app, you would immediately recognize the syntax. The important thing I wanted to show in there is sending SMS here. And we'll see the log in a second here. The important thing I wanted to show you is that what they have done is basically, they provide an sdk, so their customers, which are also developers to a certain degree, basically go ahead and can create custom code based out of that, and viola. This should have seemed familiar for you guys. They are basically wrapped because everything is open source on our end and so forth. They have wrapped the editor, and they erupt the creation. They are creating functions on their own subscriptions, but on customers' behalf, and they are managing it for the customers. But now they have a way to run custom code, which we didn't have before, and this is basically, if I go here, this is basically, if you look here, this just an Azure function that we're using, which is pretty cool. And if you look at the experiences and workflow, you can look at logs, and you can see actual all the traces is basically much the same thing I've showed you guys thus far with all the information. All right, I think we're getting very close. We're given a few time for questions. So again, in function programming model, best practice is you want to make sure that your function is doing one thing, easier to debug, easier to maintain, more robust basically for programming long term. Want your function to finish as quickly as possible, talked about it, definitely have it stateless, it's not a must, but it's highly, highly encouraged. Definitely out of the fact that if you're running at scale, we guarantee nothing on where you run. And we can have one instance of your function running on VM1 and a different instance of your function running on VM101, and they cannot talk to each other. So don't maintain state within a function, not good. And item potent is a good practice for APIs in general, okay? So Azure function, yeah, I think it's awesome, okay. It's Event-Based Serverless Compute, as I said, all of the demos you have seen here, there are server behind, serverless is a horrible word. But to describe Serverless, basically the fact that there are servers there, you really shouldn't care that there are servers there. It abstracts away the infrastructure, it abstracts away the services, I/O, this is the binding comes into play, and offers a serverless programming model that if you buy into it, you can build really rich application. And I think with that kind of done, you can try functions if you have Azure. If you have an Azure account, just go ahead and do it in the portal. If you don't, you can go to aka.ms/TryFunctions same thing with Try App Service, go ahead and try App Service. And with that, I think I'm pretty much done. Thank you.  [APPLAUSE] 