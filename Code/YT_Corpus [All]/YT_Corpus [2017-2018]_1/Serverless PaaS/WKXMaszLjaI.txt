 He already got his place on stage. I was planning to invite you to the stage there would be some effects Don't go back Wait, wait, don't go back. I wasn't looking to the stage. I didn't see you, like it is possible. Welcome to the last post of our conferece. Please welcome Daron Yondem Welcome Thanks you. Hi everyone. I'm still here. I'm taking over the stage? Wait, let's talk for a moment. OK No Server, No Cry Introducing Serverless We will have three different presentation in this section. Daron is here with us. Thank you for being here. That's a nice t-shirt. I got only one session right? Just one, but looks strong. Well, we will see if it is strong or not. Crowd will tell. Leaving the stage to you. Thanks again for joining us. Thank you. Ok, 20 minutes. Did they talk about this? 20 minutes is too short to do a presentation? If no-one did, here I did it.  There is a lot I want to cover. I will need to go fast. I will try to do a demo as well. I have it in my slides. But I'm not sure if we will have time for that. This is our titled for today. Here is how the story starts The first time we were talking about cloud I actually checked it, I still have it, They gave me a plaquet when I first talked about cloud on stage. It was in 2008, in Turkey. Since 2008 it is close to 10 years now. And so far if you look at it the description we used to define the cloud is still not applicable. It is of course painful to observe this. What am I talking about? Pay-as-you-go. You pay as much as you use. But If you ask what's the unit of measurement for consumption You might hear interesting answers.  The unit can be a processor core. A CPU per hour, per day. If you think about a pure pay-per-use scenario I should really pay for what I use and not ask me to provision a processor core before I can use. I should not need to estimate how many cores I might need. It does not matter how fast the platform reacts to my requests. you are essentially asking me to assess, or estimate my current of future workload. and the original reason for me to go to cloud was the fact that I couldn't do that. you, the service provider, had to solve this for me. We were discussing these 10 years ago.  If you look at today, we are still not there yet. Serverless is the cure for that. Let's start If you look at it, I'm not sure what sessions have been presented today I did look into the agenda, but I was not able to join to the event early. I had to hop between events today. When we talk about cloud today what is very trendy? Anything? Trendy, buzzwords about cloud? Just buzzwords. Anything? AI! Ok, nice. Machine Learning right? AI, ML, what else? Containers? Super sexy We deploy everything with containers. Everyone wants to learn container orchestration. In fact when you start with it.. Let me ask you something How many of you did production deployments with containers? Let me see hands. One Two I'm kind of happy we are not hitting ten here. Why am I happy? Because this proves I'm right. Containers are sexy. You can easly spin out containers locally with docker. It is really fast. But when you try to go to production the challenges are more interesting. The journey will not be that easy.  It is beautiful in local development environment run, build, drop in seconds create instances and so on it is not the same in production. Because at the end of the day containers are today's virtual machines. There is a new name for it. It works faster. Today, we call containers the new infrastructure. Containers are our new virtual machines. When I need to explain someone what containers are and most of the time I do explain to poeple who don't know about containers because I talk to developers on microsoft stack I tell them to think about virtual machines with a smaller footprint memory consumption is low, OS kernel is shared and that's it. but think about it the same way because operationally it is the same. one major different is that containers are immutable is that a good or bad thing? it is faster, more agile and we like it. but at the end of the day most of the problems we have with VMs are still there. what's the first problem? let's say you need to do security patches. in the old days we patches VMs now you need to patch your docker images you need to distribute your images if you got a global deployment you will need to globally distribute your images you will need to host registries in every datacenter where your app lives do you want me to make it sound more complex when you go to production? and you will need to mess with the orchestration part which is a different world which container is alive how am I going to scale my containers? How do I decide on infrastructure scale based on various container types I have in a cluster. Wasn't cloud supposed to get rid of these problems? Wasn't that the promise? So, is there a savior? Yes, "Everything's gonna be all right!" Our theme is "Bob Marley" as you noticed. "Everything's gonna be all right!" But how? Serverless I hope I will have time for the demo. at least I will show you some screenshots Serverless is what we, from day zero called CLOUD Let me give you some background about myself I'm a developer and I want to play with code Think about it You are writing an app for an operating system out there Do you care if the hard drive is connected through IDE or SATA? you are going to create a file on that OS no, you don't. Hopefully not. because the OS encapsulates that, hides that you get your logical file system you get a stream or something, and put your data there. if you bring this logic into a cloud discussion why would I care about the processor core? why would I care about your physical world? why do I still care about how much memory is allocated? How many cores are there per physical VM? There goes distributed transactions I know that was a big jump of topic but that's where we will land. You will need to tackle these problems. I don't want to! I don't want the additional garbage that comes with it. your new world scaling problems are not interesting to me you are there to solve it Mr. Cloud. Serverless can fix this to an extent. Even if it does not fix all your problems it fixes most. You can't do a 101 presentation without a quote from Martin Fowler right? This is the definition. There are two important acronyms here. Backend-As-A-Service Function-As-A-Service Let's imagine we don't know what Function-As-A-Service is. Backend-As-A-Service sounds familiar though. Whatever the word Backend makes you think about whatever that comes to your mind it looks like, serverless is the solution for it. I'm going to provide somethging and the platform will handle the rest. What do I understand? I just want to work on my code nothing else. I don't want to know about any scaling stuff. I want to write my code Five million people are going to send requests to it? I don't care. I will pay for it. You handle. I don't care about any of the underlying layers. You might define this as an upper layer of PAAS. In theory we are in the PAAS world. But in todays definition PAAS has gotten a little closer to IAAS Can you image a PAAS where you deploy containers? FAAS feels more high level compared to PAAS today. That's the picture you will see when you look at FAAS providers out there. If you ask me, this is the ideal PAAS I wanted to have. You provide the code and it handles the rest. Another important aspect is "no-commitment" No hardware commitment No one asks for estimations. Did your service never got used? Pay nothing. Did it get used once, pay just one. Used twice, pay twice. Whatever the unit of payment it is. At the end of the second item you will see a unit called GB/s I will give example from Azure It is kind of the same with other platforms as well. Imagine this.. this is reality by the way. you have some code and you give it to a provider whenever the code runs you pay for the cpu time and the amount of memory you used per second. That's it. Could that be more granular? I don't know. I don't have any suggestions. If you look at various cloud platforms today this is as much granular as it can get. and you have zero commitment when it all starts. Put your function in production. Not used? Pay nothing. If it is used, pay for the cpu time and memory and you have zero problems about scalability it does not matter if you get five million requests or ten million or just one this is the ideal world. of course in every presentation like this one one never talks about the drawbacks talking about the drawbacks is this serverless thing microservices? building functions sounds like microservices. this might sound confusing and that is about our definition of microservices going serverless does not mean you are building microservices you might still build a monolith you might still not have vertical separation across functional units you might still have huge shared infrastructures that is ok. serverless is maybe an infrastructure model I'm just making up a definition right now, here serverless is not about how you write your code and design it. it is not about your internal code architecture it is a deployment style, a code execution style it is a hardware resource allocation and consumption strategy but interestingly there is a different side for the story when you go serverless there is a big chance it will push you into the microservices direction. you might not like it because there is a cost for going microservices it has additional development costs, operational costs if you don't want to get into that... because of the fact that serverless will push your mindset into microservices you might be forced to take that additional cost but again, you don't need to. now that we are going through these you might be thinking can we build our next project serverless? or, what would it look like if you have built your recent project with serverless? don't think that way. don't think about this like it is the next technology you should migrate. if you want it to be that way, fine. But I don't see it like that. You will need to go through a mindset change. Ideally, if you are going microservices if you are able to take the costs, serverless can be your heaven. With that said, will your choice of FAAS provider help you with service discovery in your microservices world? today none of the provides are very helpful in that. the question is if we are going to build a microservices based solution today should we go serverless with a FAAS provider out there? Today, I would say No. So.. where we are at now? What are we going to use Serverless for? Today, the easiest way is to think about Serverless as your glue between your cloud services. Connect your services with each other. This might sound like event routing Sometimes it's been called the stored procedures of cloud You put it there and execute You want it to be triggered by something or not, up to you. it's the stored procedures of cloud you got a function.  it is deployable on its own its independent. it can live alone. it has its own lifecycle. all independent and it works. so what we can do with it? if you look at Azure Functions here is the list of languages supported. Javascript there supports NodeJS You can use any of these languages per function. By the way CSScript is different compared to C#. The .NET Library option supports all .NET languages. At that point you deploy a .NET assembly. You can have as many functions as you want in a single assembly. By the way, think about how it conflicts with the microservices design. if you have 150 functions in a single assembly and you are deploying it as a single unit can you call these independent microservices? It depends. If you ask me, they end up being dependent to each other if packaged together. We got triggers and binding in Azure Functions. Here I included a list triggers mean you can point an event and bind it to your function it does data binding as well. it does not work with AWS S3 but just for the sake of giving an example the matching service in Azure would be BlobStorage A file upload to a blob storage can kick a function and it can pass your function the blob as a parameter actually you can even bind the data you can even have the runtime deserialize a blob to a POCO. your function will be executed getting the deserialized data from the blob. you can do whatever you want in the function and you can use an output binding to push data out to a blob as well. all serialization and deserialization is handled by the SDK. what you are seeing is the current binding list you can write your own bindings as well the ones that are interesting are first, the webhook you can implement webhooks out of the box and the second one is the httptrigger it exposes an http endpoint for a function to be executed from now demo I have five minutes left. I should be able to do a demo. My laptop is shut down? It's a 20 minutes presentation and I tough I could do this on battery. Help! I'm not going to write code from scratch. Can we switch to my screen? Awesome! I have a prepped Azure Function App I will click here and add a new function. you can do it from Visual Studio. It's Microsoft you can do it from everywhere. I will do it from the portal. When I do it from the portal it will create functions with CS Script. You can't do the Assembly deployment version from the portal. You can do it from Visual Studio and deploy straight from the IDE. Please, internet.  When you click "Add Function" it actually opens a function gallery. You get a list of function templates.  And I have four minutes left. Should we go back? Three, two, one...  I think we should go back to slides. We can come back it if opens up. I do have screenshots though. I knew this would happen. This one is actually a different feature. We will discuss it.  In the demo I planned to do we would have an httpTrigger and get an http endpoint. when we hit that we would see the function running. the CS Script can be anything you want. it is totally up to you in a side project of mine I had a webhook from github hitting an azure function and the function was saving some data from github into a back-end SQL. Why would someone need that? Don't question it please. But when you need it and you don't know how much it would be used and you don't want to pay when it is not used you just build a function and you are done. This one up there is called function proxies. When you start building multiple functions with http endpoints they all will have various addresses. In order to separated URL managemend from deployed functions you can use function proxies. It is a very lightweight API management layer. The function URL and externally exposes URLs can be routed here. Durable Functions on the other hand are simply fantastic. This is a single function up there. I can execute that with an http endpoint. In the function signature you can see the DurableOrchestrationContext When I get the DurableOrchestrationContext I can call other functions in the same function app. if you look at it you will see all the awaits in there. The CallActivityAsync is actually calling a different function. we are sending a parameter to that function executing it waiting for it to complete in async getting the answer and continuing the path. and my main function here is durable which means we have snapshots at every await. when the function goes boom, it will restore from the same snapshot. with every await the orchestrator is taking a snapshot of the state. The orchestrator stores the state in a durable storage. This is called durable functions. A lot of effort would be required to accomplish this. This functionality comes with the functions SDK. There are multiple implementations of the functionality. This is just one of them. You can add all tasks and call all of them async. These are all Azure Functions. Do not forget these are going through http. Calling 10 different functions is one thing Waiting for all of them at once and continuing your flow is another. And again, keep in mind that the parent is a function as well. if you wanted to this on a containerized environment with microservices this would take a lot of effort. here this is part of the platform 1 minute left. Here is the link to the documentation. I specifically wanted to put the Functions Runtime link out there. You can download the runtime and run it on your own datacenter. Whatever Azure Functions is including the management portal you can install it in your own datacenter worked nodes will work on windows containers now that I said it don't think that you will need to manage these containers you can scale the worker nodes as much as you want create your own functions environment it works on linux servers runtime works on MacOS this is the new Microsoft and 10 seconds left I'm done. Thank you all! 