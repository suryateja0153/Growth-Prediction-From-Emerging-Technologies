 Hello everybody.  [CROSSTALK]  Good morning.  [CROSSTALK]  How was the keynote?  [CROSSTALK]  Yeah, a little bit long. Was it late? Was it running late? [LAUGH]  [CROSSTALK]  That's when you know a keynote is good. When it runs late. [LAUGH] So thank you for being here. And let me tell you a little bit of context of this session. This session is impossible to do. It's literally impossible is another view of the application platform for developers right? How can you fit that in one hour? There's no way, so I think my goal here is not going, I need to go deep sometimes. So I will try to do a couple of things that are a little bit deep. So we have a little bit fun, it's not like slides all the time. But the idea is to, to give you guys another view and to answer, you know, everything that is happening at least from a very, very high level. And then we go in a couple of places in a little bit more, more depth. My name is David Carmona and I work as a principal PM in the developer division. So our division is the one doing Visual Studio, .NET, Team Services, Summary, and all the good stuff for developers. We have a lot of fun with you guys. So how many of you are developers here? Can you raise your hands? Nice, okay you are in the right session. So the first thing that I say when I start talking, cuz where do you even start when you have to introduce the Microsoft Development Platform? You don't even know where to start. I like to start with the developer role, right? And I know that this is a little bit. But this is, I mean between us, we have a cool job. This is, we used to say it a lot, but it's not only that it's a culture, it's also how much our companies need us, right? So we are in the center of that innovation. And good news for us. They need that innovation. So the center now of the innovation of any company is the development, is software, is the digital transformation. And that is for us, cool, but at the same time a big responsibility, right? Cuz let's be clear that development is not something that is easy, right? So just because it's cool and we have fun sometimes in our job doesn't mean that it's an easy job. I was chatting with some of you before the session and the general feeling is this thing is getting more complex instead of easier. How can we manage, to make this thing more complex, instead of the opposite? Every industry in the world gets easier over time. Our industry is getting more difficult over time, right. So that's something for us to think, and that definitely has an impact on the way that Microsoft is looking at that development platform. Cuz we hear you everyday on that complexity. The other thing so by the way the example that I always use for how important a developer is, is just looking at some companies out there right? So you see every of these cases it was software the one which moved completely an industry. Completely changed the market, right? So software was the one behind any of these companies that displaced completely another company that was leading, right? So it has that side of the coin as well, right? So we have your responsibility, and not only that, we are the key factor for differentiation but also the key factor for failure, if we don't do it right, right? So that's for us to have in our mind every day. So then what does it mean really? So what are the big challenge that we have? So yeah, we're the center of innovation. Yeah, so what? What are we being asked to do, right? And of course, each of you are being asked to do something very different, which is also interesting how we have to do so many different things. But they're recurring themes that I see all the time, right, with developers. And one of them is a big pressure that we're getting. Let me put it in a positive way, let's call it, instead of pressure, let's call it opportunity. Right, so we have a huge opportunity that we see in every company. And it's moving from this functional app that we've been creating for years to something very different that really has a nice, beautiful, amazing experience and that is not UI. That is more than that. That is things like embracing mobile. Things like customization of those applications. So tremendous pressure that we have to move our business into that area. The other one clearly is the cloud. But the cloud, now that I think, now we're in a moment where the cloud is not really a because I have to. I think we all understand that the cloud is the place to go, right? So we all have that pressure, that hey I need to, so I'm behind my competitors if I don't leverage the cloud, right? Leveraging the cloud, now the conversation is more about how I can leverage that cloud back extending my assisting business. So this is not something about moving some workloads to the cloud. This is really about fully leveraging the cloud, extending my business to it, right? And then the third one that I think that I see all the time has more to do with the how. How we as developers, develop. And those old days of hey we are starting a new project in the company it's called blah and the timeline is two years. In two years we're gonna deliver this project. When was the last time that you heard that? I think many projects that was a two years project, right. Never again. We never have two years for creating our projects anymore, right? So projects are in continuous evolution. And we have the first deliverable in three months. And then we are continuously, every week we are delivering new capabilities. And that's something that dramatically changes the way that we as developers create that software. And that has implication not only on the architecture of the applications that we have to do but also on how we develop those applications. So looking at that, if you now look at very high level, if you now look very high level to the Microsoft solution. It aligns very well. So a way of looking at the Microsoft platform it aligns very well with those three things right? Why? Because you have, clearly you have a whole set of platforms and tools for you to create those experiences that are going to impact your end user. And then of course we have all the cloud platforms for you to extend the business to the cloud right? And then in the middle something that we do which is not really a platform so I not even gonna have a section about that. It's like embedded, it's infused in every platform that we do in Microsoft. You have the concept of continuous agility, right. You have the concept of dev ops for example. How you can deliver those obligations with agility. And those are springboards that we have across the platform, so everything comes together for you to be able to embrace the new cycle. This super quick cycle of developing applications. So this is the way that I'm structuring this session, right? So I have a first section, where I'm gonna talk about the first area, rich experiences. And I have a second section that is gonna talk a lot about cloud. And then on both of them I'm gonna talk about how to do each of them with agility, with dev ops. In one case mobile dev ops, and the other case, cloud dev ops. Sounds good? Yeah, okay, let's go to it. So let's just start with mobility. I don't need to tell you this, right, but just in case anybody didn't notice, yeah, this is not going to be easy. Mobility's not about one OS, mobility's not about one device. Everybody knows that, right? So any analyst will tell you that at the very least three, that's the average on any enterprise. But it's getting even higher and higher because of things like IoT, right? So this is another one of those things that are not going to become easier, but just the opposite, right? So we'll have more and more form factors, more and more devices and more and more different OSs that I need to target. And that's a challenge. So there are two approaches to this. Right, so if you have been developing for mobility in the past, you have two approaches. You can go native. That's a perfectly fine approach, right? Now when you go native, the way that I like to look at this when I make that decision is by comparing hey, this axis is about my experience as a developer. So how productive am I gonna be if i pick this technology? The other angle is how is gonna be the experience for the end user, so how rich is gonna be the experience for that end user, right? And maybe, and let's be clear, it's providing an amazing experience for end users. So you can achieve everything that you want with a mobile application that is developed natively, right? So any API, any UX, anything you can accomplish with a native application. The problem is that with this proliferation of different devices, different form factors, and different OS's, how do I get productivity if I go native, right? So it's not affordable for the regular enterprise. Yes, it's affordable for Uber and Netflix but us mortals, how can we afford having a different code base?. For every single device that we target, right? That's very, very challenging. And not only that, even the tools that I'm gonna have and the abilities that I'm gonna have on each of those devices is challenging. I mean, creating a full native application is challenging on any OS that you are targeting, right? So then you go, okay let's go to the other side. The other side that is very popular, especially in the enterprise, is I go hybrid, right? So I create, using using I will create this HTML application that is using a frame that it looks and it behaves like it's native but it's not native. In the inner side it's HTML and CSS, right? And great news, my productivity goes to the roof, right? Why? Because I only have to write once and I can reuse that regularly. The problem is that I'm sacrificing the end user experience. So I'm using most cases, the common denominator of those platforms and things like getting access to every single API gets more challenging in those applications, in those platforms. And we have that duality that is difficult to manage, right? So in Microsoft, we provide those two, right? So you know that you have the ability to target a Windows on a native way. And we have Cordova tools, as part of Visual Studio. You can target iOS, Android, and Windows with Cordova, right? So we provide that but we also have something for this middle area, right? And that is Xamarin, right? So if you know Xamarin, I won't go in detail but because probably you all know it. But Xamarin allows us to have the best of both worlds, right? So, it's a native platform, so everything that you do is native. Meaning that you have access to all the API. There's not a single API in iOS, Android, or Windows, of course, that you cannot get access to it. Right, so that's important. Second thing is that it has native performance. So you can do things like red UI, you can do things like immersive experiences, as part of those platforms. And the third thing is that you have access to all the native controls. So it looks like an application for that particular platform not something that is across all the platforms the same, right? So that's the end user side. But then, the developer side is like everybody's happy cuz Xamarin, as you know, is all. And that means that I have all the productivity of C#. That means that I can reuse all the code if I want to. Actually Xamarin has something very interesting, which is your ability to dial the level of code that you want to reuse, right? So you can say hey, I want to go 100%, right, that means that I can use Xamarin Forms, which is an abstraction on the UI. And I can use all the libraries in C#, and I can just use a site listing application. The same code across all the devices. But I can go the other way and say, no, I want to have a screen for every single device. And I want it to be different, right? I can go that direction by using the native capabilities, the native UI platform of that device, that's another option. And then everything in between. You can say, no, I'm gonna use some Xamarin Forms with some controls on every platform that I'm gonna customize depending on the device that I'm targeting, right? So that, on top of this is .NET, meaning that not only I can reuse code between all the devices, but I can also reuse code with my older client applications. Like for example Desktop, or, even more amazing, with the server side. So I can, for example, share the same entities across my server side and my client side which is interesting. So this is Xamarin, I think the best way of looking at Xamarin, and this is the moment where I go a little bit deeper for just one second, is showing it to you just a little bit. So I don't have a lot of time to show a lot of Xamarin. There's a session, I'm not sure if it's today or tomorrow, but there's a session on Xamarin, so you can go deeper there. But let me show a little bit how it works. Right, so this is interesting, cuz my mouse is not working. Okay, touchpad moment. This is gonna be ugly. So I have here Visual Studio reading. So I created already a Xamarin application. The way, so just to show you how I did it. File New project, and in here you have all the OS's, right? So you can create an iOS application in the C# node for example, right? That's an iOS app or I can create an Android app. But even more interesting, what I did in this case was a cross-platform app. So in this case I create, this is a template that will create all the different projects for all the different devices in a very nice structure. So that project when you create it, I didn't do anything different, you have this. Let me zoom in here so you can see better. So you can see that, that template is creating a solution that has four projects. One for Android, one for iOS, one for UWP. That's where you're gonna put all the code that really is targeting one specific device. And then you have another one which is portable that goes across the three of them. Now, by default, you can have everything on the portable one, right? So actually, in this particular case, the portable one is the one that has the UI. So you can see here the XAML page, that is a Xamarin Forms page that I have in my shared code. So I'm also sharing the code of my UI, right? But if I want to have here, I could have only the entities and the logic. And I can directly, in here for example, in the UWP, I can have my XAML UWP native UI, right? So I can play with those two approaches. In this case, what I have is this Xamarin here, which is this one that I have open here. This is an abstraction on top of the different platforms, right? Now, the cool things about this approach is that I can still mix, whether I want to go across all the devices and I want to use a specific control or a specific capability in one device, right? So that's the power of Xamarin Forms. So, for example, in this case, by the way, I'm using VS 2017 in this demo, so you can download the RC already from the website. And one of the things that you will see in that preview, in that release candidate, is new capabilities for Xamarin. One of them is what you see here. So this window, so you see here? That is a Xamarin previewer, so you can play with your Xamarin Forms on the left. So for example, I can, what did I do? So you see that it's in real-time. And I can do a rotation -40, right? So I can do whatever I want, right? Now, the cool thing of Xamarin Forms, let me show you something. So what I'm gonna do is I'm gonna import a namespace. Let me show you this namespace in here. So this namespace that I just imported, Is an assembly that is Xamarin.iOS. Xamarin.iOS is the namespace or the assembly with all the API for iOS projected to C#, right? So what I'm basically doing is now that I added that preference, I can use anything in that assembly. Meaning, I can use any control that is defined in native iOS, right? So for example, instead of this one here, I'm gonna remove this one and I'm gonna use a native map. So this is the native iOS map, right? The one that you will use on an Xcode application. So once I do that, let me run this thing. So I'm running this thing on a local simulator, so one of the things that is coming with VS 2017 is a local iOS simulator that is doing remoting to another Mac OS, right? But you don't have to switch between machines or anything like that. So directly from your Windows machine, you can develop and you can emulate an iOS device.  Was that in 2017?  2017, yeah. Yeah, the question was, was that in 2017? Yeah, it's part of 2017. Do I have a connection here? Did I lose the connection with the emulator? Let's do it, let's give it another chance. So let's think what is happening here, right? So what I just did in Xamarin Forms that allows me to go across all the devices. I added a native control that only exists in iOS, right? So the key question here, so if I do this on an Android device, what would happen? And you will see that what happens is that, of course, that control won't show up. So you have the ability now to create sections that apply to each particular device. So you have, it's like the best of both worlds, right? So this is a native iOS map. The cool thing is that because this is running on my Surface, I have multi-touch, right? So I can even, with my fingers. I think this lost the connection again. Okay, so you saw the concept, right? So I'm having some connectivity issues here between the two laptops. So directly in my Windows machine, I can develop iOS, Android, and Windows applications, and I can go a native with them, or reuse as much code as I want, right? That's the core concept. But do you think that's everything? Do you think that's all you need to create the application in multiple devices? And this is where we move into what we said before, right? What about the agility? What about my ability to continuously create, to continuously deliver this application? That's tricky, right? And that's where you have things like. So on any other platform, you need to think about things like, how did you build that? How did you continuously build this application, right? So how do you set up a continuous integration and continuous deployment environment with a mobile application? How do I test that application? How do I make sure that obligation is gonna work not only in my simulator but also on all the different devices not only for a particular platform but for any platform, right? So how do I make sure that this is working on other Android devices or the newest iOS device? Right? Or the newest Windows UWP PC? So how do I manage all of that, right? How do I distribute this application? How do I measure the analytics? How do I close the loop on cross analytics. So all of that, I need a solution that can help me to achieve all of that, right? And the traditional approach is yeah, there are tools everywhere for each of these items, right? So you can mix and match from author and you will have frank staying in there, that you may be able to be successful, right? But our idea is, let's make sure that of course we have all these services available for you as individual services or each of the service that you see here. You have that available and you can use it just by itself and you can mix and match with other services. But we're also coming with all the services together in what we call Visual Studio Mobile Center. So Visual Studio Mobile Center is basically. Our collection of services that will help you not only on the developing of the application but also the entire life cycle of that application, right? So let me show it to you super quickly how does it look like. So I have it here again touchpad. So this is a mobile center. So you see that it's very basic interface. So you see that there's the bottom of their add new application. Let's click there. So this is gonna let me create a new application. And the first thing that I can see. So the application, I can use any framework, right, so it's not only Xamarin. And that's something important, so if you are using anything. Like for example Native, Objective-C or Swift for Xcode you can use it here. And in this case let's click on Xamarin. The next thing that it's asking you, so we said that one of the things on this, when we want to achieve agility is continuous integration, right? So this is allowing you to set up continuous integration for mobile applications. And that is challenging if you want to do it by yourself, right? So that means that this thing is gonna connect to that repo to that repo that I'm gonna select for example that one here. And every time that I make a change on that repo. It's gonna get the sources. And it's gonna build the native application for me. And building a native application, as you know, is not simple, right? So it includes all features of an iOS application, it will include running this on a Mac device, right? It it's an Android application, we have to deal with the Java's degree. So not simple to set up that, right? So, I can click it here and you can see that it is asking me is basically, what's the solution in that report and then when do you want to build that solution? Right? Every push, so every time that I made a change on that repo It will trigger a new bill or in demand, right? So i just click where i wanted to and I want it to be built. The next thing that it's asking me, and this is the other thing that I said before, right, so, if it builds, that doesn't mean that it works, right, especially on the mobile wall. How will you know if that application is gonna behave the same way on every single device that is out there? So, that's where we bring the Xamarin test cloud. So, Xamarin test cloud allows you to run your application on hundred of thousands of different device mobiles all in the cloud. So, you have to have them in your office, right? So it's as easy as selecting the devices. You just need to click on the devices that you want it to run. And then depending on how far you wanna go you have also the ability to create your own tests like, hey, your script on work, the automation script for that particular test. And then it will upload the application, the test, and it will run it for you after every bill, right? So you not only know that the application works, but also that it works on every device. And the last thing is the distribution, right? So, once I test the application, how do I distribute that application, right? And, you can do it directly to the corresponding app store of that particular device, but, usually, what you're gonna do is having different groups of beta testers or internal people that will help you to test the application before going to the app store, right? And in this case you can see that I can define groups of people and I just need to click on the relevant groups and the application will be able to automatically deploy to those devices once it's built and tested, right? So everything, so far, so good. So, I'm not gonna create this application, because I have one here with some data on it. So, you can see here that I have things like build. So, this is my log of the latest builds for this application, all in the Cloud, right? And I have all, depending on the branch, I have a branch like follow, so I can see that directly in there, right? So that is the centralized build. And that is, yes, the surface, right? Cuz the closest that I have in here for a sample is test. So for those applications, for those builds that succeed, I have complete information on how the test of those applications went in this cloud of devices, right? So let me click on one of them that didn't go well, for example this one here. So I can see here for example. That these particular test, the sign up test didn't work. And I can go through the steps. You can see that as I go through the steps I have a screenshots right of my application. These are real screenshots that happen on real devices that I don't have, right? So and this is the test that was a security in dull script. So I can see all the steps in there. I have also the option to see the video, but in this case what I can see is that this particular step didn't work on that particular device, on an iPhone 4S. Who knows why, right? So now I can go there and see exactly the logs, and where that's an ability that I have. On that particular device, right? So you see all the power of the testing cloud. What about distribution? So for distribution this is easy, right? So it will let you know where is the application right now? So it's the QA, QA has that particular version, collaborate those, have another version. But the good part of it is that I can see the analytics, right? So in this case, let's go for example, for questions. So I can see the questions that my users are having with this particular application, right? So in this case, I can see here an exception. In this world inside of the blah, blah, blah. I can see the structures in there, i can see all the information that I need to really fix that issue. And I have also [INAUDIBLE] to see analytics,right? So all my daily sessions, the duration, distribution by device. I can have my own events, so I can say, hey, every time that I do something in my application. Like I add a team or something like that, I have an event. So all of that information, all in one dashboard, right? So the perfect solution integrated for you to have that entwined view on the application. So this is VS Mobile Center. But this is just half of it. Because now we move to the cloud, right? And this, so most of you were in the keynote, right? So you know how we, how the cloud is really transforming the businesses, right? So I'm not going to go there. I'm just going to talk about practically, for us developers, what does that mean, right? And the way that I like to look at it is by. There's no, so I'm pretty sure that none of us in this room will say today or that particular day I personally remember on January 21st, 2014 I was in the Cloud. I made it, I was finally in the Cloud. There's, that probably in another context like our managers. They may think that, right? But that's not the reality. Cloud is a journey and we take steps to the cloud and you are never fully 100% in the cloud. Actually, you are never, you are probably depending on your application. You have. You're fitting different places, right, different places of maturity. So this is not as easy as just say, boom, i am in the Cloud, done. And the way simplifying all of that journey to the Cloud, the way that I see that journey happening a lot. In different phases, depending on the application. So it's not the whole company doing these steps at the same time. But you have of course, coming from on-premises, then you see now the first step is how you embrace the cloud infrastructure. So ISS, things like VMs in the cloud, and then you go what I called born in the cloud, right? It's like, when [INAUDIBLE] the metrics. When you see everything in the cloud, right? And now you have all your applications. And leverage in really truly, leverage in the cloud, right? And that has a lot to do with how I use cloud as a platform, and not just only as infrastructure, and that has a lot to do on even how I architecture my applications, right. And we're gonna talk about that a little bit for a minute now for Microsoft services. But when you're in that, when you see the metrics, right? The benefits that you usually see is. So one of the simple IT costs, so the [INAUDIBLE] is that when you go past you are fully cloud native which means that you are leveraging all of the performance. And you are optimized for the cloud so that immediately is cost savings. So the factor of utilization of VM in the cloud has nothing to do with something like a app service where you only pay for what you are using, right. Then of course, you have even deeper transformations like how quick you can develop, right. So pass is not only about constructing infrastructure, it's also about getting you services, right. That you can use. So that allows you to build on top of services that are part of Azure and therefore development cost can go down, right? And then the last one is agility. So if you do this in a way that allows you to deploy very fast. That allows you to deploy each piece independently, that means that you are able to do the same thing that we did before with mobile, but now in the server side. How I can continuously develop and deploy my individual services to the cloud, right? So we did a research with Forrester and this is Azure, so this went to Azure customers. And we basically partnered with Forrester to identify what was the benefit of those customers. That we're moving from IIS to PaaS, right. Then the two numbers that I especially interested are the two on the right because those are the ones that affect us right. So 80% IT time save that's us. That's time that we save. Right, so that's cool, 80%. And 50% faster time to market, that means less time developing, right? So that's us as well, right? So those are numbers from analysis and real customers, right? So those are very eye opening on what we can achieve if we are in this boring in the cloud face, right. Now let's take a look to Azure. So I can't bring and you probably saw that slide with all the services in Azure, right? So that slide is like mind-blowing, like my gosh, so many services here. Where do I even start, right? So if I want to simplify to the max for us developer. What is Azure for applications? I go summarizing those four layers, and it's a super simplified version, right. But there four core servers for you to create applications on top of Azure. Below this one, this is like a layers structure. Because below all of this you have IIS, right? So below ACS you can assume that you can always go to the and do VMs on Azure, right? Or scan sets, totally fine. And then on top of that you have different levels of instructions on top of the platform, right? On the first level, that I always look at it from an instruction point of view on the VMs themselves is Azure Container Service. Azure Container Service allows you to embrace a microservice architecture or embrace basically a place for you to manage, scale, and orchestrate your microservices with containers, on top of VMs, right? And is the very first step of a structure that you can achieve with Azure, so you will have to manage things like moving containers or managing those containers, or scaling them on top of the VM. The next one is Azure Container Service doesn't solve a lot of development challenges that you have when you are embracing a cloud native architecture. So think of managing a state. Managing identification. Managing all the issues, knowing all the issues that you have where you are in a sole distributed architecture as Azure container service, right? So that's why if you want to get abstraction on top of that. If you want to get an abstracted platform for that will take care of things like those for you. The service fabric, right?. So you can use that to get a different level of productivity. Then you can say, you know what and then, I'm not creating a high-scale microservice, hundreds of microservices architecture. I'm creating a web application. I'm creating the front end of that application, or I'm creating the services for that mobile application. I'm creating web and mobile application. Then you have a different instruction layer that is app service. If you are creating a web or a mobile application, app service will give you a much higher instruction that will help you, help create your application, tailored for that particular scenario. Now if you are creating the next, you are working on a bank. And you are creating your microservice architecture for all the back end of the bank. Then that's not app service. That probably could be something like service [INAUDIBLE]. But if you are creating a high scale, a web application or a mobile application, app service is perfect for that, right. Then on top of that, even if you want to strike even more and you don't even want to care, you don't even want to be focused on things like services. You go to functions, and in functions you don't even have the concept of a server, you don't even have the concept of managing anything. So function is yes, a piece of code that you can ask it to exit here, it will execute for you and it will return. That's it. That's function, and you don't have to care about the concurrency, or setting threshold on CPU for when it's needed, to spin a new instance of that, for example, app service or going down container. All of that is being done by Azure. Now you only pay per usage. So you don't have to worry about the service behind it. So let's do some demo, so we can get this concept. I'm gonna start top down, so I'm gonna start with the highest level of a structure with functions and then I'm gonna go deeper on that, okay. So functions. I have here, I can close this one already. So I have here, I'm already in the Azure portal. I'm in a function there. In this case, I have a function already created. But before I go into the function, let me create one for you cuz it's super easy. So the mouse is back, awesome. So you have already pretty fine template for functions. In this case, I'm gonna trade that in my opinion the simplest one which is a simple HTTP trader. So these are templates, we'll see how you can customize those templates but you can think of a function like a piece of code that is executed in the cloud when something happens, right. And that something happening is the input trigger, right. So you have to find that input trigger and you have multiple ones. So you see in there when something arrives in a cue or [INAUDIBLE] triggering, some other service where something's stored in our blog storage, something an event in Event Hubs. In this case, the HTTP trigger is when an HTTP request comes, right? So it's the easiest, the simplest of the triggers. So once I do that, then we just create it. I'm gonna go, so you see that there are four here I'm gonna go, instead of showing the code I will do that in a second. I'm gonna show the triggers, right? The integration part of it. So this is where I can customize this template to tell Azure when is this function going to be executed. What is gonna be the output? So where is gonna be connected to? In this case, super simple. When there's a [INAUDIBLE] request, this trigger, it executes, and the output goes to another indirect return of that HTTP request. So a service, right? So this is really a all of this. We [INAUDIBLE]. An API. A web API, right? So it's that simple but I have the ability to change it, right? So I can delete this one. And you can see here all the triggers you have timers, events, files. Let me go back to the HTTP one. Okay, so those are the triggers, right. Now, the code. So the code I have two options for writing this code. I can do it here, in the browser. That's an option. So as you see there's an in browser experience for creating the code. We also have [INAUDIBLE] for Visual Studio, right. So you can use Visual Studio, specially if this gets complex I would recommend you to use Visual Studio because you have IntelliSense between. You have multiple files, and it's much easier to manage, right, Bob?. In a case like this, which is literally, Hello World, I think this should be fine, right? What this method is doing is it's logging something for Bob, it's basically taking a parameter here, so this is a parameter that it is taking from that request and it's doing hello and that part of it. That simple, right? So, I can go here if I run it, by the way, let me add before I run it [INAUDIBLE] .info, and I'm going to show the parameter. [INAUDIBLE] plus [INAUDIBLE], okay? Now, I'm going to save it and run it, so you see that this is a development environment, right? Even without having the trigger, I can always execute, so you can see here that this thing is a unit. I have here parameter Azure because the parameter that it used was the string Azure, right? But the cool thing is not that, the cool thing is that I can take this, and this is service that now I can ping, right? I can come here, put this, and I think I have it in here already, Chicago. There you go, and this is a service, so I just added Chicago as the name parameter, and you see that he replied, right? Super simple, so I didn't have to set up any server, many plant, nothing at all, right? I pay per usage, right? Super simple approach to operate. So, the highest level of a structure, and I can do cool stuff. So in here I have an assisting one, let me show you this one here. This one is also a function, in this case it's trigger. If I go here to the integration, this is triggering when there's an image added to an Azure block, so a particular Azure block, whether anybody is adding in their file, this function will trigger. The output will go also to another Azure Blob Storage. So, what this function is doing is taking that, let me show you this. It's taking the file, it is decoding that file, to suppose that is an image and a jpeg image, right? With that image, it's calling, and you can see that call a little bit down here. It's calling cognitive services To get the sentiment of the person who's showing up in that image. So this is getting a little bit more complex, right. So, taking the image in the service, calling external services, and calling the emotion APIs as part of connectivity services and then understanding the face that is in that particular image, whether it's happy, it's sad, it's surprised, whatever. And then depending on that, it's creating an image That I see here, if it's surprise I will use a different frame for that image. If it's angry another one, if it's happy another one, right? And that will save it in the output, in the. So then the result is that if I go here, I have here the storage is right? So this is the storage This is the blob stories that is listening to that is the function is connected to right? So once I'm here let me go in here. I think I have here a file with [INAUDIBLE]. What is this? [INAUDIBLE] I'm gonna add this surprise [INAUDIBLE]. Let me just drag it in here. So it's uploading it. Now I can go to this and you can see that the function executed, right. And you see here all the parameters, all the output. Anger is low, contempt is low, disgust is low, but as you go to the right, you see surprise is the highest. Right, so it can work. And with that information, the function created another image that is stored in another block of storage, like I double clicked to already. We have created this nice card with a surprised man, right? So that action functions, right? So There's no more instructions like this. I mean we could think that would probably there will be another layer of instruction, but right now, if you want to do service in Azure, that is the highest level of instruction that I think you can assume for developers. Let's go to the next one. So the next one is, you want to go deeper to that kind of stuff that we saw in the slide, right? So for the next one, I'm not gonna use functions, I'm gonna create an ASP.net web API. Let's see what can I do with that, right? So now I'm gonna switch to Visual Studio. I can close the solution and I'm going to create a new project, File, New Project. So some context in here. So this afternoon I will be going much deeper on .NET core. For this particular session. And of course, everything that I'm doing here I work in the .Net team. So I'm gonna do everything with .Net. But you can assume that everything I'm doing here you can do with every other language, right? Like or Java or whatever you want, right? So Azure supports all of them. In this particular one, what I'm creating is ASP.Net core application, right? And that has several advantages Being one of them, as we would see for those who want to come, is cross-platform, right? So I can develop this and deploy it on any OS, not only on Windows but also on a Mac and more importantly, Linux. So that means that that, on top of the architecture of .NET Core makes it perfect for containers. So the challenge for this demo is I'm gonna create a container based on an ASP .NET application. And we'll see what we can do with that, okay? I think before doing that, let me do something. I'm gonna go back to the slides just for a second. I think I need to do this first. I think I need to go a little bit before that and explain microservices right? So, how many of you are familiar with microservices? Half of you, all right. So, another buzz word right, and as any buzz word, Very careful with them, right? [LAUGH] So don't jump into something just because everybody's talking about, right? So and then microservices there are many ways to explain what is the microservice. What is a microservice? I like this one. I like comparing to a known microservice architecture, right? So We come from a world that we use to have the architecture that you see on the left, right? So we used to have monolithic applications that are separated into functional layers. So you have a presentation layer. You have a back end with a business layer. And then you have data access on whatever layers you have in there, right? That was a great architecture, and we've been using that architecture and it's still a great application for a lot of different applications, right. Now, the issue of that architecture comes when we connect that with what was said before of agility, right. So now imagine that you want to be agile, that you want to continuously deploy and improve this application. The obvious way to do this is to make sure you are embracing an ideal organization, an ideal development organization. Which means, you have more isolated kind of independent autonomous teams that are creating a smaller chance of that application and have continuous delivery of that [INAUDIBLE] of the application. Right? So imagine that you have, for example, I can talk about our case in developer division in Microsoft. So we are like probably 1,500 people more or less. And we don't have, so we have organization is splitting into smaller things, right? And everything is in a room, right? So we have shared rooms. So everything from 10 to 15 members. They are sharing the room and they have the entire responsibility of everything. From talking with the customer to creating the application to testing the application to deploy the applications And then operate that application, learning from operation and close the cycle to do the next on that particular panel application, right? So, that is extremely, cuz then you those teams highly accountable for what they do and continuously creating those applications. We felt these super long cycles. Of bringing everything in the organization together right? That never happens right so you need a lot of always right. But something and this was I think I don't remember his name but there's a nice quote. He was from the 50s. Somebody saying that a [INAUDIBLE] mimics The structure of that organization. So usually by looking at the [INAUDIBLE] organization you can see how is the organization structured, right? So if you want to create a monolithic application then you create a monolithic organization, right? The other way also works. So the only way for us To make sure that moment of independent isolated and autonomous PC working completely. The only way for that to happen, is creating useful architecture that we need in that organization. Which means, micro services. So, the other way at looking at micro services is a way for you to change your application in other PC's Each of them independent not only from the functional point of view but also from the operations point of view. So you should be able to deploy. Completely independent from the rest of the microservices of your organization, one particular microservice. That's the magic of microservices, right? Cuz then you can have multiple microservices in an organization, and each of them created by one particular team, that can run by themselves, right? Now, that's the happy way of telling the story. The horror way of telling this story is the mess that this could be if it runs out of control, right. So imagine that each of those microservices are completely incompatible. So imagine the versioning nightmare that you can have in there. Imagine how complex it is to manage a service or an architecture with hundreds of thousands of microservices all running in an orchestrated way. Going to deployment, going to production in a continuous way for each of those microservices. Making sure that everything is orchestrated, that's the challenge of that architecture, right. And that's where you can think of the Azure Container Service as the basic infrastructure for that. And then the rest as additional level of abstractions for that. So microservices, you realize that I didn't mention the other buzzword of the year, of the almost decade, not decade, but at least a couple of years, which is containers, right? And that's because microservices and containers are different things, right. But the reality is that containers is a very straightforward implementation that you can use for implementing a microservice architecture. So that's why usually you will see that they come together a lot. And when you say container, usually the next word is, of course, Docker, right. Docker is de facto standard for creating containers, right. So let me show you this thing here. So how do we connect microservices with containers? Why are they always so close? The reality is that one of the challenges that you will have when you're creating a microservice architecture is how you package that microservice. So you need to make sure that the microservice is lightweight. So imagine that a potential implementation of microservices, you could say is, every microservice is one server. Nightmare, right? So there's no way that you can manage that. If you need to spin a new server every time that you deploy a microservice, that's crazy. The next thing you could say, yeah, I want to create VMs, right? Not a great idea either. Cuz microservice, you have hundreds of thousands of microservices. So you need high density of microservices, and VMs are not providing you high density per server. You need something lighter. And that something lighter could be a container. So containers are very lightweight implementations of an isolation technology, that allows you to run multiple containers on a single server. And that's great. The other big news about containers is that it can be packaged in the developer machine or anywhere. And that thing, directly, you can move it between or across environments without making any modification. That is interesting, right? So that means that the whole thing of, hey, it's running in my machine but it's not running in production, that shouldn't be the problem with containers. Cuz you can create the container in development and that can go to production, right? You are physically shipping that container, right. So when you bring the two things together, that's powerful for microservices. So in our case, so when you can think of Visual Studio and containers, in this case I'm using .NET, but again, it could be any technology. So the cool thing about containers is that you can create that container in your development machine or on places like VSTS, right, on a central CI system. And that same container, you can decide to deploy it to Azure or you can decide to deploy on-premises to either Linux or Windows Server. And with .NET Core, you can do that. So you can target Linux containers or you can target Windows containers. And the same container can flow through all your development process. So then this gets complex, right? So what is the level of complexity here? There's not only one microservice. There's gonna be many microservices. So in this case, I have five microservices, each of them done in a different technology. So you have, even Java, Ruby, whatever. You can create microservices on any technology, right? So now the tricky part is, how do I set up what I saw in the mobile piece, that continuous integration and continuous deployment, with containers? How do I set that up? Not easy, right? So what you can do, and that's what VSTS, what Visual Studio Team Services is enabling you to do now, is shipping or orchestrating that whole continuous integration process. So this is how it works. So you go to Visual Studio. In Visual Studio you use any of those technologies to create the container. In this case I'm gonna create .NET, right? You create that container in there, you can test the container, etc. You can do everything that you want with that container. But then, once I push the code to my Team Services repo, that is gonna trigger the build, right, just like regular. It will trigger the build in my continuous integration server. And what VSTS can do for me is packaging that container, or multiple containers if I have multiple services, and deploy those containers to my development environment or even to my production environment. So that's all the orchestration is what Team Services can do for you. And then you can deploy that to a service like Azure Container Service, which is the orchestrator in production for those containers. That allows you to scale them, to monitor them, to manage them, to administer them, etc. So that's the magical combination. So I told you that I was going to go deeper in a couple of places, this is one of them. So now I'm gonna go deeper here, right, for you to see the power of this. So I'm gonna start, as I was mentioning before, with a very simple ASP.NET project, right? And in this ASP.NET project, I'm gonna create. Let me create, so I'm doing here, let me show you what I'm doing. I'm saying that the solution is called MyContainersApp. And that solution is gonna have, at the beginning, it's gonna have only one project, which is a web application. I'm gonna start with one single application here. And did I create this application before? Let me check very quickly. Demos Containers. Let me do it here in this folder. There you go, okay. So on this application, I'm gonna create a web application. So a simple ASP.NET Core web application without any authentication. Okay, that is going to create the application. So I won't go into the details of the ASP.NET coding here. But let me just show you. This was because of the [INAUDIBLE] open, let me check. Okay, let me just show you that this is a web application with a controller in here. This is the template for ASP.NET Core application. And if I run this application locally. And this will run on IIS. Let me start closing. Okay, so this is my application, right? So it's running locally, so I can do this. So what I'm gonna do is when I click on About. I'm gonna just show in here, let me show this. This is basically using, it's getting the OS, the description for the OS that I'm running on. Just to understand which OS I'm running on. And I'm gonna run this again. And when I click on About, it will show Windows 10. Come on, come on, About, Windows 10. So far, simple, right? No containers involved. So what I'm gonna do now is I'm gonna package this as a container locally. So still, nothing about continuous integration. So let's start easy, right? So the easiest way to do that, let me just pin this thing, is I can right-click, Add  Docker Product Support, that easy. When I have that, what it's basically doing is adding a couple of files. One of them is this Dockerfile that you see here that is defining. So this file is defining the container. So it's telling it, hey, get this image from Docker Hub, right, from the repository of containers, right? So you have images for a lot of Microsoft technologies. And you have several images for ASP.NET Core that you can reuse. And then in there, copy my application and execute it, right? That's it. So once I have that, now when I run this thing, you see that it's now showing Docker in here? So let's debug this application. Now, this is tricky. So now this application is running inside a container. Right, so the container has been packaged. That container is running. And I'm able to debug that container from Visual Studio, right? Now, the interesting part of it, if I click on About. Am I, no, this was the wrong one. [INAUDIBLE] Okay, you saw that I can break my code, right? So break. But now the funny thing is that if I hover my mouse here. Linux, right? So now this whole container is a Linux container. I can create a Windows container, but this is a Linux container. And I'm running it locally in my Windows machine. Now, what do I do with that? So now I have my container. So without even going to the CI system, what I can do with that container is that I can deploy to Azure directly from my development machine. And it's the same container that is deployed into Azure, right? How do I do that? So I'm gonna go in here, again, right-click, Publish. And in Publish, let's create a profile and say that I'm deploying this thing on a Linux app service, okay? This will, let's wait for it to pop up. Okay, let's use this source and it ends on 24. So this is creating now an app service in my Azure subscription, right? And that app service is gonna be the host for me to deploy that container, right. So if I come here, this is done. So I have here my new application, my new app service that was just created. So far so good. And now I'm gonna Deploy my application. So what this thing is doing, I'm going in the meanwhile. You saw I was going to this configuration of that app service. What this is doing right now is compiling my application, put it in a container, push that container to Azure, to a raise 3 in Azure in the meanwhile. And then getting that from here, right? So, It is hosted on app service. That's basically what it's doing. So one that is done, this is the configuration that is now changing. So, Visual Studio is going here in changing that configuration to point to my image. When that is done, this is the new website. And it's running as a container in Azure. So this is the simplest way for you to create a container, right? That simple, and now, that container, you can do whatever you want with it. You can move it to any Linux or to any on-premise or cloud. Now. Let's make it a little bit more complex, right? So the next step that you will usually have with containers is that you will have more than one container. So, let me add another service in here. Let me close all of these. And I'm gonna right-click, Add New Project, and in this case, I'm gonna add, I'm gonna call it Service1, okay? I'm gonna say that is a Web API. And directly I'm going to say enable. Let me do it by hand. So I have this servicing here. Let's do the same thing at Docker Support. It will create, so this is telling VS to create a container for this service. Now I have two containers. I can also now orchestrate the two containers. So I'm gonna say add solution support. And what that is doing, let me show it to you. Solution support is creating this other file. So this file is even higher level, right? So now this is defining all the different services in my application. So with this file, I can take now this file and take to an orchestrator like ACS, Azure Container Service and I can deploy this application, right? It would be exactly the same but in this case multiple containers. So far, so good. Now, the difficult part is not that. The difficult part is how do I set my dev ops continuously so this is gonna work every time that I modify the code, right? If we're doing that, what I have is right-click here, Configure Continuous Delivery. So what this is doing is it's taking all these microservices. It's taking all the solution that I created and it's going to set up a continuous integration environment for me. So every time that I change anything in this code is gonna do all this stuff in the cloud, right? Is when I take my code is gonna bill and package those different containers, and it's gonna deploy those containers to Azure. So I can continuously improve and continuously deploy my application. I'm not going to actually do this, this will take a while. But then, what you're gonna have is a system like this. You're gonna have a first thing they will have is an ACS. So this is an ACS. This is Azure Container Service. You can see that it has a release in there, DemoTechSummit that is pointing to my repo in VSTS. That's all that it's doing. And then the other thing that it's doing is that in my VSTS if I go here and I see my builds, this is one of the builds that I have. My build in the server is creating that Docker image for me. So it's taking the code, creating the Docker image and then at some point deployed if I go here to release automatically for me. Let me go here. Tada da da dan. Where is edit? Edit here, you can see that is deploying to ACS. Right, so that's everything that it's doing for me. So I have a very complex continuation scenario with just one click, right? Configure continuous deployment from Visual Studio. That would be like going deep, deep, deep in the stack that we're pointing before, so. Let me go back here for a second and let's do a step back. So what are the three things that we have seen in this session? So at the beginning, we saw operating those reach applications for any device. And we saw how in the process of writing those applications, you need the agility that it can be provided by things like continuous delivery, right, and that was Visual Studio Mobile Center. On the other side, we saw how you can do the same thing in this case, for the server side, with all the different levels of a structure that will allow you to attach and to grade any application that you want. And then, how, no matter, [INAUDIBLE] that you pick, you can implement as well, a continuous delivery mechanism with DevOps. Now, we'll see, I have three minutes, so I can get some questions if you want to. I think what we can do is close it here. I will stay here on the stage so if anybody has any questions, cuz I don't see mics in the room. If anybody has any questions please come here and I'm happy to stay here for more time. Thank you, guys.  [APPLAUSE] 