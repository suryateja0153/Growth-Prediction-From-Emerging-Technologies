 What happens if our sensors have more than 2 or three wires? We have explored photoresistors, Hall Effect sensors, and break beams. They each had simple circuits that connected them to the Arduino. Inertial measurement units are more complex. They use Microelectromechanical Systems or MEMS devices, which are only micrometers thick. They need additional circuitry to amplify and filter the small signals they produce. The gyroscopes, accelerometers, and magnetometers are put on an integrated circuit or chip with the components needed to produce a useable signal. Option 1 is to buy this chip from a retailer by filtering and finding one that fits our needs. If we found a DIP version of the chip, we could prototype using a breadboard because it has connecting pins attached and properly spaced. Most of the ones we find will be surface mount, which require tricky soldering and custom circuit board. In either case, we would have to use the data see to find the pinout diagram that tells us what each tab does and use references circuits to design ours. Luckily, we have a second option. Companies like SparkFun and Adafruit do all that work for us and have ready-made breakout boards, which are more friendly for hobbyists to use and allow us to integrate the sensor into a project. Instead of soldering the tabs, we are now able to solder header pins to the breakout board and place it in a breadboard. SparkFun and Adafruit have tutorials that help you understand the components, teach you how to wire the circuit, and implementations for the breakout boards. They typically provide documentation about the board and chip including their schematics and the data sheets for components. In the data sheet, there is a block diagram that shows the accelerometer and magnetometer on sensor block together and the gyroscopes on a separate one. On the pinout diagram on the next page, gyroscopes are represented with “G,” accelerometers with “X,” and magnetometers with “M.” SparkFun and Adafruit provide locations and descriptions for these pin on their boards and diagrams for wiring them. On the board we used, the top six pins are for communication. We can choose from Serial Peripheral Interface (SPI) and Inter-Integrated Circuit (I2C). They are different communication protocols. SPI uses more wires to communicate, but does it at a faster rate since it sends and receives data on different lines. I2C is slightly slower and needs only two wires. You can use whichever protocol works with your circuit. The top four pins are for SPI. CS - means chip select this allows the program to chose between the gyroscope block (G) and the accelerometer/magnetometer block (XM). SDO is serial port data output, which is the line the data is sent out. SCL is the serial clock line and synchronizes the data being sent between the Arduino and breakout board. SDA is the data line for information sent from the Arduino to the breakout board in SPI mode. When using I2C, we only need the SDA and SCL lines. SDA becomes a two way data transmission between the breakout board and the Arduino. They take turns sending and receiving information, which is why it can be slightly slower. The SCL again keeps the data between the two boards synchronized. Future videos will expand upon these communication methods. We then have our power and ground. The bottom pins are all interrupts. We won’t use them, but they can be turned on in the program. Interrupts stop the program from proceeding down its checklist of task in order to immediately do something else no matter where it is in the program. Now that we have the circuit wired, we can move on to the code. They both provide example Arduino sketches and libraries. The Arduino sketch for the board basically says print out the values for the gyroscope, accelerometer, and magnetometer. Libraries are a way to reuse code and keep the sketch simple. All the cumbersome work is done in the library files. There is an .h file, which is your header file. This file outlines what your library will accomplish and sets up basic parameters. The .cpp file is the implementation file and it specifies how the program will be run. You don’t have to do any coding in these files. You just need to add them to your local libraries. You can manage your libraries from inside the Arduino IDE. If you install a library that provides examples, you will see new options in your example file drop down. The provided sample sketch for our SparkFun IMU board is well commented, but we want to give you a basic overview of what the sketch is doing. At the top, the SPI and Wire libraries are included. The are commonly used libraries for setting up communication between the Arduino external devices. Even if you are using I2C, you need to add the SPI library, because the SFE_LSM9DS0 library calls it out and will not work properly without it. This library is the one specifically written for this IMU. The sketch then defines where the connection to the breakout board is. You need to comment out the protocol you are not using. You can choose between printing out raw values from the sensors or values that are calculated and scaled. These calculations will occur in the implementation file. You can chose the frequency at which the program prints out values. Now that everything is defined, we move on to the void setup loop. The serial communication is initiated with a baud rate of 115200 this time. Then the library is initialized and some error checking is performed. The void loop sends the program to five functions. printGyro is a function name. There is nothing in the parentheses, because it sends and receives no information outside of the void loop. Since the function doesn’t return anything, void is placed in front of it. Inside the printGyro function it calls the readGryo function that is inside the cpp file. This is followed by an if else end statement. It says if PRINT_CALCULATED was defined above the void setup, then it prints the calculated values from the cpp file for the x, y, and z directions. Else if PRINT_Raw was defined, then we print out the raw x, y, and z values. The endif just ends the statement and we exit the function. The program goes back to the void loop and is told to go to the printAccel function. The acceleration and magnetometer functions work the same and the gyro function. The heading and orientation do not need to pick from a calculated or raw value. This is why they are sent float type variables from the void loop, which are the magnetometer and accelerometer values. Inside their loops, they calculate and print the heading and orientation using trigonometry. If you are not ready to create or own board or libraries, breakout boards are a perfect alternative. Typically you just have to solder the header pins on, use their provided wiring diagrams, and download their libraries and you are ready to go. Thanks to Google’s Making and Science team’s support, today we learned about breakout boards, libraries, and functions. You can check out more science content using #sciencegoals. If you have any questions or comments for us, you can leave them down below or talk to us on social media. You can support us at Patreon.com/SciJoy. And remember, keep exploring. 