 Hello world. It's Siraj and today. We're going to build a genetic algorithm for the game space invaders Well, it's actually not space invaders. It's called citious invaders, but it's or it's very similar It's based off of space invaders so I'm going to start off with a demo of what we're going to build there's a javascript version of this and There's a python version of this and of course we're going to do the python version Because that's what we do python of course so let's look at this game first ready set go, okay So we are this dude at the bottom you you've played space invaders before I don't even tell you how space invaders works But it is a special version because what happens is these invaders will Breed or crossover every 5 seconds they're going to breed every 5 seconds and my job I'll hit the space bar is to kill them all all The time all of them they're going to keep on breeding over and over again, and I've got to get them to be obliterated But they're just going to keep on breeding and what they're going to do is they're learning from my behavior They're not just breeding for the sake of breeding. They are learning from my behavior, and they're getting better over time There's a learning process happening here But it's not gradient based optimization. Which is what we're used to and it's not reinforcement learning base Which I talked about last week with a DQ learner. There's a whole different paradigm. It's called genetic algorithms and Sometimes called evolutionary algorithms as well, but now there's a there's a million of them anyway So that's what the game is going to look like this is in the browser We can also compile it from our desktop, but that's the basic idea. Oh my God. There's so many of them They are breeding like rain Vader's ok so That's what we're going to do and so what our algorithm. Does very simple It's a very simple algorithm, but the concept itself is very cool Is it starts off with 4 invaders so the game doesn't can never have less than 4 invaders 4 is the minimum? So there's no, there's no winning the game just you know whatever but you can't have more than 100 invaders so that the interval is between 4 and 100 if there are a hundred invaders on the screen we lose it's game over But if they're what we try to keep them as close to four as possible by shooting them and so each invader Has for what are called genes you can think of them as attributes as well speed how fast it's moving the Probability is going to change Direction which is between zero and one as all probabilities are the Size of the invader it could be big be small. They're variational There's all sorts of sizes and the color which is kind of Negligible really, but what will update that as well? it's a hex value and So it had four attributes or genes as we call them in this paradigm and every five seconds. They mate or cross over and it produces children like new invaders that are supposed to be better than then it's apparent than their parents and The invaders are the highest fitness by some measure of fitness that we define we're going to define what fitness means It's like you know our measuring contest and By some measure of fitness. We're going to determine who gets to breed and who doesn't the very Darwinian process So that's what it is and invaders that learn the best or or who have the best set of genes are going to be the ones who get to crossover or breed So this is a this is this image all of genetic algorithms all of genetic algorithms can be summed up in this image But before I get to this image Let me look down here a little bit and give it a little bit of background because I never talk about biology But it's dope so let me talk about it so dna. We all know what Dna is right It's the blueprints of life all all humans share 99.9 percent of the same Dna it's that point 1 percent Difference the results in our the way we are different the results in Charlottesville, and oh anyway You know I got stay relevant here. You know trending terms anyway But Dna is the blueprint of life from Dna Springs everything else and so genes are The recipes so you can think of Dna as the cookbook it's a book of all the recipes and the recipes are the genes right you have a gene for your Hair color you have a gene for your eye color you gene for everything right and so dNa consists of genes and from? Genes that make up the Dna strand come proteins and proteins make up the physical attributes that make up who you are so Right, that's Dna And those are genes and so we could think of these genes as parameters for each individual so each individual is like has a set of genes or parameters that adapt over time based on how they breed and So all life on Earth has sprung up this way through Darwinian natural selection The idea is that usually species will overpopulate it'll they'll create more than necessary To survive, and then there's going to be variation amongst all the individuals of the species This this guy's skin color will be brown has to go will be why is that's been called black all Sorts of different people and then what happens is selection, so everybody's going to try to reproduce I mean, that's the point of life if you think about it at the low level or at the basic level I mean there there are other points of life like it doesn't just have to be about sex it's going to be about social impAct You make your own meaning in the end, but I digress anyways everybody tries to breathe, but the ones that Whose Children are the most? Fit are the ones who get to survive or the ones who are? Most likely to survive and the way that nature does this is it lets it find those that are most fit by some measure of fitness in the real world it would be brute physical strength and those genes are then more likely to be passed on to next the next generations and So that's adaption so that's like the idea behind which now go back to this genetic algorithms are based off of So we initialize so the first step is initialization So we'll create a population whether that space invaders whether that's different solution solutions to some train Routes optimization problem like different routes and then those routes evolve, but anyway we initialize some population of solutions possible solutions, and then we assign each of those Individuals a fitness value by some fitness function that we decide what? It's very problem specific as well like based on the problem. What is the how fit is this individual or Solution you can call it as well, and then we select those individuals that are the fittest and then by some measure of You know what that fitness is in the easy case We can just think about it fitness as outputting just a single scalar value right for each person, and then we just choose those individuals that have the highest Fitness level and that highest fitness level could be you know it has to be greater than 10 or else They don't get to breed and we choose all those that's a selection process and then there's crossover or mating or sex if you want, you know whatever it is and right so they reproduce these genes why am I laughing because I said sikes I know oh my god my So these genes reproduce, that's the whole point right? That's how you came out. That's awesome. Huh? Oh Okay, so then they cross over and then the fittest ones those are the children We then the last step is Mutation we take those children and we add sometimes we add some kind of mutation to them so we can multiply it in by some random distribution like a gaussian or you know whatever else and That's that's how that works, so Let me go back to this okay So then we mutate them and so what the reason we mutate them is so there there is some variation, right it Doesn't necessarily mean that the genes that are passed on are the optimal gene values like they could be better But we know that they are the best of the type of genes that we've been given so we could take those best of what? we've been given and if we mutate them we open up the possibilities of Their being better genes out there that weren't even from the parents right you see what I'm saying So that's what we bury them a little bit. We had some kind of variational probabilistic aspect I'm doing this because I'm talking from something about distributions right and Also in terms of crossover there are different ways of crossing over parents You could add these two scalar values together You could multiply them you could multiply divide by two and then square it you know it depends on what you define bikes crossing over And once we meet some stopping Criteria then we we end the game like let's say you know we want the solution to be x amount so we'll measure how good it is and So in our case that's going to be having a hundred invaders That's the stopping Criteria, but if we haven't met it and we just repeat this process over and over and over again All right, so that's that and now we're going to talk about the use cases So okay So most of the advances in machine learning have been due to gradient based optimization as long as we can compute some gradient value we can compute how best to update the weights of our network the parameters of our network right whether that's through supervised or unsupervised Learning clustering a classification Generation you know variational auto encoding all of these things are based off of having a gradient value that we can then update our Weights with but in this case. There's no gradient value. This is a totally different paradigm There is no linear, Algebra And there's no calculus involved there is just Algebra like performing the crossover and then performing the mutation It's like multiplication Addition subtraction basic operations and then probability and the probability is the mutation as well like you know if there's a probabilistic Aspect to who gets to reproduce and what those mutations look like so there's only probability and Algebra Whereas in a gradient based optimization where most of the advances in Machine learning have occurred There's calculus in linear, Algebra and probability theory and statistics so it's an easier way of thinking about it and it's not necessarily as It's not necessarily as efficient when it comes to certain use cases But these genetic algorithms are used in Real world applications one of them one example is for relational databases like post gray or H2 they select the best query plan by the which is the one with the lowest estimated cost They're used in finance a lot for stock price prediction for Portfolio optimization evolving designs so computer-aided design is a great example where You have some idea of what the solution should be you don't know exactly what it is but you have some kind of base design whether that be a cad model like a 3D cad model or a of Rules to conduct some kind of experiments, and you can evolve these rules over time So that they get better and better And so this is used in Evolving cad models in engineering Wind turbines and things like that things that you would design which is a really cool field and very close to be related to generative generative modeling from Grain based optimization like Generative adversarial networks and variational autoencoders, where you Generate new Data. It's kind of similar to that. It's been the same kind of subfield computer-aided design So those are two use cases although, right? You don't you don't see these you don't see like the top researchers that deepmind or open Ai or you know anywhere posting Papers on genetic algorithms it just doesn't happen, but I still believe in them I still believe in them and when to use this if you have a huge search space And you're not really sure what the ideal solution should be like computer-aided design. It's a very creative Open-ended solution, then that would be a good This would be a good solution to that problem And so whenever you have a multi-dimensional search space is just a huge search space And you don't even know what the deal is okay? So that's the high level of what genetic algorithms are Now what I'm going to do is I'm going to go over the code for this game It's very doable and it's all going to be in python The only parts that I'm going to code are the three main parts and the three main parts are? selection Crossover and mutation so those are the parts going to code the rest of it We're going to go and just glaze over it, and I'm going to talk about what's happening there. So there are four different Classes here there are four different classes, and we're going to start at the highest level class Which is just this right here this 30 lines of code the main code And then we're going to iteratively go down the hierarchy of functions So we get to the lowest level which is evolution where that is where the real evolutionary code is happening And that's where I'm going to code some parts alright So let's write the high level so we have four dependencies here that we're going to importantly make this really big for us So we can really see what's going on here All right Make it bigger bigger is better as they say in As I say okay, so for for dependencies sge is a wrapper around Pi day now pi game is the most popular game building library in python and Sge you pronounce. It sage is a wrapper over Pi game Which makes it even easier to use however like with all wrappers because there is a layer of abstraction The trade-off is you don't get as much control over the details? But we're not going to talk about you know the details We're building a very simple game and so sgz sge is essentially pi game, but wrapped to a higher level Game is our objects that's going to contain the game logic Objects are are The player and the invader class that will define as well, and os is just for you know operating system functionality, right? so in our main function Here's the highest level of the code so first I'm going to define where the file is and then we'll create the game object So when we when we initialize invaders game that's just going to set some basic parameters like the clock time Whether or not there's a game over which there's not going to be when we start off duh and some other things But these are just game specific parameters not player or invader specific parameters those are objects alright So then we'll initialize a game and then we're going to load up the background and by the background I mean the color of the the back of the game right let me just show it over here So the color of the back of the game, I'll keep going back to this by the way, right So we want a black screen and so that's what we're doing here. We're defining a black screen We have a wall height we have a resolution We call it wall Sprite a Sprite is like a figure right animation But the we're just going to call the background a wall sprite as well, and we'll set it as a background layer And we only have one layer So it's just setting the background layer to that wall Sprite as a rectangle that we draw once we have that We'll add it to the background So we take our background layer that we've initialized and add it to the background and so that now we have a black Box for a game so far and now we have a background now we'll initialize our objects We have a set of invaders, so we'll start off with six of them So we say let's create a little initialized and invader six times And we'll store them all in this invaders array or list, and then we have our player Which is just one that's us And then we say the player is always the first Object we take both of them and we add them to this object array with the player being first so it's in we're initialized before The invaders are and then we start the game well, we don't start the game We initialize a session of the game, and so this is kind of like the pi game specific syntax of like you know syntactic sugar It's like an intensive level where you initialize a session and then you run the computation graph so we initialize this section here with the gameroom function giving it the background that we define and the Objects are player and the invaders, and then we remove the mouse because we don't want to see any of that We have--we're focus on our invaders in our player. That's it right, and then here we go. We start the game Why we initialize a session and then we start the game and that's it at high level right very easy stuff No, no evolutionary anything no anything really too. Easy almost right? I know it's too easy for you you Use smart use smart person you alright, so alright anyway, where were we? Right so now we're going down a level of Hierarchy. We're going down one We're going to objects so for objects we define our invaders right so we define our game and we define our classes So now let's define those objects those those entities inside of the game so our first entity is going to be our invader now how our invader is the one that is the Individual that will breed and cross over you know all this you know mutation all of this evolutionary logic will be applied to this invader So let's define what this invader What the attributes are so our first step is going to be to define the genes the genes for the invader? So when I say attributes this is what I mean the first one is going to be sides and so these are key value Pairs stored in a dictionary okay, these are key value pairs, so for each of these genes We are going to sort a minimum value and a maximum value, and we're going to have some generated random number here So we're going to be able to say let's generate a value for this Individual for this gene, and it's got to be between the min and the max and if it's smaller than the min Or it's greater than the max then we're just returning the min or the max respectively But you can't generate a value for this gene for any Individual that's Beyond the scope of this min and max value, right? So we'll do that for the sides of them, right? so the size has to be between 1 and 7 the color right we have colors on a scale of 0 to 255 but our min is going to be 5 or speed between 0.01 and 5 our y velocity or X&Y velocity of our speeds and you know both direction both Taxis and Then our probability of changing directions in both the x direction X direction and the y direction up and down up and down up and down wavy hair. I got my hair dyed silver again Yes, oh my God. It was so long I'm so happy to have the silver again back to this back to this Back to this ok so we have those jeans and now let's look at this next function Which is to generate some jeans foreign invaders? So whenever we initialize an invader this generate gene function is called right here It has a set of attributes when we initialize it So let's look at what this code looks like we're going to use that generated number like we define over here to define What this is going to be like write a value for the specific gene? So we know what the max value is and what the min value is and if the generated number is less than the men return the min if it's greater than the max return the max else Returned the generated number and so that's how you that's how we generate genes for each individual in this function, right? So when we when we when we initialize an invader like we did over here? We said let's initialize six of them when we initialize an invader this is the logic that's being called right so first of all we'll generate some random values for its genes and store them in the Attributes, and then we'll set the generated genes for this invader in terms of genes that's just you know genes are the attributes same thing and Then we'll set it Sprite Animation which is that like? Now robot looking dude. That was it this this thing, right? It's not game over the game isn't over till I say it's over or till we say it's over. Haha. Okay press enter Ready steady go e. Come on. Come on. Gene there we go - fun game right, so it says Little Sprite animation. It's like little character thing here, and it's just it's just a png It's just an image a static image that we're setting here using the the beauty of sge. That's just lets us You know magically set these Sprites for an object that we declare and then we're going to pull these values from the gene So we have these generated values, and they're all stored in this jeans list, but we'll also have individual variables for each of these gene values just because it's easier to call later to get to pull later on and We'll set the width for the image and the height the scale and it's going to start off with 0 in terms of its fitness Score we don't know how fit it is yet because it's just initialized so let's initialize that value at zero zero to hero hercules That I was just saying that I try to keep it interesting anyway up Right so we have those values and now Ok so here's here's nothing really cool. So notice this function right here is then step you're like okay event step Great what this what this does is it? In one so there are vents right so every step or time step in the game There's a series of times that you know every interval like There's always time steps in machine learning and so at every time step do something, right? So what is that thing that this? Invader is going to do what it's going to do is it's going to increase its fitness score by one Because the longer is alive the more fit it is that's what we're saying. That's what our Fitness correlates There's more to the fitness score that I'll talk about in a second, but that's kind of a basic idea But because this this this invader has survived a single time step We're going to increase that fitness score by one and so then we change directions randomly So we'll initialize some random value and say if it's less than the probability of changing directions Then change the direction else you know for both x and y Then we have logic for bouncing off the edges and the wall all four sides up down left and right Ok so that's all it does it computes Movement like where should this invader move in this time step and so that's how the invader just moving randomly all over the place But it's not just moving randomly It's moving randomly But based on the like what the values of these jeans are so you see how its movement is Dependent on the Jeans right one Gene will be the x probability One Gene would be the y probability the x velocity the y velocity Okay, so okay. So here's the interesting thing So you're looking at this and you're like, okay? So this happens at every time step when is this function called? So you'll look at this you'll copy it you'll control f you will try to find words where it's called well This is just this is just a duplicate of it's not called there. This is another duplicate Where is it's been called so the thing is it's not called anywhere there are event listeners So that's that's another thing about sge or sage with pi game you have Adventists inners because if we were to call this we would just have like a while Loop right, because we have to call it continuously throughout the whole game, but we're not going to do that. Why should we do that? We're just going to have these event listeners, and they're built into fGG so what I'm saying is these functions are going to fire Every time there is a new time step by themselves kind of auto magically it's built into the framework kind of like Ios Or Android programming if you ever done mobile development You don't want to just You're not you're not manually constructing event listeners for all the actions that a user can do swipe up swipe down tap You know two fingers three fingers you have those event listeners that are a part of the core framework that are going to fire whenever a user does that action so User swipes up which would fire So if you're if you're to put a breakpoint inside of that function and the user swipes up the breakpoint would catch that Action, and you could execute whatever code you want to and it's very useful for mobile development And it's also very useful for game development Having event listeners built into the framework so we don't have to build them so we can just say Then step is going to be this and the reason we can say this is because this class Inherits from the Sce DSP object class we're overriding these functions, right? So that's that's it for our invader right? That's that's the basic logic of us defining What those genes are and then logic for moving and for generating? Generating those values for each gene okay, so in a single time step Now let's define for the player right, so when we initialize a player we are going to say okay We can only move in two directions left or right. That's it So we'll define maps for both of those keys, and then we're going to say okay. What's the starting position? What's the sprite image right and that's it for our? Initialization steps and then we can go to our event step and remember this is called every time step of the game So we'll say okay first of all let's capture the direction entered by the player whether it's left or right and we'll put that in the Key motion variable We'll find a speed in the x-Direction and then we'll animate the sprite according to the movie Direction, right? So if we're going left and move the image this way, we're going right would be image this way That's it And then we keep a paddle inside of the window, right? so then we're never outside of the bounding box on both sides we want to keep the player inside of that bounding box and So whenever the player shoes right later the player shoots we're going to say you know whenever the space button is pressed the number of invaders must be higher than the minimum loud and a number of bullets lower than the maximum and Only if that's the case can the player fire a bullet, so these are? parameters for which for when we can fire a bullet or not which means We have one more class and that class is the bullets itself so like that little bullet That's traveling when the when the player shoots, so we'll animate that using this sprite function. It's that lit It's a little you know fiery little image will set that will set it speed Which is going to be the starting speed that we define as a beforehand? And then we'll say in the event step which is happening at every iteration either destroy it or if there's a collision then kill that invader, whoever it touches all Right, so that's four objects class and Now we have our game class and so in our game class. We'll say okay. We've got our game engine. We've got our player and invader object's evolution which I'll code in a second time and then our clock, so then we have a bunch of global parameters here for the resolution for the position of the objects for how How the number of milliseconds between generations like five thousand milliseconds or five seconds and the minimum generation time as well like what's the width? the lower limit that we want it to be the number in invaders four and the Max 100 minimum for max hundred so in a game class which we initialize, right? Here what happens here? Well like I said we we are initializing a bunch of these game specific parameters the hud which is a score and the timer Whether or not to game over very basic stuff the clock And then we have some basic code for the hud. Which is not you know I won't go over that and then a new generation, okay, this parts interesting so soul generate some new invaders and then will reduce the time between Generations which makes it harder for the player, right? so that's what we had this minimum value for the generations 2000 because the time for generation between generations will decrease every time step so it gets harder and harder and Then in an event step for one full game will first calculate the number of invaders on the screen show the score And if it's more than a threshold, it's game over. We're done. We're through are the jig is up The gig is up, but if if it's over a threshold then it's time to breathe again, so we'll create a new generation Right and so but if it's for if it's if it's if there's four invaders on the screen And we're trying to kill one of them. We can't do that So we'll draw this immunity bubble around them which means that you just can't kill them until more are generated so that's kind of our way of saying this is the minimum number of invaders will have key prices for you know escaping and for pausing the game And so okay, so this is this an interesting step this is where the animation for how crossover is happening happens right here So whenever so every 5 seconds the game pauses and then those invaders will breed and then so what's happening is will say recombinator Crossover step to create those kills child genes and as a new individual to our current list and then reanimate, okay? and so then for keep resting and for event closing all right so now let's get to our good stuff the real the real the Real meat of this code so before I get to these three things let me talk about the bounding interval for the genes So we always have some downing interval like it's got to be between this this scalar value and this scalar value So this is where the crossover and the mutation is happening, and this is where the selection is happening so the three really key aspects of how this works will create a list for the offspring that will store the values in for all the for all the children and so for each pair of Parents, right we're giving it parents as the parameters here. We're going to say okay, so for each pair of parents Let's go ahead and create an empty store for the offSprings jeans, so we'll say okay So for the jeans of each child for the despair of parents for each gene from the Key value pairs remember? It's a dictionary that these gene values are stored in we're going to store both pairs as gene attributes, okay? So for both parents, we're going to compute what those genes are that we want to give to our children as Values, and we're going to randomly generate the child genes attribute so for the children the for the for each Child genes and this gen is going to be the index for the specific child, we'll use a uniform distribution to compute what the values should be so we'll say okay, men values and then max values so it's going to be a distribution between the min and max values for this gene and Then we'll randomly decide. It's time to mutate the children so if if it's so We'll generate some random number, and then if it's less than the mutation probability then we'll go ahead and mutate the children else We won't so this is this is how we select Whether or not we're going to mutate the children or not Right so m our mutation probability is 0.1. So it's got to be less than that So we'll say okay, so first get the min and the max values or the parent so the min and the max value Porta parents Pulse again min, and then we have for the the max value for the parent look at gene props Gen Max all right and then we'll get the value for the child and the child is going to be That same index and now it's time to mutate so for mutation. Here's what it looks like for mutation, so so basically the communication step for introducing new genetic material into the population by replacing one parameter in the genome by this random value within the allowed range And then once we have that then we can go ahead and return We can go ahead and add the children to the store. So offspring dot append and then the children gene and Then finally we'll return all of the children return offspring and this goes Right here, okay great, right? So that's for a crossover and mutation that's how we're crossing over parents. We're saying we're taking these values from both parents and using those values for those genes to help compute this child gene and then we're mutating the child gene right using this random Normal distribution, so that's crossover a mutation and then their selection so all these children who gets to reproduce, so For all the members of the population will sum up all of their fitness scores And then we'll say ok so we'll randomly generate a distribution and then for each invader We'll subtract its value the fitness value from the randomly generated number and if it's less than zero Then that invader gets to breathe so here's here's why we're doing this so you might be thinking okay? So why could we just compute the fitness for each individual and then say whichever you know however long. It's alive We'll just keep incrementing that fitness value the scalar single value, and then the ones that have the highest fitness scalar Why don't we just choose those why do we have to add this random value the reason? We're adding a random value here is because the ones with the best genes and the immediate term doesn't necessarily mean it has the best genes in the long term so if we add some kind of variational or probabilistic aspect to it then that allows for Different possibilities right it means that these genes right now were the best ones But let's add some variation to it just in case there's other possibilities out there you see what I'm saying So by adding a variational aspect to selection it Just improves How we evaluate the fitness? For each individual and so that's that's it really for this and then we have this mating pool and tournament But that's just for that Just we're printing out the terminal so that's it for this code. If you liked it, please check out the github repository I've got all the instructions in the details in there Definitely try out a genetic algorithm on your own They're very simple very easy to understand you don't need to know back propagation or calculus or linear Algebra very simple stuff You can easily implement them in Pi game and open a is gym and open a eyes universe There's a bunch of possibilities and if you do this Then it's just going to increase your confidence as a developer as a machine learning engineer as a data scientist. Whatever it is So thank you for watching I love you guys seriously I do it for you. Have you made it this far? I'm very proud of you. Thank you, and I'll tell you a little secret Something big is coming up and only you get to know that because you made it to the end I can't say what it is, but something big is coming up before the year ends for this channel It's going to be amazing alright. So that's it please subscribe for more programming videos and for now I've got to evolve my hair so thanks for watching 