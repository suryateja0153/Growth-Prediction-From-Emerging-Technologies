 [Music] Since a few months ago, we have been hearing about bitcoin and the rest of cryptocurrencies. Most of the time, the news are about their value changes, but rarely they talk about the technology behind it. In this video we will try to explain how it works in a simple way. But, before talking about how bitcoin works, we have to know how the trade works and the principles on which the value of our money is based. Trading is as old as our own civilization. In order to overcome the difficulties with bartering, since ancient times, we consider that gold has an intrinsic value that could be used for merchandise or services exchanges. This tradition remains nowadays. As a result, bank notes represented a quantity of gold until the 1950s. An historical example of the danger of unregulated currencies is the Panic of 1837. At that time in the United States each entity was allowed to issue their own dollars. This brought the risk that, in case of bankruptcy of these entities, the issued notes lost their value. Currently the only entity that is capable of issuing US dollars is the Federal Reserve. In the same way, the only entity that is capable of issuing euros is the European Central Bank. Nowadays, the value of a note is the trust that society has in the institution that issued it. Cryptocurrencies are intended to offer a network with some properties such that society can rely on them as an actual currency. One of these properties is that the amount of currency that the network can issue is limited. In particular bitcoin can never reach more than 21 millions of monetary units. Another property of these coins resides in the use of cryptography. These techniques, although they can be complex, can be explained with simple examples. Imagine a school class. So we have desks in the class. [Mumble] Okay, a few desks. And inside it there are two people: Alice and Bob. They like each other and they want to send themselves some notes but as we see in the drawing, they are not together. In fact there is a person in the middle, Charlie. He also likes Alice and he is jealous. Then, Alice and Bob want to encrypt their notes in some way that Charlie does not know what is in them. So, this is why cryptography is used. Cryptography was already used in the time of the romans. In fact, one of the first ways to encrypt messages was to move the letters of the message a finite number of letters. But of course, Charlie is not stupid, so this method does not work for Alice and Bob because it is very easy to break. Let's suppose Alice wants to send Bob the message "Te quiero" ("I love you"). Then, in order to encrypt it with a right shift of one letter, that is, each letter becomes the following. 'T' becomes 'U'. 'E' becomes 'F'. 'Q' becomes 'R'. And so on. Then the message that starts with 'UF R' and so on, is not understandable. And this is what we call Caesar cipher. Clearly with this method a person who gets an encrypted message could deduce that is a message, he wouldn't know what it contains but he could deduce that it is a message. For example in this message we have two letters one space and five letters again. So we can think that it should mean something. Therefore we say that this method is not a safe method. A safe method is one such as, if somebody receives an encrypted message, he cannot distinguish whether that is a message or a set of random letters without meaning. Alice and Bob are very smart, but Charlie too, therefore, Alice and Bob would like to have a method so that, even when Charlie knows about it, he couldn't access the content. He could know they are sending a message but he couldn't know what it says. Imagine that Alice and Bob use the following system: Alice has the message and puts it inside a box. She can close it with a padlock. Alice puts the padlock and lock it. Alice has not the key of the padlock. Bob has the key. Then Bob can use the key, open the box and take the message out. Charlie can see the whole process but he has no access to the message at any time. So even if Charlie sees what Alice and Bob are doing, he can't access to the content of the message. This is in what the current methods are based on. We cannot use real boxes, but we use virtual keys Now, imagine that our padlock have two keyholes: one is used to lock the padlock and the other is used to unlock it. The key that locks the padlock will be called public key and the key that opens it, private key. Everyone can see the public key. In fact, Alice and Bob don't care if Charlie borrows the public key. The only thing that matters is that Bob saves well his private key. This system has many applications. For example when you want to make a login on any website or when you want to make a transfer in a bank. And how can we use this for cryptocurrencies and money transactions between people? Let's see an example. We have a group of friends: Elena, Bea, Celia and Iván. And let's suppose that they are lending themselves money. That is, they can go to a bar and instead of having to pay each one his share, one pays everyone's. Or they just lend money. Elena borrows some money from Bea, Elena ask Ivan for 10€ and so on. They have a problem if the group of friends grows, because the number of transactions between them increases. Then it is difficult keep track of how much money you owe others and how much money the rest owe you. They are an organized group of friends and they have decided to have an accounting book where they record the money transactions between them. At the end of the month they meet, they see how much money each one has spent. Who owes more money and who owes less. In this accounting book everyone can write so for example Elena could say that Bea owes her 500€ without Bea's consent. At the end, a way to fix it could be that each person signs the authorized payments in the shared book. So, we have already solved the problem with the transactions that did not really take place. But now we have another problem. What happens if Bea starts to spend money and, at the end of the month, she disappears? In order to avoid it, they agree how much money the group has. Then the first day of each month, they agree how much money can be spent by each person. And from now on, every time a person wants to make a loan or wants to borrow money, it does not take place if the the person who gives has not enough money. Actually, we have almost invented what a bank is. The difference is that, in a bank, a third person has the accounting book, an entity in which we trust. But, in this case, we don't want to involve third parties. As we do not want to involve third parties, we give a copy of the accounting book to each person and every time someone makes an exchange of money, everyone records the exchange in their respective books. When somebody exchanges money with somebody else, he agrees to communicate it to the rest of the group. But it could happen that someone in the group did not catch it or it could happen that a person receives information from two different people and he didn't know if they refer to the same transaction or not. A solution to this problem is given by blockchain. We have here our accounting book, where we said that we had our records of how much money is sent and who sends it and a signature of the person who has make that exchange. We are going to gradually convert it to a digital format. So the equivalent for our accounting book in blockchain it's going to be a block. A block stores the information of these transactions with a digital signature of the person who has carried it out. The way we sign these transactions works with a mechanism similar to that we have explained before of public and private key. Let's explain how this signature system based on the use of a special tool such as hash functions works. Let's imagine that we have a lot of letters. We have them stored and we want to be able to find a letter quickly, without reading it completely. So what we want to do could be, for example, to identify each letter with a name. A name that summarizes its content. We could for example identify each letter with the first word that is written on it. So for example this letter would be identified by the word "Hello". Other letter by the word "Good" because it begins with "Good morning", etc. What is the problem? That there could be several letters that begin with the same word. So we would have that with a single word we can identify so many letters and we have to read each of them in order to know the one we are looking for So this is a problem. We are going to try to complicate this a bit more. What if instead of taking the first word of each letter we take for example one in three letters? This will make it more difficult for the same name to match for several letters. But it is still possible that someone, knowing this, can write several letters that will be identified with the same name. It is difficult but still possible. We would like to find a method such that it would be practically impossible to have two letters identified by the same name. In computers, a system very similar to this one is used. Only instead of letters, what we have is data. These data is applied to what is called a hash function, which is a function that for a data set returns a name as it happened with the letters. We will say that a hash function is good if for very small changes in the data set, the name we get is very different and if the probability that the same name identify two different data sets is very low. And how does this signature system work? Well we're going to have a special hash function. It's like a normal hash function but it uses the data and a privete key in order to get the name In addition, we will have another function that given the output data and the public key that everyone knows can know if these data is correct, that is, if it has been signed by that person. In the context of transactions, we will use this method to generate the signatures. We will start with the transaction as the initial information, we will apply the function using the private key of the person who made the transaction and we will obtain a signature that will be different in each transaction even if it identifies the same person. As each transaction has a unique identifier even when the same person makes two equal transactions of the same amount to the same recipient the value obtained applying this function will be different. Well, in addition to having a transaction signed by a person, a problem that can happen is that for example Celia sends 100€ to Elena and then this same transaction repeat again, that is, Celia send again 100 euros to Elena the next month. How can we distinguish one transaction from the others? The simplest way to do it is assigning a different number to each of these transactions. So, in our block, besides the concept of the transaction and the person who has effected it, we will have a number that identifies them. Each block will be a set of transactions which the entire group consider valid, that is, they are signed by those who have carried them out, and nobody spent extra money. A blockchain is a chain of blocks in which people have agreed that what is written in them is valid information. Okay, here we will have some information about other transactions. Okay. And it is a temporal chain. As time goes by, new blocks are added in which the whole group trusts. One thing that we have to talk about is how this link between blocks is made. Well, each block will have a section in which a reference is made to the next block and each block will have information about which block is before. So it is impossible for anyone to try to exchange this information from one site to another. Those identifiers are obtained with the hash function. Then the only thing that we would have to see is what is the next block in this chain. What we had said before is that each person just after making a transfer will communicate that to the rest of the group. We will keep that mechanism. And let's suppose that the unconfirmed transfers are written down. When we want to create a new block, we take all these transfers, and create a new block with them, write the identifier of the previous block and now we just have to add it to the chain. But who makes these blocks? These blocks are made by miners. Miners are people voluntarily engaged who collect this information and create blocks. But if we have several people working on the same task, Who wins? The first one that finish a proof of work. This proof of work consists in filling in the end of the block with a number that modifies the content and as we have explained before, the identifier of this block is going to be the one that returns a hash function. So if we demand that the result that we get with the hash function have to start with a bunch of zeros, let's say that to be a valid hash it has to start with five zeros. the only way to guarantee this is to change this number one by one because apparently there is no easy way to get this result. This task is a very difficult task. Then, the first one that gets a number that placed here at the end of the block get a result, by passing it through the hash function, with a certain number of zeros, in this case five, that's the one who wins the race and the one who place the next block in the chain. But how hard is this proof of work on which the trust in the system is based? We know as we've seen before that a hash function is difficult to manipulate in order to obtain the same result with similar data. That is the reason why one block cannot be replaced by another, because the best way to do it is by checking approximately 2 to the power of 256 different identifiers. And is this safe? It is easier to win the lottery. [Music] So how big is 2 to the power of 256? Well, let's imagine our universe. In our universe there are a lot of galaxies. In each of these galaxies there are a lot of stars. Each of these stars has many planets. In our galaxy, only one of these planets has people. But it has a lot of people, it has seven billion people. Now imagine each one of those people have a million computers. Each one of those computers, assuming they were very good computers, could perform four billion operations per second. They are a lot. So, now let's imagine that each of those people of each of the stars of each of the galaxies in our universe would have put his million computers to make calculations at the time of the Big Bang. Well, today, computers would not have finished doing the calculations. And only in that resides the confidence that you can have in the blockchain? In fact, the blockchain mechanism brings more security to this new monetary system. It could happen that at one point two persons place a valid block at the same time. Then, which one do we choose? Well, the decision is made later. People decide that they will keep the longest chain. So if at some point we have two different chains someone will have to break the tie and that person will make one of them longer and from now on they will always take as the valid one the longest chain, in which more effort has been placed. With this we solve two problems. The first one is that they can not spend the same token twice. Normally, when we buy something, we give a banknote in exchange for the product. In this environment it is difficult to know if we are only spending that token once. With this chain of blocks we guarantee that if a payment has been made, that payment has actually been made. The second problem that we have solved is that there will not be a single person in charge of creating blocks. It is assumed that there is a community of people, miners, who are creating them. And the probability that the same person is always doing the same tasks is very low. We gain, for example, if we had a list of transactions, and Alice is always creating the newest block Alice could exclude some transactions from the chain. But this is not going to happen because there are going to be other people who have noticed this transaction and they can put it in a the next block. The only case in which Alice could take advantage of this is if she had her own branch and place blocks in it. But what happens? That a single person competing with the rest of the miners will not ever have the longest chain, then her chain will fall into oblivion and the valid chain will be the one of the rest of the people. The question that we should now ask ourselves is: what do the miners get out of this? Why do they maintain the system? Well, they earn money. The short answer is that. For doing that job When they create a new block, the miners automatically receive a quantity of money determined by the system. The way in which this is carried out is in the block a transaction is made in favor of the miner. So if they can put their block in the chain, this transaction will be effective, and therefore they will receive an amount of money. Currencies like bitcoin, ethereum, are based on this system, and we are hearing so much about them nowadays. 