 Hi, I'm Kerry Ann and welcome to Crash Course computer science. Over the past few episodes, we've been building up our understanding of computer science fundamentals, such as functions, algorithms and data structures. Today, we're going to take a step back and look at the person who formulated many of the theoretical concepts that underline modern computation. The father of computer science and not quite Benedict Cumberbatch lookalike Alan Turing. [Crash Course intro playing] Alan Mathison Turing was born in London in 1912 and showed an incredible aptitude for maths and science throughout his early education. His first brush of what we now call computer science came in 1935 while he was a master's student at King's College in Cambridge. He set out to solve a problem posed by German Mathematician David Hilbert known as the Entscheidungsproblem or decision problem, which asked the following: is there an algorithm that takes as input a statement written in formal logic, and produces a "yes" or "no" answer that's always accurate? If such an algorithm existed, we could use it to answer questions like, "Is there a number bigger than all numbers?" No, there's not. We know the answer to that one, but there are many other questions in mathematics that we'd like to know the answer to. So if this algorithm existed, we'd want to know it. The American mathematician Alonzo Church first presented a solution to this problem in 1935. He developed a system of mathematical expressions called Lambda Calculus and demonstrated that no such universal algorithm could exist. Although Lambda Calculus was capable of representing any computation, the mathematical technique was difficult to apply and understand. At pretty much the same time on the other side of the Atlantic, Alan Turing came up with his own approach to solve the decision problem. He proposed a hypothetical computing machine, which we now call a Turing Machine. Turing Machines provided a simple, yet powerful mathematical model of computation. Although using totally different mathematics, they were functionally equivalent to lambda calculus in terms of their computational power. However their relative simplicity made them much more popular in the burgeoning field of computer science. In fact, they're simple enough that I'm going to explain it right now. A Turing Machine is a theoretical computing device equipped with an infinitely long memory tape which stores symbols and a device called a read/write head which can read and write, or modify, symbols on that tape. There's also a state variable in which we can hold a piece of information about the current state of the machine. And a set of rules that describes what the machine does. Given a state and the current symbol the head is reading, the rule can be to write a symbol on the tape change the state of the machine move the read/write head to the left or right by one spot or any combination of these actions. To make this concrete let's work through a simple example: a Turing Machine that reads a string of ones ending in a zero and computes whether there is an even number of ones. If that's true The machine will write a one to the tape and if it's false, it'll write a zero. First We need to define our Turing machine rules. If the state is even and the current symbol of the tape is one, then we update the machine state to odd and move the head to the right. On the other hand if the state is even and The current symbol is zero, which means we've reached the end of the string of ones, then we write one to the tape and change the state to halt, as in we're finished and the Turing machine has completed the computation. We also need rules for when the Turing machine is in an odd state, one rule for the symbol on the tape is a zero and another for when it is one. Lastly we need to define a Starting state, which we'll set to be even. Now we've defined the rules in the starting state of our Turing machine, which is comparable to a computer program, we can run it on some example input. Let's say we store 1 1 0 onto tape. That's two ones which means there is an even number of ones, and if that's news to you, We should probably get working on crash course Math. Notice that our rules only ever move their head to the right so the rest of the tape is irrelevant. We'll leave it blank for simplicity. Our Turing machine is all ready to go so let's start it. Our state is even and the first number we see is a one. That matches our topmost rule and so we execute the effect, which is to update the state to odd and move the read/write head to the right by one spot. Okay, now we see another one on the tape But this time our state is odd and so we execute our third rule which sets the state back to even and moves the head to the right. Now we see a 0 and our current state is even so we execute our second rule which is to write a 1 to the tape signifying that yes, it's true, there is an even number of ones, and finally the machine halts. That's how turing machines work pretty simple right so you might be wondering why there's such a big deal Well cheering shows that this simple hypothetical machine can perform any computation if given enough time and memory It's a general-purpose computer our program was a simple example But with enough Rules states and tape you could build anything - a web browser, world of warcraft - whatever! Of course it would be ridiculously inefficient, but it is theoretically possible. And that's why, as a model of computing, it's such a powerful idea. In fact in terms of what it can and cannot compute there's no computer more powerful than a turing machine. A computer that is as powerful is called Turing complete Every modern computing system your laptop your smartphone and even the little computer inside your microwave and thermostat are all Turing Complete. To answer Hilbert's decision problem, Turing applied these new Turing machines to an intriguing computational puzzle: the halting problem. Put simply this asks "Is there an algorithm that can determine, given a description of a turing machine and the input from its tape, whether the Machine will run forever or halt?" For example we know our Turing machine will halt when given the input 1 1 0 Because we literally walk through the example until it halted, but what about a more complex problem? Is there a way to figure out if the program will halt without executing it? Some programs might take years to run so it would be useful to know before we run it and wait and wait and wait and then start getting worried and wonder and Then decades later when you're old and gray control-alt-delete so much sadness Unfortunately turing came up with a proof that shows the halting problem was in fact unsolvable, through a clever logical contradiction. Let's Follow his reasoning. Imagine we have a hypothetical Turing machine that takes a description of a program and some input for his tape and always outputs either Yes, it halts or no, it doesn't and I'm going to give this machine a fun name H for Holtz. Don't worry about how it works. Let's just assume such a machine exists We're talking theory here. Turing reasoned if there existed a program Whose halting behavior was not decidable by age it would mean the halting problem is Unsolvable to find one Turing designed another Turing machine that built on top of H. If H says the program holds Then we'll make our new machine loop forever. If the answer is no It doesn't halt, we'll have the new machine output a no and halt. In essence We're building a machine that does the opposite of what H says: halt if the program doesn't halt and run forever if the program halts For this argument we'll also need to add a splitter to the front of our new machine So that it accepts only one input and passes that as both the program and input into H. Let's call this new machine "Bizzaro" So far this seems like a plausible machine, right? Now it's going to get pretty complicated But bear with me for a second. Look what happens when you pass Bizzaro a description of itself as the input This means we're asking H what Bizzaro will do when asked to evaluate itself But if H says Bizzaro halts then Bizzaro enters its infinite loop and thus doesn't halt And if H says Bizarro doesn't halt then Bizzaro outputs a no and halts so H can't possibly decide the halting problem correctly because there is no answer. It's a paradox and this paradox means That the halting problem cannot be solved with Turing machines. Remember Turing proved that Turing machines could implement any computation So this solution to the halting problem proves that not all problems can be solved by computation. Wow, that's some heavy stuff I might have to watch that again myself. Long story short Church and Turing showed there were limits to the ability of computers no matter how much time or memory you have there are just some problems that cannot be solved ever. At this point in 1936 Turing was only 24 years old and really only just beginning his career. From 1936 through 1938 he completed a PhD at Princeton University under the guidance of Church then after graduating he returned to Cambridge. Shortly after in 1939 Britain became embroiled in World War II Turing's genius was quickly applied to the war effort. In fact a year before the war Started he was already working part-time at the uk's government code and Cypher school Which was the British code breaking group based out of Bletchley Park. One of his main efforts was figuring out how to decrypt German communications Especially those that use the enigma machine. In short these machines scrambled text. Like you'd type the letters H-E-L-L-O and the letters XWDBJ Would come out. This process is called encryption The scrambling wasn't random. The behavior was defined by a series of re-orderable rotors on the top of the enigma machine Each with 26 possible rotational positions. There was also a plug board at the front of the machine that allowed pairs of letters to be swapped In total there were billions of possible settings. If you had your own enigma machine and you knew the correct rotor and plug board settings You could type in XWDBJ and hello would come out. In other words, you decrypted the message Of course the German military wasn't sharing their enigma settings on Social Media So the allies had to break the code with billions of Rotor and plug board combinations There was no way to check them all by hand Fortunately for Turing, enigma machines and the people who operated them were not perfect Like one key flaw was that a letter would never be encoded as itself as in an h was never encrypted as an h Turing, building on earlier work by Polish code breakers, designed a special-Purpose electromechanical Computer called the Bombe that took advantage of this flaw. It tried lots and lots of combinations of enigma settings for a given encrypted message if the Bombe found a setting that led to a letter being encoded as itself Which we know the real Enigma machine couldn't do, that combination was discarded then the machine moved on to try another combination So Bombes were used to greatly narrow the number of Possible enigma settings This allowed human code breakers to hone their efforts on the most probable solutions Looking for things like common german words in fragments of decoded text Periodically the Germans would suspect someone was decoding their communications and upgrade the enigma machine like they'd add another rotor creating many more combinations they even built entirely new encryption machines. Throughout the war Turing and his colleagues at bletchley park worked tirelessly to defeat these mechanisms and overall the intelligence gained from Decrypted German communications Gave the allies an Edge in many theatres with some historians arguing it shortened the war by years after the war turing returned to Academia and Contributed to many early electronic computing efforts like the Manchester Mark 1 which was an early and influential stored-Program computer But his most famous post-war contribution was to artificial intelligence, a field so new that it didn't even get that name until 1956 It's a huge topic So we'll get to it again in future episodes In 1950 Turing could envision a future where computers were powerful enough to exhibit intelligence equivalent to or at least indistinguishable from that of a human Turing postulated that a computer would deserve to be called intelligent If it could deceive a human into believing that it was human. This became the basis of a simple test now called the turing test Imagine that you are having a conversation with two different people not by voice or in person But by sending typed notes back and forth. You can ask any questions you want and you get replies But one of those two people is actually a computer. If you can't tell which one is human and which one is a computer then the computer passes the test There's a modern version of this test called a completely automated public turing test to tell computers and humans apart or captcha for short These are frequently used on the internet to prevent automated systems from doing things like posting spam on Websites. I'll admit sometimes I can't read what those squiggly things say. Does that mean I'm a computer? Normally in this series We don't delve into the personal lives of these historical figures But in Turing's case his name has been inextricably tied to tragedy so his story is worth mentioning Turing was gay in a time when homosexuality was illegal in the united Kingdom and much of the world. An investigation into a 1952 Burglary at his home revealed his sexual orientation to the authorities who charged him with gross indecency. Turing was convicted and given a choice between Imprisonment or probation with hormonal treatments to suppress his sexuality He chose the latter in part to continue his academic work, but it altered his mood and personality Although the exact circumstances will never be known, it's most widely accepted that Alan Turing took his own life by poison in 1954 He was only 41. Many things have been named in recognition of Turing's contributions to theoretical computer science But perhaps the most prestigious among them is the turing award the highest distinction in the field of computer science Equivalent to a nobel prize in Physics, chemistry or other sciences. Despite a life cut short Alan inspired th e first generation of computer scientists and laid key groundwork that enabled a digital era we get to enjoy today I'll see you next week. Crash course computer science is produced in association with PBS digital studios at their channel You can check out our pla ylist to show like gross science ACS reactions and the art assignment. this episode was filmed at the Chad and stacey Emigholz studio in Indianapolis, Indiana And it was made with the help of all these nice people and a wonderful graphics team thought cafe Thanks for watching and try turning it off and then back [on] again 