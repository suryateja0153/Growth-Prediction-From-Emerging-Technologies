 Welcome to second lecture on our course .It's titled system-on-a-chip and programmable system-on-a-chip. So basically this lecture is again an introduction to SOC design. So system-on-a-chip normally we call them SOCs and SoCs and SoC-based designs, they have become a major sub area within a embedded systems. That's why we are going to discuss this topic. And most of our labs will be based on SOC design. So SOCs, they are also integrated circuits, ICs, which look similar to your processes or FPGAs. But the difference is as the name indicates each chip contains an entire system. Now when we say entire system in this semester you will be seeing microcontroller and you will find the difference between traditional micro processes and microcontroller. You'll find like microcontroller they integrate more peripherals compared to a microprocessor. So inside of microcontroller you have a processor core in addition to that you usually have memory volatile or non-volatile RAMs and ROMs as well as input output control blocks etc. Now SoCs they integrate much more than microcontrollers. ok? So let's look at few examples. One of the most popular one that you might have heard is the snapdragon SoC, which is the most widely used mobile processor. So sometimes you will hear it as a mobile processor sometimes you hear it as an SoC. Actually it's an SoC. So if you look at the floorplan or the die of this SoC chip, so you can see it has processor inside. So these are the processes. Cortex a-57 and a-53. They are arm-based processes. In addition to processor you can see it has DDR memory here, it has a separate core for multi media processing, it has separate core for display control it has a USB controller again separate display engine and it also has a GPU inside the same chip. And it also has the modem for controlling your mobile communication. So you'll see the entire system is within a single chip. okay? And another widely popular SoC is the Apple A12 chip Bionic. You might have heard about it. Because this SoC in addition to the processor here you have six cores in total the four core GPUs also. And you also have something called a neural engine, which is for neuro-morphic computing. So eight cores of neuromorphic computing engine also. So that's why we call it a Bionic chip also. It also has memory controller and what is the remaining of the chip we are yet to find out. So this is done by people who are opening chips and finding out how things are inside the chip because Apple they officially don't release this information. Another popular SoC is Exynos which is becoming popular. This is an SoC from Samsung and they are using this chip in the low to middle order mobiles. So architecture is quite similar. So it has multi cores here a57 this ARM processor a57 processor and there are a53 processor. In addition to that it has all kind of peripherals i2c spi timing control display control all other peripherals. So again this is an SoC. You have the camera controller here. So all the peripherals in the system they are integrated inside a single chip. So that's why we call them system on a chip. now there are certain advantages and disadvantages of SOC so of course one of the major advantages is saving space because you have a single chip which integrates all the peripherals so the overall area required for the system is much smaller which makes sense when you go for mobile technology you phone to be very slim very small sleek so we need to use SoCs and since all these systems are on the same chip power consumption is much less so if you look at any computing platform the most of the power is consumed for inter-chip communication when data transfer happen between the chips they have to try high current which consume a lot of power know here all the peripherals are inside the same chip because of that there is no or very low interchip communication so the power consumption is less and performance is usually quite high again because all the circuitry is in the same chip so it can run at very high clock frequency so the clock frequency and throughput they are usually high cost is lower again because of high level of integration it is better to buy a single SOC with all these peripherals integrated rather than multiple chips each for each functionality so the overall cost will come down reliability is again higher than integrating multiple chips and the security because everything inside the same chip the probability of people hacking during interchip communication or side-channel attacks the chances are lower those are the main advantages of SOC it comes with some of the disadvantages also one major issue is a single point of failure even if you if you damage a small portion of this SOC you will have to replace the end chip if you are using separate chip for building the entire system if one chip goes bad you have to replace only that chip but here even if you damage one small portion you will have to replace the entire chip so that makes it a single point of failure another issue is the high initial investment okay so it's again a high level of integration so the initial design and manufacturing costs it's quite high actually and again because of it's a very complex circuit very complex chip the time the investment on verification and testing is much higher than going for discrete implementation now this is a typical design flow for SOC it basically involves development of SoC as well as the programming of the SOC so you can see on the left side we have Hardware subsection going and on the right side we have a software so a SoC again plays a major role in so-called the hardware software co design approach that we see the system contains both hardware and software and they are not develop completely independent they run in parallel and we have certain checkpoints where we make sure there is proper coordination between the hardware development and the software development which we call as hardware software co-design we will learn more about it in the course as we go forward so again I am not going to explain each and every step because we will be practically doing most of them so basically you will have hardware design hardware simulation prototyping then software design, software testing, application software then the integration and final testing. In this particular course we are not going to build our own SOC. Of course in a university environment that's not possible we are going to use a special kind of SOC and we will not be going for production of our custom SOC okay so we'll be concentrating on these portions so we'll be doing most hardware part as well as software now again when we talk about SOC there are two kinds of associating the first type as the traditional SOC and these are similar to our a ASIC and on these SOCs the circuit inside the SOC is burnt or implemented at the time of manufacturing itself so all the SOCs I mentioned before the Snapdragon or Apple Bionic they are traditional SoCs you cannot change the circuitry inside the SOC now that doesn't mean these SoCs are not reprogrammable you can of course reprogram by using software so you already have a circuit you already have processes GPU you can control them with the help of software now they have certain advantages specifically their throughput is quite high and the power consumption is less the disadvantages are if you want any modification to the circuitry okay if you want to do some upgrade you will have to redesign the entire chip we will have to go through the entire testing phase again which may be quite expensive now these kind of chips they make sense when we go for large production so the arguments are similar between the development of ASICs and the development of FPGAs whereas it makes sense where FPGA makes sense similar arguments so tradition associates they make sense if you are going for mass production now if you are not going for mass production if you need SoCs for small scale application then it makes sense to go for so called programmable SOC in programmable SoC the part of an SoC or part of the IC is pre-built such as the processor core and the remaining portion of the chip can be used by the consumer or end-user to implement his own circuit okay so that's why we call them as programmable SOC and usually the part of the SOC which can be programmed by the user is an FPGA fabric so you have one chip inside the single chip you have part of the chip which is fixed which cannot be modified and you have part of the chip which can be modified and the part which can be modified they will have the FPGA architecture which we discussed in the last lecture so there are again advantages and disadvantages exactly same as the comparison between ASICS and FPGAs so usually their performance is slightly lower but from development time point of view or from risk point of view it makes sense to go for PSoCs or problem SoC when you need a small-scale production now when we go with SoC design in general or with PSoC the current trend is to use so-called IPs for designing your system so in in IC design the IP stands for intellectual properties not of Internet Protocol okay so the idea here is similar to a software development so you might have seen in software development you do lot of code reuse you'll be using the code written by other people you may have either access to the source code or you may have access to precompiled library in any way you you don't have to rewrite the code you can reuse the code written by other people all the code written by yourself in the past the major advantage here is during the testing phase because this part of the code is proven code you don't have to test it again so that saves a lot of time so following the same concept here the idea is you reuse the hardware either developed by yourselves or developed by third parties and we call these Hardware modules Hardware blocks or IPS hardware IPs they usually come in three flavors first one is called hard IP so hard IPS are basically IPS which are built into the chip so you can use that Hardware block but you cannot change that Hardware blocks so a good example is the processor core inside an SOC or the processor core inside a PSoC program SOC they come as hard IP so you cannot move item you can just use them next one is called a soft IP in this case the IP developer he'll be giving you the source code in VHDL or Verilog one of the hardware description languages and you can use that code directly in your development your system development you can integrate their code with your custom code and you can build the engine so that's what we call as a soft IP and the third category is called firm IP again this is similar to using the compiled source code in software here you won't have direct access to HDL language instead they will be providing you an atlas you have seen that list in last semester so you'd be giving netlist in EDIF format or one of the custom format which you cannot decode and find out what is actually happening but the implementation tool can understand what this netlist is describing and it will be able to interface this particular netlist with your custom code so provided you have the netlist and you know what are the inputs and outputs from this particular IP so in our course we will be extensively using this IP based development flow now let's discuss about Xilinx Zynq so Xilinx Zynq it is a very popular PSoC programmable SOC and for our course we'll be using this particular chip so Xilinx they call them zynq APSoC or program system on chip which is basically a system on chip so it's an integrated circuit which looks like this now to use it we need a development board also so the development board that we are going to use is called Zed board. so this is the board and you can see this particular SOC is sitting here in addition to that there are a lot of peripherals here available again I will be explaining them later it's a Zed development board so just keep in mind the term Zynq SOC or in some cases we will also find in literature they are called hybrid FPGAs so it has an FPGA inside as well as a processor core okay so that's why we call them hybrid now let's look at the architecture of Zynq in a bit more detail so this is what is inside the chip okay bird's eye view the chip is mainly divided into two parts so the blue color here that is actually a built in processor processor cores it is a hard IP that means you cannot change this portion of the chip and this portion of the chip is called processing system or we always refer it as PS so whenever you hear PS remember it stands for processing system it is a part of the Zynq chip it is a hard IP it contains processor and you cannot change the circuit in this part but of course you will be able to program this processor now the remainder of the chip this big area it is called programmable logic or PL sorry typo here incorrect it this part is called PL programmable logic and it is basically an FPGA fabric or it follows the architecture of an FPGA so you can build any digital circuit that you wish in this portion of the chip and you will see there are some interface between PS and PL and these interfaces follow so-called the AXI standard advanced extensible interface standard which is a standard developed by arm for communicating between microcontrollers and peripherals again details we will discuss but the main takeaway is you have PS here you have PL here this part you cannot change the hardware you cannot change but you can program the processor in this part and this part you can implement any custom hardware digital hardware that you want and PS can communicate with the hardware in PL through these interfaces through the AXI interface this is little bit more details it's exactly what I mentioned so you have PS here inside PS you have processor there are other peripherals also it also has built-in memory inside this PS portion and this processor can run you a simple operating system it can actually run Linux kernel also it can run application we will be writing in lab in C or C++ we will write and hardware drivers also all those things will be running in the processor in the PL part you have your custom peripherals sitting here and the processor can communicate with these custom peripherals through this AXI interface now this is a comparison between Zynq implementation and other way you can develop your system you can either go for ASIC of course you know what it is application specific integrated circuit a ASSP stands for application specific standard processor so again this is an another technique of developing custom solution here what you do is you develop a processor and it has instructions so we have seen in the computer architecture course every processor has a set of instruction set so in ASSP you will develop instructions specific for the particular application for which this processor is targeted for so if you are dialing a processor of our image processing you will have special instruction for example you can have an instruction for multiply and accumulate or you can have a special instruction for RGV to gray-scale conversion okay so we have specific instruction for that specific application that is what is ASSP and two chip solution you build your circuit using multiple chips discrete or you go for Zynq what are the advantages and disadvantages it is showing it seems like it's better to go of it Zynq in most cases again this slide is taken from Xilinx who is the manufacturer of Zynq so take it with a pinch of salt again but of course the risk factor it makes sense the risk is much less when you go for SOC a program in SOC and the time to market is also quiet less it's flexible and it is scalable but again let me repeat the major drawback will be the size of the circuit that you can implement within the Zynq chip so it is limited by how much resources how much CLBs is how much lookup table how much flip-flops are available within the chip that restricts how big your a circuit can be within this chip so if you look at the circuitry inside a Snapdragon or Apple Bionic it is so complex that you may not be able to fit all those circuits inside a Zynq chip okay so that's the major disadvantage then again slide from Xilinx what are the major highlights of Zynq and as I mentioned before it has processor inside these are ARM processors actually so it has a dual-core cortex a9 processor okay and it has lot of other peripherals also in the PS part and it is tightly integrated with PL it has a flexible array of i/o this is a closer view of the PS part of Zynq okay so this is an expanded view of this portion PS and again you don't have don't have to remember the details but good to know that the PS part it has two arm processes so you can see arm cortex a9 here cortex a9 here so it has two processor cores cortex a9 and they have their own cache memory separate each processor has a dedicated FPU stands for floating-point unit these are special circuits which are used for doing floating-point arithmetic so you know floating point in IEEE representation they are much complex so there is dedicated hardware for processing those numbers it also has memory controller you can see it has DDR LPDDR memory controller and you can put external memory to the chip it has on chip memory in addition to that on chip memory you can expand the memory by adding external chip and these are the controllers for the external chip here you can see a bunch of the difference again available there are two USB controller two Ethernet controller GPIO UART controller CAN controlIer I2C controller SPI controller so these different communication standards you will be covering in embedded lecture what is SPI, i2c, CAN, UART etc basically these are all used for communicating with other peripherals outside the chip so for the time being that is enough this is the view of the PL so here you can see there is a gap here this is where PS is sitting remaining portion is PL and the architecture is exactly an fpga architecture so there are CLBs sitting here there are such boxes sitting here and you can build any harder in PL by following whatever we discussed in the first lecture now in addition to CLBs modern FPGAs they have two more basic building blocks actually which I skipped in the first lecture they are block RAMs and DSP slices Block RAMs they are very small memory blocks they are small ram the capacity is usually 4 kilo bits or nine kilo bits very small DSP they are dedicated multipliers so if you want to build small memories or multiplier circuit inside an FPGA usually we won't use CLBs because you will have to use a lot of CLBs to make a memory instead of that it can use these small memory units and combine them to build a larger memory we'll be doing it in lab similarly if you want to build multipliers inside an FPGA we won't be using CLBs to implement the multiplier we will be very using or rather the software tool that we are going to use it will be using these DSP slices to implement them so of course you can use CLBs to implement memory as well as multiplayer but it is more efficient to use Block RAMs and DSP slices to do it now this is again you have seen this slide in the previous lecture this is the floor plan or the die of an actual Zynq so you can see what is inside the chip so this black area this is the PS where the processor and the peripherals are sitting and this large area it is the PL which is an FPGA fabric and these two portions they are interfaced through so called the AXI interface so that they can communicate with each other now there are three different use cases where you can use Zynq so in the first case you can use only the PS part of the Zynq and you can have a pure software implementation of the system and you are not going to use your own custom hardware okay so you are not going to tough the PL part you use the ARM core processors inside the PS part now it doesn't make much sense because Zynq costs a few hundred dollars if you want to implement something purely in software you can buy micro processor so micro controller really really cheap maybe four five or ten dollars you can very good microprocessor so no need to go for a Zynq second case is you can use only the PL part of Zynq and implement your custom hardware and don't touch the PS part that means your system is purely custom hardware based purely hardware based now again this doesn't make much sense if you want pure hardware implementation you can just go and buy an FPGA our traditional FPGA which is much cheaper than Zynq okay and the third scenario is your system is composed of both software as well as harder so you have some software in your system running in a processor and you have some custom hardware so the software can be implemented in the PS part and the hardware can be implemented in PL part and they can communicate with each other and this is the scenario which actually makes sense so Zynq is again used in cases where your system is composed of both software and hardware so it is quite popular in software hardware co-design approaches okay so that's all in this lecture we will have more details in the next lecture 