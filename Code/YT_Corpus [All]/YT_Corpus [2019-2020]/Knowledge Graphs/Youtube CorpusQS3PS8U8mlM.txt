 [Music] you [Music] you so in this lecture we will learn about two things one is about bipartite graphs the second thing is about minimal spanning trees these are the concepts the differently on this lecture let's first define what are bipartite graphs in the previous lecture we talked about coloring or coloring the vertices of a graph graphs which can be colored using two colors which can be vortex colored using two colors are referred to as bipartite graph so let's write down the definition two colorable graphs are called bipartite graphs so if you have any graph and it can be colored using two colors these are called as bipartite graphs and the reason why they are called bipartite graph is because it's naturally splits into two parts okay so let's say these are all the vertices getting one color so let's call it as color one and these are all the vertices getting color two now if you look at the edges of the graph every edge is of this kind one end is in this particular set let's call it this is a and this is B and the other edge will be in B okay this is how every bipartite graph would look like one edge in D in one part and the other edge in the other part because if you had two vertices in the same part then of course these were the colors given to the graphs and if you had an edge in which both vertices were on one side then that would essentially mean that that edge is not properly colored its endpoints received the same color so that's not allowed so bipartite graphs are essentially two colorable graphs now we will give an alternate characterization to bipartite graphs we write it as a theorem and we'll prove it a graph is bipartite if and only if it contains no cycles of odd lengths and you look at all the cycles in the graph if none of those cycles are of odd lengths then it will invariably be a bipartite graph okay and if you take a bipartite graph that cannot contain any cycles of odd lengths let's try and prove this theorem the One Direction is easy suppose let's just imagine that there is an odd cycle suppose this is one particular cycle in the graph cycle of odd having odd number of edges now suppose this graph was colorable then all these vertices would have gotten some color so if you take this what is one of these vertex start at any vertex if you give color one to this its neighbors must surely get a different color so this must be of color too there's no other option and this what the next vertex should be of color one and the next should be two and the next should again be one and that would cause this particular edge to be colored in such a way that both its vertices have the same color so that's not a valid coloring so this would happen in any odd length cycle if you have a cycle of odd lengths you start at any vertex by the time you reach back to the vertex you will see that as the colors have to alternate the last edge cannot be colored properly okay so odd length cycles would imply that the graph cannot be colored using two colors and hence the graph cannot be bipartite so we know that odd length cycle implies not bipartite so the contrapositive of this statement would mean bipartite implies no odd cycles okay now we need to show the other direction that is let's take a graph which doesn't contain any odd cycle that will be bipartite okay so let's look at any graph and we are going to color the edges in a particular order okay so we take any particular vertex let us call this as v1 so we are now looking at a graph without any odd cycles and we will show that it is bipartite okay so let us take any particular vertex of such a graph so let G be a graph without odd cycles and let's choose a particular vertex v1 okay we are going to construct an ordering and for this we will first look at all the vertices of vertices which are adjacent to v1 okay that is what we will call as level one okay so level one consists of all vertices which are neighbors of V one and then we will look at the neighbors of vertices in level one okay that will be at level two okay look at all their neighbors except of course the neighbor V one we look at all the other neighbors and that we will be putting in the next level and we continue this so we will get something like a levelled arrangement of the vertices this is the level 0 that is vertex V 1 and then there are level 1 vertices its neighbors will give you the level 2 and so on so this will have some number of levels note that if you look at the original graph and look at all its edges they will pass for level I to level I plus one or level I to level I minus one they cannot jump to levels because if if there was some vertex here and there was an let's say there was some vertex at level one and it is connected to level three then automatically it would have been in level two as well because it's a neighbor so it would have to be in level two so there is no possibility of jumping the levels okay so all the neighbors were essentially accounted for here of course the previous neighbors whatever I mean for example if you take a node here some of its neighbors are going to be here and then some of the neighbors are going to be in the layer above it what we have argued us nothing can go from one layer to this this is forbidden okay now can there be edge between two vertices in the same level is this possible we will argue that this is also not possible because suppose there was one such edge it is within a level then these would have some ancestor some common ancestor of course v1 is their common ancestor but there could be some common ancestor at a layer closer to this particular level if you call this as level I there is some other level which is closer to I then let's say v1 and there is a node there such that that's a common ancestor of both U and we okay now if you look at the common ancestor and the path to you those apart from that common ancestor to V and apart from the common ancestor to you and both these paths will have length exactly the height difference between these two layers and they will be equal and therefore if you look at so if this was a common ancestor there's a path common ancestor and then there's a path to you there's a path to be and there's an edge between them together this forms an odd cycle because this path length is X this path length is X and this is of length 1 and therefore 2x plus 1 being an odd number you have a cycle of odd lengths but we assume that G is a graph without odd cycles we wrote it differently but yeah so this is G is a graph without odd cycles so if you take a graph without odd cycles then this is not possible ok so all the edges will be between adjacent layers and within a layer there are no edges now any graph without odd cycle we can construct this leveled arrangement and now if you look at the odd layers and give it one color and the even layers and give it another color we can essentially get a valid coloring using just two color ok because between two odd layers the distance is at least two and therefore there is no edge between them same applies for between the even layers ok so that completes proof that I mean if you take a graph without odd cycles they can be colored with two colors it is a two colorable graph or a bipartite graph now we will see another concept called as minimal spanning trees we learned about trees and trees we're graphs such that there were no cycles in it and that they were connected now here when we are talking about minimal spanning tree we have a specialized kind of graph in under consideration so what we will look at is what are called as weighted graphs so weighted graph is nothing but a graph with the edges having a certain weight so a weighted graph is a graph with weights on the edges that means we have a function that's WT which goes from the edge set to natural numbers okay so W T e would be the this will be called as the weight of the edge for example here's a weighted graph with six vertices and the weights being as indicated by the numbers above the edges so here if you look at the edge a B and the edge BC there they are having the same weight so what we will assume in our study of minimal spanning trees is that the edge weights are distinct say if e1 is not equal to e2 then weight of e1 is not equal to weight of e 2 so so we can think about our weighted graphs as graphs having unique edge weights each edge weight is a distinct number and we will assume that it is a natural number now let's define what our minimal spanning trees a spanning tree is a tree so T suspending - you're off a graph G is a treaty which is a sub graph of G so there are no isolated vertices there are no isolated components so if you take a sub graph of G this means this subset of the edges such that they form a connected graph and it doesn't have any cycle in other words you wanted tree such that every vertex is part of this tree for example if I take the red colored edges that forms a spanning tree you can see that there are many spanning trees for this particular graphs now the weight of a spanning tree is defined as the sum of the weights of the edges so weight of a spanning tree is the sum over the edges in tea weight of edge for example the red tree that has been described its weight this so if you call the red tree by tea weight of T is equal to one plus three plus two plus five plus six so that is 17 and minimal spanning tree is a tree which has the smallest weight amongst all the spanning trees so there could be multiple spanning trees and if we didn't assume that the edge weights are distinct there's a possibility that the there could be multiple trees with same weight and so all of them will be valid minimal spanning trees look at the smallest weighted tree spanning tree that's called as a minimal spanning tree for example in this graph if you take another collection of edges so if you take these blue colored edges their weight is going to be if you call them as t1 weight of t1 is going to be 1 plus 2 plus 2 plus 4 plus 4 that's going to be 13 so that's less than T but it is not clear why this should be the minimal spanning tree of this particular graph now we will see certain properties which will help us compute the minimal spanning tree of any graph so there are two crucial properties which will help us identify the minimal spanning tree the first property is called as the cut property so cut property essentially states that the least weighted cottage is part of every minimal spanning tree so we need to understand what is a cottage so a cut is defined as a partition of the vertices so when we say partition of vertices we need to get so we need we need to have a partition of the vertices into two parts okay and two non empty parts so let's say this is your Part A and this is Part B so a union B is your vertex collection of vertex vertex set and the edges so now if you look at the edges of the graph there are three kinds of edges edges which lie completely inside a edges with sly completely inside B and then there are edges which go from A to B these are the only three kinds of edges and these edges which go from one part of the cut to the other part is called as the cut ends okay so that essentially tells us what is the cut property look at all these edges these cut edges for any possible cut all such edges would essentially be part of every minimal spanning tree here we are assuming that the edge weights are distinct and therefore there will be a unique least weighted cut edge we can always relax these conditions for example if there are multiple edges carrying the same weight even then we can apply cut property for that what we need to guarantee is that for the cut that we have chosen there is a least weighted cut it there is a there is one cut it whose weight is strictly less than every other one and that cut edge should be present in everything else if you had multiple cut edges minimum ones minimal ones all having the same weight then what we can do mean that at best is that one of those would be part of every minimal spanning tree so let us look at some particular uses of them above lemma so if you look at the cut where vertex a is on one side so if vertex a is on one side and everything else is on the other side okay and there are two edges which goes from this side to the other side namely the edge having weight one and the edge having weight to the cut property says that one must surely be present in all minimal spanning trees why is this so we will see shortly similarly if we had taken a and B as a cut has one side of the cut and rests everything on the other side or abd on one side and CEF on the other side and there are two cut edges namely the edge four and the edge five sorry the edge having weighed four and they are shying away - and we can say that the edge BC will surely be part of every minimal spanning tree now let's see how we can prove cut property now suppose the cut properties Falls what does it mean that means there is some particular edge which is the least weighted cottage but is still not present in the minimal spanning tree so suppose let's say the edge e is equal to u comma V is the minimum weighted cut edge okay across let's say the cut we will call it as a comma B cut it means one side is there and the other side is B and a let us say a contains u and B contains we okay that is how that's how you V is a cut edge and suppose E does not belong to MST so let's just draw the MST so some tree is there and then if you add this edge into it what will happen is that's going to create a cycle okay because the spanning tree by virtue of this being a spanning tree there is already a path between U and V okay because every vertex was present and this is the tree now if you add the edge UV that's going to create a cycle now can we somehow say that the minimal spanning tree that you currently have is not the optimal spanning tree so this diagram was our spanning tree T and we are assuming that UV is a minimum weighted cutted now minimum rated cartridge means it is across some particular cutting a comma B and we want to identify those vertices so let us first draw the diagram so this is our a and this is our B and on top of this diagram given the layout are three so three will you have some edges on the a side some edges on the B side and surely because it is a tree there are going to be edges going from one side to the other now what we are guaranteed by our assumptions is that UV is not one of the edges but if you add UV to this that's going to create a cycle okay so let's just add the edge UV so suppose you is this and V is this we add UV to this that's going to create a cycle and in this cycle by virtue of this being a cycle the ravine if you just trace the edges there is a path from V to u ok u to V is an edge that we had added and surely there's a path from V to u and that path should surely cross the cut at some point okay that means there is an edge which starts in B and ends up in a by virtue of that being a cut edge for the cut a B it's weight so let's call this as e prime weight of E prime is going to be greater than weight of E so now let's imagine the tree which is obtained by removing the edge E prime so this edge we are throwing out and we are in place of that adding the UV edge now we will shame that the new object is going to be a tree it's going to be a tree because this doesn't contain any cycle the only cycle that was there was the cycle that we got by adding UV that cycle has been destroyed by removing the edge E prime so this is a cycle-free graph and every vertex which is connected earlier still remains connected so this is a new tree and the way of this particular tree so let us say the new tree is T prime rate of T prime is equal to weight of T plus weight of UV minus weight of B prime but e Prime's weight is going to be greater than the weight of UV or the edge E and therefore this quantity is a negative quantity so weight of t plus a negative quantity will give you the weight of T Prime and this contradicts the assumption that tip was the tree having least weight so it's not a minimal spanning this argument tells us that T cannot be the minimal spanning tree because we have found one particular tree whose weight is strictly less than that of T that's the proof of cut property so construct any possible cut split the vertices into any possible manner and look at the edges which goes from one side of the cut to the other and amongst those the least weighted edge surely is going to be present in all minimal spanning trees that's the cut property okay later on we will see how we can repeatedly use this cut property and construct the minimal spanning tree of any graph the next property which will which is again going to be a useful property for constructing minimal spanning tree is the cycle property so consider recycle in any graph any weighted graph and look at the maximum weighted edge in that cycle make a guess as to whether that edge will be present or absent in minimal spanning trees cycling property states that max weighted edge will not be part of any minimal spanning tree okay so how do we prove this let's take a graph D and suppose the sightly property is false before we go into the proof let's see a couple of examples so in this particular diagram in this graph G if we look at dB that's the maximum weighted edge of the cycle involving edges with weight 1 2 & 3 so the edge marked in green cannot be present zetsu cannot be present because it's a maximum weight arranged the same applies to the edge EC because that's also the maximum weighted edge is the cycle BCE D and EF is also not part of a minimal spanning tree of part of any minimal spanning tree because that's the maximum weighted edge of the cycle C F e ok so in this diagram in this graph if you look at the edges that has been excluded they are fit to be excluded none of those edges can be part of any minimal spanning tree and therefore if you look at the remaining edges they must be part of every minimal spanning tree okay reason being if you remove any one of them there is no other edge that you can add to make this graph connected so this tree indicated by the blue lines are going to be the unique minimal spanning tree now let's see bicycling properties true let's see a proof of cycle property so suppose cycling property is false what does it mean that means there exists a cycle such that E is the maximum weight edge of that cycle and he belongs to the minimal spanning tree let's call the minimal spanning tree s T so e belongs to t e is an edge of the tree T ok this should give us a contradiction so let's look at our three we'll draw it out and some particular Reds e which is the maximum weighted edge of some particular cycle is present ok suppose this was that particular edge if you remove that particular edge that tree will automatically break into two parts okay so that's going to naturally give us a cut involving or a partition of the vertices so let's say we're going to draw a tree like this this is our edge UV and there are no other edge going from side a to side B in the tree so there are all these other vertices they are all connected to you and there are all these other vertices which are connected to the well that's our tree our minimal spanning tree was something of this kind and if you remove UV then that disconnects the graph but now if you think of the original cycle C of which UV was a maximum edge if you look at that cycle and trace out that cycle starting at the edge UV then at some point there should be an edge going back into I'm going from B to a the cycle of which the edge E was part of must have an edge which goes from B to a ok and clearly this is not going to be an edge that was part of the treaty because the treaty did not have any edge going from side a to side B other than the UV edge okay so let's call this edge as T prime okay and since this is part of the cycle weight of a prime this is going to be strictly less than weight of UV again replacing the edge E Prime replacing the edge E with E Prime we get a tree of strictly less weight okay so we can conclude that T is not minimal it's not the minimal spanning tree okay and therefore our assumption is contradictory okay so we know that cycle property is also true so now equipped with these two properties cycling property and cut property we will describe a couple of algorithms to solve the minimal spanning tree problem okay when while spreading through problem is you're given some particular graph some particular weighted graph and you need to compute the minimal spanning tree and these are classic algorithms the first algorithm is called as kruskal's algorithm we won't bother about the data structures used in these algorithms but instead we'll just look at the steps of the algorithm so crystals algorithm does the following you look at all the edges sorted by their weights in increasing order okay so consider edges in increasing order of their weights okay so e1 e2 and so on there were M edges then you look at it just even e2 yep and keep on adding this into the tree okay so initially you have these n vertices which we can think of as isolated vertices first vertex first edge that you add is even and then maybe you will add e to and so on each time you are adding an edge you will check if there is a cycle formed by the edges that are already so suppose even need to and then you added III and suppose II for was between these then you are not going to add it for okay so consider the edges in these orders keep adding them without creating cycles okay and in the end if you had started with a connected graph you will get the minimal spanning tree okay why is this algorithm correct the reason is the sightly property now every edge that we have removed from this particular tree is an edge which deserved to be removed because that cannot be part of any minimal spanning tree this also tells us that if the edge weights were distinct that gives rise to unique ordering on the edges and therefore it will create a unique minimal spanning tree okay so on graphs where the edge weights are distinct there is precisely one minimal spanning tree and that can be found by this method methods correctness restaurants the fact that all the edges that we have removed in the process to create that tree can I mean those are the edges which cannot be present in any minimal spanning tree okay so if we look at our original graph okay so if we sorted the edges according to the edge weights the edge weights would have been 1 2 2 3 4 4 5 6 ok we need to have some way of identifying which was the weight to edge okay but if you look at weight 1 & 2 these edges are will automatically be added this also can be added and you add 3 there's a cycle so that's not going to be added when you add 4 that's not going to create a cycle that gets added the next 4 is also going to be added and 5 & 6 are going to create cycles okay and therefore they will not be and therefore this example verified that the tree obtained is indeed the minimal spanning tree prims algorithm is also a very simple way of constructing the minimal spanning tree so you started in the algorithm works in the following way you start at one particular vertex and look at all its neighbors and amongst the neighbors add the least weighted edge okay and keep on and then let's say if you have added one particular vertex now you consider this as a set and from this collection find out the least weight arrange and then add that and then consider those three as a set and add the least weight edge and so on okay so at any stage you have a collection of edges collection of vertices which are which forms a connected component and from this component look at the least weighted outgoing edge and that's what we added to expand this particular tree and in the end you will get the you will get a tree and that tree is guaranteed to be the minimal spanning tree why is it the minimal spanning tree because each edge that you add at any given stage is the minimum weighted edge of a certain cut so when you added the first edge if you look at the cut consisting of just that one vertex and everything else in the other side okay you have a valid reason for adding the particular is it you've got it at any particular stage you have some partial tree and those partial trees define a set of vertices and the complement of that would be the other part so if you cancel this is a cut a be the next edge that you are going to add is the minimum weighted edge across the cut a B and therefore by cut property that is an edge which deserve to be added to every minimal spanning tree okay so we've learnt two algorithms to compute the minimum spanning tree and the correctness of both these algorithm comes from simple properties simply graphs properties like cut property cycle property we'll stop here for today's like we will end today's lecture here it will continue studying other properties of graphs in the coming lectures you [Music] you 