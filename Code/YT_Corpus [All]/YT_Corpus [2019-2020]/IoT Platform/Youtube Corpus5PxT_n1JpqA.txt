 Today on the IoT show, we'll talk about a brand new feature to the Azure IoT Hub service. That new feature is called device streams and allow us to establish telecommunication with TCP between services in the Cloud and applications on devices. So basically, you'll be able to securely and safely authenticate through IoT Hub and communicates over TCP between an application and a device. Reza, the PM for that new feature of the Hub comes to the show to talk to us about it. [MUSIC].  Hi everyone, this is the Internet of Things show. I'm Oliver, your host and today we have Reza to discuss a new feature in IoT Hub which is called Device Streams. Reza, thanks for coming on the show again.  Absolutely.  We had you recently. For those who don't know you, actually, can you introduce yourself and tell people what are you doing within the Azure IoT team?  Absolutely. My name is Reza Sherafat and I'm a Senior Program Manager in the Azure IoT hub platform team. So, we work on the IoT Hub platform primitives. Many of the messaging features, remote procedure call and the new one that we're taking to public preview which is called device streams and I'm here to give a quick demo and introduction to that for you.  Awesome. So, yeah, we'll get to that new feature of IoT Hub. IoT Hub is growing every day with new features that are dedicated to IoT scenario. I understand that this one is something that has been asked by customers for enabling in specific scenarios that we're going to actually see. So, what is Device Streams about?  Absolutely. So, as I said, this is a brand new feature that we're adding to the Azure IoT Hub portfolio features. It solves actually a pretty common problem that customers have. A very common scenario that we have seen customers deploy their devices in is inside of private networks. These might be networks inside of enterprises or factory for local area networks or manufacturing plants, et cetera. As a result of the security requirements on these networks, in many cases, there are firewalls deployed at the perimeters of these networks to block all the incoming connections from outside. Yet there's a large need for different scenarios. So, for example, when operators need to maintain some of these devices and service these devices from a remote site. These might be operators from a third party company that need to access the devices and remotely connect to their network initially before being able to perform the functionality that they need to perform. There are other scenarios as well. So, for example, when you might need to do diagnostic on the device, you might need to access the diagnostic portals that are deployed on the devices or might even need to access the file system on the device.  Yeah.  Access the logs that are sitting on the file system in order to do various functions and to support various scenarios.  Yeah.  So, as I mentioned, the security of these networks is a top concern for customers and the presence of the firewall is, basically, there to ensure security of the network. So, as a result, there is conflict obviously because the firewall is blocking the incoming connections and yet there is a need to access the devices.  It's something that IoT Hub, once the device is authenticated and connected to IoT Hub, we have this tunnel for communicating over various types of protocols including AMQP depending on what you choose to transmit telemetry data or to synchronize the device stream which is a JSON file.  Yeah.  What you're describing are actually all about existing protocols. So, you would need to implement in-between a back end and a device that traditionally would go on specific ports that are closed by the firewall if I understand correctly, right?  That's right. So, as you mentioned very correctly, in fact IOT devices that are home to an IoT Hub already have an outbound connection to Azure Cloud and particularly to IoT Hub. What we are enabling through Device Streams is to leverage that outbound connection that's already established on the device to the Cloud to also be used for receiving traffic over incoming connections on the device side. So, particularly, as I'm showing in this diagram, even though these external services that might need to access the device are blocked under direct connection line to the device, they may still use Device Streams to rendezvous in the Cloud side. They, basically, particularly the device and the service side both connect to IoT Hub and IoT Hub acts as a proxy, basically, that transfers the traffic between these two entities and from the device to the service and back from the service to the device.  Makes sense. The service application has to be authenticated also.  Yeah.  To your IoT Hub. So, meaning that IoT Hub knows the two entities and it actually can ensure that your end-to-end application or implementation is totally safe.  Absolutely. Device Streams is a very much security focused feature and encryption and authentication of the tunnel that exist on both sides of the Device Streams is something that happens transparently under the hood without much involvement from the application side.  Okay.  So, let me go over and quickly review some of the advantages that Device Streams bring to the customers. First and foremost, Device Streams enable end-to-end connectivity to IOT devices in a firewall friendly manner. As I mentioned earlier in our conversation, it is really the question of how to connect to IoT devices in way that does not compromise the security of the network the devices are on or the security of the devices. So, it's really important to be able to avoid opening up of firewall ports in a random fashion or avoid complicated setups that sometimes might be needed through virtual private networks or other setups that are a substitute to Device Streams. The other benefit that Device Streams offer, as you again correctly mentioned, is authentication, an enforcement of authentication. Both sides of a device stream need to authenticate with their corresponding IoT Hub credentials. So, it ensures that not any endpoint in the open Internet can connect to a device. Only those that have access to the secrets of IoT Hub are able to communicate and establish these types of tunnels. The third benefit is encryption of the communication line over Device Streams. Basically, all the application data that is sent over device streams is encrypted by default. This is particularly true regardless of the fact whether the application uses encryption or not, even the application if they transfer just pure text messages and in plain text, we encrypt them over the channels both between the device and IoT Hub as well as the service and IoT Hub.  But there's transparent for the actual application that it's going through that tunnel, right?  Yes. So, the device side sees the bytes as they were sent from the server side and the server side sees the bytes as they were sent from the device side.  But in between, we take the package, encrypt it.  That's right.  Ensure the authentication first, encrypt the message, pass it over, decrypt it through our SDKs as suppose on the device side of things and then we have the application that is accessible.  Yeah. So, traffic over the network, over these tunnels, are encrypted but once the device or service received a byte stream that the other side has sent, it's decrypted and is basically handed over to the application in its original form.  Okay.  Finally, I want to mention that device streams is compatible with the TCPIP stack. Basically, any client-server application that might run on the service and client that uses TCPIP can tunnel their traffic through Device Streams.  That's a lot.  Yeah. That he is quite a bit.  That's a lot of functionalities and one that comes to mind immediately is SSH, right?  That's right.  I want to login to my device remotely to do the task that you were mentioning. Well, anyways, you have demos coming up, right?  Absolutely.  So, we'll see that.  We'll see that in a bit. But as you mentioned, both off-the-shelf applications such as SSH or other applications that are built into Operating system platform such as remote desktop can tunnel that traffic through Device Streams and in the demo I'll cover those. But this is obviously, I want to emphasize that this is not only restricted to these applications even though these are among the most commonly demanded scenarios of customers to ensure secure connectivity to the device. It's still is a tip of the iceberg. As you said, there are various types of applications that the customers can develop on their own and use Device Streams where there are various types of standards-based applications like the HTTP, HTTPS, can now also leverage device streams in the a very similar manner.  So, I have a question. I might be a bit tricky and being in public previous thing it's pretty fair but do we need to expect a tax in terms of performance in these communication because instead of going directly, you're basically getting encrypted safer communication, but I would assume that theoretically, you have a little tax in terms of the performance of that communication, right?  Yeah, that is true there is some, basically, extra data packets that need to be transmitted. Particularly, in terms of the end-to-end latency, there might be a tax that that needs to be paid.  But minor for the benefits of having the authentication, the encryption, taken care of by IoT Hub.  As we, basically, introduced this feature and overtime we're going to introduce it in new regions. If customers ensured that their hub is located in the same region that the service and the device are physically located, then they can minimize the impact of these types of latencies.  Fair enough.  But as I showing in the demo, in fact, the IoT Hub instance that I'm using is in the Central US region which is quite away from us.  Because we are in Bosnia.  That's right.  We are a little bit further.  No, we're in US, don't worry guys.  But the applications that we use Device Streams for are mostly interactive. For example, in the SSH case, you will see that the SSH prompt quickly shows up and there is very negligible amount of delay at least in this demo.  Once again, for the value in terms of security it adds and the control you get over your device and so on, I think it's totally acceptable to have a little tax in performance, right?  That's right.  Yeah.  If their compromise is to open up firewall ports which in some cases is absolutely a no go for organizations.  It's going to be a no, no.  Yes. That is the alternative.  Yeah, Okay.  All right. Let me quickly go over what it entails to establish Device Streams. I'm not going to get into much of the details but at a high level, I want to mention that the device and service are entities that from a traditional perspective, they are already connected through IoT Hub and particularly, they are interacting with what we call the IoT Hub's main endpoint.  Okay.  When the service wants to initiate a connection to a device they perform a handshake, and as part of this handshake protocols, they established a secondary connection each to a second endpoint which we call the streaming endpoint. That is the endpoint where the actual data bytes are transmitted over a device stream is sent over.  Okay.  I'm showing that at a very high level in this diagram. At the end of this process, each device and service, through our SDK, get access to a web socket client which they can use to send or receive data over. This web-socket is particularly connected to the streaming endpoint and offers the same level of guarantees and reliability and ordering guarantees that are on par with a TCPIP.  Okay.  So from that aspect, any Byte that they write to this stream, is received from the other side as is and without any reordering or reliability issues.  You mentioned the use of our SDKs, so on the service side of things where you would use the- known as service SDK for IoT Hub and on device side, you would use the device SDK and then we assume that someone already has an application that connect to IoT Hub can benefit from that new feature by upgrading the version of that SDK users in his application and then leveraging that new endpoint and set of features, right.  Right. So basically, applications have two ways to use device streams. One is through our SDK, which means that they can programmatically integrate into our SDK and start calling our APIs to initiate these Device Streams, do the handshake and ultimately received a web socket client in order to send and receive data. That is integration path number one. But for applications such as SSH an RDP and the applications that are more off the shelf, customers normally don't have access to their source code or for various reasons are not willing to make any source code changes. There is a model of using proxies that is actually involved in the demo that I'm going to show towards the end of this.  I'm I actually going too fast?  You're definitely going fast.  That's good, because that means that you're actually presenting what I'm interested in.  That's right. So, this demo, demonstrates the use of device streams for the SSH scenario which as I'm showing in this diagram here, it has two entities involved. One is the device side which actually runs SSH daemon, the server side of the SSH protocol, and the other one shown on the right, is the SSH client where the user tries to run and login and acts as the client side of this stage protocol.  Okay.  As I mentioned, for various reasons that direct connectivity between these two endpoints can be blocked for example, through the use of firewalls. Now, we want to apply Device Streams as a technology that enables end-to-end connectivity between these two programs, while they're booing the traffic through IoT Hub, so that we can have end-to-end connectivity without violating the organization's policies around the firewalls rules. So, what we have distributed as part of our samples and they are also accompanying quickstart guides on how to set this up and run the samples, is two programs that we call Device Local Proxy shown here in orange, and Service Local Proxy shown here in blue. So, these are the programs that take the integration path number one and they integrate with our SDK programmatically. They start calling our APIs. Under the hood, they interact with the IoT Hub and create Device Streams without the knowledge of SSH daemon or SSH client in this scenario. Now, interaction lines number one and two correspond to basically the same handshake workflow that I had in the previous slide. But now, when the user is ready to create an actual SSH session to start accessing the device, the proxy programs also act as a client and servers for these two SSH daemon as well as the SSH client. I'm going to show this using these two extra arrows. In arrow that's tied with number three, the service local proxy is acting as a server listening and port. In this case in arbitrarily configurable port, port number 22, 22 and the local host of the service host. The user, uses their SSH client to connect to this port. Instead of directly going and interacting with SSH daemon over port 22. On the other hand, in the line that is shown here using tag number four, the Device Local Proxy acts as a client to the SSH daemon and connects to this SSH daemon over port 22 which is the standard port for SSH.  Okay.  Now if you look at the diagram we have end-to-end connectivity between the SSH client program on the right, that goes through this Service Local Proxy through IoT Hub, down to Devise Local Proxy and ultimately to the SSH daemon as the server side of the interaction.  You were mentioning that these are provided as open-source samples right? So, don't freak out like the implementation of all this mechanisms and chains of events, is something that actually you can get pretty easily done using the open source samples that we print.  That's right. So, the program are themselves very simple. So, to demonstrate this interaction, there's not much magic involved. The users can look at the code and in fact apply it in other places as well.  Perfect.  So, what I'm going to demonstrate, is I'm going to use my Windows laptop, to host in fact, both the device and service. But unfortunately since Windows I'm not running as a SSH server, I'm connecting to a different machine that has SSH. I am going to bring up a three terminals. Terminal number one, two and three from the left. The first terminal, shows the terminal on the device and I'm going to run the device local proxy over there. As part of the configuration of the device local proxy, I'd like to show that I'm providing three pieces of information. I'm providing the device connection string, which is the authentication string used to interact with the IoT Hub,I'm providing a host name for where the actual SSH server is running, and in this case as I mentioned I'm connecting to a Linux box. So I've provided the IP address for that box and ultimately I'm providing the port used by that application and in this case SSH uses port 22.  Okay.  So these are the three pieces of information configured on the device side. On the server side that I have in the middle, again I'm providing three pieces of information. The first one is the connection string server. Service connection string again for the server side to authenticate IoT Hub. Then I'm providing the device ID that it needs to connect to, this corresponds to the same ID that the device authenticates with. Ultimately I'm providing a port number which is an arbitrary port that the Service Local Proxy will listen on for incoming SSH connection from the user.  Okay. So, don't pause the video and try to get these connection strings whose anyways IoT Hub related to that demo will be long gone by then.  Definitely. Alright. So, the third terminal over here is the terminal that I'm going to use to run SSH client. So let's go one terminal at the time from the left. I'm going to use.Net run to run their projects of this sample program. I'm going to do the same in the middle terminal for the server side. As you can see, the Device Local Proxy is configured to connect to a remote terminal and this address and this port. The Service Local Proxy similarly, is ready and listening on the local host port 22, 22. Now, I am going to use the third terminal to SSH to where the Service Local Proxy is listening on which is local host on port 22, 22 and I'm going to provide my own username and I do have a typo local-host. There you go.  Real demos.  Yes. There you go. Okay. Now I've already connected to the local proxy and this is actually the SSH prompt that is coming from the SSH server. So, I'm going to provide my credentials. Yes, and I mean, this is the SSH prompt that is being served through Device Streams to client program here.  Yes. As we can see the person using that SSH client, sees no different from a regular connection to a remote machine using SSH right.  So, other than connecting to local host on port 22, 22, there has been no change on the client side and normally, applications should be written in a way that that is only a matter of a configuration and change of configuration for those programs.  Great. Great demo. So the call-to-action is for people to go try out this public preview of the Device Streams feature of IoT Hub? Thanks Reza, coming on the show, thanks guys for watching. Don't forget to subscribe to the show. [MUSIC] 