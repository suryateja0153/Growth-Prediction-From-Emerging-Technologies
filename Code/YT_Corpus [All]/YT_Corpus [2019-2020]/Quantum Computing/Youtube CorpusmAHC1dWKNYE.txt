 so it looks like uh you're all very excited to go through day three what i wanted to do is just very quickly start by telling you just how much you've learned in the past couple of days um when i took a quantum algorithms course the first time to get to the point where you are now it took roughly four weeks so what you've learned in the past two days is roughly four weeks of material and while the field has changed while the field has dramatically improved in terms of the learning content that's available to all of you what i do want to point out is that you have taken on a rapid pace in your learning and it's exciting to see all of you picking up so many of these concepts and doing the lab problems but please do take a moment to go through the material over and over again and digest it as you're going through these lectures so today's lecture is going to be focused on building out quantum programs so you're about to transition from the starting point which is where you are learning about quantum concepts in general and how to work with quantum algorithms into a slightly more advanced concept now which is building quantum programs using quantum algorithms so today will be your first exercise the the program that we're going to be building out is called shore's algorithm and it's a factoring program but what i would like to do is just just give you an overview of what we've done so far and do a quick review and then show you the the preliminary concepts involved in shore's algorithm so we're going to learn about shore's algorithm in two lectures the first lecture is going to be today's lecture and we'll be talking about components of shore's algorithm called the quantum fourier transform and i'll also show you a related concept called quantum phase estimation which uses quantum fourier transform in tomorrow's lecture you'll see the exciting part where we put all of these learnings together and build out shore's algorithm now shor's algorithm i keep repeating this name just to give you a quick introduction is one of the crown jewels of this field it's one of the algorithms that as soon as the research results came out started a lot of excitement within this field so i really want to show you the the core of schwarz algorithm in in detail but what that will require is going through the preliminary concepts today and then tomorrow we'll go through shore's algorithm by putting all of these things together all right so i'll begin by sharing my uh my writing pad here and turn off my video and start discussing with you about shore's algorithm so let's do a quick road map so where where have we gone so far and what are we going to learn today so i'm going to write down roadmap and review some very quick concepts that we've learned so what did we learn we talked about qubits and quantum states in the very first lecture so what does this mean we talked about qubits in quantum states so we learned things like the zero state which is this kind of notation that you've seen in your lectures is really just a vector that looks like this it's just one and zero the one state really just something that looks like this and you also went through uh several gates that you could use to manipulate these quantum states in particular you went through things like the hadamard gate which if you remember looks something like this and we also saw maybe the x gate if you recall which looks like this now all of these concepts are very important to learn and all of them are quite useful for you to um quite useful for you to keep in mind and maybe even memorize but what what the fundamental concepts are that you learned centered around manipulating the quantum states or the wave functions which we wrote down generally as psi to be of the form a0 plus b1 what does this mean you learned about how to measure specific parts of the state so for example if you project psi onto the zero state that gives you a and if you project psi onto the one state that gives you b and more generally what that means is if you were to measure psi the probability of measuring zero is the norm of a square so if a is a complex number you're taking the magnitude of that complex number and if you're measuring psi the probability of measuring one is equal to this so you're taking the magnitude of that complex number b and you're squaring it so what is what is the most important thing that we've learned so far well if you measure this particular state you have to get either zero or one so these two probabilities have to add up to one so we made the statement that these two norm of a square and norm of b square have to be equal to one and this statement has two implications that i'll point out to you so here are the two implications so implication number one of the following statement is operations on quantum states need to preserve the norm and the way they preserve the norm has to be exactly equal to one which is what we've seen what does this mean this is actually a very complicated sounding way of just saying we have to be able to maintain this condition no matter what kinds of gates we apply okay so what what exactly does this tell us well that tells us that the kinds of operations that we can apply always have to preserve the norm and the kinds of operations that do that are called unitary operations so this is why the kinds of operations that we've been applying are norm preserving and norm preserving matrices are commonly called unitary matrices and for those of you who have some linear algebra background what this means is the complex conjugate uh the transpose of that matrix so u dagger is equal to u inverse so what does that mean if you take the the dagger of that matrix and multiply that to itself that's the same as well you can do it in any order you want so you dagger you or you you dagger at the end of the day this is the identity matrix so what it means is if you apply the unitary operator and then it's complex conjugate transpose that should give you an identity that's like doing nothing okay so why why does this why does this work well one of the key features of these unitary matrices so if you write down any of these unitary matrices you'll find the determinant of these unitary matrices is equal to one well i'll put absolute value of the determinant okay so that's the very first implication of saying that norm of a square and norm of b square have to be equal to one what is implication number two implication number two is for a single qubit you can think of unitary gates which are the the gates that we talked about so that's these gates are rotations on the surface of the block sphere so why does this work this works because the bloch sphere is a unit sphere so its radius is equal to one exactly and so you're maintaining that radius equal to one as you're rotating on that surface so you've seen in the first lecture that applying rotations onto these single qubit gates is exactly equivalent to applying unitary matrices onto them okay so that's that's another important concept to keep in mind you've seen both of these implications so far in your lectures maybe you may not have noticed i'd like to point out to you a third implication that comes out of these which will be important for today's lecture so i'm going to change the color here very quickly and remind you implication number three which is the eigenvalues and eigenvectors of unitary matrices which are exactly the gates that we're talking about above are special how are they special well first of all let's talk about what it means to have eigenvalues and eigenvectors the eigenvectors of of this particular unitary operator u are the are the eigenva are the vectors such that if i apply u on that particular state i would get exactly that particular state with some coefficient in front of it so let's call that lambda x now there are a couple of conditions i'd like to tell you without going through the proof in a lot of detail there are two things that you have to keep in mind for unitary matrices which are exactly the ones that we're dealing with these eigenvalues so this one is the eigenvalue and this one is the eigenvector just as a quick refresher the eigenvalue has to be of the form e to the i theta so what does that mean it has to be a complex number and a very special kind of complex number that has magnitude 1 and just looks like a phase on top of something so there's a theta coefficient that comes there okay so that's a very significant statement that i'm making here what i'm telling you is that when you apply the unitary operator what you're doing is effectively applying a phase onto its eigenvectors okay so that's the most important part and at the end of the day all this is telling you it's just a very fancy way of saying all the unitary matrix is doing is rotating that particular is adding a global phase onto that particular uh onto that particular eigenvector okay the second thing uh i want to point out to you so this is something special about uh about the type of the eigenvalues the second thing i want to point out to you is that if there are two eigenvalues so let's call them lambda x and lambda y if they're not equal to y if they're not equal to each other excuse me then we can say something very profound what we can say is if lambda x is not equal to lambda y then the corresponding eigenvectors let's call them x and y are orthogonal what does that mean that means if you take the dot product of x and y it has to be exactly equal to zero and this is another very important thing to keep in mind so in principle you've already learned about all of this it may not have been apparent as you're going through the material but it's good to highlight these points because i think they'll be useful in the rest of the lecture so again quick quick review of what we just did we said the unitary matrices have special conditions on their eigenvalues and eigenvectors the eigenvalues i told you have to be of a special form which looks like this e to the i theta and we made also a statement about the eigenvectors given two different eigenvalues corresponding to two different eigenvectors i know that those two different eigenvectors have to be orthogonal and this is something that we'll learn we'll learn as we go so just just as i'm going through this material i'm watching the discussion in the chat very quickly and seeing people asking questions like what is the difference between a unitary and a hermitian matrix i'd like to remind you again so unitary matrices are the kinds where u dagger is u inverse this is unitary hermitian means u dagger is equal to exactly u notice the difference u dagger is u inverse for unitary and u dagger is u for hermitian i hope that clarifies uh the difference between those two kinds of matrices they're both very important and they're actually very very important uses generally in in quantum physics but i think for this particular context today i'd like to focus on unitary matrices because i think you'll see some key things coming out of them and in fact later on as we're dealing with uh as we're dealing with quantum phase estimation you'll see that unitary and hermitian matrices are actually very closely related there's a very close relationship between the two all right so i hope that has been a good sort of review of the kinds of details that you've seen in your uh in your first lecture let's quickly talk about what you learned in your second lecture so in your second lecture you went from discussing uh these kinds of details about eigenvalues and eigenvectors to kind of a bigger picture perspective and you talked about the joy jose algorithm so what was the purpose of the deutsches algorithm uh what you are doing is trying to figure out if a function is either constant or balanced so what does that mean it either always gave you the same output so that's constant or it was balanced meaning that it gave you one output half the time and another output half the time for half of your inputs and the really cool thing that you learned is that you can use a quantum computer to determine if uh can use a quantum computer to determine if a function is constant or balanced in one shot and that's a really cool thing to learn uh this is one of these things that that really got the field excited and people really started kind of paying attention to the fact that quantum algorithms may very well be powerful you also learned about one of the one of the crown jewels of the field called growers algorithm and in fact this was the focus of your second lab what was the point of grover's algorithm the point of growers algorithm was to tell you about how to do unstructured search what does unstructured search mean it means you're given a list for example something that looks like this 1 4 9 five eight there's no there's no pattern that you can take advantage of here there's just no structure that's why people call it unstructured search so to find a number maybe that you want to look through in this list you really have to say is it this number no is it this number no is it this number no and you really have to look through the whole list until you eventually stumble upon the number that you're interested in so classically in the worst case you'd need to look through all of the numbers in that list at least so you need to at least look n number of times if you have n items in that list using a quantum computer and grover's algorithm we know that we can do unstructured search in n items with o of square root of n which just means in the worst case the dependence of the number of iterations that you need is square root and not linear in n and that's a really profound thing that's really awesome to learn all right so i hope that kind of reminds you of what you've learned so far in your first two lectures uh you've gone through quite a bit of material and now let's talk about the the preliminaries for shore's algorithm which is what we'll be covering in today's lecture so let me change the color here and say today we're going to be focusing on preliminaries for shore's algorithm i'm sure many of you have heard about this algorithm and we'll go through the algorithm in quite a bit of detail and i'll show you some examples to help clarify the concept i'll just point out here that this is a famous algorithm and really one of the algorithms that brought into perspective just how powerful quantum computers can be in the 90s okay before i continue uh down this path of talking about schwarz algorithm brian um can we take a couple of questions here just to clarify some concepts for people your thing absolutely um i think one question that might be helpful at the beginning here are unitary matrices the only norm preserving matrices yes so unitary matrices by definition are norm preserving that's why when we immediately said on quantum states we need to preserve the norm and therefore our matrices have to be norm preserving that's definitely nailing down unitary matrices it's pointing you in that direction great and then um one more question that we had uh i think that just for you to be aware of to answer maybe at the break someone was asking about all the books you have behind you uh i want to know the book do you use to help get you to this level so don't answer that one now but maybe when we get to our first break you can have that list ready sounds good uh there are a lot of them and a lot of them are useful for different contexts i can talk about why each one is useful at least for me uh over the break okay let's go back to the lecture material uh all right so shore's algorithm why why do we care about shore's algorithm what are we trying to do well shore's algorithm can serve uh in in many different uh in many different quantum programs in different ways but the most popular one perhaps is to solve the following kind of problem so let's describe what problem we're trying to solve if i give you a function that is periodic i would like you to give me its period so find it spirit this is a deceivingly short problem that sounds like it has a solution that should be very easy but it's actually a very challenging problem so let me give you let me give you kind of a stricter definition of this problem let's let's be a bit more concrete so i'll say strict definition we will call that function f and it takes an argument x and i will say if f of x is equal to f of y for x is not equal to y if and only if x minus y the difference between them in absolute value because i only care about the difference is p times some constant so p here is the period so this this kind of uh this kind of precise definition is actually a very very complicated way of saying something very simple that i can show you visually so let's do an easy example so let's take the following function i'll just draw it out for you and let's say the function is a function of theta and it's actually a function that you know very well called sine of theta what does sine of theta do well it ranges from -1 to 1 and it looks like this okay so this is this is one of the easier periodic functions to deal with right so the period is immediately notable if there are two values here let's call them x and y the period here between x and y for a function sine theta is 2 pi so i can always tell you maybe if this function keeps going later and comes back down and maybe there's another y here there's another 2 pi here so all that means is the difference between x and y in this case is 2 pi times some constant where that constant is some integer that we're not going to focus on too much uh we said x and y and the absolute value so this has to be a positive number obviously um z plus and zero but at the end of the day the concept that i'm trying to show you here is that the periodicity here is very clear you can all very clearly see the period and tell me exactly what the period is but let me show you a bit of a harder example so let's do the following let's say hard example it's going to be a bit tough to draw this so let's hope that i can do this well let's think of a function that does something that looks like this and then starts over again and does exactly what it did over on the left side so if i gave you this function with your eyes you could look at it and tell me this is the period but in fact if you are zoomed in and you are looking only in this small region for example what you would see is something that looks like this well if you see that zoomed in region does that mean this is the period so you can see here that functions that are not necessarily sinusoidal can be quite confusing in order to tell the period so there's there's there's a bit of a there's a bit of a difference here between the easy kinds of problems the sinusoidal problems and for those of you who deal with audio processing signal analysis some of you have already seen that you can take advantage of how easy it is to work with these kinds of these kinds of functions and to find out what their periodicity is and to take advantage of them as decomposing other complex functions this hard example should show you one concept which is that you might be trapped in local regions when you're trying to determine the periodicity so you really need a lot of data points in order to tell the period of something that's more complicated like this and sometimes there are examples that look like this let's call this an even harder example and i will be very careful to draw my axis here x and f of x here let's say the function looks like this what's the period here is there a period here well first of all when you look at this function it's very hard to see anything periodic by eye but in fact what you don't know is that you may very well be too zoomed into this function so in fact if you went out further you might have noticed that it would actually start repeating and do exactly what it did before so now the period looks something like this so i hope all of these examples show you exactly how kind how the problem of finding periods can be very complicated uh when when these kinds of things are uh are not necessarily as easy as dealing with sines and cosines like we saw in that very first easy example okay so why are we talking about all of these periodic functions well first of all if you have to classically find out what the period is it's going to take you something that looks like so remember this is the same worst case notation that i used before it's of an exponential that looks like c some constant times n to the one third and log n to the two thirds a very complicated way of saying there's an exponential here so it's e to the c n to the one third and then there's a log of n to the power of two thirds so you can see there's an exponential dependence and how hard this problem becomes as you need n bits needed to describe p the period so this is some of you might be familiar with things like fourier transforms and dealing with uh fast fourier transforms these are the techniques that can get you this kind of this kind of benefit so this is how you do things uh classically in the quantum example this is where shore's algorithm comes in shores algorithm can do this in o of n square log n times log log n and when you see something like this it's important not to be distracted by these factors log what i want to point out to you is that there's no exponential here it's now something that's faster than o of n cubed it's a little faster it turns out these coefficients can be can be can be quite large sometimes so let's say this is a little faster than o of n cube well this is already exciting right so here you had an exponential in n it's it's a it's a cube root of n but let's just say in it's an exponential here you don't have that exponential dependence anymore you've turned that into a polynomial problem so this is the kind of thing that people call polynomial uh exponential speed up so this is an almost exponential speed up and what you have is this benefit where shor's algorithm speeds up this particular problem of finding periods and the reason why this works there are two reasons why this works the first reason is quantum fourier transform which is at the heart of shore's algorithm and the second reason is another piece that we'll learn tomorrow called modular exponentiation so i just want to point out one thing to you um these blocks of shore's algorithm are quite involved today we'll cover this one and tomorrow we'll cover modular exponentiation so these reasons are why schwarz algorithm works as well as it does and what is the implication of all of this well first of all i want to point out to you that the problem of factoring a number which is a product of two prime numbers this problem is the basis for the security on our computers in several places so what does this mean i just you might have noticed i just switched a problem on you i was talking about periodicity up here and now i'm talking about factoring numbers it turns out tomorrow you'll learn that the idea of periodicity and the idea of factoring numbers are very much related and in fact the idea of converting between one and the other is why shore's algorithm is so successful but given that this problem of factoring is why is the basis of the security on our computers the fact that you can now solve this problem much more easier in a much more easier way on a quantum computer this is one of the reasons why there is a strong implication for knowing uh and getting quantum computers to work so this is has serious implications for security but is also not easily accessible today and the reason it's not accessible today as you'll learn in the next this lecture and the next day's lecture is that it requires several qubits and several good qubits okay so i hope this uh this clarifies uh why we're here the reason why we're doing today's lecture so again as a quick reminder let me write down in a different color today we're going to be talking about the quantum fourier transform and quantum phase estimation now i haven't talked so far about quantum phase estimation in the story that i told you but you'll find that quantum phase estimation is actually what shore's algorithm is in disguise so i really want to make sure that you see shore's algorithm tomorrow but i'll make sure that you have a very good understanding of quantum phase estimation today so i'll just put a caveat here by saying shore's algorithm is really just quantum phase estimation in disguise and this will i hope become very apparent as you um as you work through the lectures in the today and tomorrow all right let's take a quick pause here um and see if any questions have come up if not i'll start talking about the quantum fourier transform uh brian are there any outstanding questions i'm going through i'm looking for people asking questions about today's lecture here so uh we have one question that's highly upvoted it's a long one though so if you open up the ask a question you'll be able to see it too while implementation of quantum fourier transform and shore's algorithm why can't we use classical superposition and they give an example of what they're talking about using electrical pulses with phase difference will have the same or identical constructive or destructive interference patterns um i will it's it's good to pause this question although i would strongly recommend brian maybe take take a screenshot of this question so that we can answer it tomorrow because as soon as i'm talking about shores algorithm tomorrow and putting boxes together there's a point where i'll point out and tell people this is where you couldn't have done this with a classical system but for today it doesn't make sense to focus on this question great screenshot taken thank you brian uh if there are no other questions i think we can uh we can continue sure thing okay so what uh what is quantum for a transform let me just very quickly start changing the color here all right so like many things i could i could give you a very complicated definition of what the quantum for a transform is here but at the end of the day the quantum fourier transform is actually a very simple concept a quantum fourier transform is effectively a change of basis from the computational basis to the fourier basis okay that's that's a very short and succinct way of saying a quantum fourier transform is effectively a change of basis dot end of story what does what does all of this mean what does the change of basis mean what is computational and fourier basis let's go through that in a bit of detail but one thing i want to make sure at the end of this lecture is that all of you can repeat quantum fourier transform is effectively a change of basis from computational to fourier bases it's really that simple all right let's talk about the computational basis you've already seen this what is the computational basis let's talk about one qubit let's do an example of a one qubit computational basis states are 0 and 1. that's it it's really not that complicated 0 and one are the computational basis states uh fourier basis is something you've also seen you may just not have have you may you've you just haven't been told that this is the fourier basis uh the fourier basis is actually the plus and the minus states it's really that simple uh so so let's let's this is i'm just telling you a fact here but let me show you the connection between the two so i'd like to start by drawing zero and one on the block sphere so here's a block sphere or at least my impression of a block sphere it's a pretty bad drawing as it is now let's say this is 0 and let's say this is 1. so 0 looks like this and 1 looks like this so where is 0 0 is pointing to the top where is one is pointing to the bottom so you've seen uh the bloch sphere and how these states can be represented what is the what is the fourier basis doing the fourier basis is actually doing something very simple instead of taking you between the two poles up and down it's taking you between the two sides on the equator so you're either here or you're here the other way pointing the other way so i'll write a notation here this will be the first time that you're seeing this the fourier basis version for zero i'll call it zero with a tilde on top the one uh the fourier basis for one i'll call it one with a tilde on top and that's what this looks like so this is this is exactly what uh what doing a quantum fourier transform is so you're going from this notation where you're going between top and bottom to being on the equator and having phases that go around the equator and in fact some of you might have already noticed well wait a minute i know how to make that transformation i know how to go from the computational basis to the fourier basis at least in the picture that i've shown you here it's actually very simple so a one qubits quantum fourier transform that does this any guesses can anyone put what guess you'd make for how to make this qft transfer so how would you go from the top side to the bottom side bingo uh so shrishti you have that exactly right so hadamard gates is how you do a single qubit qft so all of this is to tell you the amount of knowledge you've already gained by going through the material in the first two lectures you may not have put it together but this is exactly what what it means to do a quantum fourier transform to transfer from one basis to another and in particular the way you do that for a single qubit case is to do um exactly what i've shown you in this picture at this point i think we're due for we're due for a break so i think it's important to take a break but before we do i just want to put an image in your minds so i'd like to start sharing my screen now brian if you'd help me i'm going to click the share screen option and i'm going to do this particular screen so i've written a demo here to show you um so i showed you a single qubit qft but i'd like to show you what it looks like when you go to multiple qubits so this is the state 0 0 0 in the computational basis and this is what that same state looks like in the fourier basis you see all the zeros went down to the equator now if we instead look at a different state 0 0 1 what would you expect think about what results you'd expect here 0 0 1 so one of the qubits is flipped in the fourier basis look at what happened so this one was down here it rotated all the other uh to the other side this one was down here it rotated 90 degrees this one did 180 degrees and this one which started at the bottom and therefore started off on one side is now getting a phase only of 45 degrees so 180 degrees 90 degrees 45 degrees this is actually a very curious thing so i could change the state and keep showing you different examples but i think the best way to demonstrate to you the difference between the computational basis and the fourier basis is to show you a picture that we have in the kisket textbook so this is a four qubit case where we're taking you all the way from zero up to two to the power of four minus one so up to fifteen you can see what from zero through 15 look like in the computational basis all you're doing is flipping between zeros and ones right so you're basically doing binary counting in the fourier basis instead what you're doing is rotating on the equatorial plane i'm going to drop this link in the in the chat so that you can take a look uh at exactly this animation but what's important here is for you to see how powerful it is to be able to do this so in the computational basis you only have the freedom of being in the up or down states in this particular case in the fourier basis you can now play with phases on the equatorial plane and this is exactly what it means to do a quantum fourier transform to go from this picture at the very top to this picture at the very bottom so let's take a break now and we'll go through in some detail how exactly the quantum for a transform works 