 so this is the presentation and so i'm going to go through this slideshow in a little bit of a different way than i intended but uh let's go for it anyway um so this lecture is an introduction to quantum error correction and um to justify why we're doing this first i should talk about why we need to do quantum error correction and it's because say if you use uh the the devices that we have uh available uh so you can go to quantum computing.ibm.com and of course um run jobs on real devices and if you do that then you'll find that if you set up as qubit to be zero and then you measure it then it's mostly but not always zero and if you set it to be one and you measure it then it's mostly but not always one so you find that these devices don't actually work exactly the way they should each gate that you do is slightly wrong and the qubits will get perturbed by external forces as an interaction with the environment is what we call this and the measurements that we make sometimes lie sometimes it's a zero and you measure it and it tells you it's a one now this isn't something that's uniquely true for superconducting qubits but the same is also true for all other ways that you might imagine to make a qubit out of some physical system so there's there's other ways of making qubits such as spin qubits topological cubits photonic cubits and all other kinds of things these this is just uh sort of temp um you know random words for you at the moment probably but uh there are many ways that people have tried to make this this this thing that you've been learning about for the past few days to make it in real life um and they use different physical systems to do that and anything that they use it's always going to be a little bit rubbish and there's no way of getting around that we can make it as as good as we can and we can reduce these effects as much as we can but there will always they will always be there to some degree and when you're thinking about running an algorithm like shaw's algorithm on very large numbers the number of gates that you need and the circuit depth that you need to run that is so great that even if you reduce the errors to the to them being effectively happening once one in a million times then if you've got a million things going on then one of them is going to happen and then it's going to mess up your algorithm so there is no way to reduce the noise low enough to get away from the fact that they are always going to be a little bit imperfect um so yeah if we think about the algorithms that you've looked at so far like so if you think about the standard what i would call textbook algorithms like shaw's algorithm grover's algorithm um for factoring in search respectively these assume that qubits are perfect when people are studying uh quantum computing at this sort of computer science level where they're thinking what can one do with qubits how can one make algorithms out of them and it's always done with the idea that these qubits are absolutely perfect they are exactly the two-dimensional quantum systems that you will have learned about in the last few lectures um but if you run these algorithms with the actual physical qubit so qubits that are physically there on a device made out of a physical system then you'll get not so great results because um the algorithms have been designed assuming that they are perfect and they are not quite perfect so this is a graph from the um from the section of grover's algorithm in the textbook where it is searching for these two particular bit strings and it's run on a real device and you find that it does indeed with highest probability find these two particular bit strings um and there's a car going outside at the moment so maybe that's a bit of background noise but with mo mostly it does find these but there is also some probability of says oh hey this is the correct answer some of the time where it's not this is not a correct answer at all and that's entirely because of the effect of imperfections in the gates increasing over the course of the algorithm and this is just on a free qubit variant of grover's algorithm if you scale this up to much larger systems then the effect of the noise is going to at some point overwhelm uh the fact that you can at least in this case see what the right answer should be so this causes us a problem uh the problem is if we want to run algorithms we need um flawless incarnations of the idea of quantum information this these perfect things that really are ex described by the exact mathematics that you've been learning over the past few days uh but what we have is a noisy version of that so we need this flawless incarnation of the idea of quantum information a perfect qubit and we call these logical qubits but what we have are physical qubits so what do we do in this regard well either we can just try and use physical cubits as if they were logical qubits and if it doesn't work then oh well but we could say what works and for that we'll we'll find that not much really works unfortunately um or we can try to use the physical qubits to somehow build a logical cube they're in some ways to make something that is more than the sum of its parts to take many noisy qubits and somehow out of that make a noiseless cubit and that is the idea behind quantum error correction uh so yes quantum error correction is how we do this um and now typically we need many physical qubits per logical cubit we can't just take a physical qubit and wave some sort of magic wand and it and all of its imperfections disappear it becomes the logical cubit that we need in our algorithms instead we typically take many physical qubits per logical cubit and this is an example here this is a grid of 17 qubits nine of them in black and eight of them in this sort of outline circle you don't have to understand what this is at the moment but this is a representation of the the smallest version of a very popular error correction code which provides a little bit of protection so to get a logical qubit which isn't perfect but is a little bit better than the physical cubits that it's made out of you need 17 physical qubits to make that slightly better logical cube and if you want to make an even better logical qubit then you have to use even more cubic physical cubits if you want to make something which is effectively perfect then you might need thousands at least physical cubits per logical cube so the overheads in quantum error correction can be pretty horrible and this is why we don't use error correction in our current devices we just we don't have the overheads if we use error correction we might with our biggest device be able to give you one logical cue build out at the end and uh that's probably going to be underwhelming for most people uh so for the long-term goal to make something that can run grover's algorithm from the short algorithm and everything uh we are working towards being able to do quantum era creation then that is something that we are building up on over time at the moment we're doing proof of principle experiments on error correction but we are getting better and better to to show better and better logical qubits but in terms of actual applications in the near term we we imagine more that we will try and make do and mitigate so we will not try and use logical qubits but we'll use the physical qubits that we have and just try and mitigate errors by less formal techniques than um than we do for quantum equation so this is an overview of why we need quantum error correction uh what we'll do in the rest of this lecture is look in detail at the ideas behind error correction both classical although we won't go into the the real depths of classical error correction theory uh and we'll also of course we'll look at quantum error correction for this we will go through two specific examples of ways how to do quantum error correction one is the repetition code um and the the reason why i want to tell you about the repetition repetition code is it is because it's the simplest quantum mechanic error correction code so i think it's the best example but the bad thing about the repetition code and the reason why that's not the only one i'm going to tell you about is it doesn't actually do everything it needs to do in order to help us build proper logical qubits and so for that we're going to uh look down at the surface code which fixes the issues in the in the repetition code and the surface there are many ways of doing quantum error correction or quote usually called something followed by the word codes but the surface code is um is i would say the the most popular the one that people think is most likely to be used in the end um to do fault on error correction or at least some variant thereof uh in this we will see in both of these codes all of the most important techniques which are relevant for all forms of quantum error correction which are syndrome measurements uh decoding and logical operations and these will mean nothing to you at the moment but the idea of the lecture is at the end they will mean something to you uh so we'll begin by just um looking into what is error correction as a whole what is even the concept of error correction uh and for that we can think of a classical example in fact we can think of a very um very down-to-earth example of people talking to each other so say you're talking on the phone someone asks you a question you need to answer that question with a bit of information you need to answer that question in binary so you could say zero or one if you were a computer but usually when humans talk in binary they say yes or no so you need to answer a question with yes or no maybe you're being asked do you want pineapple on your pizza yes or no and there's two important things now to consider how likely it is that you will be misheard so maybe it's a perfect line there's no flaws in the in the line at all you know that everything you say will be heard in absolute detail so in that case if you uh if you don't want pineapple on your pizza you can just say no and you'll know that they have understood that um but maybe it's a noisy line and if you say no they're not really going to hear they might think what was that yes i'll put pineapple on um so what is the probability that you're going to be misunderstood and also how much do you care about being misunderstood because there's there's no way that everything can be perfect this is just a fact of life so there's always some probability that you're going to be misunderstood like one one in a trillion billion chance that aliens are going to intercept your message and just flip it to be annoying um so there's always going to be some probability something's going to go wrong and you can think what is the what how much do you care so maybe you don't really care whether you have pineapple or not this is not an issue that affects you you know that you know that some people get very passionate but you particularly don't care so then this would be uh quite low but if you have very strong opinions on this issue then this would be very high and then once you have these numbers uh you can think well if the probability of getting misunderstood is very much less than the uh the acceptable probability so uh the so um it's much more it's much less likely to be misunderstood than than the limit that you care about then you don't really need to worry you'll just say yes or no whatever but if you really want to get your message across then you will have to do something rather than just saying yes or no in order to ensure that your message really is understood despite the fact that the line that you're using is too noisy and what you would probably do without even thinking is repeat yourself so if you really wanted pineapple on your pizza you would say yes yes yes yes yes yes yes i couldn't be yes of course and once a person has heard that and even if there's some interruptions in that signal it's pretty obvious you're saying yes and if you say no no no no no no no no why are you even asking me that then um it's pretty obvious that you're saying no uh so adding in more information repeating it many times ensuring that there is some redundancy is the way of encoding our message it's taking our message and expanding it to something bigger such that it becomes tolerant of small forms and in this case it doesn't matter if a few of those words that you're saying get get discarded if they just turn into noise or if some ai misidentifies them and turns them into the other thing or something it doesn't matter your message is still getting through just because the way you have encoded it in repeating it um has uh has made it more tolerant to small faults uh then so that is the encoding step you are taking your information a yes or no and you are encoding it somehow and your yes becomes yes yes yes yes yes your no becomes no no no no no but at the end the receiver has to decode the message now in this case it's fairly easy because uh your message is just many copies of exactly what you want to say in error correction sometimes the way we encode it is something more abstract so if you receive an encoded message it's like receiving an encrypted message it makes no sense if you don't know how to unpack it so it it can be that sometimes we encode a message in that sort of form in order to make it more robust against noise but in this case it's kind of easy what you could do is is majority voting so if the receiver received a number of yeses and knows then if they receive more yeses than those then they'll probably think well that that sounds like a yes let me get out the pineapple in this case a misunderstanding will only happen when the majority of the copies are flipped which is possible but it's unlikely so if you say yes instead of yes you say yes yes yes and there's a some probability of um one over ten that one of those words gets messed up then the probability that one of those words gets messed up is on the order of one over ten the probability that two of those words gets messed up is on the order of one of one in a hundred so on so most of the time your yes will be yes yes yes on the order of one over ten times your yes will be um well yes yes no and also for yes no yes and no yes yes um so sometimes that'll happen but that's okay people understand from the majority that you're saying yes but about 100 times you'll get something like uh two of those yeses perhaps being flipped to a no which is quite a weird error model to be honest when you're talking on a call your words don't usually get turned into other words but let's assume it's a uh about 100 there's a chance that um even though you say yes yes yes because there's been two error events it sounds like yes no no and the person who is um who is uh decoding this will think that you said no even though you said yes so that the probability of something being incorrect and the probability that that will happen is the probability that at least um the over two errors happen so actually there's an error in this uh equation but this should this is the probability that something goes wrong um i'm not sure if actually you can see me highlighting this because it's only capturing chrome um but this is the problem you can see it okay so this is the probability that uh the person trying to decode your message um decodes it incorrectly and it's the sum over all of the possible ways that they can decode it into in incorrectly so it should be the sum from d over two which is half of d is the number of times you repeat that d over two is half the number of times you repeat and then sum that to uh d so it's all of different ways that you can have um half or more of the errors flip and the probability of this scales well it's the probability that a flip happens to the power of the number of times you might get a flip and there's binomial coefficients and all that but really it's it just scales with the kind of like the probability that a flip happens to the power of the minimum number of flips which is problematic which is half so um the the probability of something going wrong it when you repeat three times it scales the sort of p squared because p is the probability that something is going to go wrong with each of your yeses or no's and it's squared because you need to do it two to flip two times to flip the majority for free uh but um if you repeated it five times you'll be p to the three if you repeated it um 101 times it would be p to the 50. so the probability that the majority gets flipped decreases uh exponentially as you increase the number of repetitions so as certain as you want to be that you do or do not get pizza uh sorry pineapple on your pizza you can just make sure that happens uh by repeating yourself enough times and i think this is something that intuitively we kind of know anyway if we really don't want it we would be saying no no no no no no and i don't know why i picked this pizza example randomly because i don't have strong opinions on pineapple on pizza i know maybe perhaps that's gonna annoy some people but there you go okay so this is a simple example and it in no way involved any quantum yet but it has the very basics of quantum error of quantum error correction or error correction any kind of error creation which are these steps of encoding and decoding so we have some input so some information that we want to protect and then we put that through a process of encoding we transform it in a way usually by making it bigger so it covers more information more bits or more qubits and we transform it in a way that makes it easier to protect and then a process comes along which causes errors so these are perturbations of the encoded message so after that we don't have exactly the encoded message that we started off with it has been messed up a bit and then we have the decoding process which is basically solving a puzzle we are given this messed up encoded information and we're told some errors happen but we don't know where try and figure out the clues of where the errors might have happened to undo them and deduce the original message so um that is basically the puzzle at the heart of quantum error creation in fact i made it into a puzzle game a few years ago called deca doe cooper which i think might even still be on the app store but it's not something that i am really too much with anymore but it might be fun as a game if you want to play something okay so that is well this description is actually more geared towards error correction in telecommunication where you want to send a message so you encode it errors happen along the way you decode it you get the message done this is not really the kind of error correction that is important for us because we are doing uh computation and in computation uh we want to do error correction which encodes our information at the beginning and then we do a computation on that encoded information we keep it encoded so that throughout our computation any errors that happen we can fix them when we do operations in our computation any errors that happen in those operations any areas that we introduce just by the fact that we are doing an algorithm we can fix them and then at the end we do decoding to get an outcome although actually it's not exactly that simple because uh we probably because leaving everything to the end in terms of decoding is not a good idea so what we'll really be thinking of doing is having our input which is just our all zero state probably then we encode it in some way and then it keeps on going through a process of being maybe we're doing an operation and that's causing noise or maybe a qubit is just idle for a while and it's picking up noise from the environment whatever's happening noise affects it and then we need to fix that noise so we decode and we re-encode more noise happens decode re-encode more noise happens decode re-encode for as long as it needs for us to do our computation and then we get an output although here i said we decode and then we re-encode that is not actually fully true because if we decode then we get back down to an unencoded state which is we have encoded exactly because we want to protect ourselves from the effects of errors so once we decode then we're back to being vulnerable again we don't want to be in that state so we don't want to we want to do some decoding to fix things a bit but without actually going back to our unencoded state now let's give me give you an example so that sounds less abstract so let's just think of a single bit encoded using the repetition codes so what we could have here is that we have either a zero or a one so and if we had a zero then we would in the repetition code repeat this three times to get zero zero zero and if we had a one we would repeat it three times to get one one one and then let's say and we go through some noisy process we're not gonna try and do an operation here we're just going to consider the idea that the environment comes in and causes a bit to flip and let's say that it's the last bit that flips just as an example so our zero zero zero in that case would become zero zero one because the last bit is flipped and or if we had a if we had an encoded one our one one one would become one one zero so then we can look at that and we we don't even need to decode that we can look at that and think well there's two zeros and a one that one is out of place um probably it should be a zero and then we can identify that because it is um it is uh not the same as the majority that it's probably because of the majority voting in this code the error and similarly if we found one one zero we'd see similarly that this one is out of place so we identify that as a problem and then we can fix the error just by flipping that bit so we can flip the last bit and then whether whether we encode a 0 or a 1 it fixes it so we're going to do a process of trying to find while it's still encoded we're going to do a process of trying to find hints about what errors have happened so that we can keep on cleaning up our encoding while we're doing a computation okay so this particular method with the repetition code would be fine for bits but it's not so great for qubits in fact it's not even great for bits because it's kind of not agree there there are certain ways in which the repetition code even for bits is not a great code but that's mostly due to um overheads uh we won't go into that though because that's all classical error correction uh but we will go into why it's not great for qubits uh so for example suppose we did not just want to have a qubit in state zero or a qubit and state 1 but we wanted to have a qubit in a superposition state some a0 plus b1 then when we go through this process what would happen okay so instead of just a zero or a one becoming zero zero zero or one one one we would have a zero plus b one becoming a zero zero zero plus b one one one so i i haven't said anything about what circuit we would use to do that and you can think about what circuit you could use to do that yourselves if you want but we would have some circuit which which does that encoding it does that transformation okay then something happens an error happens and again we take the example of a bit flip on the the last qubit then we would get a superposition of a 0 0 1 plus b 1 1 0. okay then we go to the next step we look at our qubits we see what their values are to see if everything looks okay so we measure them all and that means that this superposition collapses to either being 0 0 1 or being 1 1 0. and then we look at that and we see okay this one's out of place whichever it is uh we fix it and we go round and round and round uh but the trouble is at that point of measuring the collapse happened we had a superposition but as soon as we looked at our qubits we ruined that superposition so if we're actually doing a computation which requires that superposition the fact that we've uh which we're not really seeing in this um because we've not got any operations in this particular example we can't see that here but in general we might have some oper we will be doing a computation that computation would need the superposition to be there the fact that we have destroyed it by inserting some some measurements to check up on what's going on is a problem uh from the quantum perspective it is a problem so to protect against one bad thing which is our cubits flipping when we don't want them to we actually caused another bad thing which is the collapse of the superposition okay um yeah so i just thought i'd stop here and ask if there's any questions so far yeah we've got a few questions that i think are pretty relevant to what we're talking about right now one and you may get to this later but since errors appear due to hardware won't the error correction algorithms be different for different hardwares um well that's a good question um now over the years we working on error correction have been pretty much just as abstract in our thinking as people who work on algorithms ex the only difference is that they assume that there's no errors and we assume that there is and the errors that we assume are usually nice toy models of easy to understand algorithms i always think of it as a little gremlin sitting next to every qubit flipping flipping uh or rolling a dice or something deciding what to do and uh if it comes up the wrong value hitting the qubit with a with an x or y or a z this is the sort of error model that we've traditionally looked at and for that it's well at that level it's the same whether you think of it in terms of spin keywords or or superconducting qubits or whatever uh other than that i think they will need error correction will need to be tailored to the hardware to some degree but um also the way error correction works is it's it's very it's kind of agnostic as to the errors as long as the errors are local so they act on single q it acts on single qubits or small um groups of qubits then the assumptions of arrow correction will work but if you want the best performance you will have to tailor it to the device to some degree awesome and then one more question for now aside from quantum error correction are statistical methods used to normalize results such as reducing columns in a histogram based on the distance to the largest column or at least calculating the difference yeah so things like that would be called error mitigation techniques and there is if you look in the kisket textbook there is also a section on on some of the error mitigation techniques we have there such as like you could imagine if you've got a a single qubit you could prepare it in the zero state and then run many shots to see what the histogram looks like and so it'll be lots of zeros and a few ones and then you know well that's okay that's what a that's what a zero looks like in terms of the histogram and then you do the same thing for one they'll see what a one looks like and then you do the same thing for anything arbitrary and you can find kind of look at the histogram you get from that and think well given that i know what a zero histogram looks like and given i know what a one histogram looks like what can i deduce about what this histogram should have looked like so uh you can do there's all kinds of error mitigation techniques that we can we know already and i'm sure we'll develop more because this is this is more relevant to the next decade than quantum era correction arguably awesome i'll give it back to you to continue with your lecture thank you um okay so we have a problem and our problem is that we need we couldn't have identified this error without looking at our qubits and working out um where the error was but looking at our qubits destroyed our superposition so how do i how do we look at our qubits without looking at our cubits how do we measure without measuring well we just have to be careful about what we measure we are put there's not no law against us measuring in some form there's no law against us extracting information about the errors but we just must not extract information that causes the superposition to collapse if we ask the qubit are you 0 or 1 it has no choice but to choose and collapse a superposition but if we if we ask a group of qubits some other question then it might not cause all of the qubits to collapse into particular superpositions so let's go into this in a little more detail um so yeah we do need to measure but we have to avoid learning about the encoded information so let's look and look at an example where we have here um a repetition code with one two three four five six seven eight nine ten eleven repetitions so whether we if we encoded a zero it would be this series of eleven zeros if we encoded a one it would be this series of eleven ones now let's assume that errors happen on a particular set of qubits so you can see the ones that are ones um affecting the zero um if that makes any sense these ones that are flipped in the line that should be all zeros the ones that are flipped to ones that's where the errors have happened and if you look on the line that should be all ones i've i've made it so errors happen in exactly the same place there um so that uh so we're complete we're having the same errors compared across whether they're encoded as a zero or as a one and obviously if we were to look at these values we would see that those ones where the error has affected it are in the uh but are not the majority so the majority voting would disagree with them and say that they're probably the ones that are the errors um but let's not do that let's instead some go along and look at each pair of qubits along the line or bit value sorry along the line and ask are they the same or different now i think i asked this before but actually i'll ask again can you actually can you see my pointer or can you only see when i highlight things we can see your mouse and we can see when you highlight things okay the fact that you can see my mouse makes things a lot a lot easier uh so if you uh if you look at a pair of qubits or sorry bit if you look at a pair of bit values uh this is one that hasn't had an error this is one that has had an error and you'll see that they are different so if you compare the values of these two things then you'll find that then they are different so actually i should say if you compare the values when there has been no error and these are the same these are the same these are the same these are the same same same same same same same and similarly even though they're a different value over here still these are the same value as each other these are the same as each other and the same and the same and the same so a signature of everything being good is that if you look at these pairs of values you'll find that they always agree with each other and of course they should this is the repetition code you're repeating things they should agree with each other and then if we see a single error in the middle of nowhere here we find that this is different from both of its neighbors and so the fact that it is different from both of its neighbors well seeing any of these two values being different is a signature that something there is an error somewhere and the fact that it's different from both of its neighbors is a fairly strong indication or not conclusive that this is probably the one that is in the wrong similarly we can find that these are different but these are the same and these are the same and these are different and the same same same different different same so knowing that there's only two values we can we can form these into two groups we have this one which is in one group and then this one is in another group because it's a different value since these are the same as this value that there's they're also in the second group and since the this one is different from that one we know that we must have gone back to the first group so this these all belong to the first group this is again in the second group these are back to the first group so even by just knowing whether these values are the same or different without knowing what the values actually are we can still do majority voting we can still split it into two groups and find that one is in the majority one is in the minority and assume that the majority are the ones that haven't had the error and correct accordingly um so this and the the exact same process would have worked exactly the same if we had encoded a one uh because it doesn't care whether we've encoded a zero or a one because we are just looking at whether values are the same or different we don't we're not looking at what those values are we're just looking they're relative values between each other so um the insight here is that we can still do majority voting without actually knowing what the bit values are or and we do that not by looking at the bit values because that would of course have told us what the bit values are but by instead only extracting the information about whether they're the same or different so you bring your two bits together and you don't look at them and say you say i i don't know what you are i just want to know are you to say more different and then they'd say you say oh thank you and then you go along querying all of these and with that information you would be able to do the error correction without having to without knowing any of these values and this would mean that even if you've got a superposition of lots of zeros and lots of ones which became a superposition of this thing and that thing when you um when you had errors then when you ask a pair of qubits are they the same or different then the the outcome does not disturb the superposition it doesn't care about the fact that there's a superposition it will tell you exactly the same results as if you were just done a zero or a one um so this is the information we need to extract we need to do this thing where we're going to take two qubits and ask in the zero one basis are you to say more different and extract that one bit of information same or different without actually looking at what they are okay so how do we do that um so uh i think this is probably the point where i would probably pick up my pen and start doing stuff in a in a written way but because i'm doing it as a pdf on a on a browser probably i'll have to stick with not doing that but i think it should all be pretty much the same anyway my handwriting is atrocious and that's why i do things on powerpoints mostly um so you're probably getting away lucky without having to look at that um okay so the way that we can do this with this task which is to take a pair of qubits and see if they're the same or different without otherwise extracting any information um we can do this by taking so an extra cubit so for every pair that we want to ask this question we take one extra cubic so we have an example here where we have three repetitions uh these are the colored values here and then we have two extra qubits which we usually call ancillars which are the gray values here so if we want to know whether these two are the same or different then what we do is we use a couple of controlled not gates so the first controlled not gate is controlled on one of the qubits we want to compare and targeted on the extra cubic the ancillar the other is controlled on the other cubit we want to compare when we're comparing this pair and targeted again on the same ancillar and then what we do is we measure the ancillar and we get a result of either zero or one so what is the relevance of that result well let's see let's consider the case where these are both zero which is actually what we see here in this case well a controlled not controlled on a zero does nothing so this does nothing this one is also controlled on the zero so it also does nothing so our ancillary which was initially zero is still zero at the end and we meant when we measure it it tells us zero um so in the case where they are both zero we get a zero out here now if they were both one if this was a one and that was a one then what would happen okay so this is still initially zero it goes along it meets this controlled knot what does this control not do to it well a controlled knot uh we can tell a story that it looks at the control and looks at whether it's a zero or a one if it's zero it does nothing so that's exactly what we just talked about if there is a one here however it will flip it will do an x it will flip this bit it will flip this zero into a one so in the in the case that we are comparing two ones over here then this ancillar gets flipped from zero to one after this first c naught but by the exact same effect by the second c naught it gets flipped again back to zero so in the case that these two are both one we have that uh we measure a zero at the end so whether they're both zero or they're both one this measurement does not know does not care all it knows is if they are the same it gives a zero now what about when it gives a one so we see this example at the bottom here um so if you have if they are different so if this is a zero as it is and this is a one then this controlled knot control on the zero will do nothing the control dot control on the one will flip the ancilla so the ancillar gets flipped exactly one time flipping from zero to one and so the answer you get out the end is one and it doesn't matter if it was zero one or one zero that you're comparing in either case where they're different um you get a one at the end so by introducing this extra qubit and by doing these controlled knots we have found a way to not measure the qubits themselves not get any information about what their value is except that we are comparing whether they're the same or different we we want to know what you could be zero you could be so we take a pair and you we say well you could be zero zero or you could be one one or you could be some superposition of that we don't care we just want to distinguish that from the case where you're zero one or your one zero or your some superposition of that can you distinguish those two cases of you being some sort of same or some sort of different and by measuring the ancillar that is exactly the information you get zero tells you that they're the same one tells you that they're different and by taking that information we can get some information about what might have happened so by saying that these two are the same and these two are different uh by combining that information we can see well okay that means that this qubit is the odds one out so let's flip it to uh to undo the errors that have happened okay so um we're not quite at the end of the repetition code but we are at the top of the hour so maybe it is a good time to take a break until let's say perhaps um a quarter past whatever the hour is in your time zone or i think in india you're you're off by half an hour so 15 minutes from now is a way of being fine for everyone's time 