 all right I see a couple people in the audience who've already seen a good number of these slides and in fact one in the audience who I stole a number of these slides from so yeah in the meantime if you've seen these slides or in there and I know a little bit later they're gonna get a little dry in places I suggest you go to the Microsoft blog on Monday we recently put out a a note on some work that we've been doing recently with Case Western Reserve University on quantum inspired algorithms in particular using quantum inspired algorithms to improve magnetic residents fingerprinting okay and so we can produce MRI scans with higher resolution and a fraction of the time that they now run now obviously this is research and so by the time it gets to market maybe some years to come but this really has the up an opportunity to change the way we do healthcare diagnosis in the future okay also on the blog you'll find from a couple weeks ago a collaboration with willows Towers Watson a major insurance firm also using quantum inspired algorithms to improve the speed and efficiency of risk modeling which of course is with one of the major components and insurance and so quantum inspired algorithms mother real and they're here today and so my name is Brad Lackey I'm a principal researcher I will be your substitute lecturer for this talk matthias Troyer was really hoping to give this himself but unfortunately is out of the country today so I'll be covering this I'm gonna talk about chemistry but on a day to day basis I work in quantum inspired optimization okay so I think a little since questions came up I'll take a little bit of time at the beginning to talk about this rather than at the end there are multiple modal modes of quantum computing or million bottles of quantum computing is amour traditional way of saying it what I'm going to talk about here is really these chemistry applications are based on the gate model approach which is really the focus of this entire workshop but there are other models so for instance if you study cryptography some popular cryptographic protocols such as multi computation or blind computation there are quantum versions of that but they're not built on the gate model like we're gonna see today but they're built on another model of computation called measurement based quantum computation okay in that setting you don't have a circuit like we're going to see a lot you have what's called a cluster state or just a large entangled state and you make small measurements on pieces of it and adaptively tune those to push the computation in the direction you want to go and so it looks very different another model is adiabatic quantum computing which is really what I specialize in also a universal model this is based on old ideas from physics the adiabatic theorem which came around in the 1920s so it's been around for a hundred years in this case you prepare a system which you sort of understand everything about so it's easy to construct and then slowly transform that system into one whose lowest energy configuration solves the problem of interest and the adiabatic theorem says as long as this transformation moves slowly enough the system will stay in that lowest energy configuration and so at the end you've solved the problem okay and in many ways adiabatic quantum computing isn't as popular today because it's been around for a hundred years and so there's a huge amount of machinery to simulate this type of physics okay and so we have very very good classical algorithms we can run on computers today that will simulate adiabatic evolution ok so if I can take an adiabatic quantum algorithm and these are optimization algorithms are really easy to cast in the adiabatic model then we can simulate these on computers we have today and so we're actually are running quantum algorithms but we're running simulations of what would happen sometimes they're not perfect simulations they're analogous simulations of what would happen and solving problems using these algorithms and so that often goes to the name of quantum inspired optimization ok and so that's if you read through our blog post you'll see we have a lot of partnerships almost all of our corporate partnerships are based on that optimization is a big deal in industry huge deal in industry ok and so any type of speedups solving highly non convex large optimization problems are gonna have real applications okay but that's that's something completely different because adiabatic adiabatic optimization adiabatic quantum computing is is a hard way to think about computing we've sort of grown up with computers uh in sort of von Neumann architecture 'z that we're familiar with today where you have a register and you apply some gates to a register and that makes sense to us intuitively and so to develop algorithms is much easier since we have that intuition to do it even though developing quantum algorithms itself is a very very hard task developing a model that's completely alien to us is even harder ok so there's really not a lot of adiabatic quantum algorithms out there because they're very very challenging to come up with okay so so instead we're going to focus on some gate model stuff and in particular I'm going to talk about a collaboration that we had with Pacific Northwest National Labs and integrating their quantum chemistry package in W chem into using the Q take what a development kit the qdk and a non Calmes little big it going so so quantum programming well that's what it's all about as far as I'm concerned alright so we want to develop algorithms but we want to run those algorithms and so to run these algorithms we need a programming language to work with and here I'm going to talk about Q sharp that being the the the topic of the day and so really what I'll focus on today is using a implementation of an algorithm and Q sharp to count the number of gates and qubits that are necessary to run the algorithm to get an understanding of when quantum computers come around how long is this really going to take ok so initial estimates of of a classical algorithm just make it completely intractable but if you take the naive quantum algorithm just write it out and start counting the number of gates those are huge numbers they would just make it totally impossible even for quantum computers but as we refactor these algorithms we find better ways of implementing them we find better tricks for computing pieces of them we reduce the the resource costs we could eventually get these much more efficient implementations which make these things tractable when sufficiently large quantum computers come around okay so resource estimation is a good way of looking forward even though we're not necessarily going to run these on quantum computers a day to estimate what the impact of these algorithms will be on industrial workflows in ten years or fifteen years or whatever timeframe were really talking about okay so the the problem that keeps me awake at night is this one I've been debugging quantum algorithms I have enough time debugging classical algorithms so so yeah I mean I Christmas chuckling because this is his slide and so he printed off this this output but this is exactly what I see whenever I write code and run it is is just this complete mess and so quantum algorithms this is a real challenge debuggers as we understand them today use sort of the same basic tools right you set a breakpoint you look in there you see what state is and is that what you expected well in quantum algorithms you can't do that if you examine the state you've destroyed the coherence the entanglement all of the nice quantum properties of that state that you want to actually complete the algorithm so you may see some statistics at this point but that might not give you a clue about where this where the where the state is moving to right so the concept of using breakpoints and debugging in that fashion just isn't going to work right well what else is there yeah all right so so I lose a little bit I'll just a lot of sleep over that but what I'm going to talk about today is is actually bringing applications today using using quantum algorithms ok so so this is really what I do on a day to day basis because well debugging stuff is too hard all right so so we've already seen the notion of a stack indeed we're really today we're going to talk about I guess what's most sort of hovering at the top of that top squiggly arrow there okay I'm going to talk about chemistry but we're gonna have a lot of other algorithms that we talked about this afternoon and really we're talking how do we implement them how do we create a code that would push them down into the control software and I guess below that we're really not going to discuss that too much that's some complicated engineering and and that's that's really far away from from what I do and so I'm afraid I can't really comment on that but what sort of applications can we see for for for quantum algorithms so quantum chemistry looks particularly attractive because of these numbers along the bottom when we run these resource counts we think that yes we can get real payoff in the hundreds of 200 qubit range okay so so putting some numbers forward the we mention of the IBM Q which is there the quantum machine that they have in New York the original one that was on the web had five cubits the new one has 49 in a kind of interesting topology I don't know exactly what the how big the next generation is going to be but we're already starting to see this this become realistic a couple years ago Google promised the Bristlecone ship which was to have 72 qubits in a sort of grid like topology but we haven't seen that appear yet ion Q over in Maryland is promising 128 qubits those are ions I don't know how they're gonna fit that into a linear trap but you know Kris Munroe is a smart guy so these numbers don't look so outrageous now of course those are going to be very very noisy computers okay and so so even though the sizes of them were in the ranges we're talking about the length of the program you can run is going to be very very short before the noise and decoherence overruns it okay and so so yes these numbers say all right yes we could talk about small quantum computers we can think about these but we also have to have long run times and that's where we have to worry now do we use this error correction on these noisy things or do attempt to build a topological quantum computer say when the noise is small enough that we might be able to run these without the need for additional error correction ok on the other hand things like Shor's algorithm are in the thousands of qubits and so that sort of out of range material sciences also grows pretty big machine learning of course is a huge promise but there's a lot of uncertainties in the applications to machine learning there's a little bit of a war going on there every time we get a new quantum algorithm that improves machine learning somebody comes and D quantizes it and says well here's the classical algorithm that will do just as good all right so there's been a lot of back and forth on that for the past few years and so I'm not sure where that's gonna finally end up all right so let me let me just recapture what I said there in the near term we have these these machines that are coming out now most of them are based on superconducting qubits the the one exception the one at ion cubing ion trap topological things are still I mean I don't know because I don't work the hardware but there's they're not here yet the length of the program because probably talking about you know a thousand one thousand what well let's say it may be a thousand cycles or the analog of what a cycle would be the computer so a thousand time steps to get your algorithm done and that's not nearly enough to do any significant size size algorithm on the other hand if we want over here we want to have these really long term programs and we can run millions and or even billions of cycles which are going to be necessary then we're going to need to do something to control the air hey either get the air correction directly in the the physical qubit itself or build air correction on top of it okay so so what I'm going to talk about really is quantum phase estimation that's the underlying algorithm that's really driving a lot of these these chemistry applications and it belongs to this category over here it's unfortunately a relative relatively deep algorithm it takes a long time to run even though we might not require as many qubits okay so so the other words we're not there yet okay but you know five to five years ten years we might be running up against the boundaries of what we can actually do and of course at that point then we want to use it all right so so here's an example of something that you might actually want to see come out of one of these simulations theory has a predicted curve which relates the bond length and in a water sorry a hydrogen molecule here with the associated energy and we'd like to simulate around this low point because that's going to be where we find the the system at equilibrium okay so the methodology for this uses the same methodology we've used for these sort of things for well I mean forever you somehow get the theory out of some research paper you know you go up to the whiteboard and you work out what it is in terms of the simulation that you can do and then you cut and paste it into your simulator you know being in MATLAB or now in NQ sharp and an outcome some plots which hopefully match pretty well with the theory that's been developed over the years okay so so very very intensive and not scalable to to large things okay so so what we did is team up with Pacific Northwest National Labs which have the product NW chem which is a high power quantum chemistry tool this is really what the what they work with that's this is their specialty and integrate all of the wonderful modeling that they have going on in that tool and bring it into the qkd so that we can simulate it directly and not have to go through the human intensive step of converting all of the various pieces to the right form that we can then put into simulators okay and so so here it's basically a four step process I'll go through a little bit of these broome bridge is the name of the protocol this doesn't really have anything to do with what I'm talking about today but it's such a nice picture that I just had to include this is the the the this is broom bridge I guess is what it is it's over the the river over a river in Dublin and the link if you will you'd have to probably look a little bit for this is that this is the bridge where Sir Rowan Hamilton famously invented the rules for the Kearney uns okay and so what does that have to do with quantum chemistry well you know we use Hamiltonians and the names Hamilton so maybe a little bit tenuous there but but it's a great picture so so I laughs a great story but that gives us a format for linking sort of gluing these two pieces of sophisticated software together we can get all of the appropriate chemical information that we'd like using the modelling tools and in W cam and here we see examples of this and then this can be brought directly into appropriate tools to transform it into a cue sharp simulator for the phase estimation or and and other other type algorithms for estimating energy levels both ground state and excited state energies okay so so this is a little bit you know flashing code up there's no fun unfortunately I'm going to get a little bit more of that but we're gonna see a lot more of it as the day goes on here's really what's what's at stage the workflow here is about four steps and this is characteristic of just about any real-world application you can imagine okay you have some method of taking something of interest and then mapping it into a simple algorithm that you can run on a computer right now every stage of that mapping typically has dozens of options you can choose from and so finding a method which will actually get your result requires sort of searching over all of these things okay and and of course you know that's that's really where we're in computer ages really brought us forward and in technologies because we could automatically do those things you know if I wanted to find a fast algorithm for computing you know something in the in the 19th century I was you know digging through long tables and stuff like that and that was just no fun okay but now we can go through all kinds of different options test them all out and and and just find what's the best and that is the method for going from this 3,000 year estimate to run this quantum algorithm down to this one day estimate during this quantum algorithm it's how do we choose the best of these to make an efficient implementation okay so I'm gonna briefly run through these just you know if you're interested in in quantum chemistry and simulation of these things all this this work that we've done on the the chemistry library within the qdk has all of these little steps well maybe I shouldn't say all these little steps it has at least one of the major choices for each of the steps in the reduction okay so and and I'm gonna flash up this pretty quickly because I want to get to the get to the point but the the docs actually explain everything that's going on and there's sample code available and so if you want to construct the Hamiltonian or and then use like Jordan or video representation to convert it into some qubits then the explanation of all that is there and then the the utilities for doing this has already been prepared deriving a qubit Hamiltonian again everything's in there if you go on to the docs you can read about this it's very interesting what I'd like to spend time on here is discussing the simulation algorithms because there's a lot of choices that can happen we'd like to implement Hamiltonian dynamics which we can see in this slide going on right here maybe the font is not an ideal choice but so we'd like to implement unitary dynamics given by a Hamiltonian and the Hamiltonian is given by the sum of sparse Hamiltonians are simple to apply hamiltonians and so there's a mechanism for doing that and here we're illustrating trotter Suzuki but there are many many more qubit ization is another one Taylor series is a third and so at each of those have numerous parameters and so that how do we how do we find the right thing to do and and run these okay before I talk more about that let me just illustrate what the output looks like okay so here's the actual workflow what we start with is our R in W CEM box as far as I'm concerned which has all of the quantum chemistry built into it that people can utilize I'm not a quantum chemist myself and so that really is a black box for me somebody says we're really interested in say nitrogen aise which is the enzyme that has the fomo co molecule inside of it and so that might be modeled up here under this bio models biomolecules data that sends in an appropriate database and that can be manipulated and and then exported in this brew bridge file which then can go through the cue sharp simulator we go through a variety of choices on how we select our options and then target in this case a resource estimator to say is that option really a good one for simulating this complex molecule and so how long would that take and and then go back and forth so what we'd like to see is something that looks like this so here lithium hydride simulation we like to understand these the ground state and and excited state curves of how they of their bond length because at the lowest one that's going to be where we have our are stable or stable States okay and so and so here we're just seeing some outputs of some simulators you have the ground state we simulate the first excited state there's some outliers as well as one would expect but one can then put all this together and get a good estimates get good empirical plots of the spectrum of this molecule using these tools this is a very small one and so the the theory plots can be constructed directly and so it's a nice a nice example home-ice chemistry experiment here it's it's what so much the ones we're looking at here so for instance this is just simulating the ground state and a couple of things didn't quite come out right here where let me let me go up and erase the the front one here and here we're simulating the first excited state and so you can see the outputs of the simulator tracking the energy levels for the first excited state so we built that in I don't understand why it why it's producing things way up in the in the in nowhere land that's kind of curious yeah you got those yep it'll wrap around okay yep and then pop it way up there yep great thanks okay so yeah so ultimately what we're looking for is a plot like this where we can see all of the spectral lines of the molecule alright so let's look a little bit of this resource estimation there's a variety of options we have for hamiltonian simulation and each of them have different requirements in terms of the number of qubits that are required now as we expect we're gonna have limited number of qubits so that's a major concern by the training off that we also have the number of gates that are required which is the length of the program that's going to run and so we'd like that to be short as well well as expected those are fighting against each other and so there's a variety of choices we might want to make but in terms of actually doing it all of this is already built into the qdk and so it's relatively straightforward we're seeing well pretty much all of the code right here now you know here we have this thing called Trotter step Oracle which of course requires a great deal of work to build and go on how I imagine has done a great deal of work in making this making this practical but but really once it's built into the the Oracle once it's built into the qtk itself it's relatively straightforward to use okay and so and here we can just estimate now the cost of Trotter step Oracle's based on some ideas you know what do we think would be good how many what order do we want do we want to do a first-order approximation like linear approximation we wanted quadratic approximations etc and what's the size of the steps we'd like to make and we can tune those to see what see what comes out of it okay so I guess this this slide is a little bit older than I was expecting although I hope it's still up to date I in fact want to get the Python one in here but I didn't so this is the the c-sharp wrapper that goes around that that Q sharp piece of code you'll probably see a lot more of this this afternoon and really this little four four line statement right there is the in some sense the driver which is running the quantum computer if you will now here we're just doing a gate count simulator but but this is telling us to run this Trotter step algorithm to simulate a Hamiltonian and three of the four lines are about getting timings okay and then the bottom areas here this is just getting statistics that we can then print off to the screen and I'll show the picture of that in a moment or at least a graphic that comes out of this but really there's not a lot to running the code itself takes a little bit of getting used to but then you can create very very efficient code bases that automates this task really really well all right so this is just the the Trotter case and so here is the output that comes out of that there's a variety of choices we talked about the the Trotter one here cubed ization is another one then there's an optimized qubit ization which attempts to reduce I believe in this case it's reducing the the number of rotations I believe it is okay well be that as it may you get these outputs from the simulator for all kinds of different molecules it's a little bit time-consuming to do it but we actually can count the number of gates that are required to do each of these okay so for instance on this ferric sulfide I'm not sure where it is in the table here does not appear to be there but it's on the chart that's will appear later there's a variety of choices we can take the Trotter for instance gives us a certain number of rotations and a certain number of see not gates in some sense that's relevant to the to the depth of the circuit there's a more computation that has to be done to get that if we want to do error corrected things which would be appropriate for the modern modern superconducting based computers the T count t gates are the stumbling block and so we'd want to count those and the optimized one it's reduced the number of non T rotations to something that's manageable like 18 but still we have what 69 million T gates which tells us I mean that's really gonna be the quantifier of how hard is this gonna be to run okay and then with some assumptions this sort of guides the statement that oh we can do this in a day with an appropriate T state factories that have been lined up in the right way and that's complex but but really all I want to want to do here is say that we have all these different options that can be automated and then we can find efficient implementations by searching through these hyper parameters and selecting the best okay so just a quick overview of what all of these do minimizes T count that's the optimized one over there and so you know we can choose which are the best possible and the the answer is well of course it's going to vary on what you actually want to do and so the choice for a small molecule might not be the same as the choice for a larger molecule it'll vary from one to the other and so one has this now workflow that's been designed that can optimize this for all of the possible choices that you might be interested in okay so let me let me call up a quick picture here okay so here is the lamoco molecule here as part of the nitrogen a is enzyme okay it's actually living living out here so so what we see is a along the top of these charts these these top lines are these are white board results right we get up on the white board we say all right well here's how the algorithm work let me think about how I would want to implement it and prove some upper bounds on its runtime okay because I can get an implementation that I that takes only this long according to these asymptotics and heuristics and one might use these get better and better as time goes on but then we can then we can run these counts and the simulators at least up to the size that our simulators will run on to to validate where the real runtimes are for these types of molecules all right so getting to the end here I stole a slide from our marketing group because it has sort of nice pictures on it and hopefully this is very motivational so so our goal again is to to be over here where we can model these large molecules with a large number of atoms classical computing is just not going to be tractable now you cannot see that curve on there at all okay there is a very dark grey curve running up here indeed these are all exponential algorithms and so they very very quickly become in computing with classical methods yeah yeah it really it really is there but I can see I'm standing like right right up against the screen here but but quantum computers while they are physical devices and so it's not surprising in some sense that they're very good simulating physical devices and so we can think of the quantum computer itself as a programmable physics lab okay it's actually estimating what's going on in a computation by doing the underlying physics that the computation is is modeling all right so so let me finish with this is well so the same slide so this is a outlook of what we're gonna do a little bit later this afternoon and and some links if you want to look up look up all of these and even get started early and I'm happy to take questions I'll reserve a little bit of extra time because you know I hear we have result you know people want to hear about the quantum inspired stuff as well and so I'm happy to talk about that in in more detail or anything else I mean floors yours thank you No yeah what a clarifying question up what is the so you explained a lot about the process that goes into developing these things yes what is the process of finding fields where a quantum quantum computer can be useful in some sense right okay so so yeah in other words how do you develop new quantum algorithms right that's that's a very very challenging challenging process and I guess it depends on on if you're interested more in combinatorial things and and robins sitting here in the front row so I might have tap him to answer some of this if you're looking for for those then there's sort of one approach that that that you can probe more computer science types approaches if you want to look at like real world applications those often don't fall into these more combinatorial things they're more continuous valued and such and it's and you know it's like developing any algorithm it's a it's a one-off you gain inspiration about the algorithm itself about the problem itself and then find new ways of examining it okay so there are some very very broad categories that work and I've mentioned it's already a quantum inspired optimization so adiabatic so at a very general level adiabatic quantum computing is well tuned to optimization because what it's doing is finding the lowest energy configuration of a Hamiltonian and so if I want an optimization solve an optimization problem I just cast that optimization that objective function as the Hamiltonian and then the adiabatic process itself will will find that now the hard part isn't actually just writing down the algorithm that's the that's in some sense the easy part the hard part is analyzing how long is it going to take to resolve this how long is it going to run okay and what's the likelihood that it's actually going to find the solution that we want to find I mean all of this is randomized these are all randomized algorithms okay but but yeah I don't think there's any easy answer I like you know I wanted to find a new quantum algorithm today what do I have to do well no no easy response there yep yep a couple of sighs there is a it's a bunch of grafts next one yeah okay oh yeah so you want this this one or this one huh next okay this one here next one yep that one okay right so what I didn't understand in this graph these are all very interesting but at the lower left you've got the Microsoft simulations that's right so so this is once we get the the Q sharp program written out this of the quantum algorithm written out in terms of the code we can just simulate what's going on okay so if I have say 20 cubits well 20 spin orbitals which then get converted into roughly 20 cubits 20 plus o of 1 I think it's a statement then I can just write that as a vector of those amplitudes ok so let's pretend it was 20 for the moment and so I'd have 2 to the 20 complex amplitudes so a million complex amplitudes I store in memory and then every time I apply a gate I just adjust those amplitudes according to the action of the gate all right so at the end of the program I have the all these amplitudes I just sample it ok and so those those plots were all those red red dots appeared that was what was coming out of these sampler you sample it you get it you actually get the there was the result of the of the simulation ok but if you start scaling this up and so you know up here I don't know what number that is say 24 25 you know the this is becoming very memory intensive okay so we're already talking to the megabytes these are complex numbers of memory available obviously we get to gigabytes now without too much difficulty if we move this up on to the cloud using Azure that we can get this up to 30 maybe 35 cubits just because that's it takes a huge amount of memory to store all the amplitudes for that quantum state yeah these are all theory lines here this is the resource counter right so the resource counter doesn't actually simulate it just says well how long is this going to take based on all of these gates that I've counted and the number of time steps that I predict it's gonna it's going to run there's a current Q sharp suffered toolkit that it's contained simulator but also there's County yeah contains simulator and the resource counter both and there and it's just a one line switch to go between the two do you instantiate the simulator and then it runs the simulation or do you instantiate the resource counter and more or less the except for some trace commands you know the QR codes the same run the simulator on a t-cubed no probably not on 80 cubits out that would not be great although 70 might be in range for certain things okay so so going back to these quantum inspired algorithms the the Bristlecone when google put that at announce that a couple years ago and they said they wanted to run what's called low depth circuits which is a technical name as well this was going to be for their supremacy experiment they were going to say that well with these low def circuits now we can sample from distributions you cannot sample from classically right and to say not sample from classically means of course not sample from classically in any reasonable amount of time okay so a few friends of mine down at NASA Ames well they have a great big huge supercomputer they're called Pleiades and they were able to take this low depth quantum circuit problem and recast it as tracing a tensor network okay so this is really long exact same lines of these quantum inspired things we know we have a quantum algorithm it's gonna be hard to simulate that but we can estimate that using a slightly different means in this case tensing at tracing a tensor network and then we're able to do that up into the 50 qubit range and they predicted that you know with about a day's runtime on the pleiades supercomputer they could do 72 qubits all right so so 72 qubits are is then now that's in the is that Li quantum inspired range now well at least for maybe low depth circuits it is for these really long circuits this this techniques not going to work so the boundary between what's quantum and what's quantum inspired is always moving yep yeah yeah it's a quantum annealer and so so quantum annealing is sort of the the community name for adiabatic quantum computing at nonzero temperature okay so temperature thermal fluctuations having a real effect in that machine we can't you know zero temperature doesn't exist in reality we're always going to be in a non zero temperature and so they run it a handful of millikelvin but thermal effects actually do have a non-trivial effect on the dynamics of that machine but what is what it's meant to do is simulate adiabatic quantum computing using a quantum device now it's very incoherent but but it's actually a pretty amazing pretty amazing piece of machinery again really easy to simulate using other methods like quantum Monte Carlo or diffusion Monte Carlo because we have the knowledge of simulating these using different types of algorithms okay Thank You Brad thank you 