 device count so those were the device noisy I'm going to label the second one device counts and those were mitigated take a look at this [Music] hello and welcome back to coding with kiss kit this is Abe in today's episode we'll be talking about noise and we'll be discovering a technique called measurement error mitigation which allows us to squeeze the best performance out of today's quantum computers you might recall from our hello world video that we executed a simple circuit both on a simulator as well as a real quantum computer in that episode we saw a very clear difference between the two cases so in particular we saw that while the simulator which simulates a perfect quantum computer tells us to expect the results 0 0 & 1 1 we found that running the code on real quantum computers gave us small number of results that were also 0 1 and 1 0 the reason for the small number of 0 1 and 1 0 result is the presence of errors in our quantum computation and in fact these errors are caused by various different types of noise so far in our work we've been using two elements of Kiska so we've been building circuits in kis Cantera and simulating the circuits on air and running the circuits on real hardware using tera as well in this video we'll be talking about a third component called kiss gate Ignace Ignace allows us to understand and even sometimes mitigate the types of errors that we see in our computations and so in this way Ignace is the package for working with and characterizing quantum hardware one type of issue that we have to deal with on a daily basis is called energy relaxation so think of a cubic that you prepare in the excited state or the one-state if you leave the qubit in this state after some time you'll find that it decays in energy and goes back to the zero States the timescale for this kind of error which takes you from the excited state to the ground state is known as t1 there are several other kinds of errors that we could talk about but let's do something really cool with Ignis and the thing i want to focus on today is called measurement error mitigation the idea here is the following so let's imagine that we create a 2 qubit quantum circuit and we prepare the state 1 and we immediately measure those two cubits what we'll find is that the outcome is mostly 1:1 on real hardware but you'll also find a small number of results in the 0 0 0 1 and 1 0 States similarly if you prepared another starting state let's say 0 0 you'll find that your measurement shows you a small number of results in all the other states now what if you knew the chances of seeing the wrong answer for each of these initial States could you use that information to then invert the results of an unknown computation and try to get it as close as possible to a simulation let's see how this works so I'm going to start off by saying from kiss kit import everything and then I'm going to build a simple 3 cubed quantum circuit so I'll say number of qubits is 3 and I'll create a circuit which is quantum circuit composed of three qubits and three classical bits to the circuit I'll add the operation of a Hadamard gate on the first qubit and then I'll do a controlled X on the second qubit control by the first qubit and I'll do another controlled X on the third qubit controlled by the second qubit alright and finally I'll do a measurement on all three qubits okay so we can as always draw the circuit and before I draw I'm going to say Matt flawed live in line so that's the circuit that we'll be working with today you might recall that this circuit is very similar to the one that we built in the hello world video so if this was a bit too fast please go back to that video and take a look about how we built that circuit so I'm going to proceed here so now the question becomes running the circuit on a real quantum computer so how do we do that the next step is to look at those results so what I'm going to do is say from Kiska dot visualization import plot histogram and then I'm going to say plot histogram of the simulation result dot get counts and in particular for this circuit so this is what the ideal results look like so we expect roughly 50% of our results to be in the zero zero zero State and fifty percent of our results to be in the 1 1 1 state so this gives you an idea of what a perfect quantum computer should give for this circuit alright let's now run this code on a real quantum computer and to do that I'm going to first begin by importing my account so I'm going to say IBM Q load account and then I'm going to say the provider is IBM Q dot get provider and the hub is going to be IBM dash Q and the device that I'd like to use for this work is going to be provider get back-end the name of the device is IBM q x2 so this is the yorktown device once that executes the next step is to run the job on this back-end so I'll say job is execute the circuit on the back end being the device and I'm going to ask for 1024 shots again all right so it's a good idea when you're running on on these real quantum computers to first print the job ID so I like to do print job job ID and import the job monitoring tool so from kiss kid tools dot monitor import job monitor and then start the process of job monitor job so once the job is done we can get the results back by saying device result is job dot result and what I can do then is plot those results so I'll say plot histogram of device result get counts passing in the circuit so this is what the results look like when you run them on a real quantum computer and as we discussed before while the large number of your results are in the 0 0 0 and 1 1 1 states just like in the simulator you still get a small number of results in these other states so now let's do the interesting part so what I'm going to say is from kiss kit dot Ignace mitigation dot measurement import complete measurement Cal and complete measurement fitter then what I'll say is calibration circuits and state labels are given by complete measurement Cal passing in the quantum register to be the circuit that I'm working with that quantum register number is zero so that's the three qubits that I have and I'm going to give this a label measurement error mitigation calibration circuits okay so now the idea here is that Ignace has given us a series of calibration circuits to run in order to find out what the errors are as you run each of these circuits so in particular you could do something like cowl circuits may be number two dot draw and say output in that plot live mode so you see here it gave you the circuit 0 1 0 so if you run the circuit what kind of outcomes do you get so in total there are 8 of these circuits and that's expected because we're working with a circuit that has three qubits so you can prepare 0 0 0 0 0 1 all the way up to 1 1 1 and there are 8 such circuits ok now let's run these circuits and see what the outcomes are so what I'm going to say is the calibration job is execute the circuits in particular the calibration circuits and I'm going to pass a few parameters so the first thing I'm going to say is the back end is the device the number of shots I want I'm going to make this 1,024 shots the optimization level is 0 and that makes sure that these circuits are not changed as we transfer them from what we have here onto the real device and then we can say the the job ID is Cal job job ID and we can start job monitor of Cal job ok so that allows us to see what state that job is in and then I'm going to say as soon as it's done the calibration results are Cal job dot result and then we hit enter and wait until the devices run is finished if you're curious to see what the outcome of these results are so again we can do plot histogram and in particular we can show for example the Cal results get counts for just one of these circuits so Cal circuits maybe number let's say three so you see this is the state that was prepared in 0 1 1 and in fact when we measure the state we find yes the large number of results are still 0 on one but there are still the smaller number of results that we need to account for so the workflow in Ignace is very typically like what you've seen where we generate a series of circuits run them on the hardware and then take those results back and fit them so try to understand what parameters come out of these results so I'm going to create a measurement fitter and that's going to be complete measurement fitter of the calibration results and associated with these results I need to tell this function what states were generated so I'll pass the state labels as well ok and if you're curious you can also visualize the entire set of results by saying something like measurement fitter dot plot calibration so you see now the results make sense when you prepare your state in any of these cases the results that you get in the measurement look like the following so seeing the diagonal components tells you if you're preparing 0 0 0 the largest number of results so dark means near probability 1 and white means near probability 0 so the largest number of results are still the state that you're preparing but you have these off diagonal components they're very small but they do matter in the computation once you've created the measurement fitter which extracts the parameters out of the calibration results we can create an object called a filter so we'll create a measurement filter from the measurement fitter by saying measurement fader dot filter so what you can do once you've created the measurement filter is say mitigated result is the measurement filter apply on our device result ok so let's take a look at what these results look like so the device counts were device result that get counts for the circuit the mitigated counts were mitigated result get counts for this circuit and let's plot them side-by-side so I'm going to say plot histogram of the device counts and the mitigated counts and I'm going to label them device count so those were the device noisy I'm going to label the second one device counts and those were unmitigated [Music] take a look at this so we've gone from the blue chart which is the result from running our quantum circuit at the beginning on a quantum computer to these results so the measurement error mitigation has accounted for what kinds of results we expect to see for the different starting states and then inverted the results that we see in blue into the ones in red so you see a lot of the errors have disappeared here and all we have is just a small amount of error here and the results look very close to what you expect to see from a perfect simulator remember now you've taken all those calibration measurements and saved the measurement filter so what you can do then is now if you build another quantum circuit of three qubits you can mitigate results from that circuit as well so let's just build another circuit so I'll say circuit two is a quantum circuit with three qubits again and three classical bits and I'll say circuit 2 dot X on second qubit circuit 2 dot H on first qubit and circuit 2 dot C X from 0 to 1 circuit 2 dot C X from 1 to 2 and then I'll say circuit 2 dot measure qubit 0 1 2 into classical bits 0 1 2 and then do circuit to draw output is Matt plotline so this is a slightly different circuit from the one that we've created before let's quickly run it and see what happens so I'm going to execute do this all in one line so I'm going to say plot histogram from executing this circuit - on the backend being the simulator and the number of shots being 1,024 and I'm going to get the results from this and I'm going to get the counts for it for this particular circuit okay so this time we see that for the circuit that we've created the ideal results are all in 0 0 1 and 1 1 0 let's run the circuit on real hardware and see what happens so again the procedure to do this is just like before we will say device counts 2 is execute circuit 2 on the back end being the device and the number of shots being 1,024 dot result dot get counts for circuit 2 okay let's wait some time for this job to finish and to get the results back once the job finishes we can say plot histogram of device counts - and this is what the results look like so again just like you'd expect most results are in 0 0 1 and 1 1 0 but you do see a few results in two other states but now because you've created your measurement filter already what you can do is say measurement filter apply to these counts let's save these results as device mitigated counts - and if we were to do plot histogram of exactly this the results look much cleaner now so you have very little results in the other states and you're very close to what an ideal quantum computer would have so let's summarize what have we learned today so we started off by seeing how small errors in our quantum computation introduce measurements results that take us far away from what an ideal quantum computer would give us and then we used a package in kiss kit called Ignace to understand what those kinds of errors are and then to find out what the parameters involved are to generate a fitter and then to use that fitter to generate a filter which allowed us to mitigate the errors in our measurement outcomes so at the end of the day what we've done is go through a hardware run of our quantum circuit and then taken the results from that circuit and then effectively applied an inverting procedure to find what the ideal outcomes would be for that run so as an exercise why don't you try the following so you've noticed in our code we created a three cubed quantum circuit and we try to do measurement error mitigation on that quantum circuit see what happens if you go now to four cubits the the natural thing to happen is that the amount of errors that you see as the number of qubits increases should go up and you should be able to still do measurement error mitigation by generating the calibration circuits from Ignis show us what you get in the comments tell us what kinds of measurement results you find and tell us in the comments down below what you've learned from this process if you'd like to learn some more about the theory behind the measurement error mitigation work that we did you can go to our Kiska textbook where you'll find a nice section about all the underlying mathematics behind this procedure and as always thanks for watching and we'll see you in the next episode of coding with biscuit [Applause] [Music] [Applause] [Music] you 