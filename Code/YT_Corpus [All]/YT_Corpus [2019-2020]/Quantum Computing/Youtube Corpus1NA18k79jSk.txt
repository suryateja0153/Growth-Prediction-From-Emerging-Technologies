 so welcome back everybody it's my great pleasure today to be talking about two sharp or software effort in general and this announcement that we had a while back and that last week officially we went open-source so all of our software and the qdk is now available online on github in its entirety we've heard plenty before about applications and what you could potentially want to do with quantum computing so by now we hopefully have some ideas and some inspiration on the problems we might want to tackle at this point but the question is how do we get there these are all huge challenging problems we all like to save the world but in the end usually that turns out not to be quite as easy and the way we think about quantum algorithms and we teach about quantum and quantum algorithms today is very important for how people will think about them in 10 years or 20 years and what we built this future on essentially sometimes they're very nice examples like Grover Ford for example that is somewhat little and this 2d plane you can draw some diagrams have some graphics but then when it comes down to actually explaining what it is that the algorithm actually is supposed to do and how it works that usually looks something like that in detail in a classroom at a whiteboard with some formulas and a lot more detail that has that is on the slide obviously but if you're looking back at this nice virtual representation of this algorithm and if you forget for a moment all the nitty-gritty details we might want to take a step back and fundamentally think about what it is we want to do and we want to achieve to come up with new ideas with new ways of looking at a problem and approaching a problem before we go into the technical detail exactly on which sign goes where so if you would explain exactly what people are supposed to do based on this speed on this diagram what you would probably come up is something like saying well you got to get yourself a uniform super position to make sure your state has some overlap with where you actually want to go and then we can do two kinds of reflections for a suitable number of time that will effectively rotate or state in space such that we rotate towards where we want to go after you've done that a sufficient number of time you can measure and get hopefully a state that is collapsed to what you wanted to know I've written down for example here in Q sharp how this might look like and the nice thing is really that we still have pretty much these lines yes it's maybe not entire sentences but still fundamentally we can express they're supposed to be a uniform superposition you're supposed to somehow mark where you want to go your target state you flag your target state and usually that's the difficulty with this amplitude amplification kind of things you somehow need to mark it and that needs to be efficient and then you can just reflect against the plane do that a couple of times and you're done so looking back at fundamentals for example teleportation what we often see our diagrams like this one here so okay this is nice this is official it's a pretty picture it's nice to have in a paper because sometimes if you do a lot of theory it's kind of hard to sell your papers without some pictures so in that sense sometimes we want to have them but scaling up can be a little bit tricky so if you have too much to draw basically if you have a lot of nesting a lot of branching that here is in this classically controlled gates actually then it might come in a little more handy to actually have a code or pseudocode representation of it because at the very least we've got if statements that somehow make it a little bit cleaner and especially if you have more than just one X or one sec aid in there but what's more than that it's not just about that it's also if you look at this agent to see not what is it we want to do it's not telling me a whole lot of what the intent is there so instead of calling it agency not which means a lot to everybody who has already worked in the field but not necessarily to the people getting into it we could instead write well we want to entangle two qubits and then we sort of want to transfer and manipulate a kind of entanglement to do something useful with it so hopefully we hope to abstract out somewhat that line of thinking that thought to make it approachable and workable for people who have context in chemistry have context and and biology or anything else material sciences where these things may come in handy but not necessarily the entire foundation of having had a degree in quantum information theory because when's the last time that you saw something like that I hope some of you code and I hope none of you had to deal with that or maybe you did and your work on hardware but basically I'd rather write a plus B because it's just so much faster so this is a basically that we want to achieve with the software that we are building and stepping back one step we've got to ask yourself what is it we want to achieve fundamentally when designing a quantum programming language when designing a software platform how what expectations do we have and on one hand as I mentioned in a sense that's abstraction that's talking about what we want to do rather than how strong the pulse sequence has to be to achieve that for a particular platform for a particular hardware so in a sense we want to be able to talk about what we care about and what we're working on rather having to have expertise in anything from superconducting materials up to number theory and complexity theory on the other hand they're always going to be the people who download the algorithms and most likely hopefully they're going to know a whole lot more about this algorithms than most other people who would use them as part of a as building as part of building on it and developing new ways of utilizing that specific sub routines so we want encapsulation and what's important usually when you have abstraction and there come a capsulation you end up paying some over half price usually because you've got all your nice transformations and then once you start plugging them together you could probably eliminate some of it and now we've got the choice you can write an application start to finish given all the input values for every problem you want to solve for every application you actually want to run on quantum hardware that's doable if you have one or two applications given you know where we are currently that's currently certainly doable if you ever actually had a paper where you wanted to get a numerical data or something like that you probably ran into your problem where you wrote a lot of scripts that do exactly that that somehow tests a bunch of input parameters test a bunch of ways of plugging stuff together and so on so there are two ways we could go one is the responsibility is up to the developer to actually make this connection make sure that there's no performance over had to be paid from abstracting things out which requires a lot of work or we can provide in the language the means to annotate the information to provide the information that is necessary to automate that process as much as possible and we chose to do the latter end it's a very cute shop it's very young a very new language we certainly there's the first steps done and there's certainly a very long way to go but this is where we want to go of course especially given the early stage of the field given how Hardware works given that devices are probably going to be more or less reliable for the next couple of years we do want to know that our code is correct we've heard before it's a large problem to debug quantum hardware and you don't just have to debug quantum hardware there's the hardware that's unreliable there's all great ins that are usually probabilistic rather than deterministic so there's a margin of error there as well we can estimate kind of give guarantees with pounds using triangle inequality usually it's the easiest way to go the problem is these are and usually not very tight so to make it actually usable to actually speed up a lot probably we might want to just try out and heuristic we figure out what is kind of the right step size example if you have a trucker ization or something like that but that requires some confidence in that what you're doing is actually what you want to do you know in the correctness of your implementation so in a sense our first priority is prior is optimization of course making it efficient to run on quantum hardware but once that satisfied as much as we can track about whether you intended to do what's going to be executed that's also something we want to do furthermore we want to have some idea about resources about how many qubits do you need about how long is it gonna take probably once you have access to quantum hardware you're not just going to hit enter and hope for the best and see if it runs within the time that you know your qubits are alive but at least it should have some idea on whether that's doable and again versatility is very important such that we can figure out kind of incrementally improve algorithms improve Hardware improve the ways we formulate an entire program and how we handle optimization of that program and lastly execution as I mentioned efficiency we want to leverage the hardware that we have given that we are very much fighting for every qubit fighting for everything we can do we want to optimize what we have and reliability especially in terms of code so this all brings me to a couple of questions that I think about a lot and for me it's all about information essentially once when you write the program what you have is somebody with an idea how to solve a problem in their head where you want to get is to somehow translate that knowledge into something that Hardware understands specifically to do so what we need to have is a way to convey that information and that information can be conveyed in various ways and usually it's used and broken down and once you've used it you know once you've inland something you lost the information about where to read operation started and ended so there's usually a trade-off once you've used it it's probably no longer there you can use it for one thing or for the other so it's very important to think about these things and these things specifically may be very different than in conventional compiler construction for example because there are decades of research going into what we currently do to run a program on your laptop whether that's exactly the right way to go about doing it on quantum hardware that's entirely an open question and the reality is until we actually run a couple of things until we have benchmarks and test suits and some research that goes into that we won't know so we're very early here we make a first attempt our goal is to make a good first attempt with Q sharp to do that to do exactly that it's certainly something that hopefully will grow but also will evolve and morph because some of the things we think today are important may not be very important in the long run and other things hopefully pop up fundamentally what we want to do is we want to reason about an algorithm and that's really what it's all about so I'm not going to go into more details about what exactly is in the language if there are any questions I'm happy to answer them I'm happy to go into more specific on language features on capabilities and trade-offs that we have done so far and where we might want to go but I think the important idea is what I said before to get the pretty picture in a sense we want to somehow combine some processing usually some classical processing heavy classical computation is something that generates heat which is one of the main bottlenecks currently for data centers and anything like that so realistically there's always going to be a classical part to it for heavy processing that's not gonna run on your 4k or even lower where your qubits live so there needs to be some coordination between the two probably compiling it with things with Q sharp we're not competing against high performance classical libraries for machine learning for example we provide arbitrary classical control flow because it's very important to reason about the program structure and center but we're not going to compete with numpy or anything like that that's in a sense not the right expectation because it wouldn't run at the same level and then we of course also want to actually execute it and as mentioned something needs to coordinate between what is processed where so that's pretty much what makes your software stack and for today to figure out if that even is remotely reasonable we want some tools to actually assess whether we are getting somewhere we were wrong to get and we've got plenty of that Q sharp is one of course we also got an arsenal of tap tools that are there to make it easier for people to get into it to learn it to work with it we've got simulation framework set up because most people probably don't have a quantum computer in their basement or access to one so for our daily work basis it's probably helpful to have some simulation capabilities for us specifically that means not just the full quantum state simulation but also resource counts and anything you could do possibly to sort of get as good an understanding as you can about your Guren before you actually go and try to do something on real Hardware in libraries naturally so as far as the dev tool goes we do provide a couple of things a couple of integration we're going to hear more about that also after that talk there's two extensions that we provide but that's mainly you know what we provide we have a language server anything that supports language server protocol can use the cue can use that server to communicate with the cue shrub compiler so if your favorite editor is Emacs or sublime or anything like that we are now open source feel free to contribute for the simulation as mentioned we got a couple of simulators there we're working we're certainly always listening to the ask what the community wants and needs and will be helpful to have and we've got libraries like chemistry arithmetic libraries and some set of course material and exercises and taqaddas that Maria is going to talk more about a little bit later that she's all written this is one of our newest edition estupido notebooks a few the extensions are easily obtained by just downloading your favorite editor vs code in this example go to extensions and download them and the how Q sharp looks like is that it works more or less in its a processor model where you have to sharp code that is eventually supposed to be executed more or less than a quantum processor router the actual Q sharp runtime and a driver that actually calls into that code the driver right here is C sharp but it could be anything in principle we run that course or you just need to somehow be able to call in to.net core and what the nice thing about that set up is for example for the trace simulator you can actually configure a little bit what it's supposed to be watching also some durations arbitrary a set for particular intrinsic operations or gates that give you a better idea on how you're all Gurdon might perform how certain adaptions might impact that to be somewhat helpful what you can get also on one hand here's exactly number of gates as you see there but also we allow you if you run on a four-state simulator to actually dump the state to look at them the kids I know it's helpful for debugging though we're really on from a cue sharp perspective we're focused on the operations on the transformations you want to do because what a quantum state is in a sense is not relevant to what you want to do so our focus there really is the transformation itself and how they relate to each other more importantly and with that we can do some pretty powerful and cool things as we've seen one or two slides before and some as we've heard about the chemistry examples for example here with of course all the usual tools for plotting the whole thing comes with nice documentation hopefully we're always working on improving that what we have in our documentation is on one hand getting started kind of quickly setting up your environment some documentation on what the libraries are on what the language are a detailed API documentation for everything in our libraries that is generated and that should cover the most basic things what is also helpful sometimes to watch for as we have it that block coding contests and new language features or releases or something like that for those more invested in actual development and possibly also these tools that might be a good place to look and there's a complete set of link that is probably get to take a snapshot off as I've mentioned the open source repos the list there has gotten a little bit longer lately and I'm happy to show that right life okay so here's one of our repositories that just went online last week which is the compiler kind of the core piece to actually run quantum algorithms do development and so on you don't need to look at the source code of the compiler and the extensions and so on this is really if you're curious about what we do and at some point it's also going to get you know a little bit more clear looking through the repository where we're headed and where we want to go if you find issues and things that you think should work and don't here's a good place to file them we've got a runtime repository that contains in particular also all of our simulators it contains also a piece that generates c-sharp because you need to execute on something so Q sharp itself right now is taking text and building an abstract notion of that text we're on the process of kind of writing the actual compilation piece breaking it down that hopefully should happen over the next year or so but for the purpose of executing it anywhere right now we're pretty much generating c-sharp based on these high level data structures and leveraging the capabilities of the c-sharp compiler which are a lot more relevant and more practical for actually running on classical hardware and in simulators than anything that we might want to do for quantum s and there's also a third new repository which is the IQ sharp repository which is the piece that makes the chip return integration possible and also kind of having Python as a driver for example easy to have so let's let me show you a little bit how it looks like if you're actually working with an ID this right now is in Visual Studio but that's purely because I happen to like it you can use vs code or anything like that the nice thing with Visual Studio is you've got the unit testing framework and you've got the help that the editor can provide via our extensions this is one of our cutters for example to show you a little bit just you know how working an idea might look like on one hand it's helpful that you see everything that is declared in this file you can jump to it go to it right here as mentioned the cards the idea is that their set of tasks you're supposed to solve and when you initially run all the tests are supposed to fail and your job is to make them pass waiting dream and there's a nice set of instructions that come with it that explain what it is you're supposed to do and why we want to do what we want to do and for example here create an entangled pair it tells us to actually that we get two qubits in a zero state and we're supposed to create a bell state a particular one we can do that right now and as you see as I'm typing I do get live feedback whether what I'm typing actually makes sense and also in particular for example here it will actually show me the next parameter it will show the description of what that next parameter actually is supposed to be that's all built based on documentation comments in the code and our libraries are fairly well documented such that if you're hovering on things like scene up for example here you do get a description of what that gate is actually doing so it can have Q to you here run the test again and we should see that indeed that particular test hopefully should now pass and I've already filled in a third one so having solved that one actually makes the other one pass as well we've got all the features for example you can see well peak where this declaration is we see here there's for example a type declaration here it's got two items named bit 1 and B 2 to represent the message you want to transmit this here is the super-dense coding kata so the goal is to transmit two classical bits by physically by using the resource of entanglement and physically sending one cue so there are a couple of nice features on that the compiled provides for example if you're forget and open direct if you see here now finding this thing it's pretty easy it's a chest to you exactly where to look for it you can click on it it's actually going to insert as a open directive again as you know from other languages like C sharp and F rope where similar functionalities are also available obviously they're always working on improving that we've got renamed for example that makes it fairly easy and convenient to work with it's just writing two lines of code it's fairly straightforward writing a couple of hundred lines of code which hopefully people working on quantum algorithms will at some point is easier to have some support here we have this whole thing also in Jupiter notebook format and Maria the next speaker is going to talk about it some more I'm just going to show you a little bit you can actually clone for example a caddis repository you get an index and the list of all things here that are available and as I mentioned you're gonna see more about that a bit later on as I mentioned things are also available in vs code here we see the example to actually just create a Bell State and then see what the state is we can run it with top net sorry just dotnet run we'll do what we want to do and what we get here is an output that is now a little bit less readable with what the amplitudes are for particular cubits for qubit one rather for state 1 state 2 state 3 state 0 and in case you were wondering a little bit how this whole thing works for example with tracer where we have branching based on measurement results the way it's currently implemented is that when you write for example teleportation and you have a branching here what the tracer does is actually follow one particular execution path and the path it follows is going to be probabilistic depending on what probabilities have been annotated for a particular branch so what we did here for example is to say ok here are an assertion regarding what the state of the qubit should be we can have similar assertions before branchings that basically say the probability I know from based on my knowledge of the algorithm is supposed to be that and it will just probabilistically follow whichever path according to their probability if you don't said anything I believe it's a 50-50 chance and there ways obviously to force each each path and branching again there everything is open sourced you're certainly nice things one could do with that and build on that and have a more clever way to get an entire understanding of the tree for your program and we're always working on improving our tools so before I go into full demonstration here I think it's easier if I just open up the round for questions for anything you want to see any any other software aspects you would like to look at and I think that probably makes more sense no questions so then I hope for plenty of contributions and people using it or at the very least bug reports that's always a good sign that people are actually using the software perfect then I think we're all excited to hear more about course material and how to actually use these tools [Applause] 