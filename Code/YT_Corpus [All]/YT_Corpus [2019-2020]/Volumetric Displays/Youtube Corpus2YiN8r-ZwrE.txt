  Amanda: It's already April, and that means there's a fresh, new batch of free content on the Marketplace. This month you can set the visual tone with a post process fall gradient, add vast landscapes to your worlds, adorn them with lush vegetation and photoscanned plant life, and then relax by the waves created by a tropical ocean tool. Plus we've also added a customizable broadcast studio as part of our permanent collection for your virtual production needs. Head over to the Marketplace and download all five environment-focused products before they're gone. Unreal Engine Preview 6 is now available on the Epic Games launcher and GitHub. Give the latest features a try and share your feedback with us in the official Unreal Engine 4.25 preview forum thread. In case you missed our webinar, Unreal Engine and Quixel: Pushing the Boundaries of 3D, you can now replay the event via our blog at UnrealEngine.com. Give it a play to find out how a variety of industries use the Megascans ecosystem, how Megascan's Bridge and Mixer work together, and what you can expect from Quixel and Unreal Engine in 2020. Humans have looked to the stars in awe since our time on Earth began, but living in space has long been out of reach. Now with the combined efforts of organizations like NASA, SpaceX, and the European Space Agency, we are making progress not only on venturing to Mars but building a settlement. To visualize their innovative concept for interplanetary habitation, international design firm Hassell, in partnership with engineering firm Eckersley O'Callaghan, turned to Unreal Engine. Discover more about how humans may build on Mars on the B1M's website. Many thanks to our top weekly karma earners who are helping others over on AnswerHub-- Everynone, Blackforcedragon, ClockworkOcean, Shadowriver, RobMeade, Vecherka, Fatorice, ugmoe, FSapio, and mrteuy. Over to our Community Spotlights, this first piece is a recreation of an abandoned station in New Jersey by Will Mundell. So personal project of theirs utilizing Quixel Megascans foliage and traditional lightmap techniques. Let Will know your feedback on their forum post. This quaint scene, the Lonely Rorbu, is a student project that was created over three days by Ryan Thomason-Jones. See Ryan's breakdown of the project on his ArtStation, and while there, read his blog about what he wishes he knew as a student at the onset of his studies. And last up is the Rookies-entry, Aspen Lane, a VR paranormal investigation experience by Escape Studios. Set in North London, explore a family home to uncover evidence of a malicious haunting. Surface more information about Aspen Lane on their Rookies submission page. That's all for this week. Thanks for tuning into our News and Community Spotlight. Victor: Hi everyone, and welcome to Inside Unreal-- a weekly show where we learn, explore, and celebrate everything Unreal. I'm your host, Victor Brodin, and my guest today is our Senior Documentation Engineer, Richard Hinckley. Richard: Hey, everybody. How are you doing? Victor: Welcome back to the stream. I'm doing all right. How are you? Richard: I'm doing all right. Just getting ready to go through some code today. Victor: Right. You prepared a little presentation for us on the topic of iterative design for comfort. Would you mind explaining a little bit what you intend to cover today? Richard: Yeah, I guess I need to, actually. My wife said she was going to tune into the stream and said, I have no idea what that title means. She's not a game developer, so maybe it's OK, but basically-- [AUDIO OUT] --about here is, all right, as you iterate, especially in pre-production, you don't really know exactly how everything's going to work from the start. There's a lot of sort of figuring things out as you go along, or you realize like, oh, this structure needs an extra piece of data because there's this thing we're trying to do with it now that requires one more piece of information every time we try to do this game function, whatever it might be. So what we want to be able to do is when we encounter those things during iteration, we want to be able to change them in ways that don't disturb designers, don't make them go back and redo everything they've already done. And also, we also want to make tools that can work in the editor to make it more comfortable for designers to do things that they do a lot. Like there might be a game where you lay out certain things in the level and they're linked to each other in some way. And maybe you want to visualize that linkage so that designers don't have to click between one thing and another thing and another thing back and forth in the editor to figure out what's linked to what. They just want to be able to see it. So that's kind of what we're doing. What we're figuring out as we go along, how to keep everything moving smoothly and how to make it as comfortable as possible for whatever game-specific things we have that our designers need to use without having to mess with the code. Victor: That sounds good. And I do want to mention, Richard, we are seeing a little bit of the connectivity issues that we had just prior to the call, which is very unfortunate, because yesterday when we were on here, everything was smooth. So let's hope everyone-- everyone in chat, let's hope that the connectivity stays up and let Richard continue with his presentation. Richard: Yeah, I really hope so. You're coming through pretty smoothly on my end, so maybe it's OK. I don't know. I hope maybe-- it's just people in this area using a lot of their internet right now. Victor: Maybe. Richard: I hope it's OK. But anyway, OK, so you want to dive right into this code? Victor: Yeah, let's go ahead. Richard: Let me see. All right, so let me bring up this one. Excuse me. I've misclicked. Just one moment here. And we'll screen share this. One second while I just find my Visual Studio-- there we go. All right, can you see my Visual Studio screen here? Victor: Yep, we got it. Richard: Actually, you know what? This is our code, but we're going to start-- I'm going to start off somewhere slightly different. I just changed my mind. I'm going to share the editor. OK, so we're going to start off with a top-down project. This is just from when you start a new game project in UE4-- oh, and by the way, I started writing this a bit earlier. So I'm actually using 4.23 instead of 4.24. But it's not really much different. We're using the top down template just because it was sort of easy to get started on. And we just need a simple framework. We could've done this in any of them. I just chose that one to save time. So one of the things we're going to need in the game-- in almost any game-- is when the player walks into a certain area, something happens, and an enemy spawns. An item appears. Cutscene starts, door opens, whatever it is. So how about something simple here? Just these two lovely torches you see, really good artwork there on my part. When you walk between them, they go out, so haunted house stuff. And it's pretty simple to do. The actors themselves for these torches are just basic Blueprint actors. I put a light and a particle effect and a static mesh on them. That's it. Nothing really spectacular. Now, here's the first point about this. You designers are going to want to do this. The first thing you want to be able to do is take control of the base class. So I do not want these to be just regular actors. I want them to be, as you can see-- I don't know if you can read this text-- but they're a member of the class prop_triggerable. So that's a class that I've made in Visual Studio. And it is just an actor. It doesn't really do anything special, except that when they decide that they want the torches to be able to light up on their own or blow out on their own when they're triggered. Then we can come through and we have our, like, trigger box here. And we can hook it up to them. So that's the part where we start wanting control of it, because if they write all this in Blueprints and then something needs to change, we pretty much just have to shrug our shoulders and say, well, I mean, I-- can you reparent to my base class that I made, maybe? It's really best if we [AUDIO OUT] the base class from the beginning. And then they can do all the events, all the turning the particles on and off. They can do all that in the Blueprint editor. That's fine. But we just want to have the base class so that we can add functionality to all their Blueprints of this type easily and really under the hood. We really don't want them to have to think about it at all. So what I've done was I just made a simple interface that allows them to trigger a thing. And then this right here is a player trigger. As you can see, it's just inherited. I didn't write any Blueprint script on this. Let's go over to Visual Studio and look at what that looks like. This one. OK, so we wrote just a basic-- just a basic interface. I made this a pure virtual function with = 0 so that you can't-- oh, I can't click-- so that you can't accidentally implement this class and not write a function for it. You can't-- OK, there we go. Now I clicked it. Yeah. No actual code was needed for this because this is just an interface. But any actor that can be triggered, we can put just right here. And then all we have to do is override this one function right here. So we wrote that in there. Now again, the designers might have their own idea about, like, we want to play a sound effect. We want to do a-- turn a particle emitter on or off, stuff like that, maybe some things that happen over time, like they want one of those on timeline graphs. All that kind of stuff, that's great. Just give them a Blueprint implementable event that we connect to this. And then as you can see in the main class, I don't really have anything special that I need to do right now, because this is the beginning of the project. Now, later this is a good place for debug output, as well. And another reason why you want control of the base class is because then I can put debug output in here and I can see what's going on, if something is crashing or they go to open the door after they beat the boss and for some reason the door doesn't open in certain cases. Put debug text here. See if it's actually calling the trigger. You know, debug some information, see if it's like, oh, this flag is [AUDIO OUT] whatever it is. That's, again, why you really want control of the base class. And we also call their Blueprint event. That lets us go back to here. And just really simple. The first time the thing is triggered and only the first time, turn the light off. Deactivate the particle system. And so that way when I walk through the trigger it goes off. In terms of how the trigger works, again, we're keeping it really simple. We have a generic trigger box for the player. We take this one function from a actor, so when we overlap we do this. And I've made a somewhat beginner mistake here in that I really should have called the superclass. OK, beginner mistakes aside-- Victor: Happens all the time. Richard: Yeah. I mean, usually there's one catastrophic bug per stream. That's not it, but-- I hope that is it. You know what? I hope it's not my internet connection. That would actually be one that I can't demo and have fun with. But anyway, yeah. So just-- again, this is really simple. Like, you would only do this for a single player game, but it's just basic. Like, if this is player 0's pawn, then go ahead. Find all the things we want to trigger and go and tell them that the player did it. So pretty straightforward. And then you can write Blueprints that do pretty much whatever you want just by hooking up this event. Victor: We're not seeing the Visual Studio previously. Richard: Oh, I'm sorry. That's my fault. I forgot where we were looking. So you didn't see Visual Studio. I did that right. OK, let me-- sorry about that. Let me take you through that again. So here's our function in the I Triggerable actor. Our prop is super generic actor. It's literally an actor that is triggerable. That's all there is to it. We have to override this event to tell it what to do. And we give it a Blueprint event so that we can pass that on to our designers. I was saying this right here is where you would put that debug information. And then here's where we'd call the Blueprint event so the designers can do things like have the torch turn off and that sort of thing. Our trigger box, I just took the regular trigger box and I overrode just this one function so that-- this was the line I forgot-- but so that basically if it's the player, then go through everything in our target list, which is just right here. And this could actually be edit instance only, because you don't want to edit these-- you generally don't want to edit these in the archetype. You want to edit the in-level versions of them. But Edit Anywhere is just quick and easy. Yeah, so that we see everything here that's triggerable, and if it is, tell it to react to the trigger from our player. And that's it. So that's just a really super simple example. And it might look like that really early on when you start development. Then let's see what happens if I close Visual Studio while I'm streaming it. No, let's not. I assume it would be great, but I'm just going to do that then close it. OK, so that's all fine. But then-- yeah, we might have something like when the player enters and when the player leaves we do a different thing. But we also might want-- like, let's say you have a door, or even the sourcing. Maybe you want a trigger that turns it on or a trigger that turns it off, right? So each trigger now is not just a trigger, it's also a trigger and a, like, some sort of context information. Like, is this the door open button, the door close button? Should the torch light itself up or blow itself out? Like, what's it supposed to-- I know I'm getting triggered, but triggered to do what? So we need context information there. Now, the problem with doing this is, like, OK, so how do we add context information to that thing we just saw? Because it's just an array of actors. So that was a miniature mistake number 1 there. But it's the thing that's going to happen a lot when you're designing iteratively, right? Like, you just-- you wrote the thing to say, like, what actors do I need to trigger? And that was it. Now, to get extra information, what you probably want to have is a struct. So let's have a look at that. One second while I pull up the next one. And there we are. OK, so now we want trigger data. We want more than just that. And what is trigger data? Trigger data is over here. I just-- I could have put this anywhere. I just put it in the same file as I Triggerable, simply because if you're dealing with trigger data, you're almost certainly going to be dealing with triggerable actors, as well. So I thought that's a good centralized place to put that. All right, so we still know what actor we're targeting. And then we also-- we need some kind of contact information. Now, you could make this like a U Data Asset or a general UObject pointer and then whoever receives this will just have to know what to do with it. Just to keep it simple, I made it just an enumerated type. Default, turn on or open door or whatever. Turn off lights, close doors, whatever, like that. So now when we do this, we're going to pass the source actor, like we did before, and also some context information. So prop triggerable over here is now going to have to reimplement this function. Now, here's why we did this-- here's why, again, we want control over the base class. Because now I can implement this function again in code. For these torches, I might not care about the context data, and I could just call the same function here. Now, if the designer has decided that they want more data coming into that event, that's fine. That's a change on the designer's end. So when they make a reactive trigger function for their class, they can now take in this data. And this is a change-- [AUDIO OUT] --where you can't avoid having something happen on the designer's end. The designer wanted this context information. So there's really nothing you can do about it. They're going to have to rewrite that event anyway to contain the new information that they want. Am I-- am I OK on internet connection? I just got a warning about it. Victor: We did hear a little skip, but you're back. It's fairly inconsistent, so I think we'll be all right. Richard: All right, well, it is inconsistent. That is the right word. All right, so let's go into the editor with that and reopen those assets. OK, Now so here's what we have. All right, so this is what we want to have in the end. We want to have these actors and then we'll have this default. Now, the problem is that when we first change, it won't be that smooth. When we first change, we're going to have-- back over to this-- I wish I could share two windows, but that's not a thing. So when we first come back to the trigger box, the data that we had before is still going to be in this array here. Now, it's magically in this. And you didn't see the targets. You only saw the target data, right? So that looked like perfectly seamless and smooth. And that's what you want them to see. That's what you want the designers to see, right? Oh, I just loaded up the editor today and there's new code and now I have-- my triggers still work and I have this extra field there. So here's what we did. We went to UObject, and there's a ton of good stuff in UObject right here. By the way, I would recommend that you just look at the functions that UObjects have for post-load, pre-save, post edit change. There are a lot of really good functions here that can help you with managing data and with doing things when designers make changes in the editor. There's a lot of useful stuff there. But we'll start with the basic post load here. So what I did was I added a little post load function and I have a little log that comes out that says, hey, we're fixing data. So if the object has the old targets array, we take all that data out of targets. And then we take our new target data array and we make new entries to that and we just add in-- basically, we populate this field with the only piece of data we already have, leave the context enumerated thing at null or default or whatever. But then clear out the old data. Now, as soon as we re-save the level, this old data will be gone. We'll only have the new data. But as soon as we load the level, it's already fixed. So basically, if we hadn't done this-- if we didn't have this function, what would happen is we'd load it up and this field is no longer visible because we don't want people to continue adding data in the wrong format. We could leave it visible. I mean, we could easily just put edit anywhere back on it. But either way, target data, though, would be empty. So we'd be forcing our designers to go through and manually copy all the target stuff from the old format into the new format. That's kind of a pain. And worse than that, it's error-prone in a really invisible way. Like, they'd just be playing their levels and one of their triggers wouldn't fire. And if they don't notice it, then they just don't notice it. It's just not there because the data has sort of invisibly moved under their feet and it's not working anymore. But it's not going to cause a crash, either. It's just sort of not there. Those are the worst. I mean, the two worst kinds of bugs are bugs that are really hard to notice and bugs that happen like 1 out of 1,000 times you play through. Those are the absolute worst because you-- Victor: Yeah. Richard: Yeah. Your users are going to find that on the first day, if your game sells 1,000 copies, because at least 1,000 people are going to be playing, right? But you are going to have to run through your QA team 1,000 times to get it to come up. So those are the absolute worst mystery bugs-- silent bugs and mystery bugs. So to avoid that, that's what we do. We take the post load and we, say, OK, look. As soon as this object loads up at all, convert all the data. And this is not just something that happens on the CDO, the Class Default Object, right? This happens on every instance, which is why this is actually a viable solution. Victor, there's a link I'd like to put in chat. Can I, like, Slack that over to you or something? Victor: Yeah, go ahead and Slack that to me and we'll get it posted. Richard: So for object versioning, there are some more intense ways to do it. But for the-- like, I'm not trying to go into too much engine code-- I'm not trying to go into too much engine code right now, so I want to keep-- I want you to be aware of this, because this is for higher level object versioning. But it's not really necessary for what we're doing in this one. So I'm just going to put that out there. Oh, there it is, Victor. I just Slacked that over to you. And that should do it. OK, so back to the editor. All right, so back in here, our thing still works as expected. Torches still go out and we go between them. And as we saw here-- whoops, not here. Here. Our target data has now been replaced instead of just being actors with these things. Just automatically done at load time for us. If we don't save the level, it will have to do it every time. And I think you can-- actually, here. Let's clear this out. Don't save that. And you can see right here, highlighting black on dark gray, it's very visible. I hope you guys can see this right here. But it says log temp-- Victor: It's visible. Richard: Warning, fixing data. OK, good. That's readable. Good. So that was our warning that we put in code right here. That happens only if we detected those targets. If we save the level, that will not come up again because we emptied the targets out right here as we were-- right after we populated the new data structure. So this is the comfort stuff, right? This is seamless. It's under the hood. Your designers don't have to redo any work and don't have to risk any errors. That's the kind of experience that we want to create for designers as GPPs. All right, now to take this a little bit further, there's-- so let's suppose that we really like the named targets. And the named target data is-- I don't know, it's clunky. It's not great. I keep wanting to call this thing targets. And that really is a better name for it. So let's go to the next phase of this. These sources are not going to do anything amazing because I'm not an art guy. But what will-- they will be more comfortable to work with. The torches themselves are things for the designers to do. We're just making the tools so they can mess around them easily. So let's get into-- actually, let's get into our Visual Studio for this. That's what I want. All right. OK, so where's my Visual Studio? There we are. So _deprecated at the end of the name. This is an Unreal feature. So this is now-- and you notice, I don't even have this read-write. This is not visible anywhere. So what we're going to do here is we're going phase this old data out. So we're still going to have our post load where we fix the data. That's not going to be any different. And for right now, we're going to allow the legacy data to stay in. We're not going to delete it quite yet. We do have to go through our code and change everything from target to target underscore deprecated. But that's fine. And then you'll notice that in here we are still continuing to use only our actual, new target data and not-- like, this deprecate stuff hasn't been in use since the last version. So still for a while we're fine. Now, what we're going to want to do is go through and just load and save all of our levels one time. In larger triple-A environments, what you'll do is it'll be something like you do this-- like, I don't know, you have someone stay late and do it Thursday at 5:30 PM or something like that. You know, just sometime when designers are going to be using-- [AUDIO OUT] Victor: Yeah, we lost you there, Richard. Richard: What was the last thing I said? Victor: It's a good question. It was a little bit robot. Richard: OK. Victor: About 10 seconds. 15, maybe. Richard: OK, sure. So if you're in a development environment and, you know, like, you're working at a company. You're doing this. What you would want to do is you have all this deprecated data that you want to get rid of. So what you're going to do is go in and basically say, OK, designers-- Thursday or Friday night, check this in. Have all your files checked in by the end of the day Friday. And then what you'll do is you'll go in at, like-- you go in Sunday at noon. You check out every level. Open and save, open and save, open and save. And then you check them back in. Then when they come in on Monday, everything's done. So this is like how you do a one-time fix with minimal disruption to them. And we did this numerous times working on titles like Paragon. Like, this sort of thing would just happen when there was a big format change. And it's minimally disruptive. So does that all get through? Victor: Yeah. Richard: OK, good. Good. This is just how it is. All right, so now that we've got that through, we can come back and-- OK. That screen share run OK? Victor: You're back with camera now. Richard: Yes. Good. Now it's on my Slack channel. I don't want to share that. Victor: That would be the wrong kind of information. Richard: Yes. That's not something that everyone needs to see. I'll talk to you later, Visual Studio. Thank you. OK. So we also have the-- I mentioned pre-save. Pre-save wasn't useful in this particular case. But basically if you had data conversion that you wanted to do just before-- just before when you save an actor or a level, that's the way to do it. Sorry, let me get my notes here. All right, so we want to-- in here. So at this point, we can rename. Now, the way we rename without totally destroying anything here it we use what are called class redirects. I guess I should open these in here. So in your Config, Engine-- oh, and there's a page on this. I will get that to you in Slack so we can get that onto the channel. Victor: Great. And for everyone's visibility, we'll make sure to add these documentation links to the forum post announcement, as well as the YouTube description. Richard: Yeah, these are really useful resources. There you go. So these are called core redirects. Now, you can redirect-- you can rename things in enumerated types. You can rename whole classes. You can rename individual properties. In this case, we took the player generic-- oh, and by the way, this is the name as it appears in Unreal. That's why there's no-- it's not a player generic trigger box, like the class name here. That's, you know, like a UObject. They take off the U. The struct's, like, f trigger data. They take off-- they drop the f actors. They drop the a, stuff like that. So it's the Unreal reflection name, which is player generic trigger box, not a player generic trigger box. And here was that. So we took that trigger data field and now it's called targets. And then we can freely rename-- like, I literally just renamed that field from target data over to targets. And that's it. While loading the engine remaps the class name. So now we're back to using the original name with absolutely no disruption. All I had to do was check those two lines-- the line saying we're doing core redirects and the line saying, here is the one core redirect we're doing. You just check that in and check that in with your code where you change the property name. And there you go. Now it's renamed and the designers have it and they didn't have to do anything. It's just there. It's just fixed for them. So that's a feature that I don't know if a lot of people know about it, but it's just-- it's right there. It's right under the hood and it lets you move these things around without any disruption to your designers, which is your ultimate goal. OK, so that's a lot about moving data around. But I find that that happens pretty frequently. We don't need to show that there. So let's talk about something else you can do here. And this is-- we can go into a little more detail here. I really just want to talk about the basics of it, but let's open it up. All right, so one issue that we come up with something like this is that when you're editing-- and this doesn't affect our current situation because it's so small scale. But it will matter as soon as we start doing any real or serious development. My Unreal Engine is just starting up. Once it starts up-- Victor: And those redirects, they happen a lot under the hood when you're working inside the editor, as well, right? I remember sort of changing collision names for collision groups and such. And you know, I thought it was just over writing the actual data. But if you go and open up the config file, you can actually see that all of those changes are reflected there as redirects. And that's just happening underneath the hood. Richard: Oh, yeah. Yeah. Actually, if you look through some of the Engine's config files, you can find a huge redirect graveyard in there. Yeah. So that's all in there. That's already kind of all baked in. And it's pretty fast to do. Yeah, it's a pretty smooth method. And it's much better than trying to convert your data and possibly having left something out. In addition, if you really want to be neat and tidy-- and I know a lot of engineers-- and I do the same thing. Like, we all want everything to just look like it was cast from a mold. Like, you can came up with this game and just wrote it as it just came out your brain. So if you want to do that, you can go back and delete the redirects once you're sure that you've resaved all the levels, because at that point they'll all be saved under the correct names and it'll be fine. So you can clean these up eventually, but you don't strictly need to. If you don't have that-- like, everything under the hood must also be perfectly clean, like, obsession that I know a lot of us do. But if you don't have that, you don't have to worry about it. And if you do, you can clean these up after you've resaved the data, because then that new property name won't even show up. And at that point, you could actually even reuse the old property name if, for some reason, you wanted to. I don't know why you would. But yeah, so OK, so coming back, we have-- Screen share. OK, so the-- I'm sorry, hold on. It looks like-- OK. I may have pressed the wrong key twice. One more time. Victor: Try it again. Richard: I actually had actually two copies of the Engine running and I'm not sure which is the previous thing and which is the new thing that I just came up with here. Victor: I'm sure that was not the first time that happened. Richard: Yeah. OK, so this should be shareable. Zoom still thinks I have, like, several of these in here. All right. OK, that-- nope, that's not a real window. That's not a real window. Victor: Are they Unreal windows? Richard: Oh, man. Oh, man. I did walk into it, though. I asked for that. Victor: You did. Richard: All right, can you see this one? Victor: Yeah. Richard: All right, this is-- yes, this is a real Unreal window. So all right, so here's our-- oh, by the way, if you did not resave them, you get this result. These are-- because these were never, ever resaved from the original. And now we've removed the post load and all that kind of code because it doesn't-- the post load code can't compile anymore, because there's no old field for it to come from. So this is the result of catastrophically messing up and forgetting to do the resave at multiple stages in a row and then deleting your old data and your post load code. So don't do that. If you did resave it, it'll be fine. And oh, look at that. So if you have a lot of these things on the level-- and I've actually encountered this situation before-- OK, torch prop. Which one are you? OK, you're that. But now I'm over here. Which trigger-- I was working on this trigger, right? OK, yeah. And then the other tor-- OK, it's that one. OK. So I was working on this trigger. Right, like, see that back and forth flow, how that just kind of, like, wasted 10 seconds of the designer's time? Now, multiply that by how often designers have to select things and think about them and how many designers are on your team and suddenly writing a little bit of code becomes really worth it. So what you'll notice different about this one is these thick red lines that take from my trigger and show me all the things that it attaches to. Now, this was done with a-- there are a couple of ways to do this. But the one that I think is the most official way to do it, I guess, is the visualization component. So I believe I have a link for that, too. I should have a link for it, but I don't. One second. I actually had the page open in my web browser, just to make sure I was following my own best practices as I wrote that page, as well. All right, so here it is. Oh no. Sorry. That's the wrong one. One second. You know what? I'll find it-- I'll find it a little later. It's taking me too long to find it. It's just the Components page. But-- actually-- yeah, if you could find the Components page, that would-- Victor: I'll go ahead and find it. Richard: Yeah. Just look-- when you find it, just look down to make sure it has a section called Visualization Components. And then that's the page. Sorry, I thought I had the link-- I thought I had the link right here, but apparently I didn't. All right, anyway, so these are called visualization components. And there's an invisible extra component on this, drawing these lines. So let's see how we write that. Zoom, if you would. I would like to share this Visual Studio window, please. OK, so here's our trigger box. Here's some lovely functions that I didn't need for this one but I want you to know about because they're great. And here's one more little neat one. We don't need that. This, by the way, is-- this is one way to do it that I don't think you really need to do. But you can override this function-- and by the way, the default version of this function is just return false. That's it. You'd override it to say, return true. So just like this. So what that will do is that allows your main actor tick function to run in the editor and you could use that to draw debug information to the screen or anything like that. So that's a pretty useful thing to do. But the reason I don't recommend doing that all the time-- see, that's fine for a trigger, because the trigger doesn't do anything. It just sits there and waits for overlap events. But what if you had something like a squad manager? I think probably the most famous version of this would be the AI director from Left For Dead. Valve made a big deal about-- they PRed that one out. They let everyone know that was in there. So you have this overriding actor that is controlling the monsters in the game. And that's really useful, just like we had our trigger that shows us what the trigger's connected to. That kind of thing would be really helpful to know about. And you could look at it in live play and that sort of thing. The problem with overwriting the tick function there is that that probably actually has a tick function that does something and you don't want it trying to run all your in-game AI code while you're looking around at a level editor. And you certainly don't want it moving or doing things or spawning monsters as you run the editor. So that's why I don't recommend that route, although it is perfectly viable and pretty easy to do. Instead, we go with visualization components. So we make our own component. And is this visible? Is this coming through clearly? Victor: Yeah. Yeah, we're seeing it. Richard: All right, great. And it can be really simple. It just needs its own tick function. This is a component. It's a tick component. You'll notice that components, when they tick, get a couple pieces of extra information that actors don't. And we can go into why that is. But basically, it's because here's what an actor's tick looks like. An actor's tick-- see right here? This is where that-- this is exactly where that function is used. An actor's tick has this information. But the function that it calls doesn't. That's all there is. Well, it's tick actor, then this calls tick, which only gives you the delta time. Back to what we're doing, though-- So tick component gives you a couple pieces of extra information. This one is pretty important. We're not going to use the last one, but we are going to use that. And we're down here. So we want it to be able to tick in editor. So we tell it that it can tick in editor. And I definitely want it to be able to tick, and I want it to start with the tick enabled. So that's pretty much the same thing as you'd do with a primary actor tick for an actor that you want to do things every tick. So then we come down here. And if we're in the level editor-- by the way, there aren't very many of these things. So this is what you get when you're in the level editor. This one is what you get when you're playing the game. And here you're playing the game, but you're paused. I'm not exactly sure what this is. I think this is when you're in the editor but you're not updating the viewport, possibly like when you're full screen editing a Blueprint or something like that. I'm not exactly sure when that one is. But the one we want is this. So if we're in the right type of tick and is owner selected-- there's an is selected function on actors that lets you know if you're in the editor, if this is selected-- it returns false if you're not in the editor-- is owner select is basically the same thing. It just calls get owner and then checks is selected on that. Saves me the time writing the null check that I can just call this convenience function. You know, make sure we have a world and all that sensible stuff. And then what we can do-- yeah, you can make this a friend class if you want to do this with data that's not public. What I did here-- or you could even have the trigger class set data onto this one. But basically, what we do is we just say, all right, our owner is supposed to be a trigger box. If it is, go through its targets. Make sure the target has an actor, because when you've just added new target data, it's going to be null. And the very next frame, that's going to show up and be null. So you actually have to check this or you will crash it as soon as you add an actor to it. And then we just draw a debug line from our base location, which is where this component is. We could also have called get owner, get actor location. That would have worked, too. And just a red line. Give it some thickness, whatever. And then I gave it a really short duration, one millisecond, because we're going to do this every tick. So basically by the time the next tick comes around, this line will have wiped. Now you'll notice there are a couple of things that we can do with this. So first off, is owner selected? So looking back at our editor, oh, there's my login. So looking back at our editor, we see, like, if I deselect it, the red lines go away. So supposing that I wanted to stay around, we could put a Boolean on this that we default to true, or we could just take this check out. Victor: I really like how it's automated by just selecting the actor. Richard: Yeah, I mean, I really like that feature, as well. So-- Victor: And you don't have to explain it to anyone. It's sort of clear-- just intuitive what happens there. Richard: Yeah. Yeah, it's just-- it just makes sense. Now, what we can do-- let's see how long this takes to compile to figure out how much of this I'm just going to explain versus show. Hey, that's not too bad. 15 seconds. That's acceptable, I would say. Oh, what screen am I sharing right now? Victor: We're on the editor. Richard: You're on the editor. OK, so you-- so you did not see what I just did. OK, no problem. All I did-- it was pretty simple, but I intended to show you. Right here, I just took that out. That is owner select, gone. So now doesn't matter if it's selected. So now I could be working with whatever object I want, and I'm always seeing-- Now, that could get a little cluttered, visually, if we had a lot of these or, you know-- you could have just, like, spider webs going all over your levels. Like, it could be too much. So there are other ways around that. For example, you might-- and then this is where we get into that-- this is where you-- did I not show you that? I didn't-- I didn't switch my screen to the editor, did I? Victor: No. Richard: Sorry. I thought I clicked it. I think I just put myself in. OK, so here I'm showing, like-- see, I'm working with other objects, and it's still showing. But again, as I was just saying, if you had a lot of these and they connected to a lot of different things, you could start getting just lines all over your display. And it gets cluttered. And that's not ideal. So come back in here. And I hope you can now see this. Victor: Yeah, we got it. Richard: So now what we'll do is we'll go to the trigger box-- oh, by the way, I set this up with if is editor-- or with editor only data, because there's no need to spawn this component or even think about it in a non-editor build. Like, we don't want this in the final game. It's just a waste of, like, memory and CPU cycles to spawn this thing, so we don't do it. Oh, one other thing I-- sorry I skipped telling you this. When we create this thing, we also do that in is editor only. So if this component is null-- and I made it a UProperty. But you don't have to. I just-- I just chose to. It's fine. We create it just like we create anything else-- TVC for Trigger Viz Component, which is short for Trigger Visualization Component. So we create it just like normal. We attach it to the root component. Nothing really special here. Then we set that. That's the only thing. You just have to tell it that it's a visualization component. And it works as if by magic. So that's pretty much the only thing we need to do. Oh, by the way, if you want an output for just this thing-- you may notice I'm using this log, ES designer. So ES stands for Editor Stream. This is a log category that doesn't exist, except I made it up, so it does. So we can declare it here and here with just these two lines. So in an h file, declare log category extern, this is like the default level for it. Like, we get like warning, error, and then various, like, levels of verbosity. I only ever use UE log. So I specify that every time. So I just always use log and all. But there it is. You come up with a new log category. And then you put it here. And now you have your very own log category. So if you want to do a lot of debug output with this, you can put this in and designers can turn it on just to see this one thing. Or they could turn off if you're spamming the log and they don't want to be bothered with it. I use log temp a whole lot, but we can use-- just like we normally do-- like I use log temp warning. That's like, that's completely muscle memory right now. I can do that in my sleep. But for this, log es designers, there we go. We have our own log channel just for this thing. So that's just a helpful thing that we can do there. And designers can filter that out easily. I'll show you the settings for that in the editor in just a second. But anyway, so we're drawing these lines, and we want to have a feature so that we can say, hey, look, I'm working with this one specific thing. I want to see this even if it's not selected. Let's make this an editor only property. I didn't make this a friend class so I'm going to make it public. Be careful about switching access levels. You know what? Actually, that's such a bad practice that I'm not going to do that. Don't switch access levels inside of macro. You will get a nasty surprise when you're in some other build and something doesn't compile because this public was bleeding out to something that was down here outside of the if block and then you don't know why you have an access-- an access problem. Victor: Is that the tip of the day? Richard: Yeah, that's a little C++ tip there. Just-- that's not the obsessive level of cleanliness. That's the practical-- they get 50 errors when I go to ship and build level of detail there. All right, so let's make a bool. And I just always do this with bools. Debug, display, always. That's a terrible name. Don't name your variables like that. Victor: Not too bad. Richard: Keep debug display on. Victor: That's better. That's better. Richard: That's better because that first one didn't make any sense. And then we put a comment on it. So they can see-- if they just look at that and go, what? Then OK, here's a comment. Victor: Yeah, being as verbose as you possibly can only adds to the ease of working within the project. There are no downsides to writing more information, unless maybe we're talking several pages of comments. But maybe you should try to compress that a little bit. But other than that, always being as verbose as possible with your variable names as well as comments is usually appreciated by the next developer. Richard: Yeah, it definitely is. It's a huge help. I think advanced display is the right term for this. If it's not, I'll just delete it, because it's not really important. This doesn't need to be visible in Blueprint. I'm going to leave it edit anywhere. Instance only is actually what you want, but I don't know. If for some reason you-- I don't know. Oh, and you know what? Actually, transient. Like, I don't even need to save this because just because you turn-- well, if you want to be able to turn this on in one session and then save the level and reload the level and it's still turned on, then don't make it transient. My way of thinking about this is this is like temp. Like, you're just working with this right now so turn this on. But I don't need to save the level with the knowledge that the last person who was in here asked for that thing to show its debug info. You know what I mean? Victor: So for the developers here who are a little bit more familiar with Blueprints, transient might be a foreign term that they do come across in the editor. Would you mind taking a moment to just explain what the difference between a transient and a non-transient UProperty is? Richard: Sure. So transient, very simply, is data that does not serialize. So when you are loading or saving or transmitting it over the network, this data-- it's not there. It just doesn't show up. So basically, we're saying this is a UProperty field. But when I save it, don't save this field. And when I load it, don't try to load this field. It's just-- this is just temp data. So yeah, don't put that there if you want to save the data. But-- Well, same thing with this, actually. Victor: And why would you-- why is there a benefit to make some data transient? Why don't you just leave it all to be not transient? Richard: Well, you could. But it would just end up being bloated properties in your files. It's not really going to hurt anything. It's just going to make things a little bit-- like, it's not going to break anything. But it's going to make stuff just a little less efficient. And it's one of those things that maybe can add up over time. Or if you have a certain data structure that gets saved a lot and that data structure has some temp data like maybe let's say you're passing through-- you're doing like a linked list or something like that and you're passing through-- or breadth for a search-- and you need to check off the nodes you've already visited. So the node has like a checked off thing on it. Well, that can be transient data and it can be editor only data so that when you're in the real game it's editor only so it's not there in memory. It's not wasting memory on these structures for something that only happens in the editor. And also the UProperty is transient so it never saved the file. So when you're loading it, there's no, like-- during the cooking process or anything there's no, like, it loads up the property and then, oh, this property doesn't exist in this thing. OK, so take it out and continue. Like, that will cause an error, but it'll just subtly slow things down. And it won't really matter for most small scale games. It would matter if you made little data mistakes like that in, say, Fortnite. Like, we would-- it would take significantly longer for everyone to do cooks or to load up their editor. It would-- depending on what kind of mistake you made, it could impact load time on customer machines, which is your giant player base. So these are the kind of-- I kind of think of these as like little burrs that you really want to sand off. Like, if we're going to use, like, a woodworking analogy. Like, you just want to sand off all these little burrs because individually they're not terrible, but they will add up. So let's say we're going to keep-- oh, by the way, this is just how I do bools, because if you do this, that will-- and this is not an Unreal thing. This is just C++ thing. But that's 32 bits. That is 8 bits and the next 7 of them are free. You could also do this if you wanted to. That'll be 32 bits but the next 31 of them will be free. So this is just a habit that I'm in. And the editor knows that I did this. So the editor will treat this as a bool and will subtract the initial b from the name and everything like that. Like, it'll be a checkbox. It's exactly like a bool. This is just a good general habit. All right, so we're going back in here. We're going to write this-- we're going to write live code. We haven't had any errors yet, so I'm really begging for something to crash or mess up in some horrific way. It's been a tradition that I have this happen every time. All right, so if either the displug-- the displug? That's-- either the debug display is permanently on or the owner is selected or both. And when I said that, I meant-- ooh. Ooh, I need this up here now. Well, all right. I'm going to restructure this if just slightly. Yeah. Just because-- see, this isn't on the component. This is on the thing that we haven't gotten here yet. So really, that's just checking that because that's a pretty quick check. By the way, this level of efficiency is also just me being obsessive, because this code only runs in editor. So it's really not a big deal and it won't affect your frame rate in the actual game. But still. All right, so now we can check if the owner has keep the debug display on or if the owner is selected, then proceed. All right. And hopefully that code that I just wrote for the first time is going to be fine. Should be. And hopefully this will compile quickly. So you guys can-- yeah. We're still-- we're still sharing Visual Studio, right? I think it looks like it's moving. Yeah, that's about the-- so Victor, this is what I was concerned about. Right before-- yeah, about 20 seconds. Right before the stream, I did one of those and it took 107 seconds. And that's the only time this project has done this ever. But it's right before the stream, of course. All right, so let's get back to here and see if that code worked. I hope it did. OK. So that display-- oh, good. Hey, look. The advanced display was right, as well. So I hid this. This is a little debug option down here. Oh, I meant to say this, too. So here we go. Like, here's the thing that loaded weird. That was-- that was from that thing where I said I didn't save it. So you can see it actually-- sorry, this is a little off. This is where we were earlier. When I said earlier-- remember, if you've never resaved it and you missed every possible opportunity, here's where it'll mess up. This was it. It's tried to load the field targets, which used to be an object property, because it was just an array of actors. And now it's a struct property because it's an array of structs. And that it was in the map that I said we purposely never resaved. That's the kind of thing. That's also what I love about this. Look at this. I just-- like, I didn't know that was there. Or I forgot until I just filtered that off. Also, our log ES designers thing is somewhere in here. I actually don't see it right now. Oh, it might be because I don't have any UE log calls that actually use it. It might not show up if you don't actually use it anywhere. But anyway, OK. We'll get back to that later. All right, so this advanced display, when you have that in one of your UE properties, it puts it in this little window right here. OK, so now keep display on and we go somewhere else, it's still on. And then if we come back to it, we turn that off, it's on until we go away from it. So that way you can say, OK, look, I'm working with this thing. Just keep it on, because I'm going to move around a bunch of these torches and I want to-- I want to have lines showing me which ones are the correct ones as I go between them. This would be, again-- like in this case, this doesn't look terribly useful because I have one trigger and two objects. But you can imagine in an environment that isn't trivially small like this it actually starts to add up. Now, we can also add even a bit of prettier code here, too. Again, this is where the part of me that is a little bit of an artist-- not an artist, but a little bit of an artist-- starts to show up to make this stuff a little more comfortable. So let's go back to here. And one thing I really like is that-- there we go. Starting to get good at that. So one thing I really like is this debug library here. I'm not sure if you need to say don't include this in shipping, but you don't need this in shipping. I didn't put this in just because I think if you leave this function call and you don't put that in a-- don't do in shipping, it's bad. But anyway, it doesn't really matter. The important part is to pick whether you're going to do this or not and then do it consistently everywhere. So drawdebughelpers.h. And you can get functions like draw debug line. So that's pretty cool. Now, we can make this a little bit prettier. So instead of just drawing a line-- this code I did write in advance. All right. So we're going to take the clipping bounds of the actor. We're going to get basically its origin and extents. And then we're going to get the-- like, the radius of those. This is going to be a half size, so we'll treat that as a radius. And then we get just the direction from our actor, the trigger, to the actor that it's targeting. If it's small enough, we're just going to draw an arrow to it. Yeah. If it's small enough, we'll draw an arrow to it and circle it. And if it's not, we'll just draw the arrow, because it's too close. OK. So you know, the directional arrow, and you can look through these different arguments. Like, this is a depth argument. I'm basically saying this is a 0 to 255. I'm basically saying draw over top of everything. This is a depth priority argument. So that's pretty cool, because that way if it goes to the wall or whatever, you can just see it. 255 is maybe taking it a little too far, but now you have things like this is like the thickness of the lines and this is the length of the arrow head. For the sphere, you have this right here, which is the number of-- because the sphere is obviously just drawn by a bunch of lines making, like, a rough cage. So it's how many-- like, how many slices of the sphere do you want to render? If you wanted to be really cool, you could maybe figure out how big extents might be and then put more stripes-- you know, more slices to your rendering if extents is bigger. That's a little bit of detail. But yeah. [AUDIO OUT] So now it looks like this. So now when we circle these things, we get these arrows-- Victor: We're still in Visual Studio. Richard: Oh, yes. I was getting better at it, and then I forgot that I can't just do that. OK, so now it looks like this. Right. So this is much friendlier to work with, and it's much clearer, too, because you had other lines like these axis lines and whatever going around. But these lines are more clear. And we have the spheres so we know exactly what objects we're working with, and all the same features. Whoops. That's not it. All of the same features still apply, like turn off and turn on. If you wanted to be really clever about it, your visualization component could keep a copy of this array right here, this targets array. And you could detect when a new member is added, and maybe make that one have the sphere pulsate or, like, blink on and off for a couple of seconds, something like that. Again, that's just making it a little more fun and a little more comfortable. And although it doesn't have to be fun fun, like the actual game should be, having the tools give you little pleasant bits of feedback like that helps-- especially in crunch, it helps designers-- it's just a little bit more fun to interact with your system. It's a little bit more toy-like, to use the-- I don't know, Ubisoft and Shigeru Miyamoto both have this same concept, but I've gotten it from both places. I'm going to say it probably originated with Miyamoto. But the idea of making everything individually fun to use. The example that people usually go with is, if you put Mario from Mario 64 in a little room with nothing to do but he could jump around, it would still be pretty fun. You could still play around with that for a couple of minutes and it would be fun just to do that with no enemies, no challenges, no stories, just Mario jumping around in the inside of a cube. So the same thing here, it helps to keep your designers from burning out during work sessions and it just helps to sort of keep them moving through the day if these things are just a little bit more pleasant to interact with. Actually, a similar story to that-- it's an Epic story. It predates me-- was that when they were working on-- I think it was-- was Unreal Tournament? I'm not sure which one it was. One of the gun sound effects was just so fun that Cliff Bleszinski would just sit there and just play it repeatedly until the person at the next desk would come over and be like, hey, stop. But like, it's that kind of thing. It's making this a toy for your designers that makes it just sort of fun to use. It just sort of keeps them in a creative and fun mood for longer. And you end up with people who can work longer without getting burnt out and also who are just sort of having more fun and being more creative when they work. So little upgrades like this really help. So yeah, like if we had this and you added a new torch-- if we didn't program this but if you had this and you add a new torch, and then it-- see, this is why we null checked this. Right now this would crash if we didn't have that null check on actors. Now, if right there that sort of blinked into existence or pulsated and grew or changed colors as it glowed, anything like that, that would be just a little bit more fun. We could also make it so that whether we-- whatever we said here, like default on/off could be like red, yellow, green, or dotted lines or anything like that, you know, you could surround it with a-- instead of a circle, we could surround these things with a sphere. We could get like a square or a capsule. That's actually practical, too, because that gives them a little bit more visual data just looking at it. But so that's the kind of thing we want to look at. And so if we go back to the code and we see just how simple that was to do, and then we go back to imagining that this isn't here-- I actually won't have to imagine. I'll just disable it. OK, cool. So-- see, and this time, I remembered to do that. You're supposed to do that. OK, so that. But, I mean, you see how simple this was-- [AUDIO OUT] It's a couple of ifs. I'm just basically-- and then all I've really done-- I mean, this is the real meat of the code right here. It's just, draw a circle around the thing and draw a line to it. Like, it's really a small amount of code when you get down to it. But it makes this-- I mean, it looks like something's missing at this point. Victor: Yeah, you're right. Now that we're used to seeing them it's sort of like, oh, it's gone. Richard: Yeah, like, wait, where-- well, wait, what torches do I have? Especially if you just open it up and it looks like this. It's like, oh, I got two things? Awesome. Which? You have to imagine that this is a large level full of lots of objects. Like, you're actually making a full game instead of a tiny demo. Or you know, does this open that door or close that door? Does this turn them on or off? Like, what does it do? That sort of thing with no visualization here, suddenly this looks really barren. So let's turn that back on because I don't even like looking at that. Victor: Have you ever met a programmer who actually wrote a little mini game as part of-- sort of an editor tool? Richard: I probably have because I've met enough that I'm sure-- Victor: That's what it made me think of. It's sort of like, yeah, having the debug tools would be a little mini game as you're doing it. Maybe that would be the distraction that a producer would come and say, yeah, that's awesome. Cut it. Richard: Yeah, I mean, there's a line here. But like, I feel like the value of that speaks to itself. And we-- oh, wait. I didn't share it, so it doesn't speak for itself because you can't see it. OK, so yeah. I feel like the value of having that show up-- just wow. That just sort of speaks for itself. And then the debug value of like, hey, I can move around and edit stuff, and I still know what-- like, what object I was working with. Hmm, you know what else would be a cool button? I don't-- how much time do we have? Should we be taking questions? Victor: We've received a couple. Do you want to go through them? Richard: Yeah, just another cool thing you could do here is you could put a button on this thing that goes through the level and turns off all the other triggers debug displays. Victor: I think we'd definitely like to see that. And we do have time. Richard: OK, cool. Talked myself into that now. Let's do it. All right. So actually, I'm really glad that we're getting to do this, because this is one of my favorite things to show, or one of my favorite things to use, which is in editor-- in editor buttons. And they're shockingly easy to do. OK, so Victor, if you can find the page called UFunction Specifiers, that would be a good one to link. All right, so what we're going to use-- I need to find the correct-- Victor: Is this one function specifiers when declaring functions? Richard: Yes, yes. Victor: OK, yeah. Richard: Yes. So this specifier is listed on that page, but I mean, it's a big page and I wouldn't be surprised if a lot of people have missed it. Let's get my editor stream back up. All right, so-- Victor: We got it. Richard: Let's go in here. All right, so we're going to have a UFunction. And I'll just put here. It doesn't matter. This is not where I would normally put this, but-- all right. So this is the thing we want here, a metadata thing, CallInEditor=True. And we're not going to take any parameters on it, but-- Let's make this simple. Oh. OK, this could be done with-- what I'm about to do could be done with a checkbox. But let's pretend that, for some reason, whatever we're doing we don't want to do that way. So now really what you would do is, like I said, you would probably iterate through all the other actors on the level and you would have maybe another bool that-- or you know, you'd just have this bool, keep debug display on, that you would set to false. I'm just not going to do that because then I have to go to the editor and make more stuff right now on stream, and I want to show this quickly so we have time to get to the questions. But yes, let's do this. So void toggle spheres. And then we have to write what that actually is. Make sure that you're writing this-- now by the way, since I did all of this completely within an editor-only data block, I need to-- I need to make sure-- And I always like-- you don't have to do this, but I always like to tag mine like that. OK, so we're in here and we're going to need a variable to track what we're doing. So we'll make that. No user's ever going to see this, by the way, because this should not be displayed anywhere. But still good to put it in for other programmers. Oh, by the way, this is a feature I wrote, like, a while ago that I just figured I'd announce here. If you do this, a comment like this, or like one of these, that comment will not show up as a tooltip. So if you're writing stuff like this, that's only good for other-- like, other programmers need to know that. Like, for example, if we had a UFunction or something, or if we had, like, a UProperty, and it was like this-- and we just didn't like-- because like, begin a actor interface is not a good description of the tick function. Right? Like, I don't want it picking up on that if this function were to have a visible description to anyone. So I do this and it's code only. It only shows up in here. This one's not going to show up anywhere. It's transient and it doesn't have edit anywhere. It doesn't have any, like, Blueprint read-only. It's just totally invisible. It would be advanced display if it were displayed, though. OK, so b show spheres. So this function at [INAUDIBLE]. There we go. That's pretty straightforward. Now, down to here, this is the one that shows the spheres. And what did we call our owner? We called it this. All right. Maybe this won't work. Something is going to not work. Man, that all looks correct, though. It might just, like, actually work on the first time live in front of people. Victor: Ship it. Richard: Yeah, it's unrealistic. Like, this is not-- this is not how it works. It's like if we ever did anything in, like, a gym class or whatever and, like, the coach comes over, like, that's the time when you throw the basketball completely over. Like, you just-- you miss it and it bounces off the bleachers, doesn't even hit the backboard because the coach looked. You could be sinking them all day until the coach looks. All right, that compiled. Don't know why. And yeah, so-- OK, wait. Maybe it failed somewhere else because it's not showing up. Oh, I didn't give it a category. Where is that going to show up? Hold on. You're supposed to give those categories. [AUDIO OUT] Actually, I didn't-- didn't share that screen with you, did I? Victor: No, we were still in Visual Studio. I wasn't sure where you were going. Richard: Yeah, I wouldn't [INAUDIBLE].. I guess you could make the Blueprint callable. I don't know that you need to. Category equals-- well, debug features? Victor: I'd say that works. Richard: Yeah. All right, and I hope that this works. If it doesn't, won't be the first time. Victor: And it won't be the last. Richard: Yes. You know, the funny thing about that is, even if it manifestly doesn't work in front of you and you see it-- like, I prove that it doesn't work on the stream by doing it, it's still right, though. It'll still work when you go do it. I'm not making it up. So it's still good information. All right, so there we are. And yeah, I don't-- oh, no. I do see it. Nevermind. OK. Victor: You want to go ahead and share that? Richard: Oh. Victor: I'm on you. Richard: Third time's a charm. Let's just-- OK. Wait. Hold on. We're not displaying anything here. Victor: We're seeing the editor now. Richard: Yes. But we're not displaying any of the spheres. So let's go back and debug this for a second. Well, maybe we can even use our fancy new channel. OK. Warning is my favorite level because it shows up in bright yellow. It's easy to pick out. And you can filter it and there aren't a lot of things that use warning. Just clear it out if you do. Like, use this as temporary debug and then clear it out before you put your code back into source control. And then let's check down here. IfShowSpheres and this thing that was already working, then do this. And this is all-- right. This is still working. We don't have that return line in there anymore. Yeah, this should all be good. Should. All right. Now let's share the editor again. Well, for some reason it's not showing up at all. Let's see if we can find our-- well, we know that it called it, because our special, unique child that we just made up does, in fact, work. Let's see if that shows up in the filters now or if we have to restart. Oh, no, hey. Look. It's right there. Log ES designers. Yeah, so I guess maybe it didn't show up in the filters before because I didn't have a single reference to it anywhere in code. Like, it might-- the engine might have actually picked up on that while compiling and just didn't put it in the list. That's entirely possible. It's pretty clever. But-- Victor: Yeah, that is actually-- Richard: I don't know who wrote that, but that's cool. OK, so I don't know why-- yes, I do. Because this is the map where we didn't resave the data. That's why. It's the map where we didn't resave the data. And so I said this would mess things up and you wouldn't know why it broke them. Remember when I said that? Victor: Sure did. Richard: Yep, that was correct. OK, so now let's find out-- yeah, by the way, debug features, this is not a great place to put this. This is way down. It even shortens the arrow for you. Look at that. Beautiful. Victor: Is that in order of alphabetical? Doesn't really look like it. Richard: It is. And there is-- on that specifiers page, it might be-- it might be that specifiers page, or maybe the-- like a UProperty specifier. Actually, it might be-- I think it's in metadata. But there's this whole thing that was written a couple of releases ago that lets you give priorities to these things so that they don't sort alphabetically. So you can actually tell it, like, your sort priority is like, 3, 4, 5, 6, whatever. And it will list those in order. Or you can even tell it, sort before and then name another-- [AUDIO OUT] It could say debug features sort-- [AUDIO OUT] Victor: We lost you there for a little bit, Richard. Maybe 10 seconds. Richard: So that's an-- am I OK, Victor? Victor: Let's see. I think you might be back. Richard: So-- Victor: All right, you're back. Richard: OK, good. We're back. OK, so let me see if I can find this. So there is a page-- I think it's one of the specifiers pages-- where you can prioritize those things. So by default, they sort alphabetically. But you can set them to have different sort priorities like a number, like 3, 4, 5, whatever. Or you can also say sort before or sort after. So for example, I could say debug display sort before shape. And it would appear like right here. Or debug display sort after player generic trigger box. And it would sort, again, same location. So yeah, you can actually make this more comfortable for designers, not make them have to, like, pick through all the stuff that they probably don't really want to mess with. And incidentally, these categories-- if you look at the U class specifiers-- you can say hide this. So like, I mean, look at all this stuff here. If I'm making a single player game and this is an invisible object, like, virtual texture, rendering, replication, like, and a lot of this stuff just isn't relevant and the designers don't need to see it. You can hide-- you can just type hide categories equals and then quote and a comma delimited list of all the category names that you don't think designers will need to see. And those will just not show up here in this pane. So looking through that-- like, the specifiers page that I sent you there, you'll find a ton of useful but, like, we don't really-- well, this is why I'm announcing them out loud today, because we don't really, like, make a big deal out of them. But they're really, really helpful. And you can-- like I mean, you saw even just here. Going through and, like, finding this to do this-- I had to scroll down a bunch and collapse a bunch of things and whatever. If you don't want people to have to do that, well, now they don't have to. So yeah, look through the specifiers pages, because there are a lot of little things that can help to just make things more comfortable for your designers. Anyway, so yeah, that's about what I wanted to show today. And you can kind of see the potential to do-- this is just a small scale example, but the potential to expand this is, I think, made pretty obvious by the stuff we've been showing today. Victor: Yeah. And I think it's sometimes also good to expose the entire crew that might be working on your game sort of to how the different people on the team can help others, right? And so an artist might not even be exposed to the amount of extra work a programmer does to sort of help the designer. And by just knowing that there's might be a possibility for him to go, oh, you know what? This would be really useful. And they can go to the programmer and see if that might be something that they'd be able to implement. Richard: Yeah. And also just, as you get into the habit of doing this stuff and trying to make it more comfortable, this actually helps you as a game developer, as well, because this is just more practice at thinking, what does my user see? What does my user want? And sort of anticipating the user's needs and just making everything feel really smooth, that's exactly-- like, for me, that's one of the biggest parts of this discipline. And so this is just more good practice. All right, so one question I see here that I was actually just going to admit ignorance of, but now I've been effectively called out by someone asking, what's the difference between with editor and with editor only data. Victor: Yeah, that's a good one. Richard: I actually don't know. And in some-- I mean, they're very similar. Generally you would use with editor only data around, like, properties, and you would use with editor around stuff like code, like the post edit change function that I talked about. We don't need to share that. So actually, let me go back to Visual Studio for a second because I just-- I just want to show what function I was talking about. Victor: Yeah, go ahead. Richard: And bring that up on the share. OK. So this function, post edit change property, this is a with editor only kind of function. Let's go on a magical journey and see where this takes us. So hey, that's the exact one I want. Thank you. So this is the kind of thing that I will only override in with editor only because there is no reason even to compile this code if you're not in that-- and actually, I think-- yeah. Even in actor.-- or actoreditor.cpp here, even in the engine source, it's in with editor. So it actually won't compile if you forget to do that, because you'll be trying to override a function that it doesn't know about. So it will fail to compile in shipping if you try to do this. So you actually have to do this with editor. So like I said, this is a piece of code. So this is a with editor thing. Properties are usually with editor only data. The really important thing about it-- and I've seen even people who work at Epic sort of confuse them sometimes, so-- the important thing about it is to be consistent. Like, just make sure that you're using the same macro in all the places so that if you hit some case where it is different, you don't have a weird undefined external or trying to override a function that doesn't exist in the base class kind of situation. This, by the way, is super interesting. I mean, these properties are very useful. So after someone makes a change to anything in the editor, you'll get, like, the property, which is a pointer. And this can contain the CPP name of your variable. So you can actually say, if the person just clicked this, then we're going to do a series of checks to make sure that other data is valid. I have-- there was a thing I was working on where you could link together different moves that your character could do. And whenever you changed a move or whenever you changed-- yeah, whenever you changed a move, I would go through and I would look at the asset you picked for that move and make sure that that move was, in fact, set to be for that character, because it wasn't a data-type question. It was, like, specific to this data. Does this move actually work for this character? And if you didn't, it would null it out. So you wouldn't be allowed to do that. But you can do su, stuff like that that's just really useful. Or you could say, like, if you check this box then clear this other box because, you know, maybe you'd have, like, here's my jump height and here's my initial jump velocity. So if I type in a height then calculate what my jump velocity should be and populate the jump velocity with that. Or if I type in a jump velocity, calculate how high that jump is going to go and populate the jump height field. And that way your users, your designers can choose, like, do I want them to jump with the velocity of 1,000, or do I want the character to jump a height of 250? Right? So they can set it either way and both fields will get set. And that's-- and then incidentally, to take that a step further, you could use your pre-save function that I talked about earlier here. You could use your pre-save function to save whichever field you want or to, you know, you convert angles from degrees to radians, stuff like that, so that they can enter the data in a format that makes sense to them and then you save it in a format that's faster and more efficient for the code. So all sorts of stuff like that that you can do there. Yes. So OK, so that covers that question, and possibly a couple of others. Why does the actor tick function have fewer options than the component tick function? OK, yes. So I touched on this briefly, but let's go back to it. So here's why. And by the way, I was going to show this, but it would take a little bit of time and it's a little bit out of scope. You can make your own tick functions. You don't just have to use primary actor tick. And I've used that, as well. Like, think about, like, old fighting games like Street Fighter 2. If two characters hit each other at the same time, it's a 50-50, because basically every frame the game decides who gets to attack first. And so in certain cases with regular hits, they just both hit each other. But with throws, you can't-- you can't double hit each other with a throw. Only one character can get the throw. So what Street Fighter 2 did was it just went, OK. 50-50. Who gets to move or attack first? And that's it. You know, and it's a rare case and it's an arcade game, so nobody's going to know until well after 1987. So they got away with that. Now, what I like to do with attack code that could affect character state is all the characters put in the attacks they're going to do in their regular tick and then we have a later tick in the same frame where they analyze those attacks and what's happened and do the effects. So that way, they can truly happen at the same time. So you can make your own tick functions if you have stuff like that. Like, you know, you need to do two different things in a frame at two different times. The default tick function uses tick actor, which-- here's a trick. Search for colon colon tick actor, which does this. The data's here in the tick actor function. It just only calls this because when they designed this, they figured that was all you could need. When they did it for components, they put more of those fields through. But you write your own-- you could write your own tick function and put in more of this information if you wanted to. Tick functions are great. You should-- there's a lot you can do with them, and I would suggest you really look into that. Also looking at tick dependency is really good, too. You can set up so that things-- you know, everything runs before a certain checkpoint and then a bunch of other things run after that checkpoint. As an example, I always have-- if I have, like, a chase cam or something-- and I think I did a stream on this. And I may have mentioned this at the time. But if I have, like, a chase cam and it's trying to figure out where I should go based on one or more actors, the chase cam will always tick after all the actors. If you ever get a situation where you're running and your character kind of, like, jitters a little bit ahead of where it's supposed to, that's probably because the camera is following the character. And then the camera moves for that frame. And then the camera-- and the next frame, the same thing happens, but maybe the frames aren't running at exactly the same number of milliseconds so your character is running a slightly different amount each frame and it just kind of jitters. That's why. It's because of tick order. So that's a super valuable thing. I think this is going to be my way of answering questions. You ask me a question and then I go off on these tangents. Victor: That's usually how it works. And that's-- I think that's why we're here is to hear you talk about this. Richard: OK. Will the project be available after the stream? Yeah. I've always made my projects available after the stream. This time, you may have noticed me closing and opening Visual Studio repeatedly. There are five different projects here. They're all just kind of like, as we moved. So maybe I'll just put up the last one because that's the one that shows the most useful functionality and doesn't fall into very many, like, traps. So yeah, I think we'll what we'll do is I'll send in-- I'll zip up the project and send in that for just the last stage, just the stage that does all the cool stuff. And it will include the stuff we did live. And then yeah, that'll be available. Victor, I don't know-- we're not uploading it to the same distribution site we used to-- Victor: Just go ahead and send it to me and I'll take care of it. Richard: Yeah, awesome. Victor's got it. Cool. OK, let me see. How can we add the debug console on a game build? So I think you're talking about when you hit tilde and that pops up. I think that's what that means. Displays a rectangle-- yeah, I think that's-- I think that's the one you're talking about. So in a shipping game, you can't do that. However, like, because of the engine, the engine purposely disables it because it would be a bad mistake if you left the cheat codes in a shipped game. But it does show up in development build and debug build. So if you're testing out with your team and you want something that's sort of like the shippable binary, development mode is great. Development mode, by the way, also leaves the UE log commands in. I'm not sure if they show up on the screen, but they do show up in a log output file. So development builds are actually really good, and a way to think of them is they're not quite as fast as shipping builds, but they're close. So think of them as, this is how we test the thing. And we periodically make sure that the shipping build actually runs. And then when you ship, your game will be slightly faster than you expect. Just sort of take that as a windfall. There's a thing-- there's a-- you can-- I'm going to type that much of the word, because I don't remember. There is a way that you can generate-- you can write your own cheat commands, too. There's just a class you overwrite. Hold on. I'm not going to find this. This is not going to take very long. Victor: We got a bit of time. Richard: I don't want it to take very long. OK. Yeah, let me find it. It won't take long. I just got to figure out where it is. So what you can do is you will write your own-- oh, that's what it's called. It's called cheat manager. OK. I was close. So there's a class called UCheatManager. And you can write-- you can write functions that take parameters or don't. Here's one-- here's-- like, so here's an example. So you might take-- hey, that's not the function I want to use. So you write functions-- like, this is-- for example, there's a slow mo cheat in the editor. It's already in there. It's just in by default. And it does exactly what this says. So you know, slow mo 0.1 makes things run it 10 times slower. Slow mo, like, 2 makes things run twice as fast, stuff like that. But you could override it if your game had a special way of handling slow motion time that you don't get just from the engine's default ones. So you could do that because you could overwrite existing cheat codes. You could also write new cheat codes. And all you'd have to do is make-- oh, let's see if I can actually do this. Let's see if I can actually do this here. I've never-- I've never tried this from here before, but maybe you can. Oh, you can. Awesome. OK. Editor stream cheat manager. Let's go. We're going to put this in my little code folder just to separate out my stuff from the stuff that comes default with the project. Eventually this is going to dump us back to Visual Studio. But yes, you can override this. And then basically, you just put in-- are they Blueprint callable functions? Yeah. So you can override the ones that are already there or you can make exec Blueprint call-- well, that was the thing you needed. Exec. Let's come back into here. There we are. OK. So you could take, like I said, this is a function that already exists that we're overriding. So we could just override that. Or we could make a new one. I like to make a Blueprint callable. I'm not 100% sure if you have to, because I always do it. So I don't know if it works if you don't. Sure. And then I don't know, what would this be? This would be like-- just whatever. Void my cheap thing. And then you can have parameters like float param 1, int 32 param 2. Whatever. Stuff like that. And then that's it. My cheat thing will show up in the console. And now I'm going to make a liar of myself by making it not work. This will be the thing that doesn't work. Let's get those parameters in here. Let's get in the habit of always doing that. Always put something there. Victor: That's like me and the straightening out all the Blueprint lines even when I'm not done with the code. I do it even prototyping. Richard: Yeah, I've really tried to make myself stop doing that, and I've cut down on it. But there's so much like, no, four tiles apart. Align them. I want all these lines straight. Like, why? Victor: But that goes down a little bit to what you mentioned about sort of it being fun, right, and it being visually pleasing to you as you're working on it. There's something to that that could help. If you're that kind of person that might actually help your productivity and-- Richard: Yeah. I mean, and also just I guess the type of personality that is fastidious about getting everything right in an engineering context-- Victor: I think there's a medical term for that. Richard: There is. I'm avoiding being a doctor, but there is. Victor: It's whatever works for you, right? Richard: Yeah, well, oh, no. What I was going to say is I think that the personality type that tries to get everything right in the engineering context, as a side effect, like, that same personality type also wants all the lines to be perfectly straight. It's like, what are those dogs? Cocker Spaniel, Springer Spaniels, the ones that are used as sheepdogs, right? Like border collies, maybe. Yeah, like Lassie, right? But if you take a bunch of tennis balls and just drop them in the middle of the room, the dog will freak out and herd all those tennis balls into the middle of the room because it's not that they just want the sheep to all stay together. It's that they see a bunch of similar objects and there's just something in their brains like, those all need to stick together. Get in the middle, all of you, right now, or I'm angry. It's just, that's how that kind of dog works. So OK, so let's see if that compiles at all. I forget if you have to register that class or tell it that this is the official cheat thing for a-- yeah, I think you have to set this in Project Settings, too. So there might be one other thing you have to do with this. Let's-- yeah, that's about to compile. So let's head over there, because I'm pretty sure that just making the class isn't going to do it. Like, the engine has to know somehow that that's your one. So let's go up here to Project Settings. Cheats? No, really? Well, I typed mama, so that wasn't it. Manager. Hmm. I mean, I don't think that that was right. But what do we call that cheat code? Victor: My cheat thing? Richard: Yeah, it was actually right. OK. Yeah. 3.14. So then in the output log-- OK. I did something crazy there. But you saw the cheat code showed up. I don't know. What did I do wrong in here? This all looks like it's right. I don't know why this isn't right. Whatever, this isn't even a real cheat code. But there you go. There can be something that went sort of wrong. Anyway. Yeah, so you can see that the engine clearly at least knows about my-- whoops. Knows about my cheat code and I can hit Tab to auto complete it. It also shows me the parameters. I don't know if you can make that out, but-- Victor: We see it. Richard: Param 1 float, Param 2, int 32, 2, so it actually knows what my parameters are, as well. I don't know why it didn't-- I don't know why it didn't poof. I don't know why it didn't run, but-- OK. Yeah, whatever. I probably did something wrong in that debug log statement. Victor: That's OK. Richard: But that's how you can make your own cheat codes. And they do work. I use them all the time. Where are we? Victor: We had another question I thought was pretty good, which was in regards to the debugging that you added for the torches, if it's possible to do the same thing in Blueprints? Richard: The visualization component like that? I don't know that it is. Victor: You can do it with draw debug line, sort of-- Richard: Oh, yes. I'm sorry, I didn't know you meant-- yes. Just drawing lines, yes. You can do that. I'm sorry. I didn't know you meant that. I meant actually creating a full visualization component. However, what you can also do-- I've never tried this. I'm not sure if you can call a Blueprint function-- like, a Blueprint implementable function-- from one of those components. You might be able to do that. If you could do that, then you could do pretty much whatever you wanted in there. Since I've worked as a GPP, I know it from this end and not that end. But it is possible that maybe you could call a Blueprint function while you're in level editor mode and then run it. That might be possible. I would be careful about that, though, because if that does work, you still-- there's still a chance that you will modify things that are in the level editor. So when you start a new game, it makes a new copy of all the objects in the new world. And then you play around in there and mess things up, but whatever, and it's fine. And then when you come back, it has the original world. If I were to turn on a thing that makes an actor walk around or something, and I did that in the viewport tick type, like if I had it tick in viewport, that's actually moving. And if I save the level, its new position is saved. And if I start playing the game, wherever it was walking around to in the level editor, it's really there in the game for real. So you know, bear in mind that you're actually editing the level when you do that, which is why generally they're done by visualization components. Can you keep viz components turned on while playing? You should not be able to, mainly because if you recall there is that one line where we said set is visualization component to true. That should tell the engine not to spawn that stuff in game. Those are not supposed to-- those are really only intended for visualization. Now, you can use-- in fact, there are-- if you want to see an example of a more complex visualization component, look up the camera component, because that has the draw frustum thing on it, and it also has the static mesh of the camera. The static mesh of the camera is just a regular static mesh. But it's a visualization component, which is good, because you don't want the static mesh of the camera falling around your game cameras in game. The draw frustum component is more interesting because it actually does its own custom drawing routine and passes proxy data to the renderer. More advanced than I wanted to do in this stream, but it's not-- if you look through it for, like, 5 or 10 minutes, it's actually not that hard to understand. And then you could make your own components that do a little bit more heavy duty drawing or visualization in there. And like I said, you could just take a static mesh component, make it a visualization component, and then you have a whole static mesh that will show up editor only. So that's-- there's a lot of cool stuff you can do. Victor: And to be clear, you can actually do the editor-only check on your component in Blueprints, as well. You can add, like, a text component, for example. And you can check that to be editor only as you're iterating inside your Blueprint actor. Richard: Oh. Is that a statement and not a question? Victor: Correct. Yes. I'm sort of just adding to the information considering we had another one that was sort of interested if this is possible in Blueprints, as well. Just want to piggyback on that. Richard: Yes, thank you. Like I said, since I'm mostly on this side of it, I didn't realize that. But thank you for adding that information. That's good to know. Victor: Yeah, no, for sure. All right, I think that was all the questions. And we're definitely getting into the late minutes of the stream here. So unless you had anything else to add, Richard-- Richard: Nothing in particular. No, I think-- I think that's pretty good. Yeah. So we will make that available and I hope everybody had fun and learned some stuff that you can use to make your games a little smoother to work on. Victor: We did, of course, have a last question that came in. And I figured it's just right to ask and answer it. Regarding post edit change property, I have found that if you change-- yeah, are you seeing it? Richard: Oh, it's down here. I've found that if you change transform property using the gizmo instead of the text box, then the function's not-- yeah, OK. So that is a good question. There is actually another function for that. Let's see how fast we can find it. Victor: Sorry, folks. We've got to-- we're sticking around a little bit longer. Richard: That's OK. Uno mas, right? All right, so let's see. Actor, editor. OK, so post-edit-- so I think it's called, like, post move. Post edit move. Oh, wow. Yeah. That's what I'm talking about. So post edit move, this is the function you want for that. And you can take this be finished bool. And if there's something more expensive-- like, let's say you're going to put a character down and then compute, like, this character's paths to the nearest whatever and it's going to be kind of expensive or something like that. You can just put some logic so you only do it when be finished. So that'll be like when I actually release and I finalize it as opposed to every frame when I'm dragging it. So yeah, use post edit move for that when you want to do that. Don't use post edit change. There you go. That was a good question. Victor: Nice. Yeah. Richard: So there's a lot-- oh, and if you wanted to find more about this stuff, there's a ton of it. It's really good stuff. It's in-- you'll find it in actor.h. But just basically find any one of these and then start searching around for-- I mean, like, look at these. Look at this stuff. Pre Edit Change, that's a good one to use. Then you get Post Edit Change, which also tells you the property. Pre Edit Undo, Post Edit Undo, Import, Is Selected In Editor, Post Rename, like, look at all this stuff. There's all this really great stuff in here that people might not realize. And actually, well, it's actually technically a new object, not an actor. But I always end up finding it an actor. But yeah, post load sub objects, that's a really good one for-- if you have to do something with an actor after all of its components have come in, there's, yeah, post edit properties. Tons of great stuff in here. So look through here. If you're looking for how to do something in the editor, especially if you see some engine class that does something and you're not exactly sure how, there's probably an exposed way for you to do it. In almost any case, there's an exposed way for you to do it, too. So check that out. Victor: That's an awesome tip. I think that went into the extra couple of minutes. Richard: Yeah, definitely. Victor: All right. I think with that said, Richard, thank you so much for taking the time, preparing a bit of a presentation for us. I hope to have you back to do some more code. It's usually-- I think last time you were on we were doing a little bit of C++, as well. Richard: Yeah, yeah. I always like to try to do a little C++ and real-time debug some things and whatever, have some crashes, sure. Victor: That's why this is live, it's because we're doing it-- we're doing in a way that's very real, right? Richard: Yeah, I do like that about it. I don't want it to look like it's always perfect. It's-- Victor: No. Richard: --constant stumbling, and then at the end, it's ballet. But that's only when you ship. Victor: Right. Yeah, yeah. We don't have just a big list of makeup game buttons and you're like hmm, which production cycle? That one! All right, cool. Ship it. That's not really how it works. We appreciate everyone who joined us today. Watched us go through a little bit of iteration for comfort, I guess is what it was called. I do want to point out that some of our Meetup groups are actually still doing virtual Meetups. They're trying a few different things, between Discord and Zoom and what else. And so if you're looking to find an opportunity throughout the week where you might be able to join a couple people doing presentations or talking Unreal, or maybe just hanging out, go ahead and check out our Community page at communities.unrealengine.com. Next week we actually have Paul Ambrosiussen and Mike Linden from SideFX and they're going to show a little bit about the new Houdini/Niagara data interface that's been implemented. They'll be showing off how to do a couple cool things there. I believe the forum announcement post should be up on the events page of the forums if you're interested. That will be next Thursday. I think with that said, it's time to say goodbye and I hope all of you have a wonderful, wonderful rest of your week. Bye, everyone! 