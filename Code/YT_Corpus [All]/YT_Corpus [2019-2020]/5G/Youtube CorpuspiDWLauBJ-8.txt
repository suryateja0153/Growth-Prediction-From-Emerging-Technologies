 [Music] you [Music] hello and welcome to this lecture I'm going to talk about encoding LDPC codes and the 5j standard we'll begin by looking at a couple of simple ways of include encoding using the parity check matrix and then show a small toy example and then I'll quickly generalize to the encoding of LDPC codes okay so we saw encoding of hamming codes before in the previous week in the first week of this course the encoding that we will use here will be slightly different we will not be using the generator matrix maybe use the parity check matrix for the encoding it's largely similar except for some minor changes okay so let me show you how that works first for a very very small example and then we'll move on to the codes which are in the 5g standard okay so here's the small example I'm going to take let's say we have a code let's say we have a code with parity check matrix just so any very simple 1 1 0 0 1 1 1 0 1 1 0 0 0 1 0 0 0 0 I'm sorry 2 0 0 1 this is the parity check matrix you can see very quickly that it's a 6 comma 3 code ok it's also in systematic form so if you have the message vector M which is M 1 M 2 M 3 the code word C will be M 1 M 2 M 3 and P 1 P 2 P 3 ok so these are the three message bits M 1 M 2 M 3 these are the three parity words and these are computed we will show how these can be easily computed using H and M okay now what does H tell you H tells you that H times C transpose equals zero okay which in other words is this equation right so 1 1 0 1 0 0 0 1 1 0 1 0 1 0 1 0 0 1 multiplied on the right with M 1 M 2 M 3 P 1 P 2 P 3 goes to 0 right 0 0 0 ok so now if you look at what this means this actually means three equations what is the first equation you multiply the first row with this guy so the first row gives you M 1 plus M 2 plus P 1 equals 0 the second row gives you M 2 plus M 3 plus P 2 equals 0 and the third row gives you M 1 plus M 3 plus P 3 equals 0 ok so now this is all binary exhaust or modulo 2 equations so this is the same as P 1 equals M 1 plus M 2 this is the same as P 2 equals M 2 plus M 3 and P 3 equals M 1 plus M 3 so this is the way to do encoding with the parity check matrix if you will it's just a small rephrasing of the encoding with the generator matrix you look at each row of the parity check matrix and if it's in systematic form you know that one parity bit is directly specified by that ok so there's various ways of writing these things down so for instance one more way to write it is you can write H as P and then I write so this is 3 cross 3 identity and B is just this matrix right so B would be 1 1 0 0 1 1 1 0 1 ok and then you can look at the multiplication here in a slightly different way P I times M transpose P transpose equals 0 ok so what is P P is P 1 P 2 P 3 the vector of parity bits and then you rewrite this you simply get that P transpose P times M transpose plus P transpose 0 and you can quickly see that the the parity bits P transpose is obtained as P times M transpose so in other words if you want to write it differently P 1 P 2 P 3 is P times M 1 M 2 M 3 ok so this is just another way of writing it it's all the same thing written in different ways ok so this is the way in which one uses the parity check matrix and in fact encoding of LDPC codes in the 5g standard also uses the same principle the parity check matrix is specified the codeword is specify the message bits are given and then you use the parity check matrix to compute the parity bits from the message bits ok except that the parity check matrix is not directly in systematic form you have to do some small manipulation which is the manipulation I'll show you in this lecture ok so hopefully this is clear so one important thing to keep in mind is so like I said this is a three six code usually when people put messages and code no and the code parity bits on top of the of the parity check matrix you imagine that the first column corresponds to M one second column corresponds to him two third column corresponds to M three the fourth column is P 1 P 2 P 3 etc ok so this kind of visualization of the codeword with respect to the parity check matrix is useful ok so you write down the parity check matrix the columns of the parity check matrix correspond to the bits of the codeword H times C transpose is 0 so that's the multiplication right the part in the bits of the code word multiply the columns of the parity check matrix and you can associate each bit of the codeword with each column of the parity check matrix this is the same thing we did in the Tanner graph as well okay so this is a very natural Association so you imagine putting the messages on the systematic part of the code word and then computing the parities using the parity check matrix so you see here the first thing gives you P 1 has M 1 plus M 2 ok so P 2 is M 3 plus M 2 K P 3 is M 3 plus M 1 okay so directly gives you that okay so this is how the bear this is just the basics of encoding so now let's see how to use this with the parity check matrix specified in the 5g standard there's one little thing to take care of I will point that out alone and then you will see the rest of it follows very naturally in a normal easy manner okay so let's get started with that so so in the previous lecture I gave you this example of a base matrix a toy base matrix with an expansion factor 5 to illustrate how the parity check matrices are specified this is a three three by six base matrix each entry is is from minus 1 to plus 4 expansion factor is 5 and each entry is replaced by a 5 cross 5 binary matrix minus 1 is replaced by the all 0 matrix and any other number say 0 or 1 or 2 or 3 or 4 is replaced by the 5 cross 5 identity matrix column shifted column rotate shifted that many times to the right ok so one would correspond to the matrix identity matrix column shifted by one position like for instance this so this one for instance this one for instance goes out as this matrix and this all the other matrices are like that I showed that in the previous lecture okay so so what we will do in this class is we will start looking at the base matrix for the actual LDPC codes in the standard so this is another slide I showed in the previous lecture in the this is part of a base matrix for the second BG 2 which is 42 by 52 matrix it's quite large it's difficult to capture on screen so I'm showing just ten rows and 20 columns of that matrix the expansion factor is 48 okay so expansion is 48 so these two things are just indices which tell you how to look it up in the standard etcetera expansion is 48 so you'll see the entries go from minus 1 0 all the way to 47 okay and these are the first ten rows so if you notice this is the message part okay this is the message part there will be ten message blocks okay so one two three four five six seven eight nine ten okay each message block actually will expand to a 48 by 48 binary matrix so overall after expansion the message part will be 480 bits long okay 10 into 4 40 ok so that's the way 48 times 10 into 48 bits okay so usually we'll consider this in some block fashion as in the first the message itself will be taken as m1 m2 till m10 each mi will be 48 bits ok so I'll think of it as a vector just concatenate it to put together the message part okay and then you'll have the parity so this is the first parity second parity third parity for parity parity so on ok so each P I is also 48 bits ok so it's all expanded in the in the base matrix you have to think of each of these things as a block of bits ok so now if you look at it except for this 4x4 part which have shown in the box here this except for this 4x4 part I actually have an identity matrix ok so from this part on it is just an identity okay so it's similar to the small little example we saw at the beginning of this lecture just identity and P okay but this first part is not clearly identity you know you have these - once the - once gets replaced by zero but you have a zero which is identity another right below that if there's another row of zeros okay so this is a double diagonal structure okay so this structure is called a double diagonal structure okay so this is important for the from a performance point of view so you need some sort of a double diagonal structure like this for the code to have good performance particularly at high rates you need this this structure it gives you a good performance so but but but nevertheless nevertheless this makes n coding a little bit more complicated well it turns out there is a certain structure here which which you can exploit and the encoding is actually quite simple the double diagonal structure will work out very nicely I will show you that so that's the only complexity in encoding off the LDPC codes and the 5g standard how to deal with the double diagonal structure in this in this part here it's also small part so once you deal with that and find out p1 p2 p3 p4 the rest of it is straightforward ok so once you find p1 p2 p3 p4 the rest of it is just identity you can find p5 p6 p7 so on as much as you need ok so this is the basic idea behind the encoding so to illustrate this double diagonal we'll take a toy example a much smaller example as opposed to a direct example from the standard we take a smaller example illustrate how that works and then come back and tell you how to apply it in this case as well ok so this is how it's going to work of course we'll write a MATLAB program to do this encoding soon enough but this is how it works ok ok so here's my example to illustrate the double diagonal structure so you see this is a 4 by 8 block base matrix and the expansion is 5 ok so I'm using a little slightly different notation compact notation to capture this I'm going to show use this I K to indicate the identity matrix column shifted K times ok so instead of using entries like 1 2 3 I'm using i1 i2 i3 just to show it's the 5x5 identity matrix shifted like that and the 0 represents 5x5 all 0 matrix ok so I will be 5x5 identity okay then I 1 will be 5x5 shifted right by one position I too will be 5x5 shifted right by 2 positions so on okay so this is a matrix it's you can see this is a 4 by 8 matrix this is the message part M 1 M 2 M 3 M 4 and this is the parity part P 1 P 2 P 3 P 4 so you'll see the diagonal structure here there is a diagonal structure here double diagonal structure and then the zeroes are all here and then you have this I 2 being the same as this I 2 here and this I 1 being different okay so this is sort of similar to every base matrix in the 5g standard as well if you look at the first four rows the first for parity blocks they will always have the structure and the structure is pretty interesting and it's designed so that encoding can be easy okay so that's what I'm going to show you next okay so like I said message is M 1 M 2 M 3 M 4 I am not using subscript in the notation here it's just for easy typing hopefully there's no confusion okay so M 1 is the same as M subscript 1 so M 1 M 2 M 3 M 4 is 5 bits each code word is M 1 M 2 M 3 M 4 P 1 P 2 P 3 before these guys are also 5 bits each ok so now how does the encoding work here so we have h times the code word transpose equals 0 I'm going to write each block row as one matrix equation ok so this is a matrix equation five by five okay so there is a five five by five matrix s here so each M 1 M 2 H 1 M 1 M 3 M 4 P 1 P 2 are all lengths five vectors once again there is this transpose here which I'm sort of not showing in the notation hopefully it's clear to you so I put I 1 and then put M 1 as a column vector can multiply and add up okay so I get this equation and then this is the second block row this is the third block row and this is the fourth block okay second so it's indicated here the second block row third block row fourth block okay the first block so hopefully it's clear to you how the first block row came if you want I can go back here and write it down so if you if you put M 1 M 2 M 3 M 4 on the right side the row one here corresponds to I 1 times M 1 plus I 3 times M 3 right you can see I 1 times M 1 I 3 times M 3 plus I 1 times M 4 plus I 2 times V 1 equals 0 oh sorry plus I I times 2 equals 0 ok so you can see that's what the first row corresponds to and that's what every time here okay so each is a matrix equation alright so now if you notice these two are the same these two are the same these two are the same so this comes from the double diagonal structure okay so double diagnose structure gives you this the same things here and then here these two are the same and then you just have this I I 1 P 1 left ok so what this is suggesting is you have to add the four equations these four block equations you have to add if you add them you will see there'll be all sorts of cancellation here these two will cancel whatever is equal will cancel once it cancels you will be just left with whatever is on the left side right I 1 times M 1 plus I 3 times M 3 plus I 1 times M 4 and then the second row i 2i i 3 extra then the third row and then the fourth row and here you'll be just left with I 1 times P 1 that's the only thing you will be left with so of course you can bring it to this side and right equal to zero so I bought the i1 times p1 alone to that side and kept it as an unknown okay so you can find p1 from above it's from this equation you can ready-made I mean this this is just a direct equation for p1 of course you have the i1 here that just shifts the p1 a little bit so you can reorder and find out p1 ok hopefully this is clear to you so the basic trick is the double diagonal structure is structured such that when you add all the four equations everything cancels except for the first parity block p1 ok so that is the secret to this double diagonal structure which stare at it for a while and it's been done so that when you add up the first four rows first of all block rose only p1 remains and you can find p1 okay once you find p1 you are done right the reason is if you have p1 you go to the row 1 okay so you use p1 in the first equation you get p2 p2 is only unknown there and then you use p2 and then you get p3 from the second equation then you get p4 by using p3 in the third equation okay so remember the messages are given to you M 1 M 2 M 3 M 4 you have to compute the parities P 1 P 2 P 3 P 4 you add the four block rows you find P 1 and then you use P 1 in the first row right first block roll equation you get P 2 and likewise you use P 2 in the second block or equation you get P 3 then you use I guess P 1 and P 3 in the in the third block row to get P 4 okay that's the way this whole thing proceeds hopefully this is clear to you know this the same structure exists in the 5g standards LDPC codes as well okay so it's just a simple case of picking up the structure and using the same thing in your end coding you find P 1 P 2 P 3 P 4 ok so once you find P 1 P 2 P 3 P 4 ok this is again the same 5 G matrix illustration part of the 5 G matrix 42 by 52 so I'm showing you only a part you have 10 message blocks each 48 bits the parity blocks go as p1 p2 p3 p4 p5 p6 etc and for the first four rows you can recognize the doubled structure here right so these zeros are all ice - ones are all zeros and then one is i1 i1 and then you have I I itself here okay so when you add it all up you will get P one okay so you can find P 1 P 2 P 3 P 4 using this double diagonal encoding idea and then once you find that once you know P 1 P 2 P 3 P 4 this P 5 is direct from this equation okay see because if you look at this equation P 5 is the only unknown so you can find P 5 okay so it's just diagonal and then P 6 you can find from this equation and so on okay so that's the simple encoding method hopefully you agree with me it's designed so that it can be implemented quite easily the matrix itself is sparse so you won't be doing too many X or computations in the encoding and you don't have to remember too much as well except for maybe the base matrix and how its generated okay so this is the end of this lecture the next lecture will write a small MATLAB code for implementing such encoders thank you very much [Music] you [Music] 