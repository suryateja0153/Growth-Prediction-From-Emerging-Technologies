 I hope today you were able to listen to some of the great talks we've had and explore the different sandboxes and if you haven't seen the smart homes section in the assistance sandbox I highly encourage you to do so thank you we have a great team there and some really cool demos including showing you how the smart home API can help you grow a better garden on behalf of our team were really excited to share with you some of the smart home technologies that we've been building since we last spoke to you at I 18 my name is Carl Vogel I'm a product manager on the smart home team my name is Bennett I am a software engineer I am guru I'm a solutions engineer and smart home I'd like to begin with a story one of my friends recently purchased some smart home devices in particular light bulbs from one company and smart plugs from a different one and he put them in an area that he calls the downstairs and when he gets ready for bed he walks upstairs and he says hey G turn off the lights well he was telling me that often times they don't respond together one set of lights often responds a half second or a second faster than the other or sometimes they just take a really long time to respond in general or they don't respond at all as Google on our developer community work together to grow smart home we need to work together to solve these challenges we believe one method is to shift processing from the cloud to the local environment we've taken our first step in this direction to improve the experience for users like him and the millions of other users that use our products on a daily basis we're happy and to introduce that that first step is the local home SDK the local home SDK enables you to locally process and fulfill smart home commands received from the Google assistant we do this by inviting you to build and run your smart home business logic locally on Google home speakers and Google Nest displays then we securely give you access to the lower level radios to communicate over the local area network with your smart devices through this we can together deliver substantial improvements in latency and reliability but first before I talk about the local home SDK let me give you an intro to the smart home API and then show you how the local home SDK layers on top the smart home API is the foundation of our smart home program let's begin with how devices are defined and integrated into the assistant first developers specified the vice tete type this is really the what is it factor is that a light bulb is that our microwave a camera device type is our method to classify the overall essence of the device in a user's home second developers specify a device trait and this really describes the overall functionality of the device what can it do how can users control it devices oftentimes have multiple traits for example a light bulb may have the traits on/off brightness and color setting once the device type and trade are specified we can then bring these devices into the assistant and specifically into our home graph using the sync intent home graph is our database that'll enable us to build a topology of the users devices in their home now that the devices are defined and in our home graph let's see what happens when a user issues a command for your device when our user says a command such as for example hey Google turn on the lights we send that to the assistant server as a and then assistant server processed this waveform and ultimately determines which device or devices the user is trying to move into what state then we send that as a structured JSON payload to the developer to be processed and ultimately fulfilled and as we see the developer communicates with the end device through this very simple method to integrate devices into the assistant and have users control them we have grown exponentially since 2017 in fact we work with over 30,000 unique devices among 3,500 brands we encourage you to join us in to integrate if you haven't done so already and a great place to start is the smart home one-on-one talk that some of our friends gave earlier this morning although successful by almost all accounts cloud the cloud integrations have inherent limitations we may have a Google home speaker and a smart device within 10 feet of each other yet this command needs to travel hundreds if not thousands of miles before returning back to the same room this takes time and of course provides opportunities for jobs commands so we started to think at Google can we leverage the fact that these are on the same local area network the local home SDK is our method to do so at Google to the developer experience is core to our thinking and this deeply influenced our design tenets with the smart home API being the foundation we want it to leverage its capabilities and layer the SDK on top as a deeper integration not as in either org we also implemented what we call a coma zoo our philosophy in that we wanted to work with your devices as is today without requiring any form wrap modifications lastly we've heard from you thousands loved the smart home API so we wanted to mirror that familiar interface on to the SDK so what these tenets now understood let's go ahead and revisit what happens when a user issues a command using the local home SDK as we can see the user still says a command and it still goes to the assistant server to be processed however if we know that this device is locally controllable will actually send that command as a JSON payload down to the Google home speaker or Google Nest display will then pull up the appropriate developers JavaScript file that has their smart home business logic on it to process the intent and then we'll provide access to the lower-level Wi-Fi radio to ultimately communicate with your device over the local area network and notice the developer still controls the smart device but can now process and fulfill that command locally and since we still have this cloud the cloud integration we now have the cloud as a fallback so what is this app what is adding this local path do well first it allows us to reduce the latency after a payload leaves the assistant server to less than 300 milliseconds this will provide a very very noticeable benefit for your users second it allows us to drive the reliability that a smart home command reaches the device to well above 99.9% and we primarily achieve this by having redundancy in the system so the next natural question is this sounds cool but will this work with my device well I'm happy this to say this works with all the device types including the 16 new ones that we just launched at i/o and in particular this is not just for Wi-Fi devices if you use a hub or a gateway for your smart home integration for example a ble hub or ZigBee hub you can talk locally to that hub as well in addition we support all the traits that you use today with the one exception of two factor authentication recall from the tenets that our goal was not to require any firmware changes on the part of the developer and so we set out to support the most popular discovery and control protocols as shown on the slide behind me and lastly which devices can host or run this JavaScript well really happy to say here that it works with all our Google home speakers and Google Nest displays including the new Google Nest hub max so we've talked a lot about the experience for developers and this is i/o of course but what about users what do users have to do to gain this benefit and the answer absolutely nothing once you integrate the local home SDK we go ahead and establish the local path for all the users that are already on your smart home project so with that I want to turn it over to minute to talk more about the technical architecture the smart home ecosystem today relies on developers bringing in devices better discovered and controlled on the local network in different ways in many cases the application layer or the business layer logic is openly documented but nonetheless custom early on we decided to make the local home platform flexible enough such that our smart home developers would be able to leverage the platform without compromising the ability to bring out their unique features at a high level let's look into the elements to make this flexibility happen we'll talk about the Google device and what's happening there we'll talk about the overall Google infrastructure and how the Google device fits into it and then we'll go into the specifics of discover and control to give a bit of background a few years ago we built chromecast chromecast runs on chromium which is the open source project behind Google Chrome chromecast or more specifically the Google cast SDK created a wave developers to run their code on a Google built device this code doesn't run natively but rather as a app in its own container since we're running on something like Google Chrome this container happens to be a browser window and the app is JavaScript leveraging this browser technology were able to run multiple media apps in their own sandboxes securely and simultaneously building on the caste foundation we created the local home SDK and the local home platform the local home SDK and the platform together are the interface between developer smart home apps and the low-level radios used to talk to smart devices local home platform has two important tasks to take care of first interfacing with the Google assistant such that we can leverage the smart home API as is and second to provide controlled access to socket communications using TCP UDP or HTTP HTTP and HTTPS protocols I just spent a couple minutes talking about the Google home device and how you can soon run smart home JavaScript apps on it in order to communicate with your devices in the users local network we also how to build out some components in the larger smart home ecosystem with the Google assistant and with some help from you if you already have a cloud the cloud smart home integration you'll be familiar with the actions on Google console and home graph there are some additions to both of those systems in order for you the developer to help your users benefit from this new local path let's look at the high level flow to discover and control your devices in the users local environment in the next two slides before we talk about the code that you'll write to Ronald go home you'll need to add some data via the actions of the console and the cloud to cloud integration in the actions of Google console you'll tell the Google home how to find your devices in the users local network we implemented the common discovery protocols like mdns UDP broadcast and UPnP next you'll update the sync response to include a hint to the local home platform that will help with identifying a local to locally discovered device is the same device that appears in the cloud the cloud integration sync device list once the discover information is added via actions of google console and you've added this hint to sync response Google assistant will send this information to all Google home devices that a user is linked to if the local home platform can match a locally discovered device to a device in the list from your cloud we've established the local path great so now we have a local path and the user says hey Google turn on the lights the request from Google assistant is dynamically routed to a Google home device that has claimed that local route the JavaScript app running on the Google home can now handle this request and can communicate with the device using application layer protocols like HTTP or TCP and UDP sockets so when we set out to build the local home SDK we want to make sure that developers have best experience so let's look at the developer flow starting with building your application - debugging it for certifying your application and even launching like we've taken care of the complete spectrum and in next few sections of the site's we'll look into these each so first let's start with developing your typescript application they'll help us discover and control the devices locally to help discover and control devices locally you as a developer needs to do three key things first like minute mentioned earlier the scan config on actions on Google console second the little bit of help from your works with integration where you update your sync response to give us a hint that these devices may be locally controllable and third your typescript app this is the app that will run on Google home devices now a quick note about the app itself we've been talking about JavaScript as the app that runs on the devices but we highly recommend developing your app in type step it's just a better developer flow so what does this app do locally it needs to handle two key events first when Google home devices discover a device in the local network that belongs to you as a provider we fire and identify intent and that needs to be handled by your app the second one is reachable devices which is a special case of the first one where if we have discovered a hub or a bridge device and will go into the details in coming sections and finally when the user wants to control the device the platform fires executes intent and for those who are familiar with the smart home API it's the same execute intent that your JavaScript receives like your cloud endpoint receives let's go into the details of what the discover flow looks like we talked a lot about this actions on Google console so what does it look like in a few days you'll be able to see this new UI which allows you to update how we find your devices in the users local network in this particular example we've added the ability to upload the UDP broadcast packet along with the in and output ports required for UDP broadcast next we'll take a look at exactly what you need to do to update the sync response we've added a new field called other device IDs which hints to the Google home to start looking for a device and we'll use the information in this field to help duplicate a device that we find locally to a device that you told us about via the cloud to cloud integration here's a sample of what that looks like you'll notice that this other device IDs field appears at the device level so you as the developer can choose which devices you want to be locally controlled or not so now we're going to jump into the diaper skip app and this is the app that has the business logic that can control your devices it is a simple but it's a critical component in this whole process and just a quick reminder we need to handle too intense let's quickly put these intents in perspective so for those who are familiar with the Smart Hub API we have sync query and execute intent that Google servers sent to your cloud services for local we are adding two new intents identify which is fired by platform when we've scanned a device that belongs to you and second is the reachable devices intent which is optional but required for if we have scanned a bridge or a hub let's get started with the typescript app but before we do that let's look at the SDK interface and when this launches in June you will be able to download a sample and a boilerplate code from github so the interface export is exposed by the SDK is pretty straightforward it has two main classes first the device manager class the device manager class provides methods to communicate with your devices and like Method mentioned earlier it could be TCP UDP or HTTP HTTPS the second is the app class this provides the methods to attach the intent handlers so let's look at the Taipings for device manager class is the send which takes in an input for command request type object and returns a promise which is resolved when command has completed and like I said earlier it could be HTTP TCP or UDP let's look at the typing for the app class so for those who are familiar with the actions of Google node library that you use for the cloud site integration you will realize that there we have on execute on sync and on query as the handlers you can attach to here we have unidentified unreachable devices and on execute methods which you can call to attach the handlers for your app after your app has attached the handlers we call the listen API and that's an indicator to the SDK that the app is now ready to process these intents and notice that these methods are chainable finally when you are ready to communicate with your device you will call the get device manager API to get the singleton object for device manager and use the send API let's put this interface into perspective by looking at the skeleton of a sample app so in the sample app I have like identify handler and execute Handler and in the constructor for this class I create the instantiation of a local home app get the device manager object attached the two handlers and call the listen API now let's start looking at the events that happen at runtime and what your app does to handle those events I'm a visual learner so let's take a look at this in pictures you've already updated scan config via actions at Google console you've updated the sync response and now that information has been set down to a Google home the Google home starts a state machine where we look for local devices then this process repeats so whenever user plugs in a new device will find that too when the smart device responds to one of our scans the local home platform generates an intent called identifying like Gaurav has been mentioning and we then call your apps identify handler so let's look at identify handler so here's the signature of the identify handler the input is a object of type identifier request and we expect a response to be a promise that resolves to identify response the key information in identifier request object is the scan data and this depends upon the scan that we'd used to scan for your devices it could be Europe e em DNS UPnP identify response the key information will look from identify response for the device that we just found is the verification ID and this must match one of the other device IDs that we got from your sync response and if we find the match we would have established a low but now there are two other flags that are also important is proxy and is local only and they're set to false for this device if this device was an end device that we wanted to control but what if we find a hub great question Gaurav similarly when we find a hub will trigger and identify intent and is the field is proxy and is local only will be set to true and that will tell the local home platform to then trigger a reachable devices intent as the name kind of suggests reachable devices intent is supposed to return all the devices that are reachable from this hub the signature for the handler looks very similar to the identifier request the key information to look for in the reachable devices request object is the proxy device this is your hub that you told us about in response for identify now the response object we expect a array of devices and again the key information for each one of those device is the verification ID and that has to match one of the other device IDs in from your sync response like you know I'm a visual learner so let's take a look at this lovely animation we start establishing the local path with information from you via scan config via the actions of Google console and the updated sync response from your cloud to cloud integration once the Google assistant receives this information it will send it down to all Google home devices a users link to once the Google home receives this information it begins looking for devices on the local network when a smart device responds the Google home generates and identify intent to the appropriate JavaScript the JavaScript responds with a verification ID and the local home platform does some magic to determine if there's a local path if there is Google home we'll update the Google assistant with this optimized route let's dive into the details of what that magic is if you take a look at the first step we've updated sync response and you've told us via the other device these field that we should start looking for device locally once we find a device locally we'll ask you to give us a verification ID via the JavaScript if we find a match between the verification ID and any one of the other device IDs field we'll call that a deduplicated match and we'll tell the assistant that that device can go local if not that's okay we'll still go to your cloud for integration great so now that local path is available thanks to the sync response identifying reachable devices let's make sure when the user says a command it goes local so user says hey G lights on a system then sends a message to Google home in this case because we have established the local path right at that point the platform generates I execute intent and the execute intent handler in your JavaScript app gets called the key information to look for in the execute request object is the list of devices that the user wanted to control and the command and the control that user really wanted could be on/off brightness whatever so your app is going to create a command for each one of those devices or a series of commands actually and then use the device manager send API to communicate with the device and for your help we have a utility Builder function available that helps you create the execute response and you can specify the success or the failure state for each one of those devices so one thing to note here is that your app does not have direct access to IP address of the device and we expect your app to use the command request object to communicate with the platform and eventually to your device and so like we are showing here again you could use TCP or UDP sockets or HTTP HTTP requests so to recap what you need to do as a developer to develop your local smart home app that will run under google home device are these steps you'll tell the Google home how to find your device on a user's local network via the actions on Google console you'll update the sync response with a hint to establish this local path and you'll write an app that will handle identify and execute intents and optionally a reachable devices intent wait so moving on now that the app is written and its type script so let's start right building and running this app so type step simple it's at you're going to use the typescript compiler to generate the JavaScript app and the good thing is you can use whichever module system you want and as long as the target you choose is supported by Chrome browser you're good to go because remember this is an app that conceptually is running in a browser tab so far we've talked about that a JavaScript as app is running in the browser but technically you know it's an HTML page right so look at the sample HTML it really doesn't do much only loads the SDK and your app and during development you can actually host this HTML page in your local machine or on a hosting server and once you have that URL go back to actions in Google console and on device testing page there is a way there's an input box for you to enter this URL once you save this URL give 30 minutes for our servers to propagate this information and at that point if you reboot your Google home devices then you can imagine a tab coming up and it's loading your JavaScript app and if all of that worked moment of truth lights on did that work and did it go local well that question brings us to our next section testing and debugging your app can be a little complex because the app is running on the Google home device but we've leveraged a few familiar tools to make it easier open chrome inspect on a new chrome tab on a machine that's on the same Wi-Fi network as the Google home device make sure your network doesn't block packets between devices on the same Wi-Fi and you should see your app listed like this image on the screen behind me click the inspect link underneath your JavaScript and you can open up dev tools to remote debug your app but what if your app isn't in this list because your actions on Google console project is not yet in production a few things need to be right before your code kicks into action let's go through that checklist make sure the linked user on the google home device has access to your actions on Google project second make sure your sync response is updated and contains at least one other device IDs field filled in finally the scan config and your app URL should be correctly entered in the actions on Google console now let's assume that all those worked and your app is loading let's make sure it loads without errors to ensure that you can look at the console section of the dev tools page it'll look something like this if there is a problem for identify handler make sure that verification ID is correct and it matches one of the other device IDs field so that we can do the magic to go local next for the execute handler make sure that the commands are working either TCP UDP or HTTP HTTPS and finally make sure that you're returning a promise from each of your handlers so now to ensure the great user experience it's important that the smart of integration that you just did is complete and all the golden queries work so how do you do that smart on test suite is your friend when it comes to testing your integration and we're going to talk more about smart home test suite in detail in tomorrow's talk at 9:30 a.m. on stage five so join us finally let's look at quickly the remainder of the app lifecycle so your app works smart home test suite says it's working all the tests pass and at that point it's time to upload your JavaScript so go back to the console upload your JavaScript hit save after you feel ready you hit the submit button and that starts the certification process on Google's end to certify this new JavaScript and the integration once certified your project launches to all the users once it's launched you can manage your integration again and actions on Google console is your window to doing that you can monitor the ops dashboard you can look at the stack driver logging for all the error logs that are happening in production on Google End and if you find issues or errors with your JavaScript go back to the console and again upload the version 2 of JavaScript and hit submit if you see that in production there is a JavaScript bug and you need to roll back to a working version like v1 of your JavaScript you can again work with us through the console to kind of help you roll back your JavaScript so we've covered a lot of details about the complete devel from writing your app to launching your app if you want to learn more about the tools available and for fasters approval and submission process join us at the tools for creating better smart home talk on Thursday morning at 9:30 a.m. and now to know what's next I'll invite Carla so we have a busy couple months ahead of us the link behind me GTO slash local home SDK is now live so you can go ahead visit that link to learn more and we'll also be posting updates throughout the next couple months to that page in just a few weeks we'll launch the SDK into developer preview and at this time you'll be able to build and test your JavaScript app in the local environment and complete the self certification program that Gaurav was talking about and although we don't think it will take you a long time to complete this integration we wanted to make sure we gave you plenty of time and so we began launching projects to production in October and bringing this amazing speed to users we'd be remiss if we didn't give a big thank you to some of the partners on the slide behind me for providing engineering time and energy to test out the platform and SDK to make sure we deliver a rockstar product to you in June so when we've talked about going local this whole talk local execution is just the tip of the iceberg we have much much more in mind I want to briefly talk about two technologies were building that leverage local communication to improve the device setup experience and to extend the assistant even further one of the things we've we've heard from users is that set up an account linking of smart devices is hard in fact it can take upwards of 10 plus steps for users including downloading a new app creating a new user name and password setting up the device taking an OTA pretending to the Google home app or Google assistant app to link re-entering those credentials it's it's not easy for users one of the other things we heard is that and scenes that users have a lot of apps on their phone to manage their smart home and for all use smart home enthusiasts out there you'll recognize this phone on this screen behind me that you need a folder to actually manage your Markham so we took our first step towards solving this device setup problem with GE Lighting and developing a seamless setup experience that we delivered first in the Google smart light starter kit we gave users the ability to natively set up C by GE smart lights in the Google home app without needing to download any additional apps and instead of this 10 plus step process we reduced it to three steps and about 30 seconds let's take a look and see what it looks like so when a google home device discovers a C by GE light we prompt the user would you like to setup your smart light then we go ahead and connect to the bulb and discover services at which point then the bulb will begin to blink and this will let the user know which bulb they're setting up they click setup and choose which room they want it to go in and give it a name at this point we're provisioning the bulb to the local network and registering it with home graph and in just about one second you'll see that this the smart light is now set up and at which point it can go ahead and start taking Google home commands and so 30 seconds is really incredible for our users and we've heard really great feedback so far and we accomplished this by allowing GE to run their code on Google home devices and yes as you may have guessed they also used the local home SDK however to do seamless set up there's more intense too right than just the identify and execute we talked about today including indicate provision on provision etc and those are all part of the SDK and also this SDK can be used for more than just the Wi-Fi radio as part of early access we allow this SDK to also leverage the Bluetooth radios for direct connection to ble devices and through this seamless setup experience with ble devices we use the Google home as a hub so you don't need to go out and buy an additional ble or Gateway we're growing the seamless setup program now I'm focusing on ble devices in the near term so if you're interested let us know by visiting the link on the screen behind me next I want to talk about existent connect which is something that you may have heard about at CES and we've been continuing to invest in since it leverages the same local home platform that minute talked about to extend the reach of the Google assistant which we call assistant extensions and we've classified these into two categories the first is input extensions which enable a simple method for user to activate the assistant to do everything from simple queries such as what's the weather to triggering advanced smart home routines here we have a simple programmable button that instead of always requiring users to say hey gee they can go ahead and just push the button it's really great for some of those frequent queries in addition we also have output extensions that enable devices to show assistant responses such as what's the weather or their schedule from their Google Calendar so this is currently in early access right now and throughout 2019 we're going we have a really busy year ahead of us we have some product launches coming up later this year so stay tuned and our teams are finalizing the reference design and preparing the assistant connect SDK for public release later this year and by 2020 we expect developers to have self-service access and the ability to even more easily and deeply integrate the assistant into their products so to recap we believe that driving logic from cloud to on device is central to our strategy to create even better experiences for users and we believe that by going local it we can also invite developers to integrate more deeply with Google the secondly the developer experience is key to building a great smart home ecosystem our ecosystem is only as strong as our developer community you all we've taken many sape steps to make onboarding as simple as possible for example by not requiring firmware updates to garner the benefits of local execution and we always welcome feedback on how we can further improve so definitely let us know and lastly a big focus for us in 2019 is reducing friction and making device setup and linking more seamless I encourage you to explore our programs and learn more so with that I realize a 5:30 p.m. talk your for going happy hours so we thank you for coming here today and listening to learn more about local technologies if you have any additional questions check out the links on the slide behind me visit us in the sandbox or swing by our office hours and with that enjoy the rest of your i/o thank you [Music] 