 - Hello. I'm Rajarathnam. I've previously taken Data-X course in my graduate program at UC Berkeley. So with that, let's get started with today's module. Today we're going to look at part one of combination of neural network and in part one, we're going to look at the motivation to use CNNs basic building blocks of CNN and finally we're going to implement CNN for image classification a very simple and basic implementation. So let's get started. Why do we need convolutional neural network? Why cannot use the fully connected deep neural network that we looked at the previous module? It's basically because our statement size increases the number of connections required per layer increases a lot. And this would cause a lot of problem as in depth increases or the layers become sophisticated and the architecture becomes complex. So this is reduced by CNNs which you utilizes partial connections and weightsharing. For example. A 200 by 200 pixel grayscale image would have 40,000 pixels. And if the first layer of a fully connected layer, sorry a network has just 500 neurons, then a total of 20 million connections exist for just the first leg. You can just imagine for multiple layers, this becomes very heavy. So that is why we are trying to use a convolutional. And what is convolutional? A convolutional is basically a function that represents what happens when one signal blends with another signal, or we can imagine it in this space as imagine one segment to be the image and another signal to be an information sieve or a filter what would happen? What is the result if we apply the filter over the image this is expressed through convolutional operation. A convolutional matrix data will look something like this. A kernel is applied on a data to the matrix and after the operation we get a feature map displayed in the green matrix. We'll delve deeper into this in the upcoming parts. Convolutional neural networks are based on the idea that local deceptive fields in the visual cortex being responsible for our specific stimuli to a limited region of the visual field. What we mean by this is, in the convolutional neural network the initial layers that are responsible to detect only a certain kind of features in the visual field, let's say in an image, the initial layers can only detect the lines, smaller directed lines, curves and shapes, very low level details. And as the layers keep adding or the depth increases these features low-level features are used to find and detect or form a higher level features eventually forming the most representative image of the picture that has been (indistinct). That is the idea of convolutional neural network. And when you want to build a convolutional neural network, some of the basic building blocks are use of padding, strides, filters in convolutional layers and pooling layers. Now what do we mean by strides? Stride is the unit movement of the column or the filter and by default stride is equal to one. And we can visualize stride as this lateral movement and the jump to the next row. So this is a case where stride is equal to one and for padding, we have two options same and valued, we same add zeros around the corners and on the sides such that we can get the same output size as the input. And sometimes zeros can also be added in order to increase the output size compared to the input size. This is a case in which we can get this particular scenario. And the figure is valid we are not going to add new zeros. And the convolution (indistinct) in this way and based on this stride information can be left out sometimes because the stride is too high. We use these parameters when we define the convolutional layers. Now let's look at convolutional layers. So in convolutional layers when we talk about training or convolution layers the most important thing is the filters. What do these filters do? These filters act as informational safe and try to, follow feature maps through training the CNN. So when we train the CNN these filters have weights associated with them and these are the parameters that are being (indistinct) with the CNN, is trained on an input dataset. So in this case, we are going to define three filters and look at the feature map. If that filter is applied on the image for that let's look at an example. Let's use an image from the (indistinct) dataset. And for simplicity we use a grayscale image and here we would apply, define the filters, and we visualize our results. A vertical filter is used to detect just the vertical lines. And this is the filter when applied to the image, is how the image looks like. Our feature map. And if we zoom in, we can see, our vertical line kind of pattern. And if we use a horizontal then this is how a zoomed version looks like. And if we use cross filter this is how a zoomed version of a cross filter looks like. The next important building block is pooling layers. Pooling layers are used with subsample, the input image. This is extremely useful without losing too much detail. They can reduce the memory usage and the number of parameters and computation load associated with images or processing of images. So pooling layers do not have weights associated with them. Unlike the filters, they're just there to reduce the size of the image or subsample. And they add small levels of, invariance, yeah, to translation which is very useful. Now we'll be able to look at two pooling layer types. One is max pooling. So in max pooling (indistinct) is applied, the maximum value inside that column is chosen as for the feature map for an average pooling. The average value is chosen for that column. So let's visualize it. As an input the number of pixels is 145,000 pixels whereas when you apply max pooling the same image is represented without using too much of the information in just 36,000 pixels. That's the power of pooling layers. We can look (indistinct). And there you go. This is how average pooling also reduces the pixels require to represent the image. Now we are going to finally implement a baseline CNN for recognizing handwritten digits, also known as MNIST dataset. So as usual, we have a set of process to implement the CNN first, the data. Then we're going to look at building the model, then we'll train it and then test it. Let's load the data. And let's visualize, the data. It's a grayscale image hand written digits. So once we do that we prepare the dataset. We have the model. Put the (indistinct) into use as we have already used LeNet-5 architecture one of the primary CNN architectures which is use for detecting, character or character recognition in financial institutions. Let's build it layer by layer. And the first layer, what we're trying to do is, we're trying to use a convolutional layer, with a (indistinct) size of 5 and a stride of one, and zero paddling, that is padding equal to same, thus getting the same yes, input and output size. This 32 by 32 is after applying zeroes, before applying zeroes it was 28 by 28. And once the first layer is done, we're gonna go for the second layer, where they're gonna subsample that by using, average pooling. Once average pooling is done, we are then going to use a convocational layer. And again, a subsampling. Once this is done, what you're going to do is, you're gonna flatten it and connect it to two dense layers or two hidden layers, hopefully connected layers, with 120 units and followed by 184 both with ReLU activation activation, like different linear unit. And finally it would be more in the output such that probability scores are depicting, the target vector. We are gong to specify 10 units and have softmax activation, as the final dense layer. This is as simple summary of the layers. And we can also look at it in this way. (indistinct) the number of connections that we actually thought of. So just look at it. If we have 61,610 parameters to train for the simple model. Let's compile it, and let's train it. This will take a bit of time. Now we see that, the tiny parts of training is done, and we get an accuracy of, 98 and let's plot it. (indistinct) the plot Let's just test it. And visualize it. So we have the prediction seven, an ground-truth of seven. The (indistinct) two and the (indistinct) is two, and so on. That's all for part one. 