 [MUSIC]  Welcome to another episode of Block Talk. My name is Cody Born and I'm joined today by [inaudible] , who is a software engineer on the Azure Blockchain team. Welcome to the show [inaudible].  Thanks Cody, happy to be here.  So, today we're going to be talking about Ethereum Logic Apps. So, a Logic App is essentially and if this then that type of connector that you can build within Azure. So, it allows you to take any type of input connector and connect it to a set of output connectors. You can string together as many of these different connectors as you want. Usually, a flow will start with some trigger so it could be an event that's fired or some message that's passed to your Logic App Connector. That will trigger a cascade of different actions that you can take. So, there's triggers and then there's actions. So, the thing that we're going to be looking at today are a set of triggers and actions that are specific for block chain. The ones that we've built are for the Ethereum Blockchain Network.  So, the blockchain engineering team has created a new Logic App Connector for Ethereum Blockchain networks. This is our latest offering in the connector space in Azure. What this allows you to do is use your smart contracts that you have created in a blockchain network and incorporate that in any Logic App workflow, using the familiar triggers, actions, paradigm. So, what we have is we've exposed some actions and triggers on smart contracts that you can then use to create a good Logic App work.  That's really cool. So, the reason I like this a lot is because in the Logic App marketplace, you have today over 200 different connectors. Some are enterprise focused some are consumer-focused. So, this really unleashes Ethereum and allows you to integrate with all of these different connectors into your existing system. So, some examples are I could use Ethereum to send an email or take an email and have that being pumped into the blockchain network. So, let's take a look at how to actually set this up.  So, I have a demo with a simple solidity contract that I have already deployed to a blockchain network. Here's the contract. I have in Remix. This should be clear. So, this contract is really simple. As you can see, all it does is allow you to post a message to the contract. When a message is posted to it, it emits an event on the blockchain network and increments a counter. It exposes a couple of public methods where you can get the message that you last centered and also the count. Very simple contract. So, using this, this is something I've already deployed to a private blockchain network, a POA network.  Could you also use public Ethereum network if you wanted to?  You could. Once this is deployed, now I can now incorporate this contract in a new Logic App Workflow. Now, I'm going to show you how to create a new Logic App using this connector and this contract. So, I'm now going to the Azure portal. I'm going to create a new Logic App resource, search for Logic App. Here we go, I create a new one.  So, right now, [inaudible] is creating a Logic App which is essentially a container of a single flow. So, you can think of this as going to be a blank canvas that allows us to set up a set of connectors that will form our actual Logic App. So, while this is being created, let's talk about what is the goal of this Logic App. What are we trying to achieve in this demo?  I'm using this demo to showcase some of the functionality that this Logic App Connector exposes. So, basically, the workflow will be listening for events that are emitted by this contract. I will also show you how to read some state on the contract by calling some of the functions that it exposes. Then how it would be incorporated in a workflow where it calls another connectors say of I'm going to show you how to write to a blob storage. The output of this connector will make it a blob storage.  Okay, great. So, I think it's finished deploying. So let's take a look.  There's the deployment. Immediately, you're put into the Logic Apps Designer page where you can go and create the blank Logic App, it pre-populates it with some of the connectors that I have been using in the last two Logic Apps that I built. So, for example I have the Ethereum blockchain. If it weren't there, I will just look for blockchain and it would show me the blockchain connector. So, the only trigger that's exposed on it is when a smart contract event occurs. I select that as the beginning of my workflow. So, now when I create this workflow, I am going to be talking to the blockchain network and the contract that I had created initially. For that, I need the Ethereum RPC endpoint, so that the Logic App can read the contract state and call the APIs that it exposes.  I can think of this almost like a database connection.  Yes.  This is my Ethereum network. The private key like you can see is optional because it doesn't have an asterisk on its name. You don't need the private key to just read state on the smart contract or listen for events. If you wanted to call any function that incurred a gas cost when you have the sign the transaction, at that point you'd need a private key, but this demo doesn't require that. So, I'm not going to put in my private key. If you did, it's backed by Azure's security guarantees and to be safely stored.  Got it. So, essentially, anybody that has access to this Logic App will be able to sign transactions on behalf of this key. So, that's one thing to note. As [inaudible] mentioned, the key is stored securely, it won't be exposed from that point on.  So, this page now asks you for the contract ABI which is the smart contract's API and the public address of the smart contract which I can get from my Remix page. So, this is where the addresses can be got, and to get the ABI and move to the compiler page. Here's the ABI.  So for those of you who are not familiar with Remix, it is an in-browser solidity compiler and it allows you to interact with the blockchain. So, you can deploy contracts and you can interact with those contracts.  Now that I've entered the ABI in this smart contact address, you will see that this dropdown will be populated with the name of the event that the smart contract exposes. I can select that event trigger based off of that.  That's really cool. So, it's automatically populated based on the ABI that you pass in.  Right. I want to trigger it every minute. So, I'm increasing the frequency.  So, that means that every minute, it's going to look at that Ethereum contract and see if there are any new events that had been fired since the last time it ran?  Yes.  Okay.  If the event is triggered, then I can take some actions on. I'm going to use the blockchain connected again and return state off of that. So for example, on my contract I could read the message as well as get a count of the number of messages it has received.  Because those are the two public properties.  There are other things I could potentially do. I could deploy another smart contract, execute another smart contract function, which incurs gas costs for which I would need the private key or just query another function without incurring gas cost. But for this demo, I'm going to be using the "Get smart contract state". Again, I need to enter the ABI for which I'll go to Remix. The reason you need to enter the ABI another time is because theoretically, you could be working with another smart contract here, something different from the previous one. I need the smart contract address.  I'm already thinking of all types of scenarios you can build where you're taking content from one blockchain, writing it to another blockchain and based on different contracts data.  Right. If you wanted to write to another blockchain, you would just have to change the connection here. Right now, it's using the same network that I had previously setup for the previous step. Like you said, if you wanted to write to another network, you could just change the connection.  That's really cool.  So, now I have read the state of the smart contract here and the next step is getting fans here. I'm going to write to "Blob Store". Here, again, I need to create the connection to "Blob Store" and select one of them.  So, one thing to note is that these connection objects can be reused across multiple instances. So, it's something that you set up once and you can just set it up in the background and for each of the new connectors.  So, I want to create a new Blob, every time this smart contract fires this event and use it to perhaps count the number of messages received or create a new unique Blob, based on the number of messages.  Okay.  So, like you can see on the right, the dynamic content has been prepopulated for you. This is based off of previous logical steps.  I see. So, the content on the right is essentially output from the previous step in this flow?  Right. So, I'd like to count. So, that is part of the Blob name and probably the content, I'll put it in the message that was sent to the blockchain contract.  So, this is neat because as Logic App developer, I didn't have to worry about naming these variables. It automatically picked it up from the-.  Who used it. From the contract and the previous execution of the previous step.  That's great.  I'm happy with my Logic App workflow and I'm going to save it. Now, that it's saved, I'm going to start running it. In order to see it work, I have to obviously trigger an event on the smart contract, which is what I'm going to do with Remix. I'm going to post a message on this smart contract. I'm going to call it Hello Blockchain. This is the message that is sent to the contract and which I hope to see finally in Blob store. The transaction is sent Was it sent?  If you close that and then open up MetaMask, you'll be able to see if the transaction went through. From here, you say cancel or "Reject". It looks like the transaction was made.  That's great. Thank you Cody. Yes. Now, I should be able to see that the Logic app workflow run. It was triggered.  Great. So, those green checkboxes mean that it succeeded?  Uh-huh.  Okay.  Yes. Now, I should be able to see the Blob. This is where I expect to see the new Block Storecreated, Blocks container created. Blockchain message seven was created. You can see that the count got appended to the-  Awesome.  - name. It was the seventh message that that contract had received. If you look at the contents of the Blob, yes, my message has-  Success, nice. Awesome. So, what we saw today was the ability to set up an Ethereum Logic App Connector. You can take data that's triggered from the blockchain. You can have that trigger launch a cascade of different actions. The action that we decided to take was reading contract data and then writing it to a Blob Store.  Right.  That's awesome.  There are many other things you could do, integrate with Outlook and send an email or send an SMS message. The triggers could also be- when you receive a certain email message, you could put the contents of that into the blockchain. It doesn't have to be just a trigger on the blockchain. It could be triggers on any other Logic App connectors that then feeds into actions on the blockchain.  That's awesome. So, I can imagine all the different types of scenarios where you take content and just check point it onto the chain as relying upon that chain's immutability.  Correct.  As part of the feature.  Yes.  That's awesome. So, let's take a look now at all the different Ethereum connectors that we've built. So, today we saw the trigger which was based on the Solidity event. Then we saw the ability to read the full contracts state. So, [inaudible] can you talk a little bit about the other connectors that we've built.  Okay. So, these are all actions that you can take on the Ethereum Blockchain Connector. The first one is "Deploy Contract". If you have an account and its private key, you could deploy your contract and the ABI of, sort of the Solidity ABI of the contract, you could deploy it. You could also do a "State update" which means you can change any state on the contract by sending the sign to transaction for which you need a private key again. The "Query status", the inability to read all the public properties of the contract exposes. For this you don't need gas. You don't need to need the private key to be sent.  Got it.  "Read full contract" is reading all the properties of the smart contract. The previous is when the query stages is where you can call a specific function. Whereas the read full contract is the ability to read all the exposed public properties. Got it, very cool. So, the Ethereum Logic Apps is the first set of blockchain Logic Apps that this team has launched. In the future, we're also planning on launching Logic apps that are dedicated to different types of blockchain ledgers. So, I think if you are interested as a viewer in any of these different other ledgers and want to see Logic Apps for them, let us know in the comments and we can make sure that we prioritize accordingly.  Right. If you want to try out the blockchain connector, you can also use- I think Azure provides these in free subscription, so that try it out.  There will be a good place to get started. We also have our Ethereum Logic Apps Docs That you can check out that we've published that aka.ms/ethlogicapp. So, that's E-T-H Logic App. I think that's it for today. You can follow us on Twitter @MSFTBLOCKCHAIN. You can always subscribe to this on Yammer, Channel 9 or on YouTube. 