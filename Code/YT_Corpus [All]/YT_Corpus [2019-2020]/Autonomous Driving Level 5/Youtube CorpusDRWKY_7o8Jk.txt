 hi i am jaineem nandu and in this video i will be talking about the software engineering processes used in the development of self-driving cars i will also be talking about in detail how the software is tested and validated let us first understand why the development of self-driving cars is a huge problem self-driving cars or autonomous vehicles in general which we will refer to as avs from now on have to interact with and or react to the physical environment which means it needs certain hardware to gather information about the hindu environment and another set of hardware to manipulate itself to achieve its goal also in addition to the hardware it needs appropriate software to make use of the information and make intelligent decisions the requirements can be defined upon defining the end goal of the system which we can get from sae's levels of autonomy sae has defined six total levels of autonomy from level zero to level five with increase in each level corresponding to increase in automation and thereby increase in complexity of the software for example level one autonomy only needs to augment the human behavior with an exam with an example of this can be a parking assistant which only needs ultrasonic sensors as hardware so this is how the hardware and software requirements can be gathered upon defining the goal of the system the av software stack can be very broadly divided to perform three tasks perception path planning and control perception systems take information from the sensors and try to make use of that in the end the goal of the perception systems is to know what is happening around the av also known as the eco vehicle path planning uses that information to guide the vehicle to achieve its end goal of reaching a point on a map and control systems manipulate the vehicle to fulfill the path defined by path planning pause and think why is agility so important to develop av software we use a structured process model when the requirements are well defined in this case the requirements are not always well defined while testing the system we may find that there is a need to satisfy some additional sets of requirements too and hence our requirements can change some of the reasons we have to change them can be changes in environment that is whether road conditions changes in laws that is passing of new laws or amendments in the original ones changes in drive of behavior there can be many other reasons for two for not for the changes and requirements to develop an av software we must break it down into sub projects within each sub project different processes are used define milestones with the help of story cards that describe driving situations furthermore we must decouple the iterative software development with hardware example through virtualization using smaller iterations can ensure progress and quality and the most important part is to continually integrate the software pieces using vcs or version control systems can help you keep track of working code testing is the most important aspect for quality assurance regression tests after each increment is a great way to ensure that the increments are not breaking the already existing code integrating the automated testing infrastructure with vcs is quite beneficial such that whenever new iteration is committed all the defined tests are run pause and think all software is integrated and closely linked with the hardware so appropriate abstractions of software and hardware are necessary to run the tests efficiently so how to test the software efficiently the answer is simulations with simulations we can simulate the hardware with this almost any developer even remotely can test the software quickly and efficiently also we can manipulate the timing of the test such that the test may not actually run in real time but much faster regardless of the process we use if we do not use the right tools the software development becomes much more difficult and time consuming than it already is here is a tool set described by christian berger and bernard ramp in their 2007 paper engineering autonomous software in the paper they rightly mentioned that while matlab simulink can be used to design control algorithms it does not scale for complex data structures or properly supports the design and implementation of software architectures and hence c plus is used to write the actual code furthermore they stated that uml tools were only used for discussion and thereby has documentation also note that the version control systems used is subversion which was a popular and appropriate choice at the time the development of av software described by christian berger and bernard rump implements a development process with testing both virtual and real world as core components in the process for every iteration we start by defining the requirements analyzing and performing scrum pro product backlog after that we designed the simulation tests to meet the requirements and add them to the existing pool of tests we get the necessary validators or performance metrics after which we implement the test case in the simulation environment which can be code or specialized software after implementing the test we write the actual code to implement the requirements which we then test here with implementers implemented tests on passing of the virtual tests we plan and execute the real world real vehicle tests only upon passing them do we deploy the software an advantage of simulation first approach while not being discussed but is implied here is the safety of test drivers since the behavior of the vehicle is somewhat known because of the virtual test the real world test case are much better predictable and involves less risk to the driver also note that there is no feedback from real world or virtual tests to the requirements because the authors derive their requirements from the darpa challenge and hence the requirements albeit a little way need not be modified because the test cases can be designed to handle that the real world development of self-driving cars will require feedback because of uncontrolled situations not present in the darpa challenge so this is my understanding of the software engineering process i have simplified the simulation first approach by assuming the validators are taken care of when implementing the virtual tests also since the requirements for simulate first were already defined for the darpa challenge we did not see your feedback from any of the tests there while testing there's a good chance we can encounter new scenarios that we need to take care of and hence appropriate feedback is required also feedback from end users the government etc is very important and hence need to be factored in i'd like to speak a little bit about the simulation application since it's an important aspect of the testing and development of av software the background image you can see here is of different conditions in karla simulator such comprehensive simulators are not only essential to the dev to develop test scenarios based on our requirements but also they can be used to create new scenarios while unlikely in the real world can be very fatal thanks a lot for watching this video i hope you liked it and got to learn something have a great day 