 In this mini video session, I am going to talk about the common conversion specifiers, which are used in C programming language. During our discussion of the printf output statement, and the scanf I had told you the conversion specifiers determine what type of data you're reading and printing, because C really does not care about what kind of data you read and write because for it data is simply one sign zeros. So it is your responsibility to use the conversion specifiers in a meaningful manner, and then determine how the data should be treated. So if you want to treat a number as an whole number, or an integer to the base 10, you will say percentage d. And if you want to print an octal number, you will say percentage O, it's not zero, it's percentage O, hexadecimal, it's percentage x real number, or single precision real number is percentage F, double precision real number is percentage l f, it's not one f it's L is in line f character. If you're printing a single character like x, y, A, B, like that, you will say percentage C. And let's say you're interested to print your company name, like say Arjun Rohan, then you will say percentage s. All of these will be discussed in detail as to how they are useful once we discuss the various data types available in C, and how we deal with characters and strings in a session later on. But it's a good idea to have some knowledge about the conversion specifiers so that you feel comfortable using printf and scanf. To start with. To gain a better understanding of the conversion specifiers, I shall take the assistance of a simple program. So what we're doing in this simple program is, we're doing a couple of things, we are taking two, three types of data, we're taking numbers, we're taking integers, and we're taking real numbers and then trying to print output using different formats of the conversion specifiers and trying to show you how the output really looks like. And so what I'm doing here is I'm printing int, float and characters using different format specifiers or conversion specifiers by giving them different widths. width is the amount of space you're giving an output screen to print the data. So I have declared an integer variable is 101. A real number float j as 1234.123 f f and the end indicates that it's going to be a single precision floating point number. If you forget to mention the F automatically it is initialized as a double point or a double precision floating point number. Here what I've done is I've taken a name, the maximum name I can have is of 19 characters because one character is reserved for indicating the end of the name. And here are given it the initial value Arjun let's go one print at a time here I am doing printf percentage D. So when I bring printf percentage D the value of i this is 101. So in this box hundred and one is printed. Now, percent 6d is the width specified I am specifying in six output spaces, print hundred and one. By default it'll leave three spaces at the beginning this is 1233 spaces at the beginning and 101 Next I have done percentage minus 6d. So now what it will do is it will print 101 but leave three spaces after the last one. Here I am doing percentage 6.4 D, so total width is six. But I am saying point 4d. What it does is it ensures that 101 is printed. But since 101 is only three digits, it adds a zero before it and leaves two blanks before 0101. All right. So this should give you an idea about how this percentage D with percentage six minus 6d, 6.4 and all . For this to gain a complete understanding you must type this program and play around with it by changing the width and see how it reacts on the Output Screen. Because this is highly conceptual and unless you type in the code and play around with the width and the changing the science you're not going to get a real whole feel of how it is doing because I'm on a static screen. Now let's take a look at the next printf statement in the next printf statement. What I am doing here is I am printing a real number j three times with different formats of the conversion specifier. In the simple percentage F, it's going to print 1234.123047. Just in case you're wondering where the 047 came real numbers, or if you know floating point numbers are not exactly stored there an approximation. So internally it is stored as .123047. That's why after decimal digits, it's printing six places accuracy. So, .123 was printed as 123047. Now I'm saying percentage 12f, that means in a width of 12 spaces, print 1234 dot 123047. So this is 67 7 plus 4 11. So one space at the beginning. Now percentage minus 12. Yes, this is a minus minus 12. So it's going to print 1234 dot 123047 space at the end. Now what I have is percentage 12.2. That means I have 12. But I want only accuracy or precision up to two decimal places. That's why it is leaving six spaces at the beginning. It's using this four spaces 10. Okay, so it's leaving six, or it's leaving five spaces five plus four is nine, nine plus one is 10. And after the decimal places, you have two accuracy of precision of two bits or two digits. Now this 12 point two E stands for the exponential format. So since our given point two it's one to print only 1.2 ie003. Okay, so this is the exponential format of printing. Now let's go to the last one. Here, I'm interested to print the name Arjun. So when I simply say percentage, s name, it's going to print in the box very tightly without any space to the left or right, when I say 15 s, in a width of 15, it will print Arjun to the right and the remaining places at the beginning will be all blanks, this is five. So there'll be 10 blanks, each of these line indicates one blank. Now minus 15 is it will print Arjun at the beginning and 10 blanks after the last character n. Now, if I say percentage 15.2 s see what happens this point to an all have meaning with floating point number they don't have meaning with integers and characters or names like this. So, if you put 15.2 it will only print AR at the end, and all the 13 characters at the beginning will be all padded with spaces. So, I will suggest take this program run and play around with it by trying to change the width trying to change the sign and see what all happens. Now, just want to help you understand what are the different ways off or what is the conversion specifier how it is to be used. So, the conversion specified here can be percentage D percentage, lF percentage f percentage or percentage x percentage is given w stands for the width and precision stands for P. So it will be W dot p precision is meaningful only in case of single and double precision numbers, no point in trying to take characters and put to unless you want to do some crazy precision operations and W stands for the width suppose for this instead of 6d I had put 1D what will happen is the width is one but the number of digits is three. So it will ignore my width specification and it will print all the three digits. So the width is obeyed only if the width is equal to or more than the number of digits present. So here percentage one D two D will have no effect it will still print 101 so the width specification is meaningful if the number of letters is more than the width specified is ignored. P specifies the precision like this 12.2 12.2 e. This is useful in case of single and double precision. Now suppose I want to print a decimal integer percentage 3d. Okay, with a width printing of 10. Working with a word percentage three three indicates the width there is no precision for decimal number or integer number, percentage three is going to print 10 with a space at the beginning and 10 it is going to be right justified in the sense that one and zero are going to come at the end and blank is going to come before if I make it percentage minus 3d 10 would printer be printed first and the blank would come after the last zero this is called less left justified the blank before the number is called asRight juste fied so I hope you have got an idea about how to use the conversion specifiers it's impossible to cover all the possible operations with conversion specifiers I expected or you to do it in the lab or on your own to play around with the conversion specifiers and try to get the desired output 