 So now we'll talk about the use of multiple views. With multiple views, we can think about faceting into these multiple views, and one consideration is how do we juxtapose views side by side? Another is how do we partition the data,  chopping it up between the views, and what are the considerations when thinking about how to superimpose layers on top of each other within a view. So starting in with juxtaposing views, how do we think about ways of coordinating juxtaposed views.  So one issue is do they share the same visual encoding or is it different? Either way we could have linked highlighting between those views. Is the data shared between the views all the same, or is a subset in one versus the other, or is it a disjoint partition where none is the same. Is navigation shared between the views, where moving and one causes motion to happen in the other? So let's walk through a few specific examples in this design space that are very popular. So first of all, let's talk about this idea of linked highlighting. It's a very powerful and pervasive idiom for interaction that we're seeing all through visualization. And the key idea is that you want to see how a region that's contiguous in one view, - you highlight it, and then it's also highlighted in the - those items are highlighted in other views. It might also be contiguous or it might be highly distributed, and seeing those differential distribution patterns is a huge amount of the power of having multiple views. So here's an early example from the EDV system, where we're looking at baseball statistics using multiple different kinds of visual encoding. So it's a multi-form view, a multi-form approach the data is completely shared every view shows all of the data.  And we're seeing, well, it's showing all of the items and we're actually typically seeing different attributes across the views, so what have we got there is a salary plot in the upper right hand corner. We've selected the high paid people and we're seeing how are they distributed in the other views. In the bar chart showing the years they've been playing, they're very distributed. Positions also very distributed. Notice how we're doing something here where with linked highlighting: we are showing the subset of the bar, sort of in a stacked bar chart mode, of the highlighted part on one seeing how many items in that bar are highlighted in the other. We see them also distributed between assists and put outs. But we do see on the scatterplot on the right side that in fact the number of hits per year is above average for all of the highly paid people, so that makes sense. And linked highlighting can happen, both with different encodings, with the same encodings. A very common approach, let's think about another design pattern, which is the idea of overview detail. So this particular example of it is a geographic map, where we've got a so -called bird's eye view, where we have a large detail view and a small overview. In this case, we have the same visual encoding: these are both showing geographic data, where we're using the given spatial position to actually show that geometry. The data that's shared is a subset. We've got a subset in one view, compared to the overview and the navigation is linked bidirectionally: if you move in the detail view, you'll see that little box representing your location move. And likewise you can drag the box in the overview, and then you'll see the detail update. So the only difference here from a visual encoding point of view is the viewpoint, which then is showing only a subset of the attributes in one. This approach of having an overview in a detail view is extremely common, again and it can be both for shared visual encodings and for having very different visual encodings in the detail view. One more that I'd like to walk us through is this idea of small multiples. So in this approach you've got the same visual encoding across a whole set of views, and there's some differences in the data you're showing. So it could be different items, could be different attributes. In this case, to have the same example we've seen a few times for memorability, We've got different items because we're actually using different keys for the experimental condition even as we're looking at the same gene keys and the key thing is we've got the expression values for the node colors as they're changing over these different conditions. We are using the same network layout. Here the key point is what we're seeing: we can have our eyes move between these views to try to immediately see comparisons. So there's a power in being able to move your eyes between the views. In this case, navigation is shared, so moving in one causes all of them to move accordingly. So we can think about these possibilities of same versus different visual encoding, and all or subset or none of the data  shared, and there's really - of these six possibilities there's two that are less interesting. If it's the same encoding in the same data, it's totally redundant. If there's totally different encoding and totally different data, there's no way to link the views. So these different flavors of overview and detail, and the small multiples, and the multi-form are all very common patterns. Now one thing that's worth thinking about is why are we bothering to juxtapose views? And one issue is the benefit of eyes versus memory. It's much lower cognitive load to move your eyes between two views, than remembering some previous state within a changing view. So with just changing a view you have to remember what you saw before. On the other hand there's costs: every time you add a new view you've basically taken a display area away from the other views. So even though you could have an interactive system where you're manipulating and navigating and you might see many many frames, you know perhaps thousands of frames over the course of an interactive session - there's no way you can see thousands of side-by-side views simultaneously. You're going to be highly limited. So there's definitely a trade-off there between what you are able to do. Snd this is one reason why often we do both: we have multiple views, and those views themselves are interactive where you can change things. Here's an example of a fairly aggressive system, the improvise system, which is really having a lot of multiple views. It's certainly pushing the limits on what's possible.  On the other hand, through careful design there's a lot that is possible to understand across these views. There's no clear limits on how many views is okay. That's very much an open research question. Some of the things we see here: we've got an overview-detail where we have a geographic overview in the upper left corner and then a much larger detail view, we've got some parallel coordinates, we've got some scatter plot matrices, we've got a large detail scatter plot so we even have an overview detail approach there. We can see the color map. Something I want you to notice is that there's quite a few views that are basically list views. They are reorderable list views, they make it very easy to look things up All by themselves they might be a bit useless and boring, but in conjunction with a multi-view system it allows you to quickly look things up. So that if you know that you're interested in say high values of a particular attribute, you don't have to go hunting for that in a geographic map. You select it in a view that's where you've ordered according to that attribute, and then you can see it in these other views like the scatter plots or the geographic views. So let's think a little bit about partitioning into views: how do we divide up that data? What we're doing is we are splitting, typically into different spatial regions, according to some attribute and then by having these different spatial regions, that means we're using spatial proximity to imply association between those items. That's that really strong perceptual cue for grouping. So what that means is that the order that we partition in has huge implications for what patterns are clearly visible. So let's look at an example: let's take a simple case, bar charts. So if we're thinking about, we've got some sort of data set where we've got geographic data and demographic data, so in this case US states, and these demographic categories of age  groups let's think about two different orders. We could start by splitting by state so if we start by saying let's have one region for each state, then within that region we're showing a glyph which is multiple bars grouped together for the different demographic categories. So what kind of comparison does this facilitate? It's really easy to compare within the state,  it's harder to compare across ages. So it's very easy to see that all six of these states have pretty similar demographic patterns. We can see that immediately. Maybe it's harder to understand what happens with 45 to 64 year olds in Illinois versus Pennsylvania, though. So in contrast, we could do it the other way around. If our first partition is that we split by age, and then we've got one region for each age group - well, now what we've got is we can do a small multiple approach where we look at one chart for each of these regions. And now it's very easy to compare within the age, we can actually see it's much harder to compare across states but much easier to compare within the age. So there's no single right answer: it depends on understanding your task which is the answer for many many many visualization questions: it depends and it's task dependent. Let's look at something a little more complicated than just bar charts. This is a fun data set of housing prices in London England. And so with many - it's a multi-attribute data set -  so in this case first we split by London neighborhood, then we split by the type of housing like flats or detached houses or semi-detached row houses, and then by time, so the years are the rows, the months are the columns. And then these are color coded by price. So essentially we have this quite complex design of a heat map looking thing at the moment. So what can we see this way? We can immediately notice expensive neighborhoods are all dark, we can notice real disparities between the four housing types - where are neighborhoods where there's huge disparities between, as opposed to just everything's expensive, where only certain types of houses are far more expensive. So we can see that based on the order of splits. Let's try a different order. What if we switch to first split by type, and then within the four types we can split by neighborhood. We've also switched what we're color coding:  we're now color coding the price variation. So now the kinds of patterns we can see are within a type, when is there a lot of inconsistency within a neighborhood. If i were house hunting and I found something that seemed like I liked it but it was a little expensive - should I keep looking? Is there going to be high price variability within a neighborhood? That's the kind of question we can ask   with this visual encoding. Things don't have to be rectilinear You could do something where after you split into the type of house then you could show things as a geographic, in this case a choropleth, map. So, many options here. Finally, let's move on to talk about superimposing layers. And by layer I just mean some set of objects that spread out over a region that's basically the whole view,  and you want somehow to have visually distinguishable groups. And so the big question is, well, how do we do that? In the design choices, there's how many layers can we get away with? How can we visually distinguish them? Certainly one way to do it if we have a small static set of layers, it's straightforward to make a foreground and a background layer. One thing we can do is try to make sure that we have non-overlapping either regions of visual channels - notice how in this diagram here we have green things versus black things and we can actually distinguish  when we superimpose them. The world is very different for static things and for dynamic things, so we'll look at examples of each one. So with static visual layering, here's an example of where we - there's been a huge amount of care over hundreds of years that cartographers and geographers have put into map making. So they thought deeply about the question of static visual layering. What we've got in this example is a foreground layer where we've got roads where you've got a distinction of both the line width that's size coding and the hue to distinguish main roads from minor roads, and there's really high luminance contrast of the roads against the   background. Then in the background layer it's much more about the regions, it's desaturated colors - to see the light blue for the water, and the green for the parks, and the light tan for the land areas. And so you can switch back and forth and just focus your attention on which one you care about at will. So this is not interactive, it's an attentional focus switch. Now this actually came from an article, also by Maureen Stone, about get it right in black and white -  and a key design principle that's worth mentioning since we've been talking about luminance in the color snippet - is that what we want to do is often check the luminance contrast by just looking at this in grayscale, and that can really help you understand whether you've got appropriate  luminance contrast. So, a good design principle to live by! Here's another example of superimposing. We're doing something fairly sophisticated here: This is an example of trellis plots from Bill Cleveland et al. So what they've done here is they are looking at - in this case it's, I believe, barley yields in the 1930s in some different geographic regions - and they are superimposing two different years that are color-coded 1932 and 1931 in the same frame so that we can actually start to see patterns. There's also been partitioning. So remember we're doing combined strategies. So first they partitioned by the site that things were planted in, and then the rows here are different varieties of these barley wheats and then they're doing what's called main effects ordering, which is basically try to figure out a reasonable order -  just like you could do simple data driven ordering for bar charts where you just order the bar chart by the same attribute that you're actually length coding by. Here you could try to compute medians for groups in order to decide, well, what order should you have these, in a more meaningful order than just alphabetical. And then you can order the rows within the view according to the median of that variety, and so you're ordering the views themselves by the median of the site you're ordering the rows within the view by the variety. And we're doing that actually consistently so we can see patterns across the views, and then you can actually notice an anomaly here where in Morris it looked like there's actually possibly some kind of a data problem, or things were very unusual that year - but there's an anomaly where that's the only year that you have 1932 and 1931 switch left to right compared to the others. So that's a way to notice that, which might be quite difficult to do without trying to have these superimposed and careful partitioning. Let's talk about dynamic layering since we're thinking about interactivity as well. So one thing to do for example with network data, it's very useful that if you've got large and complex graphs where it would be difficult to see things if you drew the links at all time, you can draw links on demand. Here's an example on the left where we've got something, where the user clicks on a node and then immediately all the one hop neighbors are actually highlighted. In this case it's a the nodes are philosophers and the edges are influences. On the right, we have an example from an interactive D3 demo. Again you can click through and play with both of these yourself. And with this one you simply move the mouse in hover mode and it immediately updates and redraws, so very very fast response to get a very fluid sense of exploring this data set which has so many edges they chose not to try to draw all the edges at once and they let you just explore those interactively. Again, quite a bit of further reading on this topic, and we will wrap up this section and move on to the next. 