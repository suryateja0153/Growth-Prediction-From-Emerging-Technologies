 thanks so much for coming my name is Jenny McLaughlin I'm the senior platform architect at pivotal and today we will be talking about neo4j and cloud foundry from speedy app development - speedy graph database all right so now let's talk about what we really want to talk about which is what developers love we love our software's right developers all right we love it so much and we wanted to give it to the world and we want to get quick feedback make changes and give it back to the world so ideally we want to be able to deploy new features let's just say daily to production maybe you want to do hourly or maybe you want to be like Amazon they deliver their new features production every 11 seconds but let's just say daily think about what that will let us do how are our business delivered values it's all about that faster feedback loop right and we also want us to everybody focus on outcome instead of individual activities so instead of saying let's build that webpage were adding schemas to our database let's just say I want all the password buys at Times Square tonight to sign up that weekend special program so I want my teams to be really aligned with business outcome kind of like DevOps going I want my software's to be loosely coupled so I can make components out of my applications I can update them independently so I can go quicker and of course data is everywhere user generated data machine January data the velocity of the data the variety and volume of data just come into organizations like phenomenal speed and it just doubles in size every two years so we want to be able to store the retrieve the data efficiently and we want to be able to have some database to ingest the data different kinds of forms without compromising performance I won't have my middleware hardware everything to his self-service automated because even have to go through the manual process to spin up VM the WebSphere things like that I'm not gonna be able to do my daily deployment anymore and I want to be able to scale things out and back in quickly and hopefully free for free I want to be able to upgrade my software with absolutely no downtime because Facebook and Netflix they never have downtime right neither should we we have customers globally plus it's just really dangerous to have that change window in the middle of the night when folks are tired and grouchy we tend to abort our effort if something goes wrong so let's do upgrade in the middle of the day where everybody is happy we're at our peak performance and if we have to rollback that's ok we do everything in a no downtime way are one of my applications to be highly available resilient and any failing components can be automatically resurrected but in reality things aren't that easy sometimes deploying applications can be very slow think about a typical app dev team in an organization we usually support many applications right and now marketing has this new idea and they want us to work on it until it's done of course our software is never done it's just just a release but at least until which starts to get in front of customer we're either making money or we're losing money between the idea to production we have to go through planning and development and testing deploying and monitoring the application in production so that can take probably months so on the development site we decided to do agile and we do some continuous integration scrum daily is there not but we do unit testing and developers checking the code and kick off the build if it passes great if it fails we will get a notification and say hey you broke the code and go fix it so that's pretty standard but the problem is - it's too narrow right we still have separate QA team who is going to do testing in the integration testing environment functional testing environment user accepts acceptance testing environment performance testing before we go to production and for each testing environment we have to spin up the VM install as WebSphere Tomcat or you know if you're in Windows world that will be Aya's server network of five DNS certificates hook up the back-end database and some configuration deploy to code and do the testing an offender we have to do this for every environment and the funny thing is that if somebody is doing a security patch for upgrade and now I can't do testing anymore or if somebody accidentally changed my artifact my jar file or configuration or the security policy on Windows Server and now the environment is useless right I mean we've we've all seen this becomes inconsistent and corrupt and dirty just useless what's the point of testing so even though we have scrum on the development side the whole process is still a little bit waterfall right so now we have water scrum fall which still takes months from development to deployment so that's pretty frustrating and from the operators perspective things are not necessarily better either still can be slowed from patching and operating someone has to write the scripts and somebody has to apply the scripts in different environments and most likely that's gonna involve outage and operators has to consider okay there's no single point of failure so we have two setups clustering we have to figure out how to scale and make it highly available and consider security those kind of things so the the problem is that all these things to me is just not much of business value right if you think about it it's just kind of below the value line because at the end of the year your CIO is not gonna patch or shoulder and say a great job patching that server right so with all the frustrations there's got to be a better way and we want to be better at this we want to iterate fast of course everybody knows cloud native right it's kind of buzzword going around for several years and it's not about running your workloads on someone else's the data center is really about deploying your applications or services in a totally different manner by significantly reducing that development to deployment cycle time so it has three components continuous delivery DevOps and micro services there are necessary components but they require a cloud native platform to glue them together so going back to our story where you know we push this idea of to production continuous delivery is that extension it's of continuous integration it's all about having that consistent automated platform where each and every environment is as close identical as possible so instead of having that corrupted environments now we have an automated platform where everything is all made out mated the VM should be automatically spin up an OS should be automatically installed and middleware and network and all those things so when developers check in the code is going to kick off the build an artifact will be created right it will be automatically promote to integration testing environment of course you still gotta write your test scripts but that can be automated as well right you've run your test scripts and passed everything is automated get promoted to functional testings environment and past that go to user accept user acceptance testing environment there will be pause here because we need human interaction here but at least your environment is ready so your your users come in and test it and hit that green button is going to automatically promoted to the performance testing environment and you can either automatically promote to prod or you can let your proud owner decide at that point another pause but at least everybody will have high degree of confidence before the new release goes to production that this is going to work because it has gone through all these steps and that Ops is that extension of the agile team basically brings apps and apps together so we are responsible for the application right it takes the overall ownership the team has the overall ownership therefore they're gonna do what's the best for the application and consequently what's the best for business in this automated platform cloud native platform enables DevOps more than anything else it really helps remove the friction microservices are loosely coupled services with bounded context so but it really helps improve speed to market scalability and resiliency each micro service interact with each other's there was certain type of api's usually language agnostic and each micro service has its web tier and dated here serviced here dated here and back-end database so if they have to make a change you think about it is everywhere it's everything is within the same teams control right so the team really meet their own business ease and control their own destiny like we mentioned earlier we need a cloud native platform to glue all these components together and pivotal Cloud Foundry is that structured cloud native platform it is infrastructure agnostic as you can see Cloud Foundry everyone's consistently across different IAS weather is vSphere OpenStack AWS Google Cloud or Azure and there's this layer called Bosh is the open source tool it's all about deploy and manage distributed systems so barcia interacts with cloud different clouds through cloud CPI and it really takes care of a lot of operational challenges things like provisioning and monitoring and updating and patching so if there's any failing processes components is going to resurrect back up automatically and restore to restore it to the correct state that is a powerful because you can continuously deliver all these distributed systems from version one to version two to version and without any downtime right and also you can patch things and fly everything just goes smoothly and that's just the operation control very powerful so now we have the ability to deploy and manage distributed system than the first distributed system is right here pivotal application service this is pretty much you know everyone knows about Cloud Foundry where developers just do CF push and push their code to Cloud Foundry and another aspect is PKS pivotal container service K refers to kubernetes this enterprise skill of kubernetes it makes cluster provisioning a matter of minutes operation and also a seamless patching and upgrading so if you have prepackaged applications third party vendor software or some backing services you can let PKS manage those things for you pivotal functions service brings functions to the Cloud Foundry context right it really allows you to do functions and the events and behind your firewall you know in enterprise right not in public cloud so you can start tapping those Network events database events and instead of using those random shell scripts now you can turn them into functions right supports multiple language of course they can run in different crowds and the last apparel here is pivotal services marketplace this is where you can connect your applications was different backing services and speak of backing services in Cloud Foundry we're talking about data stores messaging queues and caches things like that so there are two types of services one is bash manage and the other one is externally managed remember we talked about how abar is all about acquiring a manager distributed system so bash can manage your backing service right any of you if you don't have that that service to be bash managed it's something else is managed a life cycle and we do this by by using those important and pretty simple API called open service broker API so the service broker just going to reserve all the resources for you and give you connection information and from the developer perspective is just an endpoint so now we got a look at some of the database services data stores right pretty much all developers were familiar with asset transactions from working with relational database and it's just relational databases it requires us to do you know large create a logical models and enforce the structure into a tabular physical model and with foreign keys and join tables to reflect those relationships joists aren't that bad if you just have two three hops but if you have lots of hops and that can really jeopardize your performance and sometimes the the results may never get fully calculated so if you look at these tables just if we want to know what products did Alice purchase probably a cup of hops joins and we can get results but if we want to ask the question which customers bought strawberry ice cream and that can be an expensive period right so relational database is just it's another aspect it's not meant to be able to keep up with the quick business change requirements because they're Justin Richard and Dale modeling is complex so if you need to have a huge amount of data and your business requirements constantly change definitely graph database is a better choice because they put the data relationship in the center right any of you want add a new node or new relationship to an existing graph is not gonna impact the performance much queries are very efficient even though some queries are deep and calm a new fridge a definitely leads lead the effort in the space right and in terms of graph processing and graph storage especially if you want to run graph database in production neo4j Enterprise Edition is the way to go not only does it provide developers design and development tooling it gives operators all these benefits in terms of availability performance security monitoring etc so let's let's do a double so what we're gonna do here is we are going to have the springboard application called movie graph by the way Spring Buddha is a job of framework it's a very opinionated way of building micro services in case you're not familiar we're gonna push it to pivotal web services this is Penrose public cloud it actually holds like more than 60,000 applications we're going to use user provided service to connect to new 4j Enterprise that spin up on Google cloud alright so let's look at our application I have this movie Java spring daily neo4j application and I want to make sure it runs on my local environment first right I'm just gonna say maven Spring boot run so it's up running on port 8080 if I go to localhost 8080 I see my movie rapture now I'm getting ready to push it to Cloud Foundry but remember we have to have new 4G running cloud somewhere we want to run it on Google Cloud so I'm going to spin up a new 4G Enterprise in Google Cloud I'm just gonna say launch on compute engine here see like the project just feel parameters the name of the zoom and what kind of machine type how many knows minimum three nodes and if I hit deploy in the few minutes a new 4G enterprise console cluster is going to the PD boys since I've done this before and I don't want to create another one and burn the money here so I just want to show you the results really quick here so basically it just gives me the connection string which I oh here we go I created previously this is my new 4G enterprise cluster engine point and with the URL information and user name and password so now I'm I can just find out where I'm gonna push my application to right since we're gonna use pivotal web services here and it tells me how to point the target to those pivotal Web Services so what I'll do is I will do what it tells me to do to do a CF logging now it's asking me which work when I also see the work information here so works just logical division of this pivotal Web Services think about it as its host it is hosting 60,000 applications but it's role based access control I can only see what I have access to right these organizations so I select number two here and it's asking me which space I'm just gonna use the test space so space is sub logical division of each organization now I have my endpoint here I can just go ahead do CF push one more thing is because my application is going to be connected to new 4j so I want to specify that service I can either do it from command line or I can just put it in a manifest file it shows that the name of the applications is movie graph and I'm going to use this jar file and my service is my new 4j Enterprise which I created here by using the new 4j caocao caocao cluster on google with the ID username and password all right getting ready to do safe push so what is doing here when I do see I push is uploading that jar file first to the blobstore it's doing that uploading and once that is done is going to [Music] compile that jar file can't just bundle together that jar file with this concept called build pad build pack has all the frameworks that you need all the libraries runtime you need to run your application you see it's downloading all the beauty eggs and it is detected that okay your application is a java application I'm going to use a Java field pack here right Java Butte pack so now we have a droplet putting the blobstore then auction is going to happen right and we're going to decide which self which VM is the the one that's going to run this application whoever wins that auction is gonna go to the blob store grab that droplet spin up the container put that droplet in a container and run the startup scripts and because we defined the service here this is where the service broker is going to create a resource for the application and build that connection between an application and u4j enterprise alright so it started now you might go here it says it's up running so now I guess that was about minute and a half I have my spring booth movie graph application in cloud connecting to neo4j what if I want to scale things up I can just say okay I'm going to instead of one instance I want a three instances and within seconds the same thing I'm gonna happen right all these VMs gonna participate this auction and whoever wins is gonna go grab the droplet spin up the container pour the droplet in container and run the startup scripts so that was about five seconds because in production you can't afford like minutes to spend a spin of another instance because that means and hundreds and thousands of requests you're gonna be denied and I can also do all of scaling because why why should we do it manually when we can do it automatically so my manager auto-scaling I'll say the minimum is one maximum is for scaling rule how about HTTP throughput I'll scale down if there are less than 20 heads per second I'll scale up if there are more than maybe a hundred Save alright did you see that it was there were three instances and now there are two and in a minute they're gonna be just one because I'm not hating the application there's less than 20 hits within a sec second alright so let's go back to our presentation here we just demonstrated we can write up the spring boot application quickly and push it to cloud foundry and connect to a new 4G and there's this concept called twelve factor design principles it's all about how to write micro services in a cloud environment everybody is familiar with this or we want to just talk about so maybe talk about several of them it's basically ensure your applications run and skill predictably and in a very scalable way in a cloud environment so code base is saying one code base one repository one CI CD pipeline right that's kind of no-brainer but if you think about it if you put multiple applications into wine repository you are coupling them right and dependencies is saying you want to have your dependencies in your application don't rely on Mommy's server websphere or containers to give you those dependencies because VM is common and go containers come and go your your dependencies may not be there may not be the right version they may be different between Killian and production configuration this is a good one we all know we don't we shouldn't hard code our connection strange right but let's take a step further don't put in a properties file either let the environment inject it into your application as a matter of fact when we were doing this so now it's one instance when we were running movie graph in in cloud what was actually happening behind a thing here is I used spring cloud connector you see this v cap services the environment variable so I used that and parse this connection string username and the password and injected into the application so I never need to worry about it I moved from environmental environment in QA environment I have all the connection string I need at runtime for QA I go to production I have all the the the configuration I need for production so there's never be the case where like oops I accidentally write production data into the QA environment or vice-versa right packing services trading your database message and queues as backing services I'm now gonna go through each one it's just processes is saying that write your application a stateless right because if you're you have your session stayed in your memory and let's say you have three-step signup process after the first step you contain your crashed and you have that state in your memory that city is going to be lost so that's why you want to externalize you know stored is somewhere else store that session state externally either in a caching like a rallies or external database and locks is another interesting one treat logs as event stream write it in the console don't write it in local disk because your review read logs to local disk that's just in a container containers come and go you will never see it again so we want to write to the console and let the platform train it to somewhere else so in our example when we there are several ways of seeing logs one is I could see logs here right you can tell it or from the command line I could tell it here so I have to hit generate a little bit traffic and I can see the locks here but if you let the platform to just drain their logs to the 30 party logging management system such as Splunk you can see all the logs there as well admin process is the saying when your one of your one of process such as database migration to see in the platform as if you were running a long-running process your applications so this is our previously tested very good golden rules for you to run right Greenfield micro servers and make sure they run really well in the cloud environment but what about your legacy applications we all have to support those things right and we want to modernize them right so for your legacy applications if you look at this picture where are they are they on premise today or are they running on VM some is somewhere so you want to move your legacy applications to the cloud native platform Cloud Foundry turns just to enjoy all the court cloud capability it's like scalability we we just saw how easy it is to scale things up and down right and then if you are happy there that's fine I don't want to keep you know we're not going to touch this legacy application often that's fine but if you really want to modernize those applications you can just take one step a time to move up this cloud native maturity model so the idea is for you to do as little as possible to get your like C apps to our cloud foundry first then at your own you start looking at 12 factor design principles you look at the resilience microservices architecture API first design if you want to do functions that's fine so the the transformation as you can see is not going to be overnight it's very gradual right it's a gradual process but you are moving toward a better way of building and operating your software and we're here to help you become the thought leaders on your cloud native your journey to sum up if you want to deploy and operate your applications and services quickly use pivotal Cloud Foundry if you want to store and retrieve connected data quickly use new 4G graph data database platform because at the end of the day is all about what developers love thank you very much any questions 