 With the latest software release the D-Wave Ocean SDK has a new problem inspector to help you improve your code running on D-Wave quantum computers. In this video we'll give you a tour of the problem inspector and show you how easy it is to add to your existing programs. The inspector allows you to examine the output from the quantum processing unit or QPU. When the inspector first opens we're presented with a picture of our problem on the left, the histogram of samples returned on the right,  and warnings to guide us at the bottom. The source problem is the logical problem we're running on the QPU. Each dot is a variable and each line connecting  two dots is a product of two variables. The histogram of samples is organized by energy value. In general a lower energy value corresponds  to a better solution to our problem. At the bottom, we see warnings that are displayed to guide us in improving our results. In the top right we can switch to view 2 to see more detailed information on how our problem is mapped onto the QPU.  We see our same logical problem on the left. On the right, we see the embedded version of our problem that is placed onto the physical chip. Each dot is a qubit and each line connecting two dots is a coupler. When we click on a logical variable we can see which qubits that variable is mapped to on the QPU. This single variable is mapped to a chain of qubits connected by couplers. All of these highlighted qubits represent the one variable in our problem. This process of mapping variables to qubits and chains of qubits is called embedding. If we click on a warning we see the variables and qubits involved. Rather than starting from scratch we'll use some code that lives in our collection of examples on GitHub at GitHub.com/dwave-examples. On this page we have a lot of great examples  to get you started, complete with code. For this video we're going to work with the max cut demo. The repo for this demo has everything you need to run the code yourself. If you want to learn more about the maxcut problem check out the readme that's included. We're going to run this code locally using the command line but you can also open and run it using the Leap IDE. I have my terminal open and virtual environment set up. I've already installed the Ocean SDK,  but if you need to do that you can check out our Learn to Swim series on YouTube. This series will walk you through the steps of setting up a virtual environment and installing the Ocean SDK. Let's run the demo as is and  see what the output looks like. To add the problem inspector to our program, we have two steps. First we need to import the  package for the problem inspector. This needs to go at the start of our program so that the necessary information is collected throughout. Second we add a call to show  us the problem inspector. The show command takes just one parameter:  the response we got from our system call. When we run the code, we use the same commands as we did before. This time though, we get a web browser  pop up with the problem inspector. On the left we see our five variable  logical (or source) problem. On the right is our histogram of  samples sorted by problem energy. The lower energy samples correspond to better solutions so we'll really want to focus on those. The length of the bars in our histogram tell us  how many times each sample appeared. Clicking on a bar shows us the corresponding  variable values for the sample selected. We can instead choose to see our embedded problem on the left by choosing target in the drop down menu. When we do this, our energy values  update to correspond to our embedded problem energy instead of source energy. When we click over to view 2 we see the side-by-side comparison of our logical or source problem and the physical or target problem programmed onto the QPU. We see how the variables map to qubits on the chip and how some are mapped to chains of qubits. Here we see one variable mapped to a chain of two qubits connected together. The last problem was fairly small with only five logical variables so we didn't have any warnings appear. Let's see what these warnings look like and how we can use them to tune our programs and find better results from the D-Wave quantum computer. Let's go back to the code and instead of the five variable problem we ran earlier we'll look at one with 70 variables. We'll comment out the old graph then set up a random problem graph with 70 variables or nodes. Now when we run our program and look at the problem inspector we see some warnings with information to guide us. On the left we see our logical source problem,  which is much larger this time. We see all of the same information about  the solutions returned, as well as our familiar histogram of samples. When we click on a sample we see the variable values returned for that sample. We can hover over each of the logical variable nodes to see what value is returned. At the bottom we see two different kinds of warnings:  a chain length warning and a broken chain warning. We'll dig into the broken chain warnings in a moment. Clicking over to view 2, we see a much larger logical problem this time. We can hover over each of these logical variable nodes to see what value is returned. Clicking on the node shows us the chain it was mapped to on the QPU. When we click on a warning we see the logical  variable and physical qubits that correspond. Some of the logical nodes have two colors  which tells us the chain it was mapped to broke. We can see all of the chains in our embedded graph  by selecting show chains in the toolbar. Broken chains can decrease the quality of solutions. By tuning the chain strength parameter  we can improve our answers. Here we see a chain of three qubits linked together. Ideally when the system returns a sample  all of the qubits have the same value. In this case all of the qubits have value -1 so the software will assign the variable the value -1. Sometimes the system will return a mix  of values for the qubits in a chain In this case the software tries to fix the broken chain. Usually this is done by a majority vote. How can we prevent broken chains? The Ocean SDK provides a parameter called chain strength. Increasing the chain strength value  increases the coupler strength between chained qubits  making it harder for them to break. Also, increasing the number of runs  for a more complex problem makes it more likely that we'll find better solutions. Now when we run our program and  look at the problem inspector we see a similar embedded problem on the left but a very different histogram of samples on the right. We see more of a distribution of these samples with the same functionality and information  available from our smaller problem. Switching to view 2, our logical problem  on the left has no broken chains. If we're not getting very good solutions and there is not evidence or warnings of broken chains we might want to decrease the chain strength. Having a high chain strength value can make it more difficult for the QPU to find optimal solutions due to the precision of the hardware. This process of trying to find the "sweet spot" for this parameter is what's called parameter tuning. In many software algorithms, classical or quantum, we have parameters that we can adjust to get better performance and results out of the code. Using these clues described we can tune  our parameter chain strength to improve the solutions found for this problem. Thank you for tuning in to learn more  about the problem inspector, a new free resource provided for easy code and application development on the Leap platform and with the Ocean open-source tool set. Check out some of our other videos for some more new resources in Leap. 