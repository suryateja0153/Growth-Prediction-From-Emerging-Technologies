 [Music] hello everyone welcome back to the next lecture of our architecture design in use cases course we've been going through different notions of security and privacy so last lecture we looked at what are what is transaction privacy data privacy user privacy and what are the different constructs one could use to achieve privacy and now we're going to look at one other construct a very important construct in hyper ledger fabric that allows you to achieve data privacy so we look at that so it's it's called side dB so before we get to side DB itself let's look at just the ledger aspect of hyperedge of fabric right so what are the things we are storing on the blockchain on the ledger so we're going to store the blockchain itself so this is the chain link of blocks with transactions in each block and apart from that we have a state database that holds the data that is handled by the smart contracts so each smart contract can have its own private data store and in that days store it can store information that it seeks you keep immutable on the blockchain and these transactions are referring to data in the state database as part of the smart contract invocations now on top of the state database there are a couple of a few index indices that are created one is a history index which says which transaction is in which block and a history of all such transactions over time and there is also a block index right all these are stored the indexes are stored on the state database let's say level DB for fabric and for the state database itself there are two two options one is you could use today at least there are two implementations hyper nature fabric gives you a pluggable interface for your database definition today there are two implementations one is that of level DB which is an embedded key value database and it supports basic functionality right so your embed it supports key queries so I can give you a particular key ask for the value it allows composite key queries and also allows range queries so give me all keys from A to B right in that range that's just a basic very simple key value store the slightly more surface decade one his couch TV which is which really a document store it supports so basically each key is really a document it can be a JSON document and it's about ski queries composite queries range queries plus full data rich queries so for instance in the leveldb case the data is really a blob but in couch TV you can actually have a schema and ask specific queries about data within a particular document itself or a particular key so this is what I mentioned so with leveldb it's a very simple key value store so all you can just do is get the entire value for a particular key a few additional composite key and rage query capabilities but these may not be sufficient for many applications right so if you want to do more sophisticated query kipp queries in your chain code it's really not this may not be sufficient right you might want to use a document stores such as CouchDB where you can you can do a much more richer queries on the blockchain and you can also get richer reporting and analytics performed on on the chain use using chain code okay so now coming to why side DB right so what we what many we've seen many applications ask for or many industry use cases ask is the ability to be able to selectively share particular pieces of data with only certain entities and blockchain by default replicates all the data across all the peers so even if you have channels all the entities all the participants of a channel will see all the data so suppose you have some data that you consider private that you want to suss you want to share only with a subset of participants within within a channel right so that data you want to keep private and only they say three out of ten people should see the data no one else how do you do that the side DB provides that kind of a capability where I can for each for each data element I can specify who are the other peers who will see that data so it gives you privacy even within a channel so that only subset of the PRC it it also gives you privacy with respect to the ordering service so even the ordering service will not see that private data they will only see your hash right and anyone querying just the blocks of transactions just looking at the the blockchain itself will also not see the private data so across the peers the blockchain as well as the order we can ensure data privacy of specific private data and this says it comes in handy for many applications where audit requirements are there is a stringent compliance and audit requirements and there is also regulatory requirements so such as health care kyc insurance and many financial services use cases also so the way it does that is only the evidence of the private data may be a harsh is going to be is going to be on the transaction and will be seen by the ordering service so all the other information is kept private to a subset of the authorized peers ok so the chain code is is gonna store both the public data as well as private data and the private data will only be with authorized entities only the hash of the private data gets onto the transaction now the private data is it's possible to group them into collections so collections has a notion where I can say ok collection a has these three peers collection B has these five peers so I can create those collections and it can have data within those collections so if a particular data element is in a collection that data element will only be seen by participants of the collection and just like channels it's also possible for the membership of the collections to change over time right so collections are again associated with access policies so you can define who can read the data who can write data so those access policies can be defined for each collection and the as I said the private data is only stored on the peers who satisfy that access policy so again the distinction from channel channels is that within a channel everyone sees all data but side DB is a construct whereby you can prevent certain private information to be seen by to not be seen by all parties in the channel so it can be seen by only a subset the private data is also not in the transaction and not in the block of transactions it's also not seen by the order so the unauthorized entities even if they are authorized within a channel they only see the hash they won't see the private data so how does this all work so let's take just one collection right so let's say there is a endorsement and that endorsement is going to be have two parts to it this business is basically a transaction proposal they'll have two parts one is a primary read write read write set so what this means is this is the public information that anyone in the channel can see so this is really the read the set of data elements that are read and written by the change code which is public that is the primary read write set apart from that there is going to be private data in a collection that's the primary private readwrite set and for that only a hash of that private readwrite set is captured in the endorsement itself in the transaction so in the endorsement phase only the hash of the key and hash of value is written to the public State the actual key comma value of the private information is held in a separate deep database which is called the side dB so in this case so there is a public state information and there is a private state and these are held separately the privates estate is then disseminated using gossip the public state is part of the transaction and all the peers will get the transaction but the private information is then distributed using gossip in fabric what happens after that so now you've written the hash of the key and hash of value into the transaction so that makes sure the a loves immutability and there is a private data set that only a subset of the peers in the channel have now how does validation take place now the validation of course of the public read/write set happens as before apart from that the harsh readwrite set on all the committing peers they will also check the key rate sorry they will also check the version so there is a hash of the key and it has a particular version you can check that that version is not duplicated right so no two transactions in a particular block are reading the same information so let's say a transaction a reads a particular version for a private data and modifies it in some way so it's gonna it's going to be part of the right set so it tries to modify the data if transaction B had the same version it means that it's read stale information because there's a previous transaction in the block that is modified the private information if transaction B tries to modify that same element in the same block then that will be rejected because the version on the hash of the key can be checked right if both of them are at version 1.0 then the second one will get rejected so that's really almost like the same validation that fabric does on State state variables this is similar to not allowing double spending it's the same account to to spends cannot be made from them right so that really is how validation also happens the validation happens on the hash of the key rather than the key itself now likewise just as we hired one collection it's possible to have multiple collections so you can have different collections with different subsets of of peers and they're all held as separate state information so there's private state one private state two and in this example collection one is persisted between PR one and PR two and there's a partitions two and three they are persisted by just one of the peers right so part of private Sates private state two resides only in PR one private state three resides only in PR two so they are they are bifurcated right and the only the hash of those values get into the public state okay so these collections so how does the lifecycle work the collections can be defined at the time of chain code deployment so I can say these are the collections these data elements when you're writing into the when this when the chain code is going to write this state information into the ledger it will specify whether this is public or whether it's a private collection and it's possible to easily add or remove collections over the life cycle of the chain code over time you can add new collections or remove collections you can also using the channel configuration transaction you can also configure transactions so you can add new members to a collection you can remove members from a collection so all that is possible right so all that has happens through a channel reconfiguration okay so that's really in a nutshell the the whole state DB notion of how subsets of entities within a channel can really hold private data just amongst them that data is shared with others through gossip with the other authorized entities through gossip what is there in the public blockchain itself is just a hash of that private data okay so in some sense immutability is guaranteed by the platform itself so the no party can modify this private data so the other people who have the private data will be able to detect that because the hash is on the public chain and double spans are also avoided because validation can be performed using version information on the hash of the key right the key itself is not to be only the hash of the key is in the public state so to get more details you can check out the fabric documentation on ledger it gives you good details and also a working example of how our side DB works so this really helps provide data privacy amongst a subset of participants within within a channel and also with respect to the ordering service okay so that ends this lecture on using side to side DB as a construct for Kravis e so with this I think we've seen a range of constructs for providing security and privacy in blockchain platforms and this is a very hot area for research and innovation there's a lot of action going on in both academia as well as industry space with that time slot I'll see you in the next lecture [Music] you [Music] 