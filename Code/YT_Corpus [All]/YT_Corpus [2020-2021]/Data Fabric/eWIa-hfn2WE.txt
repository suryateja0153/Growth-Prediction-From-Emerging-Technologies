 [Music] hello everyone and welcome back to our next lecture in our blockchains course architecture design and use cases before we start I must thank a lot of my colleagues at IBM who have made some of these presentations available over for a period of time so I've collected this from many different sources but a lot of the IBM heirs have helped to prepare some of these lights so have many things to say to them so we've been looking at some of the details of high pillage of fabric itself and in this lecture we're going to talk about how you can set up your own fabric network so what are some of the things it takes what are the steps it takes to set that up so first step is like I mentioned earlier is the ordering service that's the main component that is going to determine how transactions are ordered in the network and that'll be the first thing you set up or you bring up and then in the network so it could be a single solo ordering net node or it could be a distributed set of nodes that are running an ordering service let's say a Kafka consensus that they execute so that's the first ordering service that that's the first component that you bring up and the simple CLI command for you to bring that up or you can also use the SDK that is available in multiple languages in Java no js' and python so once the ordering service is up then the next step is to configure and start your notes so you could have multiple organizations that are part of this blockchain network each of those organizations could run one or more peers so you will have of course all the identities have to be set up when I say you are bringing up each of these entities I'm assuming that we or when you brought up the ordering service the identity for the ordering service is set up and likewise for the peers each of these peers in their respective organizations have been have their identities right with with an MSP and provided by your certificate authority so each of these peers have to be brought up so again there are simple CLI commands and SDK commands that you can use to to bring these these services up so each of these peers like I said could belong to different organizations so that though the peers are up but they are still not can to each other in anyway once you bring up these pure processes the next step may be to install one or more chain codes on these piers again when I say install this is just to bring up the process that will run the business logic again this is not connected in any way to the rest of the system so this pure will then have a container that runs the chain code a again another container to run chain code B likewise for all the other peers again a very simple command both from CLI and from SDK will enable you to set up to install these chain codes on the respective peers and also note the fact that the chain codes can be installed on only a subset of the peers in the network it doesn't have to be installed on all the nodes so you can decide who are the endorsing peers for each chain code and you can install the chain code only on the endorsing peers so this just this does give you a notion of privacy in the sense that the code itself the business logic that you are executing in a decentralized fashion can be executed amongst a subset of the organizations you have in the network it doesn't have to be all the organizations or all the peers okay so now you have the ordering service you have a bunch of peers you have chain codes installed in them now is when you start constructing the network itself and the communication between them so you're going to be creating some channels the ordering service is where these channels are configured so of course you could also have multiple ordering services for these different channels but in this example let's assume that there is just one authoring service in again that ordering service has multiple nodes so it is weird ordering service and it has multiple channels so in this case there is a read a channel a blue channel and a yellow channel so all these channels are configured with the authoring service and when you are configuring the channels with the authoring service you are also going to be joining pairs in that channel as the next step so the channel configuration will include the set of organizations and set of peers there are part of that channel so in this case easy Rho and E to have joined the blue channel easy ro anyone have joined the red channel he too and the speed three which is not an endorsing not have joined the yellow channel and actually they yeah the blue channel also has he won and p3 so the blue channel has e0 e1 e2 and p3 so all the nodes are part of the blue channel so this way it's possible to have different subsets of nodes join different channels and channels like I mentioned are a notion of provide a notion of primacy across the different transactions and the different state you want to maintain in the network so the same peer can be part of multiple channels so again there's a simple CLI command and again you can do the same thing same thing using SDK so it could be a client application as part of setting up the network could be executing all of these steps or it could be different nodes so basically these nodes are part of different organizations their respective client applications would have to join their peers to the channel the next step is to instantiate the chain codons channel so you have to say you have the chain codes running on the peers but you have to say which chain code belongs to which channel so again this is highlighted if you see as the border color here in each of these boxes if you take the channel red then chain code B is part of the channel right so the chain code B is instantiated on that channel so it will have its ledger and it can add transactions to the chain to the block chain in the red channel likewise the yellow channel again has chain code B alone so the yellow channel has only one endorsing p1 which is e2 it alone runs this chain code B and it's connected to the yellow channel so it will have its lecture and a block block of transactions the blue channel has all the peers and chain code a is part of the blue channel so you can see the chain code a has this blue bar so the chain code a will be part of the blue channel and all transactions on the observable will be functions that are invoked on chain coding so this is just an example network to show the flexibility of the system so you can define who which peers you can define the channels first you can define which peers which organizations are part of which channels you can also define which chain codes are part of which channel and all of these are segregated separately so each chain code is a chain code state is separate from another in each channel right so that's how it's maintained and all the chain code State across the peers in a channel are all consistent so all the state will be maintained consistent consistently using consensus again a very simple CLI command is available for you to execute and and setup set this up so with this if you see the whole network is set up and now users can perform transactions on these on this network so on the red channel users can invoke functions of chain Kotb again same thing for the yellow channel users can invoke functions of change would be on the blue Channel they can invoke functions of chain code 8 so that's how it's it's separated out I mentioned that it's possible to have just a subset of the peers executing chain codes on each channel and that is governed by the endorsement policy right so the endorsement policy states which peers have to execute and endorse a transaction before it will be deemed as valid to be added to the block chain so each chain code defines an endorsement policy and this can be different for each channel that the chain code belongs to now there are two important system chain codes so these are the system chain codes are chain codes that are implemented internal to fabric itself that perform certain important functions we will talk about two of these system chain codes there are I think three or four more of these system chain codes that have been added again these system chain codes also provide the notion of plug ability so although I call I mentioned these two system chain codes you can always think about other implementations with other properties that these two system chain codes provide so the first is in chain code that is of importance is the endorsement system chain code what it does is so this system chain code is going to be running within every endorsing peer so when when a client submits a transaction to appear so this is an endorsing peer here when a client submits a transaction to the endorsing peer it is a transaction that is invoking a particular function that is in the chain code and it first comes to the ESC C so the ESC see the endorsement system chain code is the one that will invoke the chain code will execute the transaction it will compute the read write set of the transaction so that what is the state information that was read in the chain code in that function what is the state information that was written all of that is captured by the ESC C and it will then sign the proposal response it will then sign this and say okay so when I run this transaction this is the read set this was the right set and here is my signature saying that I was the one who ran this and I endorse this so this is done by every endorsing pure and this system chain code that signing part of it now client collects all of these signatures from multi-layer all the endorsements it will then submit the transaction to the order the order will include it in the block deliver it to the pier and now all committing peers are now going to do certain functions right so that's where the validation system chain code comes in which is going to validate these endorsements so what does the validation system chain code do it will look up the policy for this particular chain code so this policy might say organization 1 2 & 3 in the network have to assign this transaction so it will then check whether those three signatures are available the other policy we look at some of these policies that how the syntax works for some of these policies but the validation system chain code does the job of going through the endorsements that of that are available in the transaction that have been submitted with the transaction and seeing if that set of endorsements satisfying the policy that was specified for the chain code in that channel so that is the validation system chain code now it's always possible that the endorse you want to use some other logic for the endorsement or for the validation you want to use some other logic for the validation or even you might want to implement that in a different language rather than go line so all those possibilities exist and this whole module is is pluggable and you can bring in your own implementation for for these things based on your application needs but for most applications we deem that these these existing implementations of endogenous system chain code and validation system chain code will be sufficient for most in most applications that we see in the enterprise world to give you a comparison with Bitcoin the validation that Bitcoin does in some sense is the validation whether the transaction is a duplicate or not so this is the you TXO model whether the transaction is unspent amongst all the previous transactions that this network has seen right so that's the you TXO model all it does is verify whether this transaction is unspent or not so here we are not following the u TXO model we are following what is popularly called as the state-based model so the validation is based on state information that we are storing in as part of the ledger and the validation here specifically one part of the validation is the validation of the endorsement policy so this is different from what Bitcoin has and this is very specific to to high pillager fabric and it's also one of the differentiators of hyper hyper energy fabric so looking at a little more detail about the endorsement policy itself what how do you define it how do you specify it when you are instantly adding a chain code this is just an example of a chain code instantiation you are providing first the channel on which you are instantiating this chain code my CC is the chain code name you have a version for the chain code so it's possible for you to deploy multiple versions of the chain code that may be improvements of the chain code over time maybe changes in the business logic can be captured so the chain code itself can follow a full lifecycle and there is a separate system chain code for that a life strike a life cycle system chain code that manages the life's life cycle or the different versions of a chain code so that's a separate so a version of the chain code and then you have a particular code that it rapid reverse - so that's the particular spot contract that implementation and then the input arguments for that for that chain code right so these are the initialization arguments so it's called the you calling the init function with a certain set of parameters so this could be any any parameters that you choose to pass at the time of initializing the chain so this chain code takes for initialization arguments so I think this is this this chain for example zero - if you're looking up the fabric code and the examples there it actually sets the account balance of a to be hundred and an account balance of B to be 200 so that's the initialization that we're doing and the minus P option here gives you the endorsement policy that's the that's what we are looking at here so what is this endorsement policy says the endorsement policy says that or go on m base be any entity of org one can sign this since i can sign this transaction so this is the the and policy so it's possible the syntax for the internal policy is any expression are using and and or gates and using any principles or a nested expression so you can I can say or guan MSP dot member and or - MSP toad members so any so both of these entities must sign and the principles that I'm called out here is really a particular role it could be member it could be admin these are the supported roles today and the MSP is a particular MSP ID so there is an MSP called or guan MSP and there is a role called member within the on MSP and anyone who has the member roles in Oregon MSP can sign this can endorse this transaction now it is also possible to have a node of K policy so that's possible to say three out of the five organizations you know you specify the list of five organization and say any three out of five if they are signing this transaction then we'll consider that as well so the inner of cake signing is also possible that's also part of the policy syntax here is just some examples of policies so one example could be and of or one member or two member or three member so in this case all one or two or three are really MSP identifiers for their respective organizations member is the role within those organizations so a member of argon has to assign a member about to has to sign a member of r3 has to sign all of these together now will satisfy the policy the other policy you can do is or I can say or one member or or two member must sign this transaction that will be the endorsement and it's also possible for you to include arbitrary combinations of antenor like in this example what this example says is first let's look at the inside thing or two and or three must sign it or one must sign it so that is the condition so it's either org one or a combination of R 2 and R 3 must endorse this transaction for it to be valid so you can have any arbitrary combinations of this of this endorsement so based on for each transaction who has signed it the specific members who have signed it we will then compare as part of the validation system chain code we will compare it with this this logic this policy that you've specified and validate whether the policy is satisfied or not so this is just a satisfying satisfaction boolean satisfaction and if it is satisfied then we will admit that into we'll admit that as a valid transaction so each at the time of the validation stage each peer is gonna execute this and validate whether it's satisfied ok so that again likewise there can be an end out of que policy also I have not given the example here but you can look up the documentation for that so it's also possible to define say n note of K members in the network after sight so this actually concludes all of the material for understanding what really fabric is how it's designed how the network setup is made so there's a lot of oh that is available for you to quickly understand get to the next level of detail right so the homepage for fabric itself is under the hyper ledger project it's available there you can look up the code and there is some interesting examples that are that are shared along with the code so there is a great Garrett repo as well as a github mirror of that gated prepper some of the latest Docs this keeps updating based on new features new features are getting added almost on a weekly basis and there are multiple features that are being proposed actively and they're also being developed actively so we are right now in version 1.1 of the fabric version 1.2 is being planned and there'll be a later release later this year there's a community chat if you're a developer you want to you have some issues with some understanding or some part of your code is not working you have a defect that you want resolved you can always go to chat and there's a very active community out there that takes an interest in answering all those questions so very active community that that helps all developers mutually so and there's also a wiki where you can also find more information over the next few lectures what we will do is we will go through some demos I will try and show you fabric in action so there are many ways in which you can set up fabric you can set it up on the cloud very easily you can set up on your own laptop or on your favorite development environment set of VMs docker containers wherever you want to set up there are instructions for you to get started very easily so you can set it set up your network in a matter of maybe tens of minutes maximum and on the cloud it's just a couple of clicks you can have your you can get going so I'll show you some of those and I'll also show you how a network is set up maybe show you some examples of how a smart contract is written so we'll go through some of those demos over subsequent lectures so to conclude some of the again the fun reading section some of the additional information you can get there is very easy instructions to if you are a do-it-yourself person kind of person very easy instructions for you to set up your own net in any kind of development environment any kind of operating system that should be okay there's also as a QuickStart guide for developers on how to you how you can get started having very easy instructions for you to get started so with that thank you that concludes our lectures on apology fabric see you in the next set of lectures for seeing some demos of fabric in action thank you [Music] 