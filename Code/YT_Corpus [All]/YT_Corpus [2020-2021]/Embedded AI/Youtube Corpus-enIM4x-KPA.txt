 hey what's up this is benjamin welcome back for another video about iot and embedded development today i want to talk about a problem that i have and that i'm pretty sure you have as well which is i have devices i have tons of devices and uh i need my computer my main uh computer to allow me to develop for those devices right and that means having literally gigabytes of ides and toolchains and various versions of tools for flashing debugging and whatnot uh lying around on my um on my hard drive and it's kind of a pain because it's pretty hard to uh to not break anything you never know what's going to happen when you upgrade a particular tool chain uh and that's going to break a a particular project that that you've been working on it's also a problem whenever i want to share code i or you want to share code with my friends and colleagues what are what are the dependencies what are the things that they are expected to install what are the um maybe the libraries for which they need to clone and download source code somewhere on their on their machine and things like that so what we're going to talk about today is um a trend that's uh that's been happening in the industry starting probably with web and cloud development which is uh this uh um notion of containers right you've heard about docker and you you've heard about this uh essentially this idea of describing uh very uh very precisely what are the uh the various uh tools and libraries etc that a particular piece of code may need at runtime so that when you want to deploy a particular web service or application in the cloud well it's just a matter of provisioning a particular container and just running it and it's super reproducible now for the past few years uh this uh notion of container uh containers has been uh pushed uh sort of to the next level by means of also also allowing to um to containerize not only a runtime a piece of code but containerize a workspace containerize the stuff that you need at development time right and for embedded development that would be things like um i need this particular flavor of cmake i need this particular version of the new arm embedded tool chain i need this this and that on my path for uh for doing debugging and um yeah that's the notion of um the remote uh the remote developments uh remote development or uh containers that um you uh maybe already are familiar with uh if you're a vs code developer you can already leverage a docker file and use it for um for it to become your um uh your uh your local workspace but something that's been happening very recently is taking this to even the next level which is uh normally do you describe the dependencies for compiling and running your code in your workspace but how about you also describe things like the plugins that one may want to install or may need to install to um to to develop and to write code for a particular project and this is called codespaces right it started with visual studio code spaces so the ability to uh to leverage containers and describing essentially um like i was saying earlier uh the the full workspace all the plugins all the github repos uh that may need to be cloned uh and have that part of um like put it somewhere on the on the repository itself so that anyone uh can just like fire up a visual studio code spaces instance um either in the cloud like if you have an azure subscription you can run it in the cloud or or locally in vs code or visual studio and then get started immediately with a super reproducible environment now um something that's uh that's in beta at the moment is github code spaces which is if i look at the say the azure autos getting started page is something and that works for any repo really uh is is something that allows me a granted that i have access to github code spaces which i do because i'm part of the beta and soon hopefully you will be too please i mean just sign up if you if you like the video and if you like what you see what's essentially happening is oh yeah sure and the azure autos getting started looks pretty cool except that it's going to be embedded development and if i clone this on my computer it might be a nightmare and it might take me quite some time until i figured all uh the dependencies i need to install etc although the azure autos team is doing a pretty nice job and pretty great job at making it super simple for you with a bunch of scripts it's still gonna at a minimum it's still gonna take you some time because you're gonna download uh lots of stuff so how about instead i just straight from the repo create a so-called codespace a new codespace and what's now happening behind the scenes is that github is firing up a a vm essentially a virtual machine that's going to be running uh a particular container and this particular container what is it like if there's no instruction whatsoever in the repo no code spaces specific instructions in the repo this container will be essentially a debian a dbm virtual machine and my ide will not have any particular uh additional plugins installed but if in the repo as part of this dev container folder um code spaces finds this then what's happening and it's pretty straightforward uh i think you can you get the idea um code spaces figures that uh there is a particular docker file that should drive uh the uh like the the the provisioning of the of the workspace itself there's a list of all the plugins that may make sense uh or may actually be mandatory for developing for this particular project uh here c plus plus tools and cma tools that makes that make some sense actually um the fact that there might be some additional uh instructions for example the azure authors getting started repo as a bunch of sub modules that need to be cloned as well so that's what we see here and looking back at the the docker file that was described here what's in there my guess is that it will somehow describe the fact that hey there is you need tool chain uh you need a tool chain for uh for arm uh for compiling for your your various uh uh autos um targets uh and yeah apparently there's something along those lines so we start off off a debian base image we install a bunch of tools that are going to be needed for compilation uh git for cloning the code c make a ninja for cross compiling and generating all the um the cmake files and then the tool chain downloading the latest uh or almost the latest i'm not sure actually but a particular version of of the new arm embedded tool chain and that's the world point a particular version and we put it on the path and that's it in the meanwhile it was me talking for maybe a couple minutes in the meanwhile the repo is now fully um cloned the workspace is fully provisioned uh all the way to the point where if i just quickly check oh well this actually looks and feels very much like vs code uh what if i uh um open up the terminal uh and let's see like this is like this is obviously my um my edge web browser but here the console i have is uh for a machine a container that's running in the cloud and that's um running exactly what was described in the docker file so if you remember and if you saw earlier there was something apparently in the work folder yes there is the gcc and there's the arm tool chain in in the path right and so that's essentially um yeah our our environment and we have the workspace that's been that's been cloned uh and we're going to try and actually compile the code now so the code is uh in the getting started we have a bunch of various examples for various boards for the mx chip for a microchip some er 54 device i want to target the stm32 so let's open the associated workspace and let's try and compile the code maybe we can have a quick look at the code as soon as it opens so this is an azure autos application so we'll probably find a bunch of c files in there uh actually let's first configure and let's make sure that we um properly configure the uh the project it's cmake asking us to do that this is actually what's gonna allow us to compile properly to have a code completion working as well uh yeah there we go intellisense this update i don't really care all right what do we have we have a main uh with um a bunch of um of threads for initializing the wi-fi uh probably initializing the the connection to azure iot at some point um etc etc and this is like full-blown vs code with code compilation and so on which is i mean we're in the browser right so that's uh that's pretty cool um i want to compile the code um how should i go about compiling the code how about i hit f7 there we go cross compiling uh maybe i went a bit too fast because um this is the code straight off of the github repo and if this is code that is meant to showcase how this device is going to be connected to azure iot i bet i should start by configuring um the code and configuring the application so wi-fi wise those are my credentials um in terms of iot hub connection i'm going to use the azure iot hub explorer which actually might not be the best idea now that i think about it i'm running off i mean i'm doing development in the browser and in the cloud to sort of show you that there is nothing whatsoever that you need to install on your computer azure iot explorer in that case is actually running on my laptop so i guess i should have thought about it before i should have shown you how to use the azure portal maybe to do everything straight from the cloud but anyhow you get the idea and azure id explorer is a cool um tool anyways so we're going to use it later on to test that everything's working properly so yeah i see that my code is now compiled but that i mean i still need to configure properly everything uh i need to provision a device um in my iot hub there is no device in this particular iot hub let's create the stm32 whatever zero zero one uh so that's how i called it i'm doing everything in real time so i think the video might end up being maybe 15 or 20 minutes long but i mean i really recommend that you stay till the end because you you get the the full real time demo um the password or like the key and to connect the connection string that would be it and now i'm going to recompile once more it should be much much faster because i did only touch one file compiling yep there we go so we have now i have the binary so that's pretty cool um uh how do i run it on my device my device is obviously not hooked up in some data center uh azure data center in the cloud it's not like i'm going to be able to directly um copy and flash the device uh from my browser um so what's going to happen is that i'm going to plug the device on my laptop and i'm going to use open ocd and do over the air open ocd to uh to flash the device so um that's the um yeah that's the device over here it's right now it's i mean it's idle and not running anything we need to put the code on it so uh i'm gonna use openocd on my machine and ask open ocd to open a um a tcp port so that um remote tools may be able to connect to it so that's open oct running i think you probably yeah you can sort of guess uh that the um the led right here is blinking except that it's uh uh yeah it's hard to see but the device is now in um debug debug mode and one more thing that i need to do is make sure that from my cloud workspace i can push code like typically if i try to debug with f5 uh you see that the what the the this particular workspace is trying to do is trying to use open ocd over the air and over tcp to connect to a remote instance of open ocd except that it's in my case it won't be running on localhost it's running on my on my laptop right which is behind my firewall behind my um dsl router etc so i need to use um there's many ways to to do that i could open i could open up the port in my firewall or i could use a tool such as ngrok to create a tunnel uh which can be accessed at this particular endpoint which allows for like anyone knowing this particular combination of hostname and port allows anyone to directly talk to my open ocd service hence to my device and so let's try and debug uh so it's going to take a few uh a few seconds well we see that the device is now at the the workspace is now talking to my openocd instance there is code being pushed yep uh the dude so the device is now now has the binary directly pushed and and and copied in ram and we're gonna run the code off of the ram um breakpoint nice there's a breakpoint that was automatically triggered and hit straight at the beginning of the main and that's fine and now if i go to the azure iot explorer let's see devices uh refresh oh that's interesting the device is now reporting that it's uh a plug-and-play device and that it's uh following and conforming to this particular model interesting so i bet the device is actually connected now uh let's see uh if the device is connected uh and if the device is plug and play we can very quickly from iot hub explorer look at maybe the uh properties that it supports apparently i can change how often i want telemetry to be sent so let's try and update that to 1 has been accepted that's a good sign yep good uh now we have telemetry being sent every second let's see there's commands set led state sure and let's try you see the led so that's not the one there should be another one that should be turned on let's see true there we go we turn the led on and off again uh telemetry let's see let's see if we have telemetry coming uh of the wire and of iodia yeah temperature as uh is being sent and is being sent uh quite often and i can obviously change uh change that and reconfigure that reconfigure that over there uh i could obviously also go uh in my code and put some breakpoints maybe uh i wanna put a breakpoint whenever uh a command is being sent to toggle the led so i can put a breakpoint uh it might not be uh set i might need to restart the app for the breakpoint to be properly um activated but let's try uh send command yeah i think uh yeah the led turned on so i think i would need to restart the app for the for the the breakpoint to be enabled but you get the idea it might not be perfect or this as of today you might find some glitches here and there but i think it gives you the um a sense of why you should start thinking already even if you're not aiming for having your developers and your users uh develop from the cloud they might still use vs code or visual studio for development but please start thinking about using the um uh the technology the dev container technology that i've described to already start uh describing in docker files what are the dependencies for your projects maybe use uh the code spaces dev containers uh description for describing the plugins as well and yeah you you will start realizing that it makes things much much easier to reproduce it helps with uh also continuous integration and making sure that you have reproducible builds and yeah that's what i had for you check out codespaces sign up for the github codespace is better don't forget to subscribe to my channel i try to post more and more often these days and if you have ideas or suggestions of things you would like me to cover in the future just ping me on twitter or just share in the comments until next time bye 