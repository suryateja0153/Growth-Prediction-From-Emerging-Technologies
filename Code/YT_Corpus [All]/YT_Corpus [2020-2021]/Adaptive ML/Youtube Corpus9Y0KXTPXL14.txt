 good evening everyone and welcome i am gabriela zara a first year phd student from school spirit santana of pisa and i will present our work on architecture for the clarity real scheduling on linux okay so i want to start talking about the the context uh real-time system today are practice everywhere and in the past decade we saw a rising interest in the topic of running real-time applications by deploying them directly on general purpose operating systems linux and derived operating systems are a common choice for safety application non-safety critical application uh especially when they must support a rich set of multimedia peripherals also thanks to the number of libraries and tools that have been developed during years linux has been improving its support for real time in this slide i have reported a timeline that shows let's say the the most critical patches that have been made to the kernel to extend the support to real-time computing i want to stick analyzing uh checkpoints all by one by one but however the the most recent what was the emerging main line of the scat deadline policy that implements uh an adf scheduler based on the cbs algorithm to provide a temporal isolation among tasks much effort was placed by this community the community in general but this community to increase the the relevance of linux as a suitable platform to develop real-time application uh but work focused not only on the kernel but let's see something more uh historically one of the most exported technique was to was to add a real-time micro kernel between the the hardware and the linux kernel and run linux as the lowest priority task leaving the management to the real-time microcardinal in practice the the approach was let's say to rely on a distinction between the real time tasks and the leftover here in the slide we can see uh on the real-time microcardio placement between the hardware and the linux kernel okay through the years also real-time extension was was developed for research purposes or experimental prototyping maybe the most notable example all are lit are litmus rt or carto linux lithus rt maybe is the most relevant one and consists of a kernel patch which communicate with the with the user space and allow application to ask for real-time tasks to be scheduled collocating let's say with this part another example is the the aquosa framework recently also many middleware was were released here a representative let's say example is the fresh forb that is a middleware based on corpora and let's application real-time application to create a kind of reservation across not only the the cpu but also this can networks anyway it relies on an extension of the linux kernel most the solution we have seen years let's say relies on on a single real time scaling strategy uh inter but interactive or multimedia workload need a variety of different tasks and with the teurogenius temporal characteristics also platform nowadays are our multi-core platform so it it is all but trivial to understand how can this application coexist in in the same system to exploit the different underlying schedulers offered by a kernel and also to config how to configure this this scheduler of the offered by keller to work in optimal way or some actual way on a multi-core platform the current approach does not scale well it needs skills skills in configuring the system to work and furthermore the this system admin can often know a priori the priority of application or pids of application therefore we want to we let's say proposed a novel framework that can be used to declare the temporal characteristics of real term of a real-time application but without enforcing the use of of a specific scheduling technique so let's forget about it our proposal is the real time system diamond a declarative real-time scheduling approach where application can simply decreal declare a set of timing characteristics and scheduling requirements such as the run time or the periodicity or also the request of a specific kernel plug-in and and then they do not have to worry about the techniques that will be used to match the the attributes okay how to to achieve this goal the proposed frameworks in practice adopt a modular architecture a set of plugins are used to translate the attributes declared by each application to proper kernel configuration and this modularity offers a set of features because apis are independent of available kernel policies schedulers can be partitioned over different cpus and the framework can be installed over on a modified kernel because plugins relies on policies offered by the native linux kernel also application without root privileges could access to real-time policies uh plugins as i said the the framework let's say is it independent offered independent api so you can port the framework on onto different operating system simply substitute so touching the the plugins okay so let's start to analyze each model one by one uh application that want to use to leverage on real-time capabilities can communicate with the diamond through the the rts library that in practice in practice is a shared library linked with the application binary and the library offers uh an api to let's say create modified and delete a logical real-time task and for it to attach a flow of execution through the logical real time task previously created uh in the slide here sorry here in the slide uh i have reported the parameters you can specify with your application such as runtime desired runtime the period the deadline the priority for instance in your application you can you can declare only the predictee maybe and then if you cannot it is enough to schedule your application with the rate monophonic plugin but maybe you know also the runtime so you can decorate the runtime and the perdicity and maybe you can specify that you want to schedule your application with adf and so the diamond will will schedule your application with the adf but maybe let's uh let's think about uh a linux kernel that is an old one and uh do not have the the edf uh scheduler and then maybe you can trust the rate monothonic plugin so all these cases are covered by the the framework okay the essential component of the architecture is the central decision authority this is the the demon and this component can connect and coordinates all the interaction among applications and plugins and in practice when when a task arrives the daemon interrogates one by one each plugin and then select the plugin which fits better the requirement of your application and then of course it sends back the the response okay so uh let's analyze the the last piece of the framework plugins each plugin must implement a set of functions that are used by the the daemon to dispatch requests and each plugin support one or more scheduling policies offered by the the kernel also its plugin may implement an admission control mechanism that can be used to check maybe if uh a new task can be admitted or not to the current task set and currently we we made available a jdf plugin rates monotonic plugin a fixed priority plugin and a round robin plugin we want we we are working on a sporadic server plugin that will be based on the posix sporadic that on linux was made available through uh the patch um written by fat jolly one of our former colleague of the laboratory the adf plugin supports the scad deadline algorithm and implements a utilization based admission test tasks that are accepted are scheduled following our worst fit policy namely are assigned to the least loaded cpu the rate monophonic plugin on the other end supports the scad fifo policy and the load on the cpu is estimated um with the recipe utilization of course when possible but because maybe tasks are let's say you have not declared the run time uh of course priority is ascended in in virtually proportional manner to the period and we have made a decision to sim task following the worst fit policy also here in the the rate monosonic plugin okay in this slide i have reported an example i could sample maybe could clarify the concept the concept let me take the the laser so in the first part the task declared its its parameter and then he tries to to create a test to let's say create a the the logical task if the test is let's say passed on success we can attach the current flow of execution through their logical task created then in your let's say cycle you can do your monetary computation but if you have uh some of us spare time because you are let's say the the demon accepted uh that your desired run time you can do also optional computation and then of course uh you can finish your period okay so let's pass to the performance evaluation uh briefly these are our environment characteristics we have on an i5 we have tested on a i5 desktop computer and here are let's say you resumed all the parameters if you want to repeat the test okay so the benchmarking application is a single threaded process that performs multiple requests to the daemon each time adding a an a real a real-time task to the task set and we want to evaluate the the cost of the task admission test performed by ada the idf plugin and the rate monosonic plugin here in the slide i have reported the the results the you can see the minimum average round three time is 16 microseconds so from the plot it is clear that while the response of the jdf plugin it's constant the rate to monotonic plugin is increasing cost that can be attributed to the operation performed by the plugin to update their priorities and assign it to a task but for both the plugin notice that the cost must be paid only when declared on a new task when your task joins the task set because during the regular scheduling operation the overhead introduces is zero because you you you use directly the uh the policy offered by the kernel okay so uh first i i i would say that the realization of this framework was motivated by the recent advances in the kernel feature that in our opinion need to be followed by corresponding advancement in associated middleware and also user apis there are a lot of future direction we want to to improve the daemon we want to work on supporting power management techniques and also heterogeneous architecture if you want if you have a big little architecture for example and we want to let's say support this kind of this kind of cases so i can say collaboration our collaborations are welcome so if you want to to contribute here you can find the repository the github repository send me an email and we can talk about it and that's all the i want to thank you for your attention i hope you have appreciated this work and if you have some question feel free to ask during the q a session thanks you 