 Unknown: Before we talk about machine learning with scikit learn in the next lecture, let us briefly talk about object oriented programming. That means Python classes. And that becomes very relevant very soon when we talk about psychic learn, because we say learns heavily based on object oriented programming concepts. And at the end of this video, I will show you an implementation of K nearest neighbors using the psychic learn API are basically the approach that I could learn uses for implementing estimators like classifiers. So, yeah, we are going to talk about Python classes now. So to get a better understanding of the scikit learn API, like I just said, and that will hopefully make everything kind of like easier to understand when we use scikit learn in the next video. So here, I created a very simple naive vehicle class. So the vehicle could be a car, motorcycle, or truck, and so forth. So just just visualize it as like some some type of vehicle here. So we have a vehicle class. And how classes work is that we receive the class definition here in this line, and then indented, we have the different class methods. Class methods are very similar to functions. However, note that the first argument to each class method is the mandatory self here. So there's also concept like static methods, however, we are just talking about regular methods here. So every method has to have a self here as the first argument. And the self here refers to the object itself. So you can think of a class as a cookie cutter that you can use to make or cut out cookies. If you have, let's say, this plate of dough, and you have the star shaped cookie cutter, you can apply this cookie cutter to different places on this dough, and this plate of dough. And then you can get these different cookies from there. So you can, these are not really nice cookies, but you can get multiple cookies. So the cookie cutter itself, that would be the class, which you can use to make what as a template to make these different objects. So the cookies here would be objects, basically. So objects created from this class, or sometimes I'll say, instances of the class and stuff like that. So I'm here, the class, you can think of it as a template for making vehicle objects. However, let's not get ahead of ourselves here and see how, what we have here in this vehicle class. So the first method here is the init method. And the init method is the so called constructor, which will basically be executed when we create a new object. So if we have an assignment, for example, on new vehicle equals that's a vehicle class. So if we call the class to make a new vehicle object, if we do this, then the init method gets executed. We don't have to explicitly call, let's say, vehicle. Class dot underscore underscore in it, this is not necessary, it automatically gets executed once we initialize a new object. So what do we have here in this init method, so this init method, accepts, accepts one argument, the horsepower that's the horsepower of the vehicle here that we have to define because here we don't have a default value, we have to define it. And then there is an attribute here. So the attribute is horsepower. So we are basically assigning the argument provided to this method to an attribute so this is an attribute. So if we create an object, if we created this new vehicle here, the new vehicle will have an attribute dot horsepower that we can then access to look up the horsepower. So here when we create this, there should be a number for example, 123, something like that. And then if we access this attribute, it would return 123 it's just a way of attaching a value or a variable. Just to This object. So in the self means the object itself created from this class or self gets translated to whatever the name of the object is when we created. And since we are running out of space here, let me forward one slide. So I can talk about this a little bit in more detail where I have lived more space for annotation. So here again, for reference, I have want to hit on the last slide. So we can take a look at this again. And now step by step. Here, on the right hand side is the code for instantiating. A new object using the vehicle class, so the vehicle class was our cookie cutter. And this is our actual cookie that we create using the cookie cutter. So here, we call that object call one, it's just an arbitrary name. And we provided with the input in the init method. So if we create, or if we call the class here to create a new object, it will automatically execute what's in what's in the init method. So in the constructor, so after we created the object, this one will be available, which got executed here. So creating this call the init method, which we also call the constructor method. And then we can use only other methods on the car object, which I will show you in the next slide. So here, I'm calling now the horsepower to torque method, which is which I looked up on Wikipedia, it's just a method implemented for converting between horsepower, it's the measurement of all let's say, You're not fast but powerful cars, and converting it to torque, so put some calculation in here, and it will return the value of the torque, so it will convert the horsepower into torque, so we have to provide the rounds per minutes on it. So that is something we have to provide. But internally that we use a different color here, internally, it will use the horsepower that we defined here. So the car remote has a horsepower attribute. So this is an attribute, the horsepower, it has an attribute that is internally used here when we call the hospital to torque, and then it uses this one. So the RPM here together with the horsepower argument, or sorry attribute to calculate the talk. Now, we can also define a method that modifies attributes. For example, in the next call here, I'm calling the tune motor method, which tunes the motor so the car after tuning, it has twice the hospital. Amazing, right? It would be great if it works. So simply in real life anyways. So yeah, now our car has twice the horsepower. So it should have, instead of 123, if you would print hospital after two motor, you would see 246. Now for the hospital. And now I'm calling the hospital to talk method again. So you can see now, it's different than before, because before our car had was bought 123 here, and we tuned the motor, so it's now 246. So it's kind of doubled the torque. So in this slide, I just wanted to kind of go over the concepts behind class attributes and methods. So there are some methods that return values. And some methods, they don't return values, but they modify the object so that it's important to keep in mind that cloud methods that return values that don't modify the object, and some modify the object. And actually, we can really, as a user, we can really know what's going on. I mean, usually this is hidden from a user. And we as the code developer, or the person who writes the code, we can, of course, see that, but usually, the users few use something like someone's or someone else's library or code, you only see this part here on the right. And from here from looking at that you can just see whether this modifies the object or not. So in a way, the only way to tell is, let's say, looking at the source code or the documentation. However, in scikit, learn there are certain conventions for certain methods that do modify the object. And we will also then talk about this a little bit later. But for now, um, there are two more methods I wanted to talk about briefly. So there's the private method. I had So in Python, there's a convention. Yeah, the Python, people in the Python community say, or the as the saying goes, it's, we are all adults here. So we are not restricting any access to anything in Python. So you can do whatever you want. In Python, you can have access to everything, everything in the Python library that you import, however, it's on your own responsibility. So if there are methods that the users shouldn't use, but if they want to, they can use them, then there's a convention to add an underscore in front. So this is a convention saying, hey, this method is private. Don't use that method. It's useful for developers, but not for you, the user, but you know, if you really want he has it, go ahead and use it, it's just your own responsibility. If something goes wrong, it's not our intention that you use it. But please go ahead, if you like. So that's what the underscore indicates, underscore, in the front. And yeah, you can just call the methods, like a normal method, even though they have underscore in front, it's just like a convention, it's not doing anything with the code, it's just a convention. Now there is a slightly stronger convention, it's using double underscore. And that is, if you have a very, very private method, where you really want to hide that method from the user. And you don't want that to show up. I don't know in certain documentation aspects, and so forth. So there's this double underscore. And this one, again, like we said, we are all adults here, it's possible to access the dollar underscore methods, the very private methods, but it's a little bit more tricky to access those. So in order to access those, we can't just call the method like that he will get an attribute error here. So it will tell you that, yeah, this doesn't exist. So we can't just call it like that. That doesn't work. So but we are all adults, here's what can we do. So the solution to that problem is this little workaround, where we put the name of the class here in front. And it's just make making the x's a little bit trickier. But again, we can access this method. So if you want to access a very, very private method, you will have to put the class name here in front with another leading underscore. And this way, you can also access these very, very private methods. But in scikit, learn, or personally, when I write code, I usually never use those, I just use a simple underscore method. And usually that is sufficient in most cases. Another concept related to Python classes inheritance, so I should have put that in the title inheritance. So you can essentially inherit from a parent class, you can make a child class or children classes that are inheriting from a parent class. So for example, I can make a specialized car class that has some additional properties. For example, the car class or all cars from the car class have four wheels. And I could make a separate motorbike class where all the vehicles, all the motorbikes, basically, inheriting from the vehicle class will only have two wheels. So that kind of way, I can inherit all the chat properties from the parent class, but can make them more specific for specific objects from a child class. So here, I'm making a child class that inherits from the parent class here. So it basically inherits all everything from the parent. So what I'm doing here, in order to do that inheritance, I put the vehicle class here, and then I'm calling this one here. So this one will cause the car class to execute its init method, so that the horsepower gets initialized from the car classes init method, and then I'm adding another attribute here, the number of wheels, so I set it to four here. So then I can create a new car now inheriting from the car class, but note that it still gets the horsepower here, because there we are still using it here. And then we are calling that in the car classes in add method. So even though we didn't set the attribute, we didn't set self dot horsepower. To horsepower, it's still available because that would be done in the parent class. And that is how it works. It's the rest is basically the same as for the parent class. Yet to connect all the topics we just talked about. wrote a very simple cane and classifier that follows the second learning API. But of course, if you would look at the source code of the second one, it would be way more complicated because it has all kinds of bells and whistles like the KD tree, bolt tree implementation, and many, many tweaks, I just wanted to make it as simple as possible so that I can fit it on one slide and talk about it in five minutes instead of 15 minutes. So I'm here, but so the same overall concepts apply. So my kin m classifier has an init method. And it takes all the relevant arguments. So yeah, I only have two hyper parameters. So here, that would be K, the number of neighbors, for example, in second learn, it's called an end neighbors, but doesn't really matter, I just call it K. And then I'm having a distance function here. And then when the init method would be called, it would set memorize, basically assign it to an attribute the number of neighbors, and then if I don't provide as a user, if I don't provide a distance function, it would use its own or the default distance function. In this case, it would be the Euclidean distance. So note here, I'm using this underscore. So this is a private method, I just wrote this method for the KNN classifier to use if the user doesn't provide a distance method, but there is no reason that the user should ever let's execute this one. Of course, also, you can see there's a very inefficient implementation, I think I gave you some homework exercise to make this more efficient using NumPy. Anyways, so here, I'm using a private method, because there's no reason why the user should call this method I'm indicating, hey, this is just internally used. Yeah, and then the two public methods, a fit method, that's the training method, and a predict method. So that's doing the prediction once the training has completed. Now, let's take a look at the fit method, which is basically the training what's going on here. So as you remember, the K nearest neighbor classifier, doesn't really do any anything during training, because it's a lazy machine learning algorithm. It's just saving the data set. So here, we are just creating a copy of the features and the training labels. And we assigning them to class attributes here. And then also all the unique labels. Note that I'm using an underscore here at the end. So what does that mean? No, because I'm sorry, here. So we didn't talk about the underscore at the end. yet. And that is a psychic learned convention. And usually in scikit, learn the attributes. With a trailing underscore, like that one, are I'm bringing it down, because it's kind of an important point. And usually, it's easy to forget. And in the past my other students that was it was a very common question and later in the class, because people forgot what the underscore was four. So this is a convention that actually works with a trailing underscore are available after calling fit. So that means you this actually, attributes don't exist before calling fit. And that is a way of distinguishing between parameters that we assign or hyper riders that we assign here in the init method. In the inner methods, we never use, trailing underscores. We only use these for the attributes created in fit. And there's just a way of finding out whether a classifier was fit or not. And these are usually things that are created during training, for example, these copies of the training set in this case. Now after training, we can then call predict. And I don't want to go over all of this. But in predict, for example, we are calling again, a private method. And this private method will find the nearest neighbor. So again, this is a method that the user doesn't have to execute. It's just internally use. All the user has to worry about is initializing a new object. And then doing the fit and predict basic that's all the user has to do. And I think I have some more slides showing this. So yeah, actually one more slide. So here, this is how we would use our cane and classifiers We would initialize it with a hammer, right or three, we don't use a distance function. So it will, by default use the Euclidean distance function. And then we call fit using the training set. So x train and y train. This is what we created previously in the last video. So this is these other features. And these are the class labels. And then after model fitting, we can call predict here on the validation set. And these are the predictions by the validation set. And that is how the psychic learn API works. Of course, this is a very simplified version. But here what's important to remember is, there's a fit methods method, there's a predict method. And these are available for all classification algorithms and all regression algorithms. Most of them also have additional methods, for example, score and transform and stuff like that, but fit and predict are the main ones. And then there's an arbitrary number of private methods, but we don't have to worry or think about the private methods. They're just there to make the application or implementation here. To make it more efficient to make the code in fitness a little bit smaller, till we could have actually squeezed all of that code into this one. But it's just like refactoring. It's easier to write code, where you have smaller, special purpose functions, because then it's easier to debug the code as a developer. Okay, so that was a very short brief crash course on object oriented programming, and Python classes and a brief glimpse into the psychic learn API. So in the next lecture, we will start in the next video, we will talk a little bit more about machine learning with scikit learn 