 Hello everyone, welcome. My name is Rodrigo Méndez. I work in the GeneXus commercial area and I am here to present what's news in GeneXus version 17. The best version so far. What are we going to be covering in this demo mix presentation? We are going to be touching on some quite interesting points that this new version delivers . Let's start first by talking a bit about what DesignOps is. Then we are going to touch on the issue of the multi-experience that GeneXus version 17 delivers and then we are going to see what were some improvements that we are also offering in terms of integration and evolution. And finally, we are going to close with something quite important, which is the possibility of working with DevOps in an extended way, thanks to GeneXus and GeneXus Server. Let's start with the DesignOps part. DesignOps is a fairly recent term and a bit what it tries to tell us is the possibility of combining what is known as DevOps, but also including the design team. What is happening? In the practices of what is known as DevOps it implies the interaction between the developers on the one hand, and the administrators of the systems or software, on the other hand. And from DesignOps, in GeneXus what we understand is to try to go one step further and also involve and integrate the application designers into this work group . So, in this exercise, in this learning process, which we began a little more than a year ago in GeneXus, what we began to do was investigate some very popular design tools on the market, of which the tool by Sketch. In this tool, what we started to do is see how we could include those designers who were working in Sketch and how those Sketch projects or Sketch designs could be reused, so that we, from GeneXus, allow us to simplify the software. What have we been seeing even in GeneXus and what are the improvements that we are also including in this new version regarding DesignOps? We will be allowing a GeneXus developer to start development already counting on the work that a designer has done. A work that can be an interface of what is a mobile application like the one seen on the screen, where the designer creates the different screens and the navigation between them. From We we will be able to import this design and we are going to to be able to start developing on this presentation interface for our system. We are going to see how we do that from GeneXus. Now from the IDE of GeneXus version 17, what we must do to import a Sketch design is go to Tools, then we go to Application Integration and we are going to select the Sketch Import integration option. Ok, here what we are going to be able to do is select within our team a file of a design made in Sketch. Once we select the file, GeneXus loads all the information of that design and what it will be showing us are the different panels that GeneXus will be generating, along with all the images, content and even the fonts that the designer chose. for this interface designed in Sketch. Once we select OK, GeneXus will begin to import that is the Sketch design specification and what it will begin to be, it will begin to create all the files in our knowledge base . When that generation of the files is finished, we will have in GeneXus the necessary Panel objects so that we can already have that same interface in our application. After that step, what remains to be done is to start working on the logic model of that application, that is, the information that will be linked to all those screens that we already obtained automatically from the Sketch import . What we have here are the different objects that the Sketch import has created in GeneXus. We can see from abstract designers that GeneXus, based on Sketch's design , already creates all the objects necessary to be able to represent the same designed interface. Here we are ready to run our knowledge base and see how that design has effectively been in our application. And after working with DesignOps importing this design, what we are going to be able to do from GeneXus is create this design, giving users a multi-experience. Why do we talk about multi experience? Because based on this design that we import into our knowledge base, we will be able to create applications with a web experience, such as a native mobile experience, where we will also be able to include the use of conversational agents known as chatbots in both. And one of the newest features in this release of GeneXus version 17 is that we will be able to generate these applications using the Angular framework generator. Ok, let's see how the applications generated for both Mobile and Angular are based on the import of the Sketch design that you showed them at the beginning after the sketch import . We will be able to see in the preferences of our knowledge base that another of GeneXus novelties is the redesign of the environment, where we will be clearly separating between the technology that we are using for the backend and for the frontend, for the backend we are going to have everything related to the generation of the programs and web applications. And then for the frontend we will be able to define the different technologies that we will use to create all the interfaces. In this case we see that we have selected that the frontend will have a delivery of a web application based on .NET. Then we have a native mobile application that is being generated for Apple. And finally, we also have a web application that is being generated by Angular. We are going to run this application based on the Sketch design that we previously imported. I also want to comment that it is important that now we in the frontend will be able to decide what type of generators we use. Where, in this case, as Android had mentioned, the Android generation is deactivated because we are only generating Apple and what we will also be able to choose is which will be the main platform on which our software will be prototyped and executed so that we can prove it. In this case we have Angular selected. Depending on the generators that we have selected, we will also have access to different configuration properties for each generator specifically. So now what we are going to do, we are going to run the application in Angular. After importing Sketch, we are going to see how we will first open the console where it will be lifting based on the Angular commands, using all the necessary packages to compile this application and we will be able to see how the application generated in the browser with the look and feel of what could be a mobile application, seen from a browser. What we have here is the application based on the Sketch Import that we carry out and this same application is generated using the Angular generator that is in GeneXus version 17. As we can see, we have exactly the same design that we had in what was the image that we had seen, that that Sketch designer gave us. And we also have implemented the navigation in that application, where what we would be left with is to make the relevant improvements to the navigation that we want to make and the linking of all these images and this static design that you see on the screen with what is the information that we will be using it in production when this application is working. We will be able to enter to see the details of the attractions. And we will also be able to see the address of each attraction, showing the map, following the guidelines that the designer passes us in this DesignOps practice. Ok, here we are going to see one of the installments of the multi-experience that I was telling you about, which is the application generated by the Angular generator. Now what I would like to show you is this same application based on the same design that they pass to us from Sketch, but instead of it being web and with the Angular framework , we are going to make it mobile native. For this. What I am going to do is I am going to show the QR codes that GeneXus generates, which are the ones that allow me to prototype on my device and from my iPhone, what I am going to do is scan these codes and we are going to see how the prototyped native application looks running from my phone. Let's save. And here what we have is the application, prototyped running negatively on my iPhone. We have navigation. Where are we going to be able to enter to see the same details that we saw from what is the application that we also generated for Angular. And we did this all based on an import that we made of a Sketch file and from GeneXus we practically did not have to do anything more than select which were the frontends in which we wanted to create those applications. Well, then what is the delivery of multi user experience , we cover what is the multi experience in mobile and in the Angular framework , which is the latest addition to GeneXus generators in this version 17. Now we are going to see a bit of the experience we deliver in what is web and what are conversational assistants, also known as chatbots. Let me show you. What we have here in this knowledge base is a logic model that we have created, where we store information about this travel agency. This comes in counterpart to the design that the Sketch designers gave us. Now what we are doing is creating the logic model to maintain all the information that is going to be presented in that application. It is important to mention that this is the logic model that is also seen in GeneXus version 17 courses. So in any GeneXus 17 training or courses that you take, you will be working on the same scheme as the travel agency. What you can see here on the screen is a conversational instance that we have defined, where we are going to be creating a chatbot, it is a chatbot that uses natural language processing services and apart from what you may be observing now, which is the interface or the instance of that chatbot, we are going to notice some things regarding what you have seen previously about chatbots and new things that we are delivering in this version of GeneXus. First of all, we have entirely designed the chatbot editor, where now the conversational flows are going to be defined differently. We are going to have a much simpler and more friendly user interface to be able to understand how chatbots work and to be able to define the conversational flows that we want to have in our system. Another of the things that we also include and that are new in terms of what the GeneXus chatbot generator is, is that the chatbot now has the possibility of allowing the user to ask questions that are Queries in what GeneXus is, that is, the user will be able to directly make Queries and obtain the results plotted as he wishes. Ok, let's see how this works. Here what we are observing is an instance of a conversational flow, that is, a chatbot that we have created. And as we can see, there were two big changes to the chatbot, one noticeably more visible on this screen, which is the abstract chatbot editor that has been entirely redesigned . This is what allows us to have an editor that is much friendlier and that facilitates even more creation from a chatbot, from GeneXus. Now we can see that this chatbot that we have created within this knowledge base is a chatbot that uses artificial intelligence services. You are particularly using natural language processing services . And as a provider of these services you are using Google's DialogFlow . So we will be able to communicate with the chatbot in a human way, using human language that can vary, and the chatbots will take care of understanding what are the things that we are asking for and what we are needing from it. The second major change that the Chatbot generator has had in this release of GeneXus 17 is the possibility that the user, when communicating with the chatbot, can ask questions about new GeneXus objects. What are these objects? They are the Queries. So what is the user going to be able to do? The user will be able to interact with this chatbot asking for different reports and obtaining the information from those reports as he prefers. We are going to see the example of this chatbot working live from GeneXus. What I'm going to do is run the application. Remember that chatbot generators also do not generate the user interface and we can choose both in the generation of the user interface for web applications and for mobile applications . And this is a bit along the lines of delivering the multi experience to our users. We are going to go to the interface where we are going to communicate with the chatbot. Well, here what we are going to do with the chatbot is in a natural way, we are going to ask you to give us the 10 best clients of our travel agency. What the chatbot is doing is: it understood what we were referring to and it is doing the Query or querying the database and it gives us a graph with the ten most important clients and how many trips each one has made. Now what we are doing is: we are asking for the same information, but we are telling you that we want to visualize it in a different way . What changed is that we want to see it in foot form. The chatbot is also capable of doing that and based on that query bring another type of presentation. Now what we are asking is for the airline reservations made and we are deciding to see it in the form of a graph. Finally, we also have queries where different parameters can be requested , that is, here we want to see the attractions by type and we also need to communicate with the chatbot and tell it both from which country and which city we are going to want to see those attractions by type. Well, once we finish covering all the concepts of what is delivery and the multi-experience provided in this new version of GeneXus 17, what I want to go on to address is what is new regarding integration and evolution in three aspects. Specifically I want to stop ... We are going to start with the first one and we are going to see that we have a new object in this version called API Object. We are going to understand a little more what this object is and what it is for when we are developing in GeneXus. API Object is the object, in this new version of GeneXus, that will allow us to mediate what the API Economy is today. Okay. What is it going to allow us? It will allow us to publish services that are decoupled from the business logic. That is, we are going to allow there to be a way to consume these services for our users. That it does not change from GeneXus and that it is independent of the internal logic within our application. That is the great advantage of this delivery of a new object in GeneXus. It will allow us, in some way, to decouple ourselves when it comes to providing services. The services that we provide will always be able to be consumed in the same way by our clients, regardless of the modifications that we need to make in the backend of our operations. Let's see how these API objects are defined and what are some of the things we can use. Here, we can see that I defined an API object for what airports are in this Travel Agency story . In this case of Travel Agency we need to make available information about the airports and for that what we did is create an API Object of airports, where we are going to make available certain functionalities for users or systems to consume information from our software. How do you work with the API object? We are going to define which are the different resources or methods accessible as part of this service with certain parameters. This is the part that users or systems that are consuming our services must use in order to receive information. And this is where the decoupling part comes in and where the intermediation purpose comes in what the APIs are with this object. The way in which customers consume the service will remain fixed and unchangeable. What we are going to be able to do through this object is to vary how we implement that service internally without affecting customers. In the first line that you see here selected, what we are doing is making available using the functionality of obtain by ID or GetByKey for an airport where, as a result, the airport and an eventual message are delivered. That is what users are going to have to consume from the service. But what do we define in the next line? We define that each time a user consumes this resource, what will be done internally within our knowledge base is a call to a procedure that has certain parameters. This second line is the internal logic of how we implement that service and it is what we will be able to vary without affecting all users and systems that consume the services we publish. It is super simple to implement and it also helps us to organize all the resources of our system that we have published as a service. We will be able to group and quickly identify all those parts of our system that are exposed to being consumed by third parties. After defining, on the one hand, how we allow the service to be consumed and what is the internal logic that we implement to sustain that service, what we will be able to do within the events is define different operations that will be performed before before service is called or after service is called. When I am talking before or after the service is called, what I mean is before or after we execute the internal logic of this service. In other words, the client who is consuming the service that I have published will enter the parameters and the necessary signature, the necessary information, let's say, to consume the service. That does not change that the idea does not change, that it can be maintained over time so as not to affect its operations. And then I am going to be able, before executing my internal logic, decide to perform certain operations. So here we have an example where for the case that a list of all airports is requested, an operation is executed where the filter, which is part of the signature, let's say, is left without value, which is internally when we are going to fly airports, let's return all airports. In this case, where we are using the word after for the GetByKey method, the event after, we are saying that after we call the internal logic of our system to implement this service. We are also going to be able to run a series of operations, such as in this checking example, where we are checking that if they ask us for an airport that is under maintenance, we are going to be returning a message to the user who consumes the service of airports and particularly that method, saying that the airport is under maintenance. Well, then, in summary, Object API in this new version of GeneXus will allow us two very important things: First, to be able to maintain a better organization of our system and to be able to quickly notice which resources of our systems are being published as accessible services by third parties. And second, what this object will allow us is also to be able to achieve an intermediation layer , that is, that those third parties that consume our service always do so in the same way and do not depend on changes in the implementation of services. In other words, we will be able to successfully decouple how we choose to implement the services that we have published without affecting all those who consume them. Now let's go to the next topic. The next topic deals with security and in this case, what GAM or GeneXus Access Manager brings are two important novelties. One is the possibility of being able to authenticate with biometric factors in the applications. In other words, we will be able to use the fingerprint to authenticate ourselves to applications created in GeneXus that use GAM or we will also be able to use FaceID. This will be two of the biometric factors that GAM includes for application authentication and authorization. Additionally, features such as the AppStore Single Sign On and even WeChat are also included. We have covered API Object, we have talked about Security, where we see that there are interesting news in GAM and now we are going to discuss the news in what is the GeneXus BPM suite. Join me, I want to show you in this knowledge base that we have, what are the news that BPM is giving us in this version. What we are seeing here is a diagram made where we can see that, in Timmer symbols we have the possibility of defining new properties. These properties, in particular the property of the Timmer definition, we are going to see that now, in addition to being based on a duration, this Timmer will be able to be based on a given date and we will even be able to define what a Timmer is that is repeats cyclically. We are going to move on to another news about BPM, which is also related to Timmers, and that is that we include the symbol, the start of an event through a Timmer. This, which will allow us, will allow us to configure this Timmer in such a way that the event that we have modeled is triggered. Also the definition here will be able to be of the type of a date or of a cyclical type, being a date, a date that we can set fixed or we can interact with it through the API of what is Workflow. In the event that the definition is based on a cycle, this will be very useful because it will allow us to model processes , which we know must be repeated over and over again in a cyclical way. In this case, what we did is model a process where we can say that all new travel promotions that appear should be checked monthly . So, thanks to this new symbol in the diagram or in the BPM modeling, we will be able in some way to represent and enrich our business processes, reflecting on the systems created in GeneXus. Another interesting thing that we have in this new version of GeneXus is another object, this Object is called the URL Rewrite, and what this object will allow us is to be able to define the rewriting of all the URLs of our application. This will give us several advantages and we will see that it is very easy to define how we rewrite the URLs. We are going to see it with this example in what is the line of our travel agency or the system that we are doing for the travel agency. Here you can see on the screen, I have created a URL Rewrite object, which is intended to transform the URLs of everything that are attractions in this travel agency system. So what we are defining here is ... on the right we have the name of the GeneXus object and on the left what we are going to define is how the name of that URL will be. What are the advantages of renaming URLs in GeneXus? Well, first of all it is going to give us much more user-friendly names , where the user will be able to better understand in the application what they are seeing and how to eventually navigate in it. Another advantage we have is that it will serve us for what CEOs or search optimization engines are . Ok, we can rename the URLs so that we know that it will help us rank better in searches on our site. And the last advantage of using URL rewriting in GeneXus is that we will have to make even fewer changes when we change environment, development. That is, if we are generating an application for a specific development environment and we have all those URLs written in a single way, when we change environments, we will also be able to access the same URLs without problem. If we run the application, we will see that the WorkWithAtractions object is going to have in the URL of our browser AttractionList. In the same way, we will be able to define object URLs that require parameters where we will be able, on the left side of the rewriting rules, we will be able to redefine the variable taking the parameters into account. One of the important things also in this version of GeneXus is that by default, now the knowledge bases that are generated and that do not use URLs have the URL with Named Parameters. Then we already through the URL we will be seeing information about the parameters. This of course can be disabled and the URLs are from the previous method. Well, so here we are running the development menu of our application and we are going to see how the URL of this GeneXus object changes. Here we can see in the address bar that this object is no longer called WorkWithAttraction, but is called AttractionList. And every time we select an attraction, as the rule was also renamed, we will see it in the form of attraction, bar and the number or code of the attraction. Well, now that we have seen what this new version of GeneXus has for us in terms of multi-experience, where is the new Angular generator, where the chatbots also redesigned the editor and allow us to interact with Queries, we saw some news regarding two New objects appear API Object and URL Rewrite. Then we also saw some improvements in what is the BPM suite and even also in what is security through biometric authentication with GAM. We are going to close this Demo by talking about the rest of the DevOps cycle a bit more, as we cover the DesignOps part. We are going to focus on what happens after development, when it comes to interacting with the development team and how we are going to build that software, how we are going to test it and how we are going to put it into production. And this is where another very important player comes in, GeneXus Server, where it is going to bring some new features to the table in this new installment of GeneXus 17. When we are talking about GeneXus Server and these new features , we are going to refer to the possibility from Continuous Integration. What are we going to be able to do when we are working on a GeneXus project where we are using GeneXus Server as the centralized repository for said project? What we are going to be able to do is define several Pipelines, one or more Pipelines where we will be able to generate or schedule different operations to be carried out automatically with our project. What are those operations going to be? They will carry out the Build operation of the project, they will be operations where automatic tests will be run if we have defined test objects and we will also be able in some way to schedule the put into production of all the Pipelines that we have defined for our draft. Here what we are seeing is the new Continuous Integration Tab within GeneXus. Once we are connected to a GX Server, what we will be able to see are all those Pipelines that we have defined, that each one can have different rules, can even be generated in different environments and can perform different operations on each other. Everything is done in this case within the same version of the knowledge base. Here we can see that while some of the Pipelines may have compiled successfully, others may have failed. So this is where we are seeing from the GeneXus IDE , the interaction with the repository is reviewed and with the Continuous Integration feature that GeneXus Server provides in this new release. We are going to see that alternatively we will also be able to handle it from the GeneXus Server interface itself, where we will be able to create the Pipelines and be able to view the information pertinent to all the Pipelines that have been created for the KBs that reside in this GeneXus Server . Similarly, as we saw from the IDE, we will also be able to view the status of the different Pipelines and what operations have been performed on them. So, with this I want to close this installment of all the news in the new version of GeneXus 17 and I invite you to watch the rest of the videos to be able to go deeper and go into more detail about what has interested you most in this new version. GeneXus 17 delivery . Thank you very much. 