 [Music] you hello everyone so today we are going to discuss on high-level synthesis so I mean as you saw in the last last lecture is that we talked about this VLSI design flow and you just saw the all the sub steps of user BLSA design flow how we can take an high level behavior and we can map that to I mean you know integrated circuits right so that is what we have seen so in today's class we just recap that whatever we have discussed in the last class and then we just go through high level synthesis by primary with an example just to try to understand how what are the objective of each sub steps in today's class right so if you see in the last class is VLSI design flow is consists of several sub steps like high level synthesis logic synthesis physical synthesis then fàbregas and packaging and testing right so and you can think about the actual things start from that English language system specification then we generate that C C++ code from that manually primarily manually that part is not automatic and then we do high level synthesis to generate a register transfer level designs from a C C++ code and then we do logic synthesis to get generate gate level designs and then physical synthesis to dinner transistor level design or the physical layout and then you do the fabrication and package and get the integrated circuit straight and what is the objective of these cycles is we try to design as abstract level as possible right so that we can design in quick time and we rely on the tools CAD to compare computer-aided design tools or EDA tool select electronic design automation tools to generate the next detailed level and that is the world objective so that we can generate a big circuit in quick time so that is the overall objective of visual VLSI design flow we try to design ads as abstract level as possible as quickly as possible and try to automate that steps we use synthesis tools to generate the next level of designs so that is the world objective and this particular concept is nicely captured in this Y diagram which consists of three axis right the structural axis is behavioral accesses and physical accesses and so if we just think about if you just go from the centre to as as fart there it is more abstract isn't it so if you just think about this so in the core level in the structure you have only transistors and behavior level you have the functions that represent the transistor functions right and in the physically do have the layout transistor layout so if you go one level off so we'll have gate level designs next we have GERD flip-flops in the structure level and the graph will get level circuits can be represented as in boolean equations right and physically we have the cells the standard cells of the cell libraries and if you go one level off in the structure level we have the registers multiplexer a loose and physically erased or transfer level designs or the tail designs physically either you go for a C or FPGA right and if you go the more abstract level so in structurally a processor memory bus may be a level yell Goutham flowchart in a C C++ code like this and physically you have this PCB or MCM so this is how the whole VLSI flow stands and we try to start designing from the as directly from the algorithmic level and that is the overall objective and what is the importance of these design automation steps the first thing is this this sort of design cycle as I mentioned if you start designing suppose you take an example of say sorting algorithm right and you just try to implement a bubble sort so you write that bubble sort in C it is just hardly four or five lumps of code right but if you not think about how you want to design the bubble sort in RTL level now you have to consider all these registers multiplexers adder subtractor comparator clocks reset everything so now the bubble sort algorithm in in RTL maybe 100 lines of code right and if you think about and bubble sort in gate level I asked you to design a bubble sort using gate level designs now you have all this and gate or gate you have to realize they are using and get on gates gates or you have reused really flip-flops registers and all those things right now your design may be four hundred five hundred lines of code right and now if you think about I asked you to design a bubble sort in transistor level which is maybe thousand mm and so cool so that actually give you the idea right if you just write a bubble sort you will hardly five minutes you can write a bubble sort algorithm and you can use a high level synthesis tool or the synthesis tool and this will generate a great level design or art a level designs or say transistor level design directly from from using these tools so that is basically give you the sorter design cycle so that is the one of the important aspect of this so the next is the design space explorer essen again if I include Axew the implemented above also tell me more options in the hardware right so for example if he try to execute the whole thing in four o'clock you might need to add er or if I want to execute the whole things in say six o'clock you might need only one adder or two adder so then you are using relays resource or there is a trade-off between time versus the resource and there are a lot of possibilities right in some cases you it's okay to design everything in safe for clocks instead of six clothes or in some time you need to execute everything in say in for clocks instead of six clocks so based on your design parameters you have a lot of options like that so basically you should already explore this design space the possibilities to get the best best result out of it so that is also possible through design automation because it's automated ten you don't have to design everything from scratch right and also the next possibility is a few nodes in the design because now you just think of have to write and gate level design consists of four thousand five thousand lines of code and you have to handle all clocks all receipts everything so there is a high chance that you make some mistakes someone so you're very careful yeah I mean of not making many mistake in the design but if you just think I would above all sir is hardly four five lines of code so you can easily write that easy later and there is chances operator this minimum or less compared to if you just design that in our tailored unit level so if you use design automation the chances of errors is less and also there is another important aspect in specification driven optimization in the higher abstraction level so what is that so is basically it's if I ask you to RTL design so writing for variations of a bubble sort is but if I ask you so you design one bubbles are just to give minimum in its a fastest RTL which compute the whole thing a minimum possible minimum possible time right or I ask you to design another bubble service you use less least number of the list number of resources so really your abstraction goal or the design optimization goal may be different and based on your goal then RTL or the gate level design that you're going to get will be different right so again you can have a high level code you can always try to do these things using synthesis tool rates because you have a high level you take very less time to design an algorithm so again if you just use this automation tool design automation tool so the specific isn't driven optimization easier so that is another advantage so this is why we mean most all the India industry or the semiconductor is rely on this all synthesis tools I mean provided by all these CAD companies so that is the overall objective so in today we what we are going to talk about is high levels in this is the first step so from that C C++ a high level behavior from C C++ we are going to generate the RTL and how so what we are going to do today instead of discussing all the sub steps algorithm behind that and what is the logic going on behind and complexities of this algorithm we are not going to detail of that thing that if you just ask I mean as a layman if I ask you to write and ask you how you can convert a bubble sort algorithm to to a RTL design how you can do that what will be our steps or not is the common way to do that things right what are the steps we should follow that we are going to discuss today and in next class we are going to discuss more on how we can automate those process what are the algorithm going behind that right so that we are going to discuss in the two models plus but today we primarily discuss on how manually or what were the steps that we should follow to convert a serial C code to a RTL design right so as I mentioned high level synthesis is basically I mean converting a high level behavior be written in C C++ to an RTL design so that I see you can see in the left hand side this code is I has a while loop and we have certain kind of operations in that and we are doing in a loop and then we produce some output X Y u and something like this right so this is something a behavior and is kind of see in the right-hand side after Hillel synthesis we'll get a register transfer level design which consists of a data path and a controller so data path will execute these operations in in the hardware right so data paths will is there to execute the suppressants and controller is there to control the of execution operations in that data path so finally our going to generate this kind of circuit from this and we are going to discuss now how we can do this step by step right so high level synthesis consists of several sub steps pre-processing scheduling allocation binding and data ban and controller design right so we are going to discuss all those things now so what is pre-processing so in pre-processing what he does we try to represent that C code in some intermediate from CDFG we calculate the data dependence inside that we do some analysis we apply certain compiler optimization on that to generate some optimized version of the intermediate code through which we can do and then what we do well so that is water is so in this diagram so it starts from a high level C code we do P processing you get a control CDFG control and data flow graph and then what we do we do the scheduling so it's called scheduling is what is that so we have multiple operations there right so we cannot exhibit everything in one clock so we have to assign time step to the operation what we have to decide which operation is going to execute in which time time step that is something scheduling right so that is what we are going to do next and then we try to map those variable to the registers in the hardware and we try to map the adder from function units as our multiplier to the function units of this into the of the hardware so that is called allocation unbinding so after allocation and binding we get to know what are the variable will map to which registers which of the operator is going to map to which function units right and what we have done that we try to generate the data path the data path is what we have as I mentioned the data bot consists of the function units we have registers and the interconnection component like multiplexer demultiplexer and the interconnection between them so we try to generate such kind of data path out of this information so which is only exhibit the suppressants right and then next once we decide about this we have to control the operations the data flow in the data in the controller in the in the data path rate and that will be the control by the controller we will discuss more on those in subsequent in this class and finally we are going to generate this which is consists of a data path and a controller and this controller every signal generates some control signal to the data pack to execute certain operations and after the operation you generate some data Bach gives some status signal to the controller based on that you generally decide the next state okay so this is the overall flow so we will discuss those sub steps with an example so what we are going to take is that second order differential equations equation solve heart which is very common in is very there is widely use Alexanian a CAD courses we'll take this example and we try to see how we can generate an equivalent hardware out of this behavior right if you look into this behavior he says some five inputs X DX UA and why why should be here I mean so Y is also here and we have output is y okay and in there is a while loop in the while loop we are going to execute when we do certain operations until X less than Y and then finally we here we are going to generate output right so this is the overall algorithm and we are going to discuss here how we can generate a hardware that is going to execute this this behavior so now will instead of going into detail of this per step that we just learnt what we are going to discuss what is the immediate person step that we should do right so it will have look into this behavior first thing you will come to your mind is that there is a while loop right and there are big operations right we cannot execute all these things in a single clock then what will happen so if you want to execute the whole operations in a single clock the problem will happen is that you have to execute these three multiplet in a same cycle then these two subtraction there are five operation in a chain so your design will not have a good speed your clock that we're going to achieve through this design will may be hardly some pillars or something right this'll fit and also that there is a low loop around this again then this loop I don't know how many times it'll execute it depends on this x and y value so again I don't know how many times I have to do this whole thing so how do you decide that I have how many clock I have to do these things so this is all these things are not possible to do and aside from this behavior so what I have to do first thing we have to extract the what are the inputs of this behavior so that we already know these are the and you have to read so any other hardware we have to we need to know we have to read these values right through some port Hardware approach so basically in hardware there is the input are coming through some port so that means we have to realize these inputs or the read this inputs through some port so that is what is this these operations right that we we have to read suppose and we the number of port in the in the hardware is limited so you have to decide how many poor we are going to use for this design and safer for these five reads I have decided to reuse three ports say so then I am actually reading DX through port 1x through port to a through port three Y through port one and say Y through port 2 so that is what I have decided that I am going to read this five inputs through these three ports using through this logic right okay and also next is we as I mentioned this operations big operations cannot be executed in one clock then your clock speed will be very less we have to break this operation in small small operation for example I can execute this is a server person this is how a person then will this right so similarly this is have a person then this is another person then we do the whole thing right then we make it so this is already computed and now I'm going to do this subtraction operation right so this is how I'm going to split this big expression into small small part and that is called see a dress code right so what I did the the same example is here so I break these operations I mean the whole whole be a whole while loop operations are here I break them into three address code so what I did I did this 3 into X I store into t1 I do you into DX I sorry this you in two days I stored in t1 I take this 3 into X I store in t2 and then I do this 3 into y here and I store into t3 right so this is what I am doing here and then what I am doing so now this is t1 this is t1 this is t2 I am now I have to do this multiplication so I am doing this here write this T 1 into T 2 t5 so that is effectively this so this is become this t5 is this and then this is basically T 3 I have to normal to be the DX that is what I am doing here t3 into DX so this is become t6 so this is what I am doing here so I'm breaking this big expression into 3 address operation so similarly we just see even if i break this operation I am going to get this 11 of presence out of this why do I have to also execute this X less than X so that is also there so this is what I have done to break this big operations into small small 3 address code so that I can execute these operations in some functionality in the harder and we can achieve greater clock speed right so this is what is that call breaking these operations into big operations into smaller operations then we have to extract as I mentioned this is while loop and there is a basic block inside this I mean we have to I don't know how many times this loop will be executed this body will be executed so I am going to represent the whole behavior in terms of basic blocks okay so I have one basic blocks here which will do this reading operations I have one basic block here that will do this the loop body so basic block is were there is no branching statement they are all are sequential operations and I have also have a bridging basic block here just to output the value of y so I have three basic block and that is what I have shown here that is the input by symbol okay I'm moving all this reading operations this is the basic block I am doing this body loop body and this is that output port this is B to right and this is that value and this is called control and data flow graph so we extract and control and data flow graph from this behavior right which consists of set of basic blocks and their control flow so this is what I have done so we have done two things we break the big expression in the three address code we extract a control or data flow graph out of it right and what next so this is so far we have done in the pre-processing steps now you have to understand that so as I mention here this T one is I get down here and then this T 2 and this T five operation depends on T 1 and T 2 right so I cannot execute these operations on unless and under this and this is over right unless I did these are executed I cannot do this so that means there is a dependence if between these buffers and V fine with v 1 and v 2 right so these can only be executed once this V 1 and V 2 is over right so that is called data dependency so once we are done with this control flow graph extraction and this splitting their operation in the three address code we have to extract we have to find out the data dependency and that among the operations of the behavior right so we if you just try to find the data dependency for this block let's try to do that so this is the same block I copied here and if I just take this right so this is the data dimension from UD X these are the input variable and this is that operation which is a multiplayer so I do multiplication our variable is T 1 and the operation in T 1 so this is that data difference the if we we try to represent this whole Express this text or the body of this of the basic block using graph right quite each input is some variables and the circular nodes are the operator and we try to find out the dependency between this right so that is what I just saw similarly if I just do this for this T 2 so T 2 is 3 and X and multiplication is happening and output is 3 T 2 and the operation is V 2 right so this is I just do it for this and then since this is depends on this so if I just do this this T 5 so T 5 is now depend on this T 1 and T 2 so T 2 is this I just right here so now this since T 1 this operation v 5 depends on our T 1 and T 2 this will come next right so this is how the data dependency dependency is expressed right so this way I can if I just draw the a for each operations I can construct a graph like this so this is called data dependency graph so we have to extract this data dependency from this basic block behavior and what is signifies it signifies the data dependency among the operations so what it signifies I cannot execute B weight unless b7 or v6 both are executed similarly I cannot execute v5 unless V 1 and V 2 is executed and similarly for other operation right so I cannot do this unless this B 4 is executed so this is how it actually give you the idea how the data dependency works and which operation will execute first and then which operation next right so this is what is pre-processing in pre-processing we do some more some more things which I will not covered here is basically the compiler optimizations so once you write a code like this there might be this many are maybe on optimized code right we might have to optimal might have better version of this code which we have not written so then we can apply some certain compiler optimization technique like say loop transformations constant propagation dead code elimination common sub-expression elements and those kind of presence on this behave you have to generate some some C code which is kind of a more optimized version of that so that I am NOT going to discuss today because our intention today is just to see how from a C code and our till can be generated those are kind of at one stopping we can recovered in a very specific lecture okay so so far we have done that so we have extracted this data data dependency graph we can represent the whole behavior as a CDFG each expression are converted into c333 address code so this is this far we have done it so now what is the next step so this part we understand so now we have a intermediate representations which is a basically CDFG for each operation is a three address operations and we also have the data dependence in columns so what is the next step the next step is to decide where I'm going which clock I am going to execute which operation right so that is our next step so what is that for example as I mentioned here so this whole loop body I mean cannot be executed in a single clock because of a lot of multiplications and other operations are there we try to do it in multiple clocks right so now that you have to decide and here we remember we usually do this seed ruling of this each basic block separately so we try to when we are going to decide the number of time step for this B 1 I'm not going to consider this I 1 or when I'm going to decide the time number of time still required for B 2 I am NOT going to consider beyond so these are kind of weak it's an individual block which you can observe we can decide the running run time or the number of times to be required to execute independently but there are certain advanced techniques are clear pathways scheduler which actually take both paths but those are advanced technique we can we are not going to discuss on those in this in this course detail ok so what we are going to consider we go to consider each basic block and try to find out how many time number of clock we require to execute the operation inside this particular basic block right so that is what is the next step because that is what we have done we need to know how many time step is required to execute certain the certain set of operations in hardware right so now for this as I mentioned there are some dependency I mean we cannot execute these unless these are this executed so based on that we can decide key I am going to use four o'clock time step so this is time step one this is time step to this is time step three and this is time step four - executive presence let's have decided that and now we see whether this data dependency is violated by this so here you can see that when I am going to execute all the input all these four operations the inputs are available so I can exhibit them there is no data dependency on the other operations so this can be done in flow there is no detected data dependency by lesson right now if you just think about this set of operations once I am going to execute this this is available this is also available so there is no problem here similarly this depends on input so but so I can do it here itself and this also this t4 is available and we Y is available so I can do this so there is no dependency violation similarly for this and this so this is what say I have decided that I use four cycles for clocks right are for time step right for time step to execute this this 11 operation so in this behavior IJ so there are 11 operations I'm going to use only for cycle to execute all foreign even operations right so this is what I have decided so this is what is called scheduling assigning time step to the operation so I am assigning time step 1 to these operations I am assigning a time step to these operations I am asking in time step two through these operations and time step 4 to this this 2 over this these two operations right so this is what is called scheduling and this is our immediate next step because once we have a behavior its untimed there is no time assigned this there is no information care how many time how many clock cycles required to execute that that we have to decide first K how many how many clock cycle I am going to use here to execute that particular set of operations so that is what is called scheduling right so this is done so what is the next step so so this is the schedule information and now we have to think about of the hardware so we have done with that key how many clock cycle is required or how many times step is required that is already done and now we have to decide yeah how many register we are going to use or say how many function you need I'm going to use in the hardware right so the obvious immediate solution is that I can store each variable in each register right that is that that we can do similarly I can use this separate from send unit for each operator that is the ORS possible case rate but the number of operator is huge and they are not very used right so that is not the purpose of hardware I didn't hardware I will try to use each operator each operator in I mean that will use them as much as possible so so our objective would be tried to use minimum number of register to store all the variables of the behavior similarly try to use minimum number of functional units to execute all the operations of the behavior right so each substrate has some sub optimization world for example in pre-processing we try to generate some try to generate some data dependency over the length of the dependency graph is less right so that is goal and because of for that we use several compiler optimization technique to reduce that in scheduling what is the objective the objective is try to generate some try to try to schedule all the persons in minimum number of time step the objective is try to reduce the number of time step as much as possible we might have some other goals that you are going to discuss later but primarily tied you execute all the operations in mean as much as less as possible right and then we go to this register allocation binding and functional external binding how you try to use minimum number of register to store or the values of the baby we try to use minimum number of function you need to execute all the operations of the behavior right now the question is how we can that manually late so intuitively how we can do that so let's see this example so in this example we had we have seen this is we use for time step to execute we use for time step to execute this behavior for time step and now which I do the objective is here try to see some register to store multiple variables so how many variables are here we have this all these input variables and we have also this in temporary variable because we have introduced so many temporary variables this t1 t2 t3 and this so you have total let's see so 15 15 variables are there so there are 15 variables in this behavior in this particular code and then so what we have just to recap this so we already have done we just do the best proceed ruling for this a symbol of 1 right similarly we can do the rescheduling for other block also right this vegetable of I and b2 but since they are kind of a same so I am just going to discuss only basic block 1 so other is just it's just the same thing we can do in the other block as well right so now we have 15 variables are objecting to use minimum number of register could store these variables and the question is how now if we just look into this behavior this schedule information the t1 is generated here right at the end of some step 1 and it's going to use here after this it is not going to use in s3 on export right there is no use of t1 in s3 and s4 so there is no need to store t1 in for the time step T 3 and s 4 right so we can actually use the register that is stored t1 to store something else because t1 has only required in the further time step to where it is going to use here at that time it is not required right so that is the overall idea if some variable is not used in Somerton time so you can delete the value in the harder if the register is not stored that value is not available anywhere so if it is not required it's not required to store as alright so we can do that so that is the idea so we try to find out the lifetime of each variable and that is represented in a graph called interval graph so as I mentioned 41 it is just defined at the end of s1 and it will be available from s2 right so the lifetime of t1 is only in is 2 it is only using time step on after that it is never used so there is this life it's basically it is not live variable X it is I can replace the value with something else similarly for t2 also the lifetime is s2 but t3 t3 is also defined here so it is for s3 it is in time save s3 this is t3 and t4 is defined here so life time is here and for t5 v is defined here so this is for s3 right so t3 v is defined in s3 and 47 and t6 they are defined at the end up stand of 3 so they are only alive here right so they are 87 6 6 and t7 here and for other variables like this input variable they are actually the since this is a loop and they are going to redefine there or there actually has to rely for whole time step because they are defining somewhere and they are going to reuse right so their lifetime is for the whole four time step so this way I find out the lifetime all our variables right now what we can do if so lifetime means forward I have the use of the particular variable and I have to store that data for that time at least other places I may or may not but that is there this mask to store the value right so we try to use we try to use registers such a way that if there are two variables which lifetime is non-overlapping I can store them in a single registers for example here t1 lifetime here t3 lifetime is this they are non-overlapping and t6 right so there lifetime here so they are this T 1 T 3 and T 6 they have a non-overlapping lifetime I am going to club them into a single registers and that is not violet any problem and they are not going to problem in the hardware because they whenever their data is used that time that data is stored in the particular register so that is what is called registered sharing so I am going to share a single register to store this 3 variable similarly I can do this / R 2 R 5 T sorry T 2 T 5 and T 7 in a register r2 so other than there is no other facility because they all are overlapping on a so there they need a dedicated register all this very well integrated register so that is what I have done here so I need effectively 11 register here right so I need 11 register here for 15 variables so I have some saving for four straps here so so if you can think of this is small example but if you have big examples there are 100 of thousands of variables then maybe there is just saying maybe much more so that is our next goal that I try to map those register because finally I have to execute everything in the hardware and there is no variable they are only have the registers so you have to map those variables into these registers now if you think about the adding actual design those has to be map into memory RAM or ROM in the design so that is also another way of doing this so your class think of the size of the array and then you have to decide which particular is going to map into which Ram or whether is consuming a program or not that is we also decide by the use pattern if it is only read only mere array then it can we have two ROM that if it is read and write both are happening then is going to map into Ram so that is also similar way but I'm as far as our example concern I have only registers I mean I have only variables so I can map them to registers of the harder so this is also done so this is the step call register allocation and binding so the next step is similarly the function you need to a functional unit allocation and binding and here in hardware you have to remember that the unit that is do multiply that is dedicated for multiplication operations right similarly the operation that is going to do Edison that is dedicated for addition maybe addition and subtraction can be done by the same operator but multiply addition can be separate from same unit so here I mean rise is registered is a unique unique type of thing so all variables use map register but here multiplier you want to map to the function unit it's multiplayer functional and the addition is going to map into the human function unit which is type of adder right so we have to do this mapping for each type of operator so what I have done here is an example for our running example how to do it for multi plan right so again the concept is little bit same the way we do the register allocation binding so so if two operations are running in the same time step right for example these two multi-meter so I am going to do only for multiplier other operations are not there so these two are in the same clock so same multiplier cannot be used for them right I have to use different multiplier for these two multiplier or I would say the three multiplier here so these three cannot be done in us using same multiplier so I need at least three multiplier to execute these three so I'm again I'm going to represent their span or the youthspan for each variable in a interval diagram in interval graph where I have this time step s 1 s 2 s 3 and s 4 I am going to write a bar in particular time step at this particular way operations is executed for example V 1 executed here so I put a 1 here I mean this bar here for V 1 V 2 is also exhibited in time step one so I put B 2 for B 2 and then I put this for three four bar enos one so these are the things in running of a time step one time step two I have two multiplication operation V 5 and V 3 this is V 3 this is V 3 and this is V 5 and in time step 3 I have one multiplication which is v 6 so this is V 6 and in time step what there is no multiplication so this is the interval graph for the you are from the usage of the multiplier this now again the same concept if that usage is overlapping I cannot use a single multiplier to do that do this particular multiple operations in the same time so we need different multiply but if they are used in different time step I can use the same multiplier right for example here I can use the same multiplier to do this this this - even I can do this but for some reason i also decided this i am going to do V 1 and V 5 in multiplayer 1 this is for multiplier 1 I'm going to do this V 1 and V 5 similarly I am going to do this V 2 and V 3 in multiplier 2 and 4 in multiplier 3 I am going to use this v4 and v6 right again as I mentioned for this since there are 3 multiplier in parallel I need at least 3 multiplied but this mapping can be different I can I could have done V 1 and V 6 together even in fact in fact I can do V 1 V 3 and V 6 also in the same multiplier but I just decide one of them right so these are all possibilities but you can choose one of them so I have decided this so this is called from Senate and of course I'm finding for multiplier similarly I can do the same thing for adder and I have assumed that addition and subtraction is done by a single function unit called adder and you can see there are four adders here this is 1 this is 1 this is 1 sub structure these are all adder or subtractor type so there are 4 but they are all in different different clock step right in time step so these are all in so this is B 10 this is p9 this is v7 and this is v8 so I have done this in different different clock step since they are known about let me again use a single adder or subtractor to exude all these four operations so I need only one substructure are added to execute this all for additional substructure none person in the of the behavior in the harder so at the end what I have received so I you I got 3 multiplayer one adder and similarly for comparator I need one because I have one comparator operator and this sickle of personality a comparator so I got one comparator so I need three multiplier 1 adder 3 multiplayer one adder and one comparator total 5 to execute all this 11 of present states 11 operations are there and I have 5 function so that is what we got from this sharing information so this is what we have done so far so you understand the concept so we first decide the time step I am going to do a which are present based on that see dueling information or that assigning time step operation information we decide how can see are some register to store multiple variables that is courageously adding a person and then we again decide how to do multiple operation using a same function unit and that is what is called function unit and like us and unbinding and after that what we receive is this so we have the register mapping information I have the information and in s1 I I have done this for this for opportunity so if you just see here I have done this B 1 B 2 B 4 and feature in s 2 I have done V 5 V 3 and V 9 similarly in s 3 I've done this three operation in s for this so I just do it for two time step I can do for s 3 and s 4 s this is s 3 and s 4 as well but so I have 4 operations here and in s 3 I have 3 operation s 3 s 2 I have 3 operation in s 3 also I have 3 operation in s / I have one operation right so and now I have this resistor mapping information I have this pounce on unit mapping information and now I can actually represent this high-level behavior using register transfer level behavior what is that so for example in time step one or s1 I have a person via t1 equal to u DX but u U is nothing but hardware U is nothing but our five right so I can replace this you by our five similar T 1 is nothing but in hardware is R 1 so I can replace this T 1 by R 1 right similarly this multiplier is nothing but M 1 because V 1 is happening here so I can replace this x in one multiplier 1 right and this similarly d 6 is nothing but R 7 so I replace this DX by our seventh so now these operations T 1 equal to u star DX is nothing but in hardware some register transfer level operations between R 5 and our 7 so I am reading our register 5 I am reading register 7 and I am doing a multiplications and that result is stored in register R 1 so this is what is a nerd register transfer level design operations in the hardware similarly I can do this V 2 I can replace this this variable with their corresponding register num name and this operator is the corresponding multiplayer and get the suppressants similarly for B 4 I will get this for reach and I am going to get this for s2 also these operations I am going to get this for is 3 also I am going to similar kind of thing and for this for also times J 4 also I get a operations like this so then you can understand the basic block I have 11 operations first I partition them into four times stiff and then I find the register informations based on having information I found the function in your mapping informations and then I can actually represent that high level behavior is using the register transfer level behavior so I have now I don't have I do not have any variable I do not have any operator I have only registers and the operations right so this is called a register transfer level behavior so now I actually map those high level VBR at least one basic block into is equivalent resistor transfer right so this is clear right so now what is the next step the next step is very natural is I have to generate the data part because I just make here these are the operations I am going to execute these are the operations I am going to execute in the harder but I have to make the connections because here I just make this essence but in hardware what is going to happen this has to be make the connection proper connection here so that this operation can happen right so if you just think about I have this this is say R 5 this is say R 7 and say this is the multiplier so I make I have to make this connection to this is R 1 then only this will happen in the hardware right so this is this kind of connections I have to make and I have to make this connection because I am reusing this multiplier this may not be a direct connection I have to make a madam MUX here so because multiple input might come here right because I am sharing similarly here also this might go to multiple places so that is called the data path generations and the objective is to minimize this interconnection cost use minimum number of multiplexer demultiplexer just to make the connections right so that is the objective of this data path generation and that is our next step data path synthesis so what I am going to do here I am going to do it for 1 2 operations in the developer connections and then you will understand the how how the things works right so as you have decide I have 11 registers so this is my final Hardware is I am going to generate so I have 11 registers here I have 11 registers here I have 3 multipliers by a multiplier 1 multiplier to multiple 3 I want adder I have on comparative so this is what is the components that is already decided here now I have to make the connection for these operations right so let me do it for these operation first so I have a connection to multiplier from our 5 so from our five to multiply 1 I make this connection right so this connection is made and then this is the right arises operand for this multiplier so from our 7 I make this connection right and the result is stored into r1 so this going to our own LC this is going to our own so just to do these operations I make this connection similarly if I just do it for our two for this v2 operation B 2 and I have to make the connection of about 10 to m2 at 10 2 m2 and then our 6 to this multiplier to our 6 2 multiplier - I'll make this connection and the result you're going to story not to so this is going right so this is done similarly I have to make the connection for this R 3 so 4 V 5 so from our 5 to this r5 to this our 7 to this and the result didn't to our 3 you can understand this girl brought 3 similarly for this XOR 6 for this adder this coming from our 6 and our 7 and output is going to r4 you can so this is going to r4 right you understand this so for the time step one I make the connections there is no problem right now if you just go into this time step 2 what will happen let us again want to consider this so now this is already done and for that this is the connection I already citrate now if you just think about this operation so now the input of multiplier 1 is coming from our 1 right but earlier it is coming from our 5 so now I need a multiplexer just to decide between our 5 and our 1 right so this is what I have done here so in the previous diagram I have only direct connection from r5 to this but once I consider this connection now I have 2 more option or 5 or r1 so I have to use a multiplexer and I need a control signal here just to decide between our 5 and R 1 so 0 means are fine 1 means this r1 right so this is what I have to add this multiplexer similarly for the right and right hand reaches this right operator I have earlier our 7 now I have our - so I need again a multiplexer that will choose between our 7 and r2 so I need this multiplexer and this contraceptive 0 means this r7 0 means this one is this right the store result is going to art too but in earliest times there are two data is coming from mmm - now it's coming from a one so I need him for at the input of art - I need a multiplexer that will dis cheese between this art - sorry this M 1 and M 2 because I in first kind of this art - input is coming from em 2 multiplied - now it is coming from multiplier 1 so I need a multiplier here 1 that is choose the input from either from multiplier 1 or multiply - at the input of our - clear similarly if I just consider this one I have to again duck up problem income for em - I have to add this multiplexer here but you can see here there is interesting thing that V 2 stories are 10 right now also it is coming from Orton so I don't need a multiply this you know both the cycle this is data is coming directly I don't have to use a multiplier here so that is kind of saving because if we just add a multiplexer is is useless in first clock is going to use select at 10 second clock also is going to select actin so effectively that multiplexer is easier done so I am NOT going to use it right but for the right-hand side earlier is living from r6 now arriving from alright so I have this is r6 and this is our rate I need a multiplexer here and the control signal 0 means this r6 1 mins are 8 and 4 multiplier 3 there is no multiplier 3 here and for add-on now it is coming from r8 and r3 so I have to make admin diplexer similarly and the result in storing into r8 so there is a different way now so then this is no multiplexer is repaired because it's subletting a new register no so for these two time step I make the connection so if I just add for s3 and s4 this way the final diagram will get this right so I can see that the multiplex are the input of this multiplier 1 I have only two inputs and these are sending two inputs this needs two inputs but for the adder when there are the four inputs possible input and there are two bits as control signal is required 0 0 0 1 1 0 1 1 0 0 means it select this 0 1 means did you say the second 1 1 0 misra second third 1 and if it is 1 1 then it is the fourth one right and so on similarly here also I needed two bits the control signal to select between this and I have added multiplexer only for two days two other is is the multiplexer is not required because it's only one data is coming to this so this is the overall data path that is going to generate it from this information straight from this informations from this register transfer operations this is the data path is required right so this is the final data path that is generated out of this information right so data path is ready I have 11 registers 3 multiplier 1 adder one corner comparator I have 1 2 3 4 5 6 7 multiplexers and the interconnections so this is the data path that is generated so we are almost at the end of this dustman so only left its control signal and controller generation so what is what is the need of controller and what is that that you should understand right as I mentioned here this multiplexer is not known it has to be controlled right the data flow from the input to the output of ultima has to be controlled by these control signals and that has to be generated and for defend control step or the time step the operation that are going to exhibit in this in this the selection that is going to happen here is different right so how many control signals are required here I need control signal for fu for this are all multiplied I don't need but here I need one because it is going to do add or sub right so zero means add one means some or other I said this is one means add and zero means subscription so I need a control signal to tell this adder this function you need to do perform and perform either addition or subtraction right so that will be decided by this so I need one bit for the function unit for our other I don't need and then I need the control signal for a few marks in the multiplexer that are the input of the F use function units rate how many bits are there one bit for this one wait for this one wait for this to wait for these two bit for this so for 2 - 4 + 3 7 so I need 7 bits of control signal to control the data flow through these multiplexers right and then how many register ok the next important thing is that this register enable so so this registers unless you control the right - this is going to write in every clock and that is so that is the god based data will be written so we have to control the writing on the registers and we need the right and I will signal right so once the right hand ml signals is there then only that register be updated otherwise you hold the old value and that is very important otherwise what will happen even if you are not doing any or presence if you do not control the control the writing on that registers what is happen it will just store some guys do you update you there's some garbage value and you have no clue what is happening there so that is very important so you need raise to a neural signal right enable signal for our registers and I have 11 registers so I need 11 bits for that okay and I have 2 marks here and 2 bits so I need 2 bits register marks in two bits right so this is what the the number of control signals required so total number of control signal is required is 1 7 8 plus 11 plus 2 is total 21 which say 21 bits control signal is required and that is order is this right and I use the color coding to decide that and now we have to decide in time step 1 what will be the control signal right or the control and pattern for time step one so as I am doing addition in the time step one right I am doing a decent I the function unit I decide one right and the next seven bits represent the max input right as I told you that zero means it will select this zero means like this so I am going to give 0 here 0 here to perform these operations this and then I have to give 0 here to select this and to perform this operation these are present because I am now in time step I want to do execute this operation not this operation right so based on that I am giving this 0 here also I have to give 0 0 and 0 0 to select the first one that's that so the control signal to the multiplexer is all zeros and then I am writing for register r1 r2 r3 and r4 in the time step one so this right and I will signal will be 0 so these are the next signals at the right hand side so this all the 11 bits are right in ml this is r1 this is r2 this is r3 this r4 so this is the right animal signal for these are registers and all other register will not be updated so they will be 0 right and then I need here multi has signal for this rate so now here I am updating register one from multiplexer 1 so this is 0 and I am updating from multiplexer to the message multiplier 2 so this is 1 right so this is 1 so this is 0 1 for this so this is 0 because it is updating from multiplier 1 this is updating from multiplied to so this is 0 and this is 1 right so this is the control signal so you understand this is the first clock controller will generate this signals to this data path control right so that it is effectively execute this only these four operators are nothing else so that is what is going to happen similarly let us discuss that is 2 so again I am going to do Edison so I need 1 here and the rest this 7 bits are for the multiplexers and now I am going to choose the second input so I need 1 here I need 1 here and I need one here I need 0 1 here because I am going to select the second one 0 on here so the counter pattern is this 1 1 1 4 this 3 3 multiplexer and this 0 1 here 0 in here so this is the control signal for the multiplexer I am updating r1 r2 are arranged so this is r1 this is r2 and this is rh arrests are zero so this is that right enable signal for the registers and i am updating here r2 and r1 so I need 1 & 0 so this is the control assertion pattern that has to be generated for the control step 2 so similarly I can generate the control signal for s 3 and s put when you understand that right so this is I am done so what I am getting here so this is the final data path so the final RTL so I am done with everything so I have generated describe the data path this is my final data path this is my final data path I have the controller FSM which is nothing but this how I am going to get this so I have just talked about this for time step and this is nothing but B 1 so I just replace the B 1 here by these time steps and similarly I am going to schedule this I 1 and for the example that took it you need two clocks you know time step so you need two steps similarly for B - I have only one operation so I am going to replace that by that particular time step right so this is say is 5 and this is IU 1 and I 0 okay so so this is my controller efficient and in what it does in controller every time step it generate the controller assassin pattern right so I just talked about the control assassin button of s 1 and s 2 so that for s 1 this is the control signal I just dropped out so what s 1 also have someone to assassin pattern yes 3 also have someone rehearsal but an S for also someone resistant button here also someone will assassin button here also and here also that such that is going to execute on is that may read that because in this upper block I am doing this reading from portrait so that will execute the reader presence from ports here this is for the basic block b1 the person that were discussed right so finally we we got this whole ordeal right which is consist of this and this I mean this is the part of only this we have some are certain other data path for this and certain data for this so this is the overall structure and what is the status so I am doing this comparator this will go to really fit into this controller so that I am going to decide whether I have to from this state I have to go this or this so this is decided by the status signal so this you understand this is the final RTL that you generate which is going to execute that differential equation solver right that I have shown in the earlier the start of the presentation so that is the C code and this is the equivalent RTL and what we have discussed here is basically how we can generate harder out of this what is the intuitive next step next step next step to generate our are out of it I do not discuss any automation or the algorithm so far I just so this is the logical way to generate and harder order a register transfer level design out of it sequel or a high-level behavior right so now when I do not talk about other aspect I'll just briefly give you some idea for example I decide about this scheduling rate and it has also for time step but if I just think about another person where I just do because these operations here depends on input I could have done it here also right so if I just do it this is another schedule right you understand this set so now this also depends on only input so I can put this two here so I just put it here t3 so I can do this five operations in time step one that still I need for proper number of time step but here I need for multiplayer at least for multiplayer right I need for multiplayer here I need three already discussed so this is better that because I need only 3 multiplayer the same time I am going to executing this in 4 time step I need 3 multiplayer I need follow I always take this it so there is a difference the possible there other possibilities are there I choose this for some reason similarly you can do one more things here so since this I need 4 times step after that this this part idle right I can move this to this time step and this to this time so then also this is fine there is no problem right so this is that schedule so the advantage here is that still I have 4 time step I am executing the whole thing in 4 time step but the advantage is now see I have to maximum parallel multiplayer there to multiple parallel to multiplayer here so I need maximum two multipliers three multiple instead of three multi-vise so this is better instead of this so what I am trying to emphasis here is that diggings scheduling there are multiple options and you never know which one is better I just saw three possibilities one is generating for multiplayer one is generating 3 multiplayer one is generating to multiply but all are using for time step so that is what I call the design phase expression and based on your objective or based on your target you might choose this one or you might choose this one or you might use the other one so that is something is the choice or the design of expression or the design targets so see dueling technique is something is how to automate this whole thing and check which is the best one right so that is what is called scheduling and we are going to discuss all these techniques in the next class so there are different kind of scheduling ASAP LFE or resource constraint time constraint so we are going to discuss those algorithms and how you can automate that process in next class so that is what is that there so initially what I is just so I just give you some schedule without thinking how we have done that but now I have to automate that process rate and during autumn I said I can add it can be unconstrained it can be resource constant it can be times constant and it can have various kind of algorithm some of them are basically exact solution some of them are heuristic these are all heuristic this is exact so we have different operation options right and we are going to discuss various scheduling techniques in tomorrow's class ok similarly we just go into this register allocation and consignee representing we have various possibility I saw you in that particular example here that instead of this mapping I just show you here that instead of this mapping I can a different meeting mapping also right I could have do this this and this in one multiplayer right so I can do V 1 V 5 and V 6 here also right so we cannot have the other options which in is better I know I don't know right so maybe if you do this the interconnection cost you list we I have to use less number of multiplexers or if you do this this may be the best option so there are multiple options even using the same number of multiplayer if I told you key you can use for multiplayer and still you can do that you can use six multiplayer and you can do all the operations differently that is also you can do that but which one going to have the really less number of resource and the interconnections interconnection also depend on this kind of mapping similarly register transfer also there are this mapping or can be different sort ey instead of T 1 to 36 I could have stored T 1 T 5 and T 7 that also I could have done instead of this I can store T 1 T 5 and T 7 that will come I could have done so there are other possibilities are there my point here is just to emphasis that point that the choice is not unique you can have multiple choice and you never know and all are interdependent that if you do one kind of scheduling the kind of register seeing ever going to generate is different or if you do kind of register seeing or function units sharing the kind of interconnections that organ is generated be different so we are going to talk about those techniques I mean and how these things are interrelated this more detail in tomorrow's class so in too much class we are going to discuss more on this various scheduling techniques how we can automate this a few allocation and binding techniques when the steps and how this data path is depend on all these steps that we are going to discuss in the next class in more detail thank you [Music] you [Music] 