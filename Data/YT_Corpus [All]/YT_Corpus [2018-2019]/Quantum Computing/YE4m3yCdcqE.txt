 all right hey good afternoon so how many of you guys came to the breakout session the last time last session okay so this stuff is new for the rest of you yeah cool so let me let me give you a little bit of an overview then I will dive into a little bit of it Visual Studio sort of session and then show you how to get started with Visual Studio code as well and then those of you on Mac will actually be able to get this thing running there's a whole bunch of documentation material out there that you can follow so I'll point you to some of it we only have 20 minutes so I'll take questions at the end if that's okay all right cool so the quantum development kit how many people done anything with quantum computing so far right handful of people no heckling okay so the quantum computers that we're talking about for the quantum development kit is actually simulated that runs on your local machine okay there's a cloud-based simulator don't worry about it just worry about the one on your machine you get that for free when you download the quantum development kit the way you program against the quantum simulator is actually quite interesting it's not like programming against a normal set of libraries it's really an adjunct coprocessor so you think of the quantum simulator itself as a coprocessor and you issue instructions to it and the instructions that you issue are actually in the form of a cue shop program so if you want to think about the big picture basically you have a quantum computer in this case when we get the real device you'll have a quantum computer some cryogenic control and then you have applications in software in the case of the simulator what we have is just applications and software and the simulator underneath right so logically speaking you write your program in the light white dot square so you write your host program in whichever language you want C sharp is a fine choice so as F sharp right or even Python then you could write the stuff that you want to be actually executed in terms of a quantum context you write that in Cuccia and you make use of the algorithm the libraries that are available and I'll show you how you can get access to those as well and then against the classical runtime you can actually run it against the local simulator exactly as I mentioned to you now how many people have actually downloaded the qdk so far and how many people actually figured out how to read Gousha ok so cool um any questions on why we actually created a new language does anyone want to know cool all right so basically when you want to program a coprocessor even a traditional like graphics coprocessors or something like that the traditional approach is to have a host language and just slap on a bunch of libraries which will make calls to the coprocessor right so when you want to do something complicated that the co process is capable of doing you'll end up having to write the sequence that's effectively a bunch of library calls that will get intercepted and then shipped off to the coprocessor to run the problem of quantum computing is that it's a domain in itself and the domain is actually fairly complex one and if you want to write programs in that domain you have it's good to have a type system for that domain and what you don't want is you don't want the type systems of the host language and the domain to actually conflict with each other similarly we have the ability to reason about the program that you want to send off across so rather than intercept a bunch of library calls and then try to figure out what's going on we are able to look at the whole program and the whole program optimization so we can figure what it is you're trying to actually run on the corner of computer and actually rewrite the program appropriately and optimize it out so that you can actually do a good job and to be able to do that properly you really need a different language so the idea that you can reason over the program that you want to write basically means that the the compiler is Allah you know gets into the mix and is able to do the the optimization for you and so this is why we picked a new language so to develop a new language that allows you to to express only quantum computations and express them correctly in its own domain so the syntax that is quite fairly familiar it means basically C C style sort of brace based syntax but it's functionally inspired so there's a lot of stuff in here then that you'll get quite naturally if you like program language like F sharp for example like immutability the ability for not able not being able to mutate state for example is something that we turn out to be quite useful so I will dive into the demo at the moment and we'll get an idea of what what it is that we're doing so let me see yeah now can everybody see the code although I want to zoom in further okay all right now actually speaking people who came to the talk before well you see we will have seen this before you have the the host programs actually written in c-sharp in this case and what we're going to do is create a handle to a new quantum simulator and this is in fact how you get a handle to the simulator object and once you get the handle to the simulator object you can then pass it to an operation which you define in your quantum code you pass it the simulator and you pass in whatever arguments you want and the simulator will actually be used to run that quantum operation on it now cue shop has a whole bunch of constructs so we have the ability for you to define functions which are pure functions from a functional perspective so functions that have no side effects functions that cannot call quantum operations for example so things that have no side effects and a pure you can you can define those and then you have operations which are effectively sequences of side-effect full functions that change the quantum state of something and so in this particular case I have created an operation called teleport classical flag in cue sha and I've given it a body and the body of the function is when I step through it will actually show that it will take the state of one qubit and transport it to another qubit and because of the laws of quantum computing where you can't clone an arbitrary state teleporting turns out to be somewhat useful so I'm just going to take you through what what it does here and I'm not going to walk through the physics of what's actually going on but the idea is that this is a development environment that you can get behind and you can put breakpoints in your cue shop code for example and notice that the value true was passed in from the program let me see so the flag here is actually true and I can continue and I expect to come back with flag being false because in the program the first instruction was sent true and then sent false so I then if I just run this code I am able to see the output name eCos shut up all in different screen so it it shows that this thing runs now why is this why is this even interesting I wouldn't write code like this classically because if you think about what's going on over here I've just created like comment blocks and saying this is what we want to do but clearly if you want it write it in a proper software engineering way you would break it out into constituent functions and be able to modularize the thing and being able to do interesting things with it so to refactor this code let's say we dive in to this thing we're still going to send we're still going to send true and false let me just close all these windows for a minute but I want to rewrite the teleportation demo in such a way so as to teleport an arbitrary state we thank and so sorry I'm still going to tell about true and false but the first thing I'm going to do is I'm going to break out one of the pieces of the code and create its own operation so to entangle to qubits together it turns out to be quite a useful operation and then you can introduce this concept of being able to say here is how you create the inverse of the operation and this is kind of why having a language is useful because if I didn't have this to create the inverse of that sequence of operations I would have had to manually keep track and write that inverse myself and now you have a software engineering problem of having to maintain those two pieces but because we have a compiler that you can actually do the symbolic computation of it every time we want to get the adjoint of the prepared entangled pair operation the compiler can actually go to the body and say hey what is your sequence and then compute the automatic adjoint sequence for you and this kind of thing is is really the the power behind the the language the ability for you to do the symbolic computation inside the compiler itself similarly I've actually split this out into the piece that prepares the state and the piece that actually does the teleportation so now you see that the teleport message just it takes two qubits the source the message qubit in the target and then entangles the message with with a given qubit and sends it across to the other side so by just using splendid software engineering techniques we can actually create multiple methods and we're able to say ok now I want to tell about a classical flag what if I don't want to teleport a classical flag what if I want to provide my own unitary matrix that prepares the state for me so in this particular case the only way to prepare the state of the qubit is in one state or the orit's you know the zero state of the one state so I can now use the same approach and create an arbitrary state but to provide an arbitrary state preparation I need to provide a unitary matrix and a unitary matrix is something that has an adjoint so how do I pass in a first order function that takes something that that affects a cubed and specify that it should have an adjoint and this is kind of where the type system comes in where when we say that the unitary that you pass in should have an adjoint the language allows you to specify that and now you're able to actually create an arbitrary state preparation and then call the adjoint of it over there and by doing so you can have prove that you've teleported the the message across right so this should give you a sense of the kind of power behind the language the ability to do standard things like encapsulation and so on but also the type system that supports the ability for you to do higher-order functions now I'm passing in in this particular case I'm passing in an arbitrary unitary matrix in this case I'm passing in the Hadamard gate and saying prepare my zero state in the Hadamard with that with the Hadamard gate and teleport that so if I now run this a thousand times right I expect to get about 500 times the state being prepared in the true state and then the state being prepared the fall state and because that's what the Hadamard gate will do if I had a much more complicated unitary matrix I could pass that in as well and so you can see this sort of functional influence where you have a first order function being passed in as an argument to a function and then being sent across I'm going to skip this one because this one actually talks about partial application and you can actually use the prepare entangled pair as the as the thing that you pass in for the state preparation because we only have another five minutes so I'm gonna step away from this at the moment and show you that this whole thing actually works in Visual Studio code as well so let me bring up Visual Studio code and you can see that it works in dotnet core and we can run the same kind of thing where we were talking about before where we build a bell pair and run it many times and so on and so forth again the driver uses the same content simulator and you can create your your code in in cue shop and run it in Visual Studio code itself so this approach basically allows this surrounding dotnet core so you can run it on UNIX you can run it on on on the Mac and you can run it on Windows as well so what else do I want to show you now let me show you the libraries let me fire up so if you go to microsoft.com slash quantum you can actually sign up for the kit and you can download the you can get started with the quantum development kit and this will have links for the Mac lab links for limits and will have line links for Windows and there's a whole bunch of instructions here about how to get started and so on there's a reference for the Keisha programming language and this is a dog store might have come slash quantum and there's obviously the libraries themselves have fully documented out you can also go to github and see the Microsoft comm quantum libraries the this contains all of the algorithms that we ship with the quantum development kit so you can start by writing code just the way I showed you or you can actually use the libraries that are there to build more complex algorithms so the phase estimation an amplitude amplification quantum Fourier transform all the building blocks that you'll need for building real applications or going through a course and writing up all the homework for it for example you can use the libraries to actually build stuff with and I'll switch back to the PowerPoint and leave some links with you and then I'll take some questions so I'm I think I'm done for this piece in terms of time happy to take any questions you have I'm taking question so so the question was how do you debug quantum code so that's a really interesting question it was a real quantum device you can't actually go in and take a look at the state of things so with the simulator you can actually if you want to and it depends on the simulator so certain simulators will give you full access to the waveform some simulator will give you full access to all the information in there but generally speaking the way in which you write code uses assert and uses like like properties of them the mathematics in order for you to figure out whether you're on the right track or not traditional debugging techniques of limited value because all the computations that you do are actually probably stick so you may not get the right the same answer every time and that might actually be perfectly okay so you typically land up running the program doing kind of printing your way out but typically what you'll end up doing is you'll run through the program multiple times collect the answers and then kind of classify the results that you have to figure out whether you have the right answer or not so the question is is there something that helps you converge oh so the language has certain constructs that allow you to specify bounded iteration so you can say repeat until success and if you know up until some condition happens and there's a construct that allows you to do that in the language but what that condition is is up to you and also if you don't actually hit that condition you'll you'll notice that there will be a failure and then you'll have to work out what's going on all right thank you 