 hello this Jonathan Burnside here today to talk with you about search graphs computer programming we're often faced with the option of trading memory for speed we can maybe precompute some data store that in memory which does cost us a little storage space but that will represent results of her algorithms we don't have to figure out at runtime now till speed up our code search graphs are one of these pre computed cases where we can trade memory for speed search graph is just a way to represent the navigatable space or the search space of our region in our game world simulation whatever we're up to in a tile-based system it's fairly easy to figure out what the sort of navigatable locations for your agent are they are all the tiles and it's also really easy to figure out the connections if I'm at some given tile as it can find what other tiles are directly connected what my set of neighbors are usually top left right bottom around the given tile in non tile-based systems is going to be a lot harder to figure out how many do I know if I'm at some given location in my 3d world what are the other locations I can navigate directly to well it's harder to figure this out it's not completely impossible we could do things like raycast to try to figure out where we could move to but that'd be very costly and and not always give us perfect results anyways so search graphs are really just pre computing these results and there's two really common types of search graphs we have waypoint graphs and navigation meshes the results of these are fairly similar and we use a lot of the same vocabulary between them specifically vertices and edges I mean either case vertex represents location that your agent could navigate to where as an edge represents the connections between vertices so at some given vertex will have a set of edges that tell us what other vertices we can travel directly to in waypoint graph we're usually just placing these vertices these navigatable spaces locations on the map by hand putting them where they make sense for a guy's to be able to travel around as well as drawing in or defining the edges that exists between the vertices if we look at the picture to the right you imagine if we see a vertex number two kind of in the middle if we imagine we wanted to move to vertex number four in front of the pink piano oh we can see that there's not an edge between them we can't walk straight between them probably because there's a wall or something in the way so we didn't have an edge there instead we can move from two to three because there is an edge connecting them and then from three to four to get to our final location Waypoint graphs will typically return that sort of line based path what are the set of points or vertices we have to travel between to get to our goal navigation meshes again work very similar and I'm going to have vertices and edges but what a vertex and edges are defined by will be a little different in a navigation mesh we're not usually placing these waypoints by hand instead we actually have a mesh of polygons we might even as a sort of naive first step approach we might use the same mesh for a navigation mesh that we would use for rendering such as maybe the terrain or the floor of the building that we want nai to be able to move around we might actually just use the same mesh for our navigation as for rendering in some cases we usually need something a little better than that but it's good starting points in a navigation mesh each polygon represents a vertex a location your agents can navigate to or is the shared edges between polygons represents the connections what are your neighbors so if two polygons on our navigation mesh share an edge then their neighbors and we can move from one polygon to another a navigation mesh can be made to return a line based paths or a point a point thing very similar to the Waypoint graph if we treat all of the polygons maybe their Center points as the vertices we could definitely get the set of these that we need to travel along in most cases specifically with a navigation mesh we're going to use a different algorithm to give us a sort of polygon channel I said water but which really means just sort of a smoother path instead of these sort of straight lines that we want to walk between all these given vertices there's sort of four really commonly used navigation mesh path smoothing algorithms splines funneling midpoints visible point tightening if any of these are of interest to you there's links here to find out a lot more about them for my research at least in game dev funneling tends to be them one of the more commonly used techniques the technique name does get its name from the shape of an actual funnel or we have a wide opening at the top that gradually gets smaller on the opposite and sort of triangle shaped and where we see this in the algorithm if we think about two neighboring polygons they have some edge between them the edge represents the wide part of the funnel whereas the vertex that were traveling to will represent the small point of the funnel in the funneling algorithm we kind of keep moving that vertex to the next polygon the next polygon the next polygon while keeping the same original top of our funnel that same edge in mind at some point when we move that vertex if we were to draw lines to it from our starting edge the top of our funnel eventually those lines would go outside of our navigatable area and go through a wall or go through actually outside of the navigation mesh whenever that happens that means the previous point we figured out is actually a good point for our search result we can travel directly to that point from their out to though to move the rest of the path we actually have to start again creating a new top of our funnel and funnel around this would happen trying to turn around the corner of like a building making a 90-degree turn that's where we would have one in such cases where we have a new point in the funneling algorithm but there's a link there if you want to read a lot more about that instead of my very simple idea of the explanation so we mentioned Waypoint graphs there's there's not really any sort of robust common solution to sort of automate building these usually just have to put them in by hand define all the edges by hand and your results when using a waypoint graph may be sub-optimal you might have paths that don't look like the shortest path possible between two given points this will be due to the waypoints that you use the past you get out of a waypoint graphic only as good as the Waypoint graph itself so it can give sub off Doyle results navigation mesh we can definitely automate like I said earlier we can even start with maybe using the same mesh as our render mesh we could then possibly just tweak that to get a better results for our navigation mash maybe removing any sort of thin unnecessary polygons that we don't want to travel on but there's definitely much much more robust solutions to building navigation meshes or automatically building navigation measures they don't usually require as much work to create as wavelength graphs that almost have to be done by hand almost completely so one of the problems with any sort of pre computed solution specifically search graphs right now is the weld it is pre computed and means it's static we already have it if something at runtime changes how things work well our pre computed data might not be valid anymore so so for path planning this might be a case where something has changed what a connection would be maybe I had two vertices that were connected but there was actually a doorway between them and now the door is closed and that connection isn't valid anymore so that sort of things can happen and we have to deal with it there's a lot of different ways we can try to fix those cases local avoidance has to do with avoiding objects that are nearby you while you're sort of traveling down the path so you know we might be traveling down a path fine that we're obstructed and your one technique is to wait wait a little bit see if that obstruction moves maybe it's just another player and anther I agents maybe the door will open in a moment whatever could be better in a moment there's a lot of sort of reciprocal velocity algorithms where we're sort of moving both of these objects know that they're going to be there and are basing their movement a manner so they're going to move around each other steering behaviors is something we'll get into next lecture but there's ones that can be used again to avoid things around you local other agents they don't run into each other it's often or push off algorithms these are this is definitely used a lot in older systems with basic ideas you travel down the given path until you hit an obstruction and then you sort of bounce off I could be in a random direction or to be based on the topology of whatever it is you collided with but then once you move away from that object to set amount you try to move down the path again this could work ok if you sort of bounce off some object and then move around it to go down your path it won't look too terrible but if you wore on into some push off some wall only to run into that same wall again and again and again sort of bouncing off some obstruction and running into it again this is definitely not going to look very natural or give you believable results for your agents another option you always have if your agents get stuck is to replan maybe especially if something could obstruct your path permanently or for a very long time maybe a door is closed and now it's locked well maybe we have to find a new path to our goal also one last option keep in mind is giving up if you do have to give up you should indicate that to the player somehow now it's not always going to be the best option for a lot of games you know FPS first person type shooter thing you don't want your AI agents to just give up and stand around looking dumb but it's something like a tower defense we might have cases where the player has made it so that there isn't a path anymore and we have to indicate that somehow maybe we don't let the game continue or make the AI do something different in those cases but but it is possible when we making these dynamic changes that may be a path just does not exist between our our current location in the goal and we do have to give up and handle that in some manner with paths lining we can actually further trade memory for speed by pre-planning all of the possible paths so in this diagram we have our Waypoint nodes that we've seen previously but to the right we have a pre-planned pathing table this actually represents all the possible paths so from any starting location on our graph to any destination is already pre-planned through this chart so how we use this chart if we look for some green numbers down the left hand vertical axis labeled start no sir or starting positions we actually might want to think of those as our current location that's going to change as we go whereas the top horizontal red axis those are our destinations our destination is never going to change this might seem weird that our start location would change but really it's our current location let's look at it for an example just like previously let's try to go between two and four so if we find two and our starting green numbers and we find for in our red destination that location in our table we see the number three represents that that's the next step in our path when we're trying to go between node 2 and node 4 we start at note to all you need to move to node3 now we start the process over again so we find the green three we still want to move to node 4 we look where those two meet in our table and we see owed for as our next location in our path and it's actually our goal so that's just a simple example of how this table can be used but you move from any one node to any other just by looking up the values in this table of course we are trading memory for speed again so how is that going to work well we don't have to do path planning at runtime anymore at least not the same way we can just sort of look up the results in this table of course we have to store this table in memory on this table is going to grow in size fairly quickly it's going to scale as we add more waypoints we're going to have a much larger table as we go so is it always a trade-off of memory and speed which one do we need more off right now 