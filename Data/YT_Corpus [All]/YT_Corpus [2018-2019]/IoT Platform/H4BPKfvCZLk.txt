 Hi, in this presentation I will show you how to quickly get started with Mainflux IoT platform. I will download the Mainflux from its github repo, execute the make command which will start the docker-compose. Docker compose will pull Mainflux images from the docker hub and start Mainflux instance. We will then use Mainflux CLI to create users, things and channels And connect things to channels so they can communicate. Mainflux internally uses NATS for messaging and it exposes a series of adapters which publishers and consumers can connect to. Those adapters are: MQTT, MQTTS, HTTP and HTTPS, WS and WSS and CoAP. I will show you examples of HTTP and MQTT communication, after that. The machine I am using here is just plain Ubuntu 18.10 and only has make, docker and docker-compose installed on it. Additionally for the demonstration purposes, I also installed mosquitto clients so I can use mosquitto_pub and mosquitto_sub to send and receive some messages. So let's start. The first thing we need to do: we need to clone the Mainflux code locally This is the Mainflux github repo and we will copy the link and then we will go to this blue window which we'll use for Mainflux IoT platform so we do "git clone" and it starts pulling the code Once we have code inside, just go in the directory and execute make run command Make run command will start docker-compose and docker-compose will start pulling all the images from docker hub that we need. And then it will started so let's wait for a little bit OK, so it pulled all the images and started the containers and now you can see some logs coming out of Mainflux. So now that we have this Mainflux instance up and running here we need a way to configure it. Mainflux exposes the API so you can add new users, new things and channels but also one handy way to do it is to use Mainflux CLI. In order to use Mainflux CLI we need to download it from the Mainflux github repo. If we go to releases, you will see that there is a CLI here and let's download it. In this black window we will use CLI to create users, channels and things so let's download it first. OK, it's here, let's unpack it. So now we can start using it.  Let's create a first user. If you go just like this without any parameters you will get a help and you will see all available commands like channels and things and users And also if you if you go like this: "./cli users" you will get the format of command that you need to use. So in this case you can use "./cli users" and then either "create" for create user or "token" to get the user token and then you need to provide user email and password. So let's create one user. And here you see that the user is created and if you follow the left side and the logs you can see that POST request to "/users" is executed and the user is created. Now we have one user, what else we can do? We can get a token for that user since we need token for all operations later on that user will do. If that user needs to create a channel or a thing, the user needs to supply the token So let's get a token. OK, again you will see on the left side that there is a POST request to "/tokens" enpoint and here's our token. So we will use this token with all following commands in order to create things and channels for this user. All things and channels creation commands need to have this token supplied. If I go like this: "./cli things" you will see that I need this token as the last parameter. So, in order to make things simpler I will put this user token in environmental variables OK, now we have it in the variable and if we want to create a thing as you can see, we need to specify a JSON for that thing and JSON is basically a type of a thing and name of a thing. So let's do it like this: .cli/ things create '{"type":"device", "name":"testthing"}' This is JSON that we need to create the device and then we need to supply a user token So now if we hit enter, again on the left side you will see that the thing service added the thing, so created a new thing and also the NGINX, which acts as a reverse proxy in front of all the services also registered the POST requess to "/things" and we have a success. And response is basically the ID of a thing that has been created So now we have one thing created. Similarly we can create another thing and this time let's create an app. Let's imagine that app and device will communicate in the future. This time we will create the app and you see, we created the second thing so this one has ID number 2 and on the left side you can also see things going on. So, now we have two things, let's see what we can find out about these things. If you go like this Now we will request the thing Again we need to supply the user token because it's our thing. And we will get all the parameters, all the data about the first thing we created. We will get the thing ID, we will get a thing type, we will get the name and one important thing we will get the token, so we need this we need this token in order to be able to connect this thing to a channel But first we need to have a channel, so let's create one channel so this thing and this application can communicate. ./cli channels create and then again we need to supply JSON for this channel and JSON has one parameter which is name. And we need $USERTOKEN It went successful and method create_channel is called on things service So now we have one channel and in the same way  we did got information about about the thing we can also get information about the channel We will get information about this channel. So, now we have two things one is of type device another is of type application. And we have one channel Let's connect those two things over this channel If you type this part of the command it will show you the usage So it will show you that first you need to specify the thing ID and then the channel ID and you need to supply the user token. We first need to supply thing ID which is 1, then channel ID which is also 1 and then user token. OK, method connect so basically we connected. You can see on the left side, and the response is OK so we connected the first thing which is device to the channel Now, let's connect the second thing which is the application. In this case and the thing ID is number 2 and the channel ID remains the same so it's number 1, and then $USERTOKEN So we do this. We now have thing with ID number 2 connected to the same channel So now we have everything created in Mainflux in order to start using it. Let's say for example in this gray window we can use mosquitto_sub this device will subscribe to this channel and listen to it mosquitto_sub username is 1(ID of the thing) Sorry, I forgot one thing. First we need this thing token. So let's export it the same way we did with user token Let's export thing token. For the first device for the first thing it was like: ./cli things get 1 $USERTOKEN This is the token we need so we will export it here And now we can use it like this mosquitto_sub -u 1 -P $THINGTOKEN -t channels/1/messages And we hit enter and now on the on the upper left corner (the blue one) we can see that we have a subsription Basically we see that this client subscribed to this topic Now this one is up and listening On the right side we can do mosquitto_pub for example, but let's first export the token. The thing with ID 2 has this token Like this, and now we can do: mosquitto_pub -u 2 -P $THINGTOKEN -t channels/1/messages -m "test" I published here successfully, and the subscriber received it, and also you can see included a MQTT messages coming through. And one more thing is this Mainflux normalizer which complains and complains because the Mainflux normalizer expects the messages in SenML format because it can normalize these messages if the messages are in SenMLformat I have one SenML message prepared so I can show you how normalizer works It looks like this, so basically a SenML message with two readings and if we pass this through Mainflux the normalizer will basically unroll, unfold, split those messages into two messages So for this example we can use cURL, so instead of MQTT we can use HTTP adapter curl -X POST -H "Authorization: $THINGTOKEN" http://localhost/http/channels/1/messages You see that the format is the same like for MQTT topic So we will basically send this SenML message which is stored in this file You will see on the left side that we   received this SenML message but also we can see that now the normalizer went fine and that it took this much time to complete without errors. We also have matrix here so all the operations have time These were two examples of MQTT and HTTP communications besides that also CoAP and WebSocket communication is possible. 