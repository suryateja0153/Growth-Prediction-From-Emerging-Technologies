 Thank you very much for the introduction. Thanks to Oracle for inviting us. And thanks a lot to all of you for being here. I know your time is valuable and I hope this presentation is useful. Today I come here to talk about containers and the future, about apps deployment. If you have been in the industry the last five years, it’s almost impossible not... unless you are completely isolated and living in the dessert, it’s very hard not to have heard about the Cloud; many of you also use containers, docker. Maybe you aren’t very familiarized with Kubernetes which is another technology we are addressing in this presentation and in many of the other sessions we have throughout the day. And they are really important technologies which literally are the future apps deployment. Why? Why is it like this? What is that all of these technologies enable which are called Cloud-native? The first feature is that they facilitate a process that used to be tiresome, manual or very difficult to automate... it’s greatly facilitated, and they enable an easy apps deployment. All of you who use Docker know that you can type DockerRunWordpress in the command line and have a blog in a matter of seconds. The same happens with the database. You can connect to the Docker store and download it and launch a machine... an Oracle database also in a matter of seconds. Not only that, but once those apps are deployed, they really ease the process of escalating them horizontally. You can grow from one web server to a hundred or a thousand. They also allow, with the orchestration systems, having gradual deployments of your apps. You don’t have to have downtime where hours go by since you have a new version of the app until you have the next one, and if there are problems, well it’s complicated to go back. Inside, these technologies have mechanisms that allow having those deployments with zero downtime. They also enable you to better optimize resources. The same as when virtualization used to let you a certain degree of consolidation of the physical servers, containers and Cloud technologies allow you to take it a step further and do a better use of your data center or to download a part, move that loading part to what the Cloud is. And lastly, this is also quite important, it provides you consistency on the development side, on the testing side, and on the production side. Normally, these in traditional apps or traditional environments can take days, weeks or even months to create a functionality until it is live in production. And many times there are companies that launch versions of their apps once a quarter because they are quite complicated subjects. What features do all these Cloud-native apps have in common? First, they are inside a container, they are packed in a way in which the app code is along the runtime of the language you need. If it is a Python app, it has a Python interpreter; if it is a PHP app, it has its own PHP interpreter. If a Java app has the runtime along with the rest depending on the OS, then it can be both a Docker container as well as an unchangeable VM. And this is very important to be able to replicate that status, as I said before, both in development and in production, as to be able to replicate it inside of the components of your equipment. If you have developers, one of the problems of having different development environments different from each other is that there are small variations, small differences or big differences in the libraries, in the runtime that prompt all classes of errors. Right? The famous, “It works on my laptop. If it doesn’t work on yours, it’s your problem.” Well, all that is using containers, it’s removed using repeatable environments. Then it is also transparent. Knowing at all times what goes inside that container. We’ve seen before, or I’ve commented how the sources are GiHap and then you can see how those containers were created, or in the case of a VM, how those VMs were created, and you can modify them and... inspect them in a way it was quite difficult before. And lastly, it allows certain resource isolation, it allows non-interfering in each of these containers with the rest of what’s occurring in the machine. It’s not the same level of isolation as in a VM, but it does allow quite new ways of separating or limiting the access of each process. The dynamic orchestration of these resources, of these containers, allows you to take advantage of the hardware, whether it’s physical hardware or VMs, but it allows you to deploy them according to your needs; you can start with three or four containers, and as the system sees a major load, those containers... new containers are created to make room for that new load, those new repetitions by users or clients of a new way, completely automated and transparent. A failing app is auto-detected or it detects if a container doesn’t have the health it should have, then that container is suppressed and new ones are launched. Besides, as part of these native architectures of the Cloud, there’s the microservices concept, where they used to be a monolithic app with hundreds of thousands of code lines deployed once a quarter, now that is separated in different services, separated in different components, one for authentication and other for user portal... Let’s say, different functionalities that can be deployed separately, can be developed separately and can be updated without having to change all the system at the same time, and they can be refactorized, re-written in different languages or in different frameworks in a much more interactive and agile way that also allows the scaling of a very complex app development. Some examples of companies who have adopted native Cloud are companies like Netflix, which was one of the pioneers and which runs all its infrastructure at the Cloud. They partly use containers, mostly unchangeable virtual machines, but they have 100% adopted it and can be adapted to what their users’ demands or the peak demands are easily, using those resources of the Cloud, as they are 100% there. Also, companies like Box have adopted Kubernetes internally as the way of deploying and managing their apps. It is also a company that runs on a scale and even the Pokemon Go game, which some months ago was a frenzy, is also in the backend and runs above Kubernetes and it’s one of its successful cases. I know what you are thinking: “You are talking to me here, Daniel, you are talking about Box, you are talking about Netflix, you are talking about Pokemon and that’s very inspiring. I take a look at the way the Netflix’s Engineering Department is, or at its Operation Department, and it’s really very nice what you are telling me, but then I take a look at my Department tomorrow Friday, I’ll go to my company, I’ll take a look at my IT Department, I’ll take a look at my data center and I’ll want to cry.” [LAUGH] And they won’t be joyful tears, right? And I come here to tell you it’s common, one comes to these conferences, listens to how Spotify or Netflix run their data centers or how they manage them, but that’s not the truth of many companies. That monster called Legacy Software, the software that you have in your data center that was written five, ten, fifteen years ago and that’s a perfectly functional software, but all the same people who built that software are no longer in the company, or was built by some consultants who disappeared the following day after giving the code, but that Software Legacy is there for one good reason: precisely, the company still exists, then having Legacy Software means you have had a successful company, which lasted over time. But it gives you a series of problems that can’t be easily solved due to this type of technology. So, now I want to give some perspective from where these technologies come and where they fit in and what type of problem they solve. It’s not a universal magic solution, where the next day you’d have to change it all and re-write it all for containers; in fact, that would be crazy and impossible. So, in this part of the presentation, I want to recap a bit about deployment from the early days in the 90s up to today, and see where it fits and which are the compromises one has to undergo with all these types of different technologies that have been evolving throughout time. To understand the past, the present has to be understood and we have to see where we come from and where they fit. They are not out-of-nothing technologies, but they are the logic evolution of previous technologies. I will tell you a bit about my background and why I’m here to talk about this and not other person or company. I have a developer background, although today I don’t do much codes, but I come from the free-software world; initially, back in the day with Linux and also with Apache. I was one of the first members of the Apache software founding. And let’s say that’s my background as developer and I was always interested in facilitating this type of software installation or documentation. I’ve written also many books, to help spreading it, and back in the day, that led me, in a crazy moment, to create Bitnami. At Bitnami, we’ve been lucky and have grown as a company, and now we have the main Cloud companies as clients, including Oracle, which is one of our partners. We have more than 150 free-trade software apps that we pack for different platforms. We are specialists in deploying in containers, in physical machines, in virtual machines, in the Cloud, and we have millions of users. I’m sure many of you, when we talked before you told me you used Bitnami and, in fact, if you are clients of Oracle and are using Oracle Cloud, now with Marketplace you will find many of our free images to start with. And there are from development environments of Ruby on Rails or non-SQL database environments packed also as SQL in normal relatives, up to complete file management apps or Wikis. So, besides the work we’ve been doing around app deployment, we have something exclusive which is, we can reach out... or we have those millions of users and clients of the Cloud through whom we can understand first-hand not what people say their department does. Alright, the time has come... Alright, now it has, hasn’t it? Perfect. Alright, what I was saying is, we have a unique viewpoint because we have all these clients of the Cloud, we have 99% of the users and clients of the Cloud. And we also have millions of users ranging from students up to 14,500 companies; many of our users are developers and system administrators who are working for 250-user companies. 250 employees or more; many of those companies have more than 1,000 employees. So we have a pretty much wide variety and we know the problems people have, and we know what they are really using. And part of this presentation is giving you a glance on how many of these companies manage their servers or deploy their apps. Many of these features I’ll discuss have to do with limitations that are allowed by platforms of that time. Then, we are going to overview physical servers up to VMs, what the Cloud is and what containers with Docker and with Kubernetes are today. In the 90s, which is when... I will take Linux as reference. Many of you start with other Unix versions; I particularly started with Solaris and with Xanoex, but I will take Linux as common point known by every developer present here. So at the beginning, everything that had to do with app deployment or server deployment was very manual; in fact, at the beginning, there were no packet managers and no Linux distribution concept. One used to go to different repositories, download the desired program sources, compile them, Make, Make Install, and deploy them. Later on, first Linux distribution came, like Slackware or Rehab or Devian, and they had a packet manager, either RPM or APGet. What’s more, many of these first apps that started to appear with the web, when the web became popular around ‘95 or ‘96, and it was expanded beyond static HTML. They were binaries of CGI, PHP apps, Java servlets, and all those apps are very simple regarding dependency. One needed Tomcat, a runtime, Java’s VM and a code to deploy the app. There weren’t tens of parts that modern apps have. And to deploy a PHP app you only needed to copy the sources, FTP was used to upload that app in PHP to the server and it basically worked. Then that infrastructure wouldn’t let you have... that physical infrastructure, those physical servers which couldn’t be automated at all, virtualization didn’t exist or it was in its early steps, as those other layers wouldn’t let you evolve; everything was very manual and with a minimal automation. I always say that the better productivity tool of the 90s was a coffee cup. Then, let’s say inside what the stack is, what the hardware is, operating system is, programming languages are or app code is, almost all was manual. There was little pell scripting, but very little. All these changed at the beginning of 2000. All of you who were here in ‘98, ‘99 and 2000 know there were some bubbles of the dot-coms, there was also the book of 2000; a lot of money was invested in Information Technologies. All that was stopped at the beginning of 2000 and there was a great momentum for the explosion of that bubble to consolidate and reduce costs. And that was mainly happening due to automation and due to virtualization and consolidation of hardware. The first trading versions of OMVWare came out and started to be adopted as a way of taking the most advantage of all that investment done in hardware during those first bubble years. And also as a way of being able to manage more equipment and being more flexible with fewer people as it was more efficient. And we are already seeing tools available, systems that allow automation of physical servers. For example, we have PXE, an Intel technology that allowed for the first time having a physical machine, put it in the rack and when that machine was booted or initiated, it had the enough intelligence to download the OS off the network and install it. This was back then... I think first specs were from the year 2000, or 2001, for the first time it was allowed to automate a substantial part to provision new machines. Later, with the virtualization matter, it was possible to make a first installation of the packets app and then take a snapshot, take some kind of picture in the time of that VM and have an image that was then reusable, and what was called Golden Images could be launched several times. For the first time, version controllers were being adopted with their USB and its version and adapted to what the configuration management is. This was used combined with Shell Scripting or other Shell language. Basically, they were all customized solutions that couldn’t be replicated; they weren’t transferable from one company to another, or from one department to another. But they would allow certain repeatability or certain guarantee that things would be similar from one version to another. So within the OS stack and hardware and etc., we can affirm that everything that was hardware was 100% automated and replicable; there are some good practices that can be implemented. The OS is only partial because now you have a Golden Images management problem and how you can keep them updated, when there are security patches, or have different versions, or how those images are created in the first place. And then, all that has to do with dependencies management or app management. It is either manual or there is no standard way of doing all this. At the end of 2000 another series of technologies came, which was in turn preceded by a new type of web apps. As Internet is getting more and more popular and first versions of iPhone arrived, first versions of mobile devices, we started seeing much more interactive web apps, web apps based on Java Script with a series of development requirements. They were made with programming languages and frameworks like Ruby on Rails, Django, Notes Yes; it’s no longer the commonly written programming in Java PHP, and it comes with a series of requirements. What used to be a virtualization already implemented by some companies at the beginning of 2000, is already an expanded practice and most companies have almost all of their data center virtualized. And also, people start talking about the Cloud, a first approach with apps in the Cloud, although they are still no better practices. Tools emerging during this period to give support to this type of apps include ongoing interaction. When Hudson was born, who was Jenkins’ predecessor... What ongoing interaction enables is that every time there’s a change in the app, you can rebuild it, test it, run a single test, and it let you automate arriving to a unit of that code you can deploy. So automating that first part of your pipeline for the deployment is important and allows another type of further automation. Other technologies that emerged during this period are platforms as services, at the end of 2000, as Heroku, or Cloud Foundry, which allow you to forget about everything related to deployment, dependencies management and databases, and taking care only of your code. They had certain limitations but they ease a lot and today they are still being used and very popular, they ease the development of certain types of apps a lot. Finally, and this is the part that every one of you who are in Systems have probably had to deal with throughout the last years, it is configuration management. Tools like Chef or Puppet for configuration management. What do these tools have? One of the first things it does is that they are tools that allow to manage servers lifecycles. By “lifecycle” I mean that servers still are, in the essential part of app deployment, the core unit. So all these tools help you provide these servers, patch those servers or update them when there are new versions of your app, there are new kernel versions, security problems, libraries... well, all those tools allow you to manage that and do it in an organized way, and make sure all your machines are consistent and have the right configuration. And that’s something that lasts on the long term. To get maximum benefits, the company is required to adopt it from beginning to end. If this is a tool only adopted by operation, the problem will continue to exist among developers and operations, such impedance that makes it hard to pass the dev code to production. The problem that these technologies have is they are not easy to adopt, it’s not something you can learn in one day, but they require training for developers and administrators. And that’s pretty hard. Dependencies still being used are still those from the OS. If you are using a server, a database, they usually are the ones that come with the Enterprise Linux system adopted by the company. What is sustained instead, if the effort of adopting these tools is made in many of the companies present here who have done it? Well, you get a standardization and a reuse level, not only inside the company, but you also get an ecosystem where someone can write recipes or playbooks on what is the best way of deploying a database, the best way of deploying a web server, and you can use it and adapt it for your company. And for the first time, it allows you to express infrastructure as code. And to be able to do that, to be able to describe how you are deploying apps or which architecture of your app, it allows you to version it and replicate it in Development and Operations. So let’s say the OS and hardware with this type of tool are completely automated and there are good practices. It’s still partially... it depends on the type of apps, type of environment. Regarding dependencies, which are usually specific to certain companies, or there aren’t better practices, and the app keeps being manual or based on each company. One of the major innovations from the 2000 in terms of productivity was platform as a service. There’s a type of apps that if they are written in a certain way, called Twelve Factors Apps, they are basically summarized in techniques to separate the status from the code. If apps are written in that way, this type of platforms take care of the rest. And they greatly ease app management and a developer’s life becomes more productive than ever before. Besides, by virtue of having separated the code status of the app, it makes easier to scale this type of apps horizontally. What is the compromise one does when adopting this type of platform as a service? Well, one is pretty restricted by the languages available, the type of database that can be created or the way of creating that database, and the dependencies or libraries available to use. But if your app fits in one of the predefined architectures of the platform as a service, it will provide a lot of flexibility. So let’s say that it automates all, except for the app code that’s what you provide, and simply the same can be done with a Docker command, a Cloud Foundry command or Heroku command, you can deploy your app. And we get to today, from 2010 onwards. What happened first? First, the Cloud evolves from being an experiment to something companies have adopted entirely. The companies with specific requirements as I mentioned before about Netflix, or big companies start moving major parts of their apps to the Cloud. So there’s a massive adoption that in turn allows this type of automation and the adoption of containers technologies, Docker and Kubernetes in this case. And in turn, all that is preceded by some stacks, and by stacks I refer to all the different services and components your app has. They can be databases, authentication systems, servers, cache servers. And they are more complex every time and, where it used to be Apache PHP MySequel, now they have Redis, MongoDB, Cassandra, MainCatchD, two or three versions of Node js. They are much more complex apps with many different interacting parts. And now, for the first time, in the last 2 years, all referring to serverless technology, where the part of the code written by the developer is not even an app. They are already individual functions. We are already seeing all that today. What type of compromises or trends are here? One of the formers is the fact of automating it all... it is the first time that can be done. Everything has an API and can be written. From launching a VM, providing a database, up to creating users, giving them permission, it can all be written in terms of API, and that allows the automation from beginning to end. Or at least having that possibility. There are people who have been using the Cloud in a more pragmatic way, which is Lift and Shift, having a machine that you used to have in your own data center, in your own machine, being able to move it without changing it entirely to the Cloud; it’s not a native-Cloud app, but it has a series of cost-saving and automation models that you can make. If you want to have access to those advantages of scalability we have talked about, you can use APIs and build your app in that way, but it’s optional. That’s a compromise, a trade off you can make individually within the company for certain types of apps, and that’s really interesting for big companies that have all types of apps and become gradual, meaning they wouldn’t have to write all their apps to become platforms as a service, or re-write their apps to put them in containers among other things because, as I discussed earlier, in the real world many people who wrote those apps are no longer in the company or their knowledge isn’t there. Also, other tool used is infrastructure; they are tools that allow you to have an unchangeable infrastructure. I mean, once you create that VM, it’s not changed, OK? That VM has OS, interpreter or the VM you need and your code, and that doesn’t change. When you want to launch a new code version, you simply redo that VM, and that’s not a completely automatic process and that allows you to deploy it. You saw I took the web servers and Yes database from the program, the Cloud allows many of those components that you had to take care of, manage or have in an equipment, it provides them as services. That database can be High of all types, even Oracle has a variety of offerings of the Oracle database, of MySequel as a service, and you don’t have to worry to manage them or at least great part of it can be automated. For the container part, we have containers for development, which is Docker, and its appealing part for developers is, it is very easy to adapt. In one afternoon in a few hours, you can watch a Docker tutorial and have something running in your machine that you can use to develop right away and which provides you with that consistency and repeatability we have discussed earlier without the need of having 3, 4, 5 VMs running in your laptop, which is not a doable thing. And it allows you to have all the tools we discussed before, Redis, MongoDB by Cassandra running in your laptop easily and consistently with the rest of the equipment. It also helps you to eliminate dependency on the OS of the versions you want to use of PHP or Node Js; it’s separated from the version coming with Devian or Linux you are using. Those containers have a runtime of Linux normally based on the OSs but for you developers, it is exactly the same. For you, one container is a black box with a functionality you can use launching or shutting off that container without being experts in managing work system. In this containers case, what the container gives you is the code of your app together with the interpreter or dependencies, everything that the OS that’s underneath and manages those containers, the orchestration system like Kubernetes, the hardware, it doesn’t matter, those are details given by the platform and it allows you to get away from all of that and have a great earning in productivity from a development viewpoint. Once you have that container in development and it’s working, how do you put it in production? Well, here’s when Kubernetes comes in, which is an orchestration environment, it has quickly become the standard. Oracle also has its offering of Kubernetes with click2kube and the industry has united around this platform to run those apps in production. Initially comes Google, an Open Source project has been done and it has many of the practices, of the good practices of management of containers at scale in a way that can be used by many companies requiring that scale, like Box or Netflix, as well as by “standard” companies that have business-line apps or simple three-layer apps and are looking for an easier and more efficient way of managing it. It can also be considered as a universal platform as a service as it has flexibility and I can write the code without taking care of anything else once I have the system here. But now the difference is that you can encapsulate that code in containers, and you can use all the libraries you want, the language versions you want, and you are in control of the functionality of your code so you don’t have in the classic platform as a service, and that makes it even more useful for many companies. And then also, as I said, you don’t have to manage lifecycle no more. The example I always give is that if you have a server and think of it as a car, then tools like Chef or Puppet help you in case you run out of gas, or if you have to clean the car because it got dirty or had a flat tire, they are tools that help you manage all that. In this new world in which creating a container or creating an automated VM entirely is much more efficient, if your car runs out of gas, then you abandon the car and go for a brand new one. Because that part of creating a sever, which used to be a very manual and complex part, and once the server was working nobody dared to do any change or to touch it, or people would do production changes and kept fingers crossed so that nothing failed, well, all that part now has been automatized in such a way it is much easier and more efficient to rebuild those servers and containers from scratch than trying to patch them or manage them, and that eliminates 90% of the complexity or the need for tools like Chef and Puppet. So, in many cases, although they are not exactly the same, they are completely different technologies, but the problem they solve is indeed very similar and that’s why you see more and more organizations considering a replacement of a major part of the configuration management with tools like Kubernetes, although they are still in their initial part, because the promise of these technologies is quite interesting. And lastly, and for me this is the most important part of the entire presentation, automating processes is no longer good practices, it’s no longer something we should do, like documentation. Everyone should write a good documentation but then, reality is different. Well it’s no longer optional. Now it’s something that one has to implement to have access to this type of platforms. The good news is that once the process is automated, it simplifies and frees you from a lot of tasks. I want to talk a bit also about how this is transferred to real life. And what other companies like yours are doing and where they are in the VM adoption, containers, the Cloud cycles. As we have discussed, we have millions of users, we annually carry out a survey and this time we have had 20K or 18K more users that have completed it all. Many of them are businesses, which are medium or big ones; we consider medium business starting at 250 employees. The survey, which we’ll be posting next week for the public, addresses all types of platforms, addresses servers administration as well as the development and operation parts. There are many things I would like to highlight. One of them, comparing it with when we did... the top part is the survey we carried out in 2016, last year, and this one in the lower part is the one we did this year. The green part, from right to left, is people or businesses who are running apps in containers in production, with more than 50 hosts, in production being considered as big production deployments, and the light green are smaller production deployments but still are production. So in 2016, it represents approx. a 30%, and that has been doubled in one year to almost more than the 60%. In one year, that’s one of the biggest differences we’ve seen with any type of technology. And then going right, we have people who are using containers just in development, who are experimenting, or who haven’t started yet. So basically, everybody, almost a 90% or an 86% I think is the data down the graphic, the vast majority of people is either experimenting with containers or using them already in production. So, you have already taken the first step which is going to conferences or days like today to learn more about these technologies. You are not alone. There are many other companies which are also following those steps. The other important part that I’d also like to emphasize is that when people adopt containers, adopt the Cloud, they don’t replace the rest of the platforms. They don’t migrate all to a Cloud or container, but they still use all types of platforms. More than 50% of the people who are using our apps, use more than one platform. There are a lot of people who only deploy in physical servers, many people only deploy in virtual servers, but more than 50% has a variety of production platforms. They are production-in-use platforms. Then, all type of tools you ideally have would have to cover all the platforms because there is not only one that can cover all the expectations or that has all the functionalities to own a modern business. And then regarding Serverless, I think the next talk will deal with it and there are other talks throughout the day regarding Serverless. Which refers to instead of writing a complete app, you can simply write the function with an input and output, and minimize the code part you write. I see Serverless as, although it’s still in its beginnings, a technology that... although there are people, more than 30%, who are already moving it to production, it’s something it’s starting to have a great potential. Some of you who programmed in VisualBasic in the 90s, one of the VisualBasic features, despite not being the best programming language in the world, one of the features that made it so successful was that you were able to integrate different controls, you could integrate libraries very easily and simply put GUI which united different controls or reusable libraries underneath. All the Serverless parts or functions as a service have that promise. It has the promise that if you write this code then you can use many of these services the Cloud provides to create an app. And you can write, you can really create quite complex and successful apps with a few lines of codes due to all the automation that lies underneath already in many of these Cloud platforms. So, to sum up or to conclude, if I can express one thing with this presentation is that there’s no magic solution nor containers won’t solve it all. I wish they could solve all the problems, but that isn’t the case. It’s another solution you will have to implement and support and which has many benefits for certain type of apps but, as everything in life, there normally are a series of compromises and if a simplified technology hugely simplifies the development time or the developer’s life, unfortunately that’s translated to more complexity in the operation part. For example, all the subject around microservices allows you to segment and develop those services separately, but it adds complexity when it comes to orchestrate them and put them in production. A container is not a specific thing, it will gain more importance throughout the following years but it won’t replace traditional VMs and apps. And lastly, the real world will keep being multi-platform, you will have to support physical machines, VMs, the Cloud, and that’s one of the reasons why we are partners with Oracle; we consider ourselves a little bit as the Cloud’s unbiased side, as clients, we feature all the main Cloud vendors, but I think one of the things that makes Oracle interesting from this type of technologies viewpoint is that it supports all these platforms and can provide you with tools, and it understands continuity and that a great deal of this adoption has to be gradual to achieve maximum benefits. If there are other Cloud vendors that only provide the Cloud, it encourages more to migrate all your infrastructure whether it is or not the most efficient one or what you can do well for your type of business, or based on the type of developers or the level of expertise your IT systems have. And with this I’ve finished the presentation. I think we have time for 1 or 2 questions. One question. So, you can give this away to somebody who has a question. OK. You have an encouragement. The one who ask the question gets a hoodie. There’s a question over there. I have a doubt regarding... in one graphic you showed from the last slides you said that around 51% of the industry was with 2 or more types of platform. Yes, it doesn’t let me go back. They are production platforms. That’s the question we ask. And at the end, in the last slides you said that platforms would continue to be varied. I imagine now there has been a trend about this graphic you discussed in the last years, where it has been decreasing and yet it’s not feasible it will turn into just one at the end... The question is if there is a decreasing trend of platforms which... It’s true. Well, I don’t know because I don’t have 2016 data. When I was preparing it, I didn’t compare them to 2016. My impression... I understand the other questions. As I’m telling you, in the next weeks we will launch it and you will be able to see it. We make data public. My impression is it won’t. There will be more platforms, it doesn’t go down. People add platforms, add platforms as a service, add containers, but they don’t delete older platforms among other things, because there’s a lot of habit with the machines being currently in production, and many times when these apps are already written and running, the return on investment for re-writing them to adopt a new platform is complicated. What we do see is consolidation for example of what’s called Lift and Shift, having lasting, virtual machines and move them to the Cloud but keep treating them as normal virtualization. That’s correct. But the rest is... things are being added but not deleted. Thank you. Thank you very much. Thank you very much. [APPLAUSE] 