 Well hello, everybody, good afternoon. Thank you for showing up for the last session. I realize I'm the last person standing between you and the experts, which the highlight of that is pretty much beer. So I hope they're gonna be beer over there, but let's work with that. Okay, so welcome to building modern cloud based web application, web and mobile application, on Azure. My name is Yochay Kiriaty, I'm a principal program manager. I've been working with Azure, and specifically Azure App Service, for five, six years now. The technical evangelist before that and bunch of other start ups. Our team, myself blog a lot on the appsserviceteam on SDN. Consider all kinds of technical stuff that we do with our team. And that's my Twitter account. If you want to find me on my email over there and we will have the slide in the end of the session as well, so. Yes, let me just ask. How many of you are using Azure App Service or Azure websites? Okay, just about a third, cool. So for those of you who are not, welcome, we'll dive into that pretty much this entire session. For those who are, maybe this slow will be a little bit boring. Anyhow, if you have an Azure account, great. You can go ahead and actually can follow up some of the stuff I'm going to do. And if you don’t, you can go to tryappservice.azure.com. And basically if you don't have an Azure account, this will allow you to experience some of what I'm doing right now in a controlled environment. No credit card, just put your email, and you'll be able to work with it. But if you do have an Azure account, feel free to just work with it. All right, so. Application development have been changed quite a bit in the last couple of years, I would say decades. From physical machine to virtual cloud infrastructure. And now basically getting to the point where some of the application that we are looking into, we are actually natively building and directly going against cloud infrastructure. Not necessarily a virtual machine like cloud infrastructure versus VM Skillset or VMs or containers, but more of a developer platform, platform as a service. PaaS, serverless, all of this is where kind of we're trending and app service is exactly in that crossroad. So to try to kind of put things in perspective in terms of analogy. Imagine that basically hosting a cloud will be like owning a car. So there are several options, right? You can own your own car all the way to the left, I guess, with the thing. And basically owning a car you need to buy the car, you need to finance the car, you need to regularly change oil, and all that. So this is like owning a VM, you need to manage the OAS, patch the OAS, do all the builds, everything around that. All the way to the other side you can take a taxi, you can take an Uber, basically a SaaS application. Where you don't really have any skin in the game. You just use it and that's it, and you're done. And you're probably gonna pay a premium per usage, but it's okay. What we're for with the PaaS model is basically, hey, this is combo in between. This is me telling you, all you need to take care of is really just writing your code, understanding your application, knowing a little bit about the platform that you're running. But we're gonna manage all the platform for you. You don't need to patch it, you don't need to patch the OS. You don't need to manage the OS, you don't need to manage scale. You don't need to manage your frameworks that you're running on. Just deploy your application and it will work. That is kind of where PaaS is in between. And it's mostly just basically a question of trade. Trade of what do you want. Do you want more control? Do you need more control? Do you need to own the entire thing as you're dong on premise? Do you need to be able to custom the OS for whatever reason? If so, then you need to basically go to infrastructure as a service run on VMs. But if you don't and you're willing to make this trade off, basically that someone else will take care of the OS for the middleware for you for the runtime. Then basically you'll probably gonna fit very well into the platform as a service model, which is where App Service is. And the SaaS obviously, as we say, it's all together, and Microsoft has a lot of SaaS option around Office and dynamics and so forth. So, what is Azure App Service? So, Azure App Service is a fully managed platform. It's the beginning, that black thing, black pillar in the middle. It's a fully managed platform. We take care of all the underlying infrastructure, meaning that you don't manage any OS. You don't have access to the OS. You don't patch the OS. You don't put up frameworks on the OS. We take care of that for you. For the moment you deploy, if you're running on one VM or ten, we're gonna make sure that your application runs across all of them. You don’t need to deploy one by one. So we do take care of all that situation for you. When you run at high scale where there's a lot of traffic, we'll do the auto-scaling and automatic load-balancing across multiple VMs. And if you have many application across multiple VM, again, we'll take care of all that for you. There are some enhanced features, we'll see some of them. There are staging environments, back up and restore, there are security considerations. There's a lot of stuff that come with this fully managed element. On to the left, enterprise grade, sorry. Basically everything around security, compliance, hardware connectivity. You can run within a VNET. You can safely connect to on premises. Global footprint, there's a way to protect your endpoints, bunch of stuff. And over to the right which is kind of the most element part for developers is where we get hyperactivity development environment. We offer you basically a lot of framework that you can run. .NET obviously, but we support Java, Python, Ruby, not Ruby, sorry, Ruby on Linux. But Java, Python, Node PHP. We have experiments with Go, Ruby run on our Linux containers. So, we have an ability basically to bring any framework/language that you would like. We include built-in infrastructure for staging. So when you deploy, you can deploy into a stage environment, run, make sure that everything testing and working properly before you switch into production. We can have something called testing in production which we can actually split traffic and says, hey, you know what? 97% goes into production and 3% going to this new version. And you can test it out and figure out how thing works and so forth. We have app gallery, we have marketplace, there's a lot of stuff that actually help you get up to speed really, really quick. So, that's App Service. And App Service basically includes multiple options or multiple application sites if you want to call it. So we have web, mobile, API, logic, and functions. And we're gonna through each one of them and I'll show a little bit of example. So, Web Apps is the original in coordination of App Service, used to be called Azure Websites, if anybody been using us that long. And it is basically the core construct that all of the other services are running on top. It basically has all the developer productivities, features, source control deployments, CICD, which we'll see, staging deployment, auto scaling, monitoring, alerting, all of that. All the different framework and application that are running on that. You can see here several application if you run through or Site Core or try to WordPress. You can just go ahead, double-click, and [INAUDIBLE]. A few clicks basically gets a full working deployment. As I said, all of the languages. And we support a lot of enterprise workload. In ind ustry running we connect to Azure ID and there's a lot of stuff in there. So because most of you didn't raise their hand if I'm asking , if when I ask whether you're using App Service. Let's see basically the Hello World of App Service and just how thing works. So with that, we're gonna switch here. Fine, we'll do it here. Basically we'll create a new website, a web app. Let's call it, Chicagodemo1, we already have, 2. Okay, works. This is my subscription. I'll use an existing resource group. These are all constructed within Azure. Resource Group is a container. We'll see it a little bit later for all your resources once we get to logic definition. This is the location I'm gonna create. I'm not gonna add up insight but you can choose to add it or not. You'll see a little bit later why you should edit when you create applications but not for this demo. I'll go ahead and create, had some Internet issues earlier. Let’s see if it works. But basically we'll take about 30 seconds give or take, maybe more. But you'll have a container in which we will be able to go ahead and deploy our application and just have the thing work for us. And we'll see so we'll give it a second. Anybody want a joke in the meantime? So it'll be a short joke because, there it is, it's done. So with this basically what we've created is a web app. And I'm gonna basically show you that this is the first time we're running the app, so it will take a couple of seconds, but this is it. This is a running application, it's an empty one, there's not a lot in there right now. We’ll get it fixed in a second, but this is it. Chicagodemo2.azurewebsites.net, and you have a full working application. Okay, as I say it's an empty one. I can open Visual Studio and deploy Whatever I want, I'll go ahead and show some of the parts of the items I've talked about, for example deployment option. So, I'll go ahead and choose deployment options, and I'll configure one and can see if we can connect to visual studio team services obviously the Azure service for basically building a pipeline managing your entire pipeline in dev ops. You can deploy for one drive if you really feel like it. Local git, github. I'm gonna just go with github. And hopefully it's remembered my credentials from before. All right so it does. So guys we're like lets choose this project and we are gonna go with, With the first one but is that a really simple node application. It has only one branch, maestro. Just keep with that. You can already configure performance test to be deployed together with your application. More applicable if you're running on a stage environment. But let's leave it aside for a second. I'll hit OK. What we're doing right now is basically we're telling the system hey I want to hook up into a git report, which we just did. And what will happen behind the scene is that now the firmware of the application will go ahead and pull the git report I have and just deploy it for me. And let's see the status of that. So you can see, it's already hooked into git, and now it's just being deploying. So the first deployment, specifically for a node application, takes a little bit time. Maybe about 40 seconds, maybe 50, because you need to do all the NPN, which we're actually doing, and I can show you the logs. But it will be done in a second and then we can actually see that. So while we do that, let me go ahead and already prep the next part of the demo. I think it's here maybe. Yes, okay. So this is basically the report I'm working on. You can see these are, I hope you guys can see. Can you see in the back or do I need to zoom in? You can see me basically doing some, testing tonight, earlier, sorry this morning. So the only thing I'll do right now just to make it simple is, gonna fire up git. Already got git, that's good. Run code, VS code cuz this is java script app. So this is coming up. Okay, so it's basically done. We can go ahead, refresh the site, And voila. All right, so this is a very simple site, but I'll show you how we can change and update it. But first I wanted to show you really quickly, what we're doing is, it took overall 49 seconds and basically pull up the information and see exactly who's the author of the GitHub, the status, the success and so forth. You can see what I want to show you is like right in the deployment command because this is the first deployment. So we're going to see the entire log. If you're familiar with node, you'll be able to see like hey we're actually running. We are identifying what we need to run here. And we are doing npm install to virtually get all the packages and dependencies. If you had a NuGet, a C# .NET project basically and we would discover all the NuGet dependencies. We will basically download all the NuGet dependencies and compile on the fly and run it for you. So all this done basically is allow you to create continuous deployment and automation with the app. So just to finish the demo let's go to our right this. or just zoom in so you guys can see better. All right. So this is the app basically. This is a very simple express app. Router is basically the controller so here's the controller. I'm rendering, I'm sending out some parameters like title and text. It's saying address service and it's gonna go ahead and says and here, take some in demo. Cool. We'll save. This is the view so over here let's save another one in line and save this as well. Okay, so now all I want to do basically is get ads, I'm adding everything. I'm gonna do a git commit see live demo, all right. There I go. Okay. And now let's do git, push origin master. Why not [INAUDIBLE] all the way. Sorry. Yeah there's something. All right first. Okay. So that's it, that's all it took. Basically we'll just push deltas and they're up. And with that I'll just show you how the hook works, get away from this really quick, back here. If I'll go ahead and refresh this view. You'll see that it already picked up my comment, it already picked up the latest version. And if I go here and refresh, basically the changes should be visible right now. Ta da, all right. Cool, so that was very simple. It was very simple app. It basically my first. This is the [INAUDIBLE] world that we're doing with app service. So this is how you create, manage your application very easily. Okay, mobile application, basically, we have set of mobile is the case. Instead of mobile services that allow you to easily integrate mobile application. That's why I have my Mac here. We'll see a mobile demo a little bit later but we support features like Offline Sync. We use a lot of user authentication, obviously for Azure Active Directory but as you can see a bunch of other providers. We can view push notification across multiple platforms and basically Azure mobile services with the mobile is the case the only mobile provider out there that supports connecting to a SQL database and support offline connection against SQL database. So we'll see how that works in a second. We also have API applications. An API application basically, we have a lot of what we call web apps that are being exposes Web API and basically all the features for Web Mobile in API are available across all of them. This is more of a marketing definition but, specifically for web app we have features like Easy Off, similar to authentication model that we've talked about. We'll see a demo later on. We have Course which is super important for the function piece of the data. We expose the swagger, we actually allow it to build swagger and we help you with building the swagger. It's very good integration with logic apps and API management. All right, so logic apps. Logic apps are, anybody been to the logic apps session? No? Okay, logic apps basically the easier way to envision them is like a managed workflow and the next slide is a demo and actually we're gonna see that. But the nice thing about Logic App is the ability to be able to connect through multiple connectors. So there's a lot of connectors built-in into the platform that actually API-based connectors. So that's why the API apps are there. But I'll show you how many connectors we have. And the thing is that the platform manage all of it for you. So you don't have to do the authentication song and dance, and the tokens are being refreshed for you and all of that. It's basically can cut across on premise and the cloud. There are gateway connectivities that you can do through there. So you can have workflow actually running in the Cloud, fetching or managing data across Cloud and On Premises has lot of automation built into it and integrates very well with a wide variety of Azure services including, app services, API's and functions which we'll see in a second. But with that let's see a quick demo of. It doesn't matter which one we go. So Contoso is an example. We'll actually dive deep very much in the future slides. But this is a good example for me just to show you how does the logic or just part of the logic app looks like. So as you can see, first glance you can see some status information like reporting, what happened, what ran. And this will give you basically an ability to view the run. So you see it looks like a workflow there is like steps in here, there is a condition that you can do and, all the information you can see failed or success status. You can rerun the information and you can dive to a lot of data input, you can go in a lot deeper. You can see raw input and output information like actual old information comes in and out, and so forth. All right, so there's a lot of trace ability in the debug into them. But the more interesting aspect is actually I wanna show the designer itself. We'd show again the very sooner view But this is how you can see actual the flow. So there is a request here, this request is being triggered from HTTP but you can trigger from a lot of other endpoints. And flow through, you can see it calls function a little bit and there's some states management and sending email, as an example over here. Let's say I wanted to take another action. Then what I want to show you here is the wide variety of managed API, these are managed API, managed connectors that Microsoft maintained the ability to connect to a lot of providers out there. Doing some exponential information is one thing but you can do there is, you can do queues, Azure queues but you can do other services. Like a blogger and box and buffer and the list is really, really long can see you can scroll for a very, very long. Obviously a bunch of office and dynamics. But a lot of, a lot of services. Salesforce if you guys seen here, SharePoint, SAS, and so forth. Nice thing about it is this can connect to the, say to a multiple API's or multiple services. So obviously the manage connector that we have any API on app service, so I said app service exposes API so you can connect with this. Any managed API through APIM, APIM can also manage API. Any other logic apps, you can nest logic app, you can think about it's characterized model. And obviously you can connect to Azure functions which is this one, then we'll see it a little bit later. I just wanted to show you a little bit how functions look like. The Logic App looks like. Okay, so we'll just ignore this, And move on. Okay, so that was Logic App. And sorry. So click functions, yes. So the next up is function, function is serverless computes basically. Event driven serverless compute. It's great. But it's easier just to show it basically. But we have a slide about function, which means I'll show you a really quick demo. But the idea behind function is that you don't even need to with app service, you build your application, your. If I have a note application like Express or I have an NDC app with Visual Studio, it can go ahead and deploy that. Cool. With function we are even thinking away that part. We don't even need a framework, we just asking you hey give me raw code in a function form that we can run you that handles events. Like HTTP triggers, like queue events like, I can storage, like something happening on a sub system in Azure. To any kind of operation and we will trigger that piece of code for you and run it. So I think I'll show you really quick how it looks like and later we'll just dive in through some more complex function scenarios. So here, function So what I want to do is, this goes here. I did a whole session just about functions, about two hours ago. This was the Hello, World so I'll just dive here, I'll make some small changes, and see how it works. Okay. So, imagine you have not seen this. Okay, right. So now this. Okay so, we're back into functions so, here it is. So, I created a function app, which basically, is just a place for me to run multiple functions. Now what I want to do, I want to add a new function. And this new function will just go ahead, and it doesn't really matter. There's JavaScript just because we can. And we'll say, hey, you know what, I want it to be HTTP triggers. Basically, expose an endpoint. Next to the endpoint this code will run any time we are gonna hit that endpoint. So this will be the demo. I create a function, and the function is created. That's it. And now all I need to do is just copy paste this URL over here, paste it in, and that's it. And you have an endpoint working. And that's all it take, all it took, sorry. Basically, create a function app which I already created but it just like created a website so you could see how quick it is. And then go ahead and basically this is an HTTP trigger, you can have auto triggers, we'll see like queue triggers in a second. And it works. That only took basically to create a function and explore it. The nice thing about function is we have something called bindings. And what are bindings? Bindings are the ability to basically control a little bit of our input, output. What do I mean? So obviously you see here triggers. A trigger, we have an HTTP trigger. You can create different triggers for example if there's a Q message which will be the next demo, Blob, and Azure. Blob items so any files or any object basically into Blob. Event Hub, RT, what else? We got a few more, I forgot. And then we can add input and output as additional, but let's just do our first second for an output. So for the output what I want to do in this example is basically show you what we can do with the bindings. So input output binding is a way for us to obstruct this data layer. What do I mean? Let's say I want to respond to the HTTP message that's came in. Take it, create some object and put it on a queue for later process, I want to create an asynch model that someone else will process it. Okay. All I need to do is basically says, hey, I want to write the message to a queue, and then you can see here there's a bunch of other stuff we can do. As I said, blogs.mdb, external files are like Dropbox or Google Docs. We can also even use SendGrid or Twilio, which we will see in a demo later. But let's say I go with Azure Storage Queue. Hit select. Queue won't actually work with this guy. Okay, hit Save, and that's it I created basically a binding, that I can work with. One last thing about functions, we really want to make you very productive and really quickly, so we get to results so we embedded documentation within the portal. And beside the fact that we can tell you how to go to access or view your storage because using Q, they actually show you what does it mean to work and give you code examples and all of that, which is kinda cool. All right, so we go back to develop and I'm gonna do something really simple. I'm doing something just really simple, I'm basically gonna say context.Bindings and output queue name, obviously the output that we talked about. This is the parameter that we are talking about so we're just, obviously gonna say like, Hello world demo. And that only takes to actually take a string, or any object that i can serialize into JSON at this point, and put it in an outer queue from Azure Functions. And let's say, Hello Tech Summit. Okay, and this will go in the save button. So you can see here basically, this code, if I run this code, if I refresh it, it basically says hey, you need to pass a name parameter query because if you quickly look at the code basically this Hello World sample that we have here is requesting a query parameter or a body object. If you're posting to have a name object. So let's just add name really quick. And as you can see, I made a change, I saved, and it is running. That's it. And by the way, it's also saved some item into the queue less or more. Maybe I should probably add like, let's do something else. Since we know we're passing this, so we can see different messages every time. Okay, so now it actually will append the name itself so if you go here and write Chicago 12, nevermind. And cool, so it's up in here. And now I need to just show you they actually end up in a queue, so let me just do that. Did we took away the, yes we have. Okay, so basically this is the queue name that we are writing to, it's all by default. If it doesn't exist we'll create it for you. So it lets me go ahead and create a new function and I'll do it now in C Sharp instead of Java Script. And we'll go with queue trigger. Where's the queue trigger? Queue trigger. And the queue items we are listening for is this. Hit the create and basically, pull up the logs real quick, hope it's not too late. Basically we already enqueue some items so we should be able to see logs, but maybe I missed that with the half a second that it took me. Going to go ahead and enqueue some other stuff over here. And here it is. Yes, so it already cleaned the other stuff. So this is the second function, right? This is a function that listens. This is a queue item, and whenever there's a queue item we will trigger, we will invoke that function for you. So we are constantly being aware of all the surroundings where things are happening. And our first function, our first HTTP function enqueue a message, and this is the function that will dequeue a message and so forth. So you can see how simple it is, this was function. This was bindings, and I say we have auto bindings. And later on we have a more detailed, more in-depth of functions. So we'll be able to see how functions are behaving. All right, so having fun with functions, we had fun with functions. Good, so app service is great. We have pretty much over 400,000 customers, active customers. These slides are slightly old, closer to 400,000 cores or VM would be more appropriate. Tons of applications, more than 10 billion requests a day, so we can handle all the traffic that you guys can throw at us. The second most-used service in Azure in terms of number of subscriptions or number of users using the service. Okay, so next what I want to do is I want to dive into into a demo that we have, which is a conceptual demo that basically ties bunch of services and bunch of Azure services into one scenario. And I'll just walk you through the scenario and then we can just go through one through one through the different aspect and see some code and see how thing handling. Hopefully it will just tie in with the fact that we have a platform versus managing infrastructure. Okay, so what we got is we have an insurance company. This is Contoso Insurance. Contoso has a lot of holding companies. It's a holding company, it has a lot of branches. So one of them is Contoso Insurance. And what Contoso Insurance has already, existing assets, is a thing at the bottom here, the green bar over here. Which is basically existing web MVC web application, which runs on premises. This is internal application for claim adjuster to approve, disapprove, do whatever he want with an incoming claim, right? And they used to be able to submit claim, in the past, you would be able to submit claim with whatever. To an agent or god knows how. Okay, what Contoso wants to do is to create some, to modernize the process. To be one of the good company insurers out there, I guess. And allow customers to submit claims through a mobile app. So what we built for them is basically we created a Xamarin form mobile application. That basically allow you to authenticate as a customer, be able to identify which vehicle had an incident, be able to take all of the details that you need from the incident, and then basically submit it. Now the thing here in between is the Azure backend. This is the piece that glue between the cloud, because the mobile application would probably always run on the cloud versus on-prem, and be able to handle all the logistics of moving data from one piece to the other, running through automation of claim adjuster, connecting to on-premise, running some work flow, and be able to interact with the customer. And if you need, you're basically feeding everything obviously to the on-premise, and the claim adjuster can approve, disapprove, if it's not automatically approved for you. Well, we got behind the scene is this. A user basically running a mobile application, there is OAuth then, here, and with Microsoft Account, we'll see it in a second. And the user basically can submit information. The way we're doing it we're using Azure Blob. Once you see the code it will be much, much easier. So a mobile application basically uploads information to the cloud. We are triggering events from the Blob to basically kick up a work flow, that either automatically approves or reject the claim. Approve or reject. If it's rejected, then basically it goes into the claim adjuster and the claim adjuster can just basically manage everything from here. And what happens, the workflow is basically we handle mobile claim, we do some more CR and we analyze the information that comes in. Goes with the flow, there's some logic applications here, we can see Office with some emails and so forth. So I think it just easier to just be able to just see it in action. All right, so now I have to turn on my Mac. Okay. Right.  Cool, so let you just go through the demo and then we can dive into the real applications here. Running on the Mac because it's a lot easier to run the IOS simulator from a Mac than running it from the Visual Studio tools. But you get the idea. So, this is the app. I already logged in. I showed you the code for login, so you actually can believe me, that I have done that. But, I have two vehicle, I'll choose one of them, I'll go ahead and, basically, now being asked a bunch of questions to fill. So, for example, the license plate of the car. So, I guess, this is the second car, sorry, the license plate, all right, so we'll move on. The insurance card, let's look at the insurance card. Here is an insurance card. We hit next, driver license, can do that as well. Here is a driver license. Phone number. One too much, should just be nicer. It's actually doesn't let me, but anyhow. Images, so I can go ahead and do some images here, I don't know, let's do the one with the red stripes or it's easy add in another image if we want to. Let's pick this one, fine. And then some notes. Demo at tech summit Chicago. I'm done with the notes. And basically now I hit that, and what happened here is that the application now is doing bunch of stuff, accepting jobs, it's basically taking, preparing a package, uploading into Azure Blob, and then be able to signal the application basically, hey, I've uploaded everything. We are ready to start the workflow. Waiting too long? All right, submit it. And this basically started the workflow and now I'll just go back to my PC because I'm more accustom of running my demos on the PC. Okay, so I'll, I think I have, Here, yes. Okay. Okay, so this is the behind the scene, cool. So, What happen is that we have a very sophisticated algorithm to approve or reject claims. Basically, first time we see your name, we auto-approve, and then we just auto-reject.  [LAUGH]  Yeah, very sophisticated. So let me search and see. Hopefully there should be new claims coming up. 16 was already there. Need to log in again, all right, search. And here is 17. And the reason I'm doing it in a, reason I'm connecting, sorry, the reason I'm connecting in incognito mode is because, maybe I should show this to you. I logged in with Emily B which is a specific and we have an Azure tenant ID. I'll show you the whole, behind the scene the whole thing. You can see here actually this is the outlook for Emily and you can see I'm running on Contoso insurance. Hope you guys can see. No you can see better, maybe. So the whole thing is based on that tenant and how we do that indication from On-prem. And we also allow, Azure active directory allow external customers as well. So this is how I can, for example, my name is being picked up from my Gmail account in this case. And you can see here that, hey, claim 17 was created, which was the last one. This is from 3:26 which is I guess the clock time in Redmond. And that's it. And now you can click on the link and you'll end up basically clicking into the claim, and claim 17 is right here. And this is the claim, and you can see because the notes and the description, these are the right images that I've passed. You can look at second party information and you can see the images that have been submitted. And we are all running, I'll show you the behind the scenes, but we're using Microsoft cognitive services and running OCR to basically identify all the information, just pick it up automatically. And that's the whole thing and now we can approve or reject. It doesn't really matter what I do. This will just kick in a different work flow that will go ahead and figure out what needs to happen, and this sends an email, hopefully works. And yeah, claim rejected, cool. Okay, so let's go in and, Look into what's actually being comprised to build this application. We are okay on time. Okay, so this is the entire app, basically in terms of all the resources. We have an Azure resource group here. Basically identify all of the items that we got in this application, and there's a few of them. Basically I have a web application, mobile application basically is exposing a set of API's for the mobile app, we'll see that go in, in a second. I got the internal application, this is the NBC app. We've got storage accounts we're running with application insights. We have two logic flows, we saw one of them in the previous demo. We're using multiple databases. Using event notifications for event hubs for pumping out messages. You can see API connectors here. These are some of the connectors that show you with the logic app. We use Github, because we are using deployment automation here. We're also use Office 365, to be able to send and receive emails, as you would expect. So, open my cheat notes to figure out exactly what is the right order I'm showing you all the lovely moving parts of this application. So one thing I want to show you for example Is the API. So in the API, On the API, just as I said, this all looks the same because these are all basically underneath the cover the same web apps at the end of the day. What I want to show you specifically is the authorization authentication piece, and as you can see here, it's allowed to allow it on. And allow it basically to connect, and I got some events sitting in terms of the token store and how to manage this, and basically it's configured with the Microsoft account. And you can see here all the tenant information on the signing on. And this is the signing information that we actually get back from, when you sign in with your mobile account, this is the data that we actually collect from the token, with authenticity provider. You can collect multiple of them. And obviously, when you do the first login, it asks you do you agree or not, and so forth. The nice thing about EasyAuth in terms of this is that this entire thing is being managed at the platform level. You do not write any back-end code to actually make it work, and I'll show you and prove to you exactly what I mean. And to do that I'll just go really quickly here. Where am I? We use one of them, doesn't matter which one. Okay so what I got here is a different app. Which is easier for me just to show this one particular feature, with our awesome web app, which is just a way to demonstrate all the features we have in just one big pile of app. What I want to do is you can see it has a custom name and so forth. Really quickly just go into custom domain, copy this, go here. Okay, so is the app that I got. This is the dynamic information. You can see here machine information I'm running, so I can show you scale. I can show you staging, a bunch of stuff. Specifically for EasyAuth, this is the EasyAuth, Piece of the data, cool. And I'm not logged in right now. And this is the information I can pick. Let me just quickly show you what I mean. So I'm running with EasyAuth it's on allow anonymous applications. Anonymous access, basically. And this application is configured not with Microsoft account but with an Active Directory. And it configure in Express and the other piece will show you this, what does Advanced mean. But basically this is just creating a tenant within Azure Active Directory. And I can hook it up into it. All right, so if I go here and login with my Azure AD. Because I'm already login to the portal, it doesn't ask me actually to authenticate anything this, and I can go back into the application and voila. This has authenticated successfully. And you can see it picks up all my credentials, the token, all the information that you need. And when I show you the code for that, I hope you'll agree to laugh about it. So so this is the NBC app for awesome web app. This is the code, see a bunch of controllers. So if I go really quick to EasyAuthController, you'll see it's very complex. Yeah, as, yeah it don't even need to. Agree with me. Very complex. So there is no magic happening on the controller level. The view, the only thing I'm doing basically, with the view is, I'm going through and because the EasyAuth basically is an IS module in the pipeline. In the manage module we catch the interception we do everything and then we inject all the credential. And basically everything within the system security with the claims and the principle are just there for you to work with. So we make all the injection and here it is and basicallyi just enumerate all of them here. So, there's zero codes for me to actually handle that kind of literal security. Or, authentication, sorry. And this obviously adds a level of security. So, we're doing the same thing with the mobile app. Where was I? Too many windows. And with the mobile app, basically if I will click the mobile piece, this is the mobile application. And, Where is my mobile helper? My own helper, sorry. So to do the login basically what we have, I'll just try to explain it a little bit. Basically this is a summary just to get dependency. This is how, because each mobile device will have its own different way to interact and to handle the token and where the token to store them. But behind the scene what we're having is a Microsoft service authentication which is part of the SDK. We're going with the Microsoft account and we're doing the log in. This will basically pop up the log in on the mobile device. And, assuming everything is successful, and with those three lines of code you have just logged in, and, on the service side, once you enable EasyAuth, as I showed you, there is no actual work you need to do. So, that's all it takes, and now you are basically authenticated into the platform. All right, so that should be cool. So that was our authentication piece, so let's see, actually I think I have slides to help me with the, yeah. So Active Directory, we've talk about active directory, so we have active directory in the cloud, it can connect on-premises connectivity obviously to the cloud, different providers. And then you can have your application to be able to authenticate Office 365 for just one example. You saw I can integrate with a bunch of other. You've seen the demo, all right. Next offline sync. So offline sync is also really cool in the mobile app. We provide again the SDKs in the mobile to be able to handle offline sync. And offline sync is important because sometimes you had an accident, I don't know where, and there was no connectivity. So you just run the application as usual, take all the information, you can actually click the done, where am I going to connect? It will wait for next time. And what handle offline sync will do for you is basically manage all of the transaction for you on the client and we have the service IPs as well. So we have the mobile SDK on the server side, we have our table controller or easy table for node, API controller or Easy API, again, for node. And you'll be able basically to working in any data source, including blob, storage, and SQL database. And you can define all that in both of the applications. So, I think I'll just show you really quick, the code because it's a little bit hard to just show the actual demos behind that. So I'm still in the server side, and mobile helper, no this is the client side, sorry. This is the server side. Okay so on the server side basically, what I got is the following. Just I wanted you to remember some of this stuff here. Like client submitted. We'll see this in a second. But the claim controller is more important here. So what we do in the claim controller is, where's the claim controller? Come on. Claim storage controller, sorry. We're doing that in the clean storage controller is basically this. We go ahead and we ask for a storage token. Cuz what happened is this, the mobile application request a storage token because I don't want to upload all the image and the package basically through my NVC controller. It doesn't make a lot of sense. It's just going to read the information. So that's one thing. Goes to the cpu of that VM directly. And the only thing that will [INAUDIBLE] directly is save it to the storage. Instead, Azure storage has the ability to create token, SAS token. Access token basically. Once I create them, I can grant access, reader access, write access, to my mobile application, again authenticate it. And now it will upload into the blog directly. Not going through my servers saves a lot of bandwidth saves a lot of CPU, saves a lot of money. And a little bit more reliable because now we can actually handle the offline sync to do the song and dance that takes care of all of that. So obviously we do the authentication. We get the thing. We get the token once it's ready we return it to the mobile app. And the mobile app will go ahead With a claim, manage the claim, this is basically, yeah. I'm going to through all of the information. Basically we have a claim table as sync, you have a vehicle table as sync, this is basically table records that are managed through a SQL Lite running on the mobile, then again, can do the sync The sync against actual SQL, all the metadata is there. And we add the file with the metadata. Once the device comes online again it's merely trying to sync, identify hey, I've got new records here, I'm just gonna start uploading them and so forth. So that's how the offline sync works. Once we get the offline sync, what happened is we basically start handling that, and specifically the function is being notified that, Hey there is an activity. And then the function is the one that actually kicks off the logic work flow. But let me just quickly walk you thru The logic app is as I say tones of connectors and this is just a partial list of all the connectors that we have. Obviously you can see a bunch of Microsoft assets but there's a lot of SAT services out there. Sorry a lot of, third party services that are supporting that as well. So let's look at the auto approved for a second. Suited in menu rejection because it just rejected one. So this is the one that we run. Just right now, right? You can see the request coming in. You can see my private email information here. You can see correlation id. I'll just copy that for later, and basically you can see HandleManualClaim because we say hey Manually we reject it. You can see this is claim 17, the new claim that we created and so forth. Was it approved? No, then send an e-mail and do a bunch of other stuff here if it's approved or if it's not approved, do something. You can see the send e-mail. You can actually see the entire thing. You can see the body. All the data and so forth. And this information comes from the push manual reject function that actually handled that for us. So there is a combination of other functions and logic apps to be able to complete this work. Nice thing about functions is once you write them, and they run, you don't really care where and how they run. In terms of management. We copy the correlation ID, good, good, sort of handle work. Okay. So I think next I just want go and actually show you some of the functions in here. And obviously this will be a much more complex function app with many more functions, and many more supportive files, than the simple the Hello Word that I show you. And hopefully, this will just Convey the message that the other function is like substantial improvement of writing code. So basically handle new claim handle mobile claim, as you can see here. I'll go not gonna go into this. We'll, go into it a little bit later. But basically it's identify there's all the information coming in, for example the claim itself is being handled, all this iCloud blob of basically objects into which then I'm gonna get all the images that we need to do, handle mobile claims specifically. Goes into here, runs, give [INAUDIBLE] here I want to show you this piece specifically. So, this is the one that is doing all the work with OCR. OCR update syncing. What, I want to show here, let me show it to you. Let me show it to you here. Will, be a little bit easier. So, these are all the functions we got. These, are all the projects for the functions. Hand mobile claim as I said this is the run method. You can see some telemetry information here a function triggered. We'll see it in a sec how it actually handles the mobile claim goes again to another function, just manages to get the other CRM claim, the database onto the updates. What I want to show you is Is all this information and this is where actually gonna do all the work of analyzing, the data. So we basically run an OCR on each of the images we have like the cards, I guess is the insurance or license. And the license plates, and then all the other images. Just scroll, sorry. So this is under OCR and OCR is under the file over here. You can see you can nest multiple classes, multiple objects with functions, and this is the OCR. And this is basically using Microsoft collective services specifically Vision to run those cr we extract environment variable we use environment variable to hold the keys instead of saving the keys and secrets in code and basically we just run the ocr client to be able to get data. Once we have all this information continue to flow into the logic. And so forth. Logic functions, we've seen some of the functions. Okay, we've talked about that. Cool. Actually I should've shown this before I showed anything else. Apologize. So I think we've seen bunch of that already, so As I said, different triggers, there are different input and as you go and expect, you'd be able to use those contract and when you're creating a function, you'll be able to expect to have input parameters. So as you can see here, in this example. This is running from excel input our storage. You can respond in output. And everything is being declaratively on the binding, so you can obviously put it into source control. And you can manage on this. And as you would expect, input table is an object you can work and iterate around this because it's uncurable. And actually can work with image text which is part of the image text objects and actually manage that, so a different application but you get the idea. So when you go here to the code you can actually fill that, if we take an auto approved language I think is a little bit simpler But you can see here there's http request information coming in. We just realized the claim. We work it out. We create a response. This is where we prove the claim. This is where the magic happens [INAUDIBLE] so forth. This is basically Azure function in a nutshell. You write a piece of code. You run, you basically deploy it, and it just runs. And it will scale as much as needed. You don't even manage the servers or anything behind the scene for that. Okay. So now I want to show you is, other then the demo I want to show this. Yeah. Okay. So before that, let me really quick go here. This, for those who are left, who decided to stay, to stick around with the session and didn't get bored already what I want to do is I want to challenge you a little bit. I want you to pick up your phone and send an SMS to this number. And tell me, I don't know. How do you feel? How do you feel about this session? How do you feel about my presentation? How do you feel about this day, this event? Azure Function, Azure App Service, Azure in general. Whatever you want, just send SMSs and see what happens. And while you're doing that, I'll go here. And I'll just basically show you what I'm doing. This is a little bit simpler functions than the ones we've just seen, maybe it will help. So what I got here is basically a [Inaudible] and when you send a message it goes to Twilio and basically Twilio sends me a web notification that I'm handling. And all I'm doing is just, for example, taking all the query information and just breaking it apart, creating some object here that I can work with and get the information. The body of the text from who, to who did you send, some metadata information about time events, when it happened. And then I'm writing it to a queue. We've already seen it, very simple to write to a queue. Once I get it on the queue, I have another function here. Similarly, this is using the Project Oxford which is Microsoft Cognitive Services. I'm using sentiment analysis in this case, and I'm creating all the object here, whatever I need to do to use the sentiment analysis. Same thing, I'm thinking environment variable. I'm not sticking keys in my code. And I get the data. I run the sentiment analysis. Here's the score. I can actually run logs, I actually can see things flying all the time. And then I go ahead and send a response back to the SMS and this is where I can show you function and binding a little bit. So these are all the people that I hope send information now. We can see it in a second. If I go to the Integrate, you can see I'm actually sending outputs here to Twilio and to DocumentDB. So Twilio is a third party service. We work with them to create this binding. It's very simple. In a nutshell, this is the binding information. They expect some keys like the SID and the token. These are environment variables. These are the basically pointer to the data itself. The secrets themselves are in the environment settings. DocumentDB, the same thing. I have database in the collection and this is the connection string. And if you look at the code, write a simple, this message now, this SMS message already includes the score. And basically, I'm just sending a response in writing to my DocumentDB, to the queue item. And that's about that. So really quick, and the algorithm to making decision whether you got a smiley face or a sad is basically based on the sentiment analysis just arranged, nothing too complicated or fancy. But this is it. I mean, this is the three functions that I wrote here, and I'm using, sorry I'm using Twilio which I have no idea how to use. I just created Twilio account so I can use the binding. And read a little bit of documentation around that, but I didn't bring the SDK off the Twilio or anything like that. And it just works, so the idea is like three functions and you got this funky little demo that sends smiley faces. But you would agree, it could be interesting. So this is the DocDB and what I want to really quickly just show you is the information which is quite cool. I'll just really quick bring up my notes. So let's just get all the guys who send good stuff. Otherwise, it's gonna be a shame. So I'll run the query, and this is maybe from earlier when I ran, as I said, the function. But these were all the people that replied, they were nice. And you can see the data, what they've sent, the score that they've got, their ID, and that's it. And I guess if I scroll down here you're probably gonna see, this one's long, man. Cool, thank you, good score. But thank you very much. Yeah, lots of great things for a cool demo, yeah. So that's the idea. There's all the info. By the way, only augmenting part of the information here because I do collect all your phone numbers. [LAUGH] No, joking. I actually need to fix that part of the demo just to keep the last four digits. But anyway, you get the idea. All right, so I wanna show you App Insights really quick, because I think it's super cool with what it can do in terms of just tying everything together that we've seen. I'll show you App Insights, it was part of the Logic App, it was part of the function, it was part of the API. So this is actually traced across all of the different services that we've talked, and I can use App Insight to run through all of the information that we have, which is really important. You can collect telemetry for every tier, right. From your mobile application, from your web application, from your API, from your logic app from your function across the board. Project the telemetry and show some information around it. So what I want to show you now is how we're doing that. And actually I really don't need it. I need one of those. I hope this was the last one I've used. And the reason I need it basically I just need to correlate, copy the correlation ID again, sorry. This is the analytics. Already I can get through it from my resource group, but this is just easier like that. Let me open up the query already created. So this is the correlation ADM. Remember I told you to remember some sentences or phrases from the different telemetry that we are putting out from logic or from functions or from the API itself. So what happened is we are basically pulling up, sorry, we are emiting telemetry information for every single step that we have. So this is claim received from the mobile app. This is claim that was received from the mobile app. I got the message, it's in the blob. Now I actually in queue the mobile application, notify the back end to in queue a message into the queue to actually kickstart the entire process, the entire workflow. And the function was triggered and then the data was required, and then the insurance card and this is the OCR, before, after, before, after. You can see all the data here. You can see all the eventing and the time it takes to run through all of the information, and the auto approval was rejected. And then all the information here and then the claim was manually rejected because that's what I did, and so forth and so forth. Every single layer of the application, everything is traceable and manageable with App Insights. And what's cool about Insights again, it's a fully managed application. So everything I showed you thus far I can deploy all of the web API and the mobile application. The backend obviously can use get deploy, which we are using, or Visual Studio deploy, and the logic app, as you can see. And it's basically, you can use the portal, and you can write. You can use Visual Studio to create, but there is no server behind logic app, there is no server behind functions. Everything that you've seen thus far is fully managed for you, and this is the beauty of the platform that I see. And with the last seven minutes what I do want to show you is just a little bit of what actually happened behind the scene with respect of the actual apps. So we do have something that we call an app service plan which is a logical representation, I would say, of your VM that do run your backend. Because the mobile backend and the API, the MVC applications are running on a standard. In our case, a basic, single small VM of App service. Again fully managed, if I run on three it will just scale on three automatically for me. What I want to show you is basically, we got the information here. We can do the scaling alert. For example, these are alerts that I can configure. So I can say like hey, if the CPU ever goes above 75%, send me a notification. I can see there was a little bump here, maybe a restart of the application. Memory is kind of constant, and you can see here. Obviously there's no load on this app, it's a demo app, but you can get the idea. There are too many errors. So this was a view for, those memory CPUs are for the app service. This is a view of my actual app. So this is for the API, where's the mobile handle? If there are any error, there's a 500 that'll get notified. And you can actually create a WebHook, and I just showed you what you can do with function of a Twilio WebHook. You can imagine what you can do here furthermore. So this whole thing is trying to say is like fully managed for you. The whole orchestration happened behind the scene. You don't really care for any of that. You can scale up, you can have automatic scale happening for you and all this is really nice. And then yeah, I think I can talk more for a couple of days if you really want. But we have five minutes. We have beer waiting for us and I want to leave room for some Q and A. So even if I have a few more slides, just articulate some of the flow here. Let's just finish with this. So basically I build my code, push it to GitHub. Automatically being deployed. Put it in a pre-production environment, staging environment. I haven't shown you in this part but trust me, it's there. I can run load test, I can run functional tests, whatever I do. You can imagine there is a whole flow here, it actually works and okay, and I can put in a loop production. Once you move into production, we safely allow, you would actually make a transition, so there's no downtime. We take care of that for you as well. You deploy it on the cloud, everything is happy. There's a PIN site, as I showed or hotkey app for the mobile, we used that as well. Collect all the telemetry information, figure out where you are, and then the cycle continues. All right, so there's actually a bunch of other slides but those are boring slides. So I'll finish up with questions and I'll just leave you my contact information if you care. If you wanna have other questions, if you wanna ask publicly, I want to thank you guys for sticking around until the end of the session. Thank you very much, and I hope to see you in the.  [APPLAUSE] 