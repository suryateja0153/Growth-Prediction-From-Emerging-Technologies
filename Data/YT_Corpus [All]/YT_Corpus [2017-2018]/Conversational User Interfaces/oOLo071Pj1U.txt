 [Music] hi everyone hi everybody let's talk about one of the hardest parts of designing a spoken dialogue between a human and a computer how to handle so-called arrows now before we dive in any good conversation starts by knowing who's talking I'm Nandini stalker and on me on Nicole's Leon is a developer relations engineer for Google assistant apps and Undine e leads the conversation design outreach for actions on Google our two teams are responsible for most of the resources that you'll find on the actions on Google public website where we show developers how they can design build and deploy their apps for the Google assistant now you can implement the techniques we'll show you today using tools like API AI through performer logic in your code or as a combination of those by the way API AI is a tool for creating apps for the Google assistants now we want to help developers create great conversational experiences the best way to do that is by considering the design first and working in tight collaboration between designers and developers I trade on that design within the capabilities of the platform now in human to human conversations hesitations and Corrections happen all the time we just did a little bit of it when I do it again and we'll display MIT on the talk now in human to computing into accidents they do too but in the form of timeouts and recognition errors the difference is that humans can take cues from each other to get back on track in real time but with a simulated conversation the corrections need to be pre-planned and that's not an easy job so the only way to course-correct in advance and still maintain a natural comfortable dialogue is to plan for them as if they were any other turn in recession now yes some of the terms we use when talking about errors in voice interfaces one of the first things to remember is that there's a difference between the technical conditions and events at the trigger and respond to these errors and all the user scenarios that are happening at the same time so any number of things could go wrong from the user's perspective so for any number of reasons now we'll show you how keeping both of these perspectives in mind will be really key to your conversation repair strategy otherwise it's pretty easy to become either too simplistic or with a basic strategy of just apologizing and asking the same question over and over again and/or being overly prescriptive and formulaic in your approach now for example here's a formula that's really common and often built into a lot of tools and defaults but this often translates unfortunately into a user having to be asked effectively for the same piece of information with very little variation three four or five or even six times so that leads to a really tough experience but what's a very frustrating one for users it's important to note also that user impressions on how they're formed in that moment when they're going through an error is not just about the interaction itself that they're going through it frames how people feel as a whole about the technology something that we really care about changing so in fact we've asked people how they feel when recognition doesn't work and they have negative visceral reactions and they can't always place why so one of the reasons is because people are using their voice voice is one of the primary markers of our identity and it so it feels extra personal when something goes wrong so let's dive in and see how we can handle these with a new paradigm so we're going to show you how to so-called air events could be handled and treated not treated at eight cases so instead we're going to leverage users innate expectations about how natural conversations are supposed to work and create opportunities for more meaningful interactions so that means for any given prompt to your user you have to be thinking of all the things that could go wrong in that moment but you can still break it down into two paths to the problem either you didn't get any input and usually that's because the user didn't say anything or because they were keep quiet to be picked up by the mic so or it could be that you've got input but you just weren't prepared to handle it in the underlying system these two categories can be addressed as either no inputs or no matches but as part of this new paradigm we're not going to start there it pays to look at how you can eliminate the bulk of your errors right off the top with some preventive strategies now first of all you want to use the power of spoken language to your advantage by using well crafted intuitive language in your prompt structure and prevent errors in the first place so there's a great talk tomorrow about this by the godfather of voice user interface design James Angola must not miss otherwise look at how you can prevent errors by being prepared to handle specific types of requests but with more robust strategy all right so your first preventive strategy you're ready to provide help in the moment so this usually means being ready for to handle if someone asked to hear something again or they express their confusion maybe more explicitly by saying something like I'm not sure why do you want to know so look let's look at how we implement that so we need to be able to first categorize these responses and then add logic to handle them some of the main concepts in Apia I include agents which can be described as natural language understanding modules for app agents consist of intense which respond to particular user inputs and contexts which are the ways to prioritize those intent as they are invoked during a conversation so during the many back-and-forth turns in your conversation each of the user responses will map to an intent so like you see here a few key ones are repeat help and quit so here's a helping tonry created in API of AI I notice how it's not just the global command help that's not the only thing we're handling all the things the user might say to ask for help how you respond to those of course will depend on your strategy and we'll show you a little bit about that but perhaps you'll give them a hint or you might ask them a follow-up question to make sure they're ready to continue to make that work we have to add additional intent for the users yes/no responses to that help prompt like you see here so ok next immediately I want to jump in and find out how do I make it even more relevant in that moment maybe by playing some dynamic data like if I want to include a variable for example sure so you can do that using fulfillment so great so as you can see in this example of some dynamic info about the game length ends the question with asking if a good user wants to continue so now they're actually listening for a yes/no answer to the health question itself yes and we can dynamically fit a context to ensure that the users yes/no response is handled by there is no help intense but so if the user got the help they needed when they heard that and they didn't say yes or no but they just answered the original question before they ask for help so we wouldn't want that to trigger an error otherwise we're sort of defeated the purpose is to the image yeah right so we don't have to worry about that since the other gaming pins are still available and we'll handle it if that happens okay so that's help and some of the questions that come up in the moment like repeat so it's a pretty big prevention strategy out of the way another very basic strategy is to prevent frustrating back-and-forth is to simply make it easy for users to leave so they might need to stop for a variety of reasons so being prepared for that is not only key to preventing errors but it's the right thing to do also it can be an opportunity for reengagement for example perhaps let them know how to come back or pick up where they left off if that's an option but without being annoying so we need to meet kripp for this we need to create another intent for quit right yes so start by anticipating all the ways the user might want to leave so just like health which phrases you might choose depend on the context so for this game example here we can see we've added some custom phrases that are appropriate for a game like stop the game or stop playing and just like health we want to make the response to user more meaningful and since it is a game I want to give them the satisfaction of knowing their score where they left off yeah so we'd like we showed you of help if you want to include a variable that's where fulfillment comes in and so here you can see our quit intent and we're giving the user the score before saying goodbye so to give you an idea just how these prevention strategies are so critical to catching things in context and why that matters so much is take a couple user responses that really means something different depending on the situation take for example I don't know and I give up so in most context I don't know means it's just another way of saying help you know but if you're playing a game and that may or may not hold true so for example on the one hand you could have a game where the user maybe wants to know a little more about the rules and they're not familiar with it so in that case sure I don't know means help like any other context but if it's a familiar mental model like guessing game or trivia where the user says I don't know or I give up in my fist mean they want the answer so they can move on so in which case it's literally the opposite of quit and means let's keep playing now this might mean breaking up your health or I don't know phrases in two different contexts take two games we've been working on in our number guessing game number Jeannie here on the Left I give up as part of the quit intense but with the trivia game on the right I give up as part of the I don't know intense this lets users skip giving an answer to the question all right so another way another way that to prevent errors is to use the built-in capabilities of the platform so we've just announced several of these at i/o so our twos and I we support commonly the accents called conversation helpers now these are being crafted to follow best design practices and also to handle errors so we recommend that you use these so you don't have to create them for yourself alright so that's a lot of deceptively simple but often overlooked error prevention strategies those should help your users feel more in control of the interaction overall now let's get to the unavoidable stuff so as we said earlier even in conversation between humans hesitations and repair happen and as we know speech recognition isn't perfect so when it doesn't work let's call those errors for now so we've got a couple great strategies coming up where we will make them feel a little less like errors per se and more like new turns in the dialogue like we've been promising but before we show you that we think it is important to see when it's what it looks like when you do start from scratch we'll look at our basic errors the no inputs and no matches if you create a new agent in API todayI you get to the fault intent as a starting point the agent will start by greeting you with the default of welcome intent and if you don't say anything it'll hit a couple of no inputs and give up if you do respond you'll hit a no match so you're saying but starting from scratch we have a clean slate of only error yeah so let's take a look at how the default agent handles no input we're going to play a video of me invoking the agents under Google home and not saying there's default actually huh I didn't hear what you just said hon I can hear what you just said hi sorry I can't help and for no matches for no messes well that was invoked the fourth fallback intent which has a set of static responses that are selected randomly to respond to the user so anything the user says will go to the default fallback intent so let's take a look at that okay let's do that so we have another video and the best anything about me I don't do default action sure here is the test version of default action hello hi I miss what you said say it again I said hi sorry could you say that again I didn't get that I'm trying to greet you can you say that again what was that I said hi I didn't get that can you say it again what would that why did I have to repeat myself sorry what was that okay goodbye okay so as you see the conversation never ends and if you want to change that you have to add a custom intent to handle the first user response obviously that's no way to hold a conversation and we do have a lot of built-ins that you can add but it's important to start from that just to see how it works if you were to start from scratch so that all the things that we show you next will start will make sense and connect otherwise API AI does provide some sample data and pre-built agents for common use cases that you could start with instead and we're always looking at ways to improve the tools better by default so in the mean time we'll use that as a baseline and explore some more targeted solutions okay now let's take the case of when no input is triggered so here remember that the user either actually didn't say anything or perhaps they got distracted or they didn't hear the question maybe they were listening they didn't understand and they're just waiting to hear what it would do next but it could also be that they started talking during the prompts and then stopped talking right when the mic started listening so how do we design for that well for no inputs you probably need to consider first if you even need the answer to get get to the next step so how you react should really consider why the user didn't respond all those reasons I talked about so it's a new turn in the dialogue there for an opportunity now we have some examples that show the difference it makes your wording depending on how hard you want to try and how much help you assume the user needs so when you write read prompts for no input you should keep them contextual but that doesn't necessarily mean repeating the exact same question verbatim so maybe you just need to reframe it or reword it to slightly or maybe you could use it as an opportunity to answer an unasked question and as far as and as for how many times you want to try maybe you don't want to belabor it and maybe you just want to gracefully exit or but for most cases you could make use of some sort of default pattern right now the default is 3 but maybe in might change that and find out just specify what you want it to say for each of those 3 so that's a design strategy for no inputs let's look at let's take a look at how to implement ok so as I mentioned earlier the default API AI by default API AI handles the no inputs for you by using a list of standard from now to change these prompts to be domain-specific you need to implement your own fulfillment logic now as part of a SDK for developing actions we provide a node.js client library that makes it really easy to do that the client library API lets you specify the no input prompts like these I didn't get a number just go there what you'll get and the conversation automatically ends after that third final prompt so for example we can stop here let's play again soon that's how we're ending it now let's look at the biggest opportunity for creative error handling no matches so just like with no inputs deciding whether use the default fallback for your no matches or something more targeted should be based on the kind of interactions you're designing for again you need to consider if the answer is even needed and if it is you have to consider the user situation and even the sequence of questions and if you don't need it that's where you also might decide to just move on pivot or gracefully end so that seems like a lot to consider so where do we start so during any conversation it's important to stop and look at what's happening in each turn so usually in one turn in a dialogue one participant is usually the owner of the information that the other person is seeking so depending on the context of the question and which side of the conversation has that information the strategy will vary so let me show you three examples of why this matters in this question the app knows the answer and the users guessing but they do have a good mental model of what's expected so potential errors are at a pretty low cost if they don't know or they need help they're likely it's just that they don't know how the game is played or maybe they want to know how many guesses they have and or like we said earlier maybe they just want to give up and have you tell them but take this question for reservation exchange here only the user knows the actual answer but you can make some logic assumptions like expecting a certain range and most of the time the answer you know will probably be something like 20 or fewer people so if the user needs help or says I don't know then the strategy you can use depends again on how critical that answer is to continue to the next step so take a third example where both sides are trying to match on shared knowledge well both sides are supposed to know the answer anyway but especially in this type of scenario where it's likely some sort of gatekeeping mechanism the user may or may not know what it is or they want to know why do you need this information why are you even asking me this and so for those types of situations they're much more likely to need in context help to continue so a good strategy here is to consider it contact by context and offer up what might be more useful in that moment exactly so whatever is most likely to keep the conversation moving forward is what would you would use to decide on how to re prompt so how do we decide on the wording I'm glad you're out well first of all there's nothing wrong with having a few generic fallback messages so we call these rapid reprints users often just need some sort of quick signaled indicate that you didn't pick up with exactly what they said the first time however this strategy only works if you were listening for the right things to begin with so if you aren't catching what they said the first time and you don't catch it even when they repeat themselves you can imagine how that gets pretty tiresome pretty quickly so you need to consider the user situational context for each and every question carefully of course so it often means asking maybe another way sometimes it even means breaking down the question into part maybe even you're listening for both but you might just ask for one just to move the conversation forward now depending on how important again the information is that you're asking for you can also make use of escalating detail to let users in on what is it you need from them and why are you asking again to keep a conversation moving and answer that unasked question and finally depending on your apps persona and how assertive it is you may also decide to be proactive and take control of the situation so let's look at how you go about implementing some of these more robust strategies first of all it'll require implemented performance for the default for wagging tail now the performance logic will then create these responses dynamically encode the core implementation strategy we recommend is the track user progress layout you're reap romps and like they say when you love something you've got to know when to let it go so for the absolute we've built together our code logic uses counters and various session variables to keep track of the users progress for example here's the performance logic for number Jeannie where we use a counter to check how many times the user providers response that was handled by the default or back in 10 now our client library for the performant logic provides a way to store data within a user session you'll then use those counters to build a dynamic reap romp strategy using both a combination of generic fallback sometimes and context-sensitive approaches like we talked about earlier now in API AI the default for backing things can be a starting point with a minimum set of basic three prompts here we have a set of default rapid rebrands that just provide a catch-all anywhere and will reap romp the users to say their response again from there you can change those defaults to suit your app so you might just want to add more to that list and add a few different rapidly props the agent will then randomly select from your prompts whenever a no-match event is triggered so but like we said sometimes you might want to pivot and ask the question a little differently though so a rapid repro so in this instance for example we created again and we wanted to use the default handler to ask a yes/no question whether the user was done playing it's so generic and catch-all but we've customized it to fit the strategy of our game but to get users back on track you actually might want your reap romp to not be generic so you want to read prompt with a little more context like some of those examples we showed you so to plan for the logic needed to implement the context-sensitive repro it really helps to see them mapped out ahead of time in some user journeys and sample dialogues first for example when I walk through the journeys nandini wrote for an Amber Genie they drove what variables and states needed to be tracked in the app for format logic and each time Yuri prompt look for opportunities to add some variability or reframe the question so this will lend more naturalness to the dialogue and help users sometimes not even realize they're experiencing an error per se so to reframe the question you are we can use the feature an API AI that allows you to tag in things with labels called context here's one that is tagged with the get time context and this is the fulfillment logic with the default fallback intent for the get time context and what it looks like so these can also be statically assigned in Apia is web GUI for each intent for example here's a list of intents we designed for a trivia game notice all the expected user responses we handle using many different intents including help quit and restart now let's say you wanted to combine both strategies we can show you how to implement both together in a more escalating reform strategy now from experience we know that rapid reforms work but we also know depending on the user scenario we might want to pivot after another error so to do that you'll need to keep a counter and increase it every time that the refuser sauce is handled by that solve a consensus so here's the performance otic for the default for baking paint for our trivia game notice how we use a counter that is stored in the station data further the first time the intent is invoked we provide a rapid reprocess and by using the client library ask function and for the second time we respond with a fallback response now obviously that escalation shouldn't go on forever when it comes to no masses no one to give up now after you've tried a couple of times once the counter goes above a threshold down out of the conversation gracefully now how you worried that again is precisely depends on your persona so back to the trivia game default for backing inhaler when the user response triggers the intent for the third time we provide a fallback prompt and then in the conversation by using the client library Cal function however if of course it's a conversation with the user recovers and another intent is invoked like we talked about about earlier if they actually answer the question then it's not a default fallback in sense then we reset that counter value now those were just the basics just the basics yep so from here you can find lots of ways to step up your conversation repair game even more I feel like yeah but wait there's more so one way is to inherently disguise errors so by adding national Nasseri ability to make the entire conversation feel more engaging so the key is that it doesn't just apply to your aircraft but all the other prompts everywhere else so this is one of the many ways that designing with a particular persona in mind all you have comes in really handy so we keep hinting at this persona so I'll show you one example of what we mean so for example in the trivia game we've been working on we use a teacher persona his name is mr. Montgomery which we he would be the type of character that is super encouraging and he really wants you've got this that's his you know he's a he's a teacher right so so to give you an idea our pizza is over 50 ways of saying you got the answer right and over 30 ways to prop you up if you got it wrong also again this is stepping up your game use threading techniques so in spoken dialogues between humans elements of a conversation are woven together in a coherent thread and it includes both context and the way the conversation evolves over time so this type of threading it helps us keep track of that conversational flow now you would have to write the prompts that thread work together well but programmatically speaking you need to support that flow in some underlying framework and that'll use tracking context and counters just like we've talked about before so to support variability in threading you could build a robust list of prompts and randomize them and you can scale that to any number from sabartés changing the code if you can randomize three you can randomize 103 the prompts can also be concatenated to create a large number of permutations and you can add a dynamic values by formatting it forms with variables that are replaced at runtime and to prevent the user from hearing the same prompts in sequence you could remember that which prompts you've played and avoid them when you're randomly picking next from the list you can also track the number of errors and in what sequence they occur finally it's after you've deployed your app your error handling approach doesn't stop there so you should check in with what your users are doing and you can adjust your strategy if needed now API AI provides a training feature which allows you to track which user responses are not being matched buying things now this feedback could be used to expand your support for the user query it can also give you hints on what new and tins might need to be added to your app so one powerful notion to remember is that users who are not encountering errors should feel the benefit of progressing through so that when an error is encountered they don't feel derailed so also it's proven that reminding them how far they've gotten or that they don't have far to go will help them get back on track okay that's enough strategies for now let's look at these in action okay so we're going to show you a demo of number Jeannie which we designed and put together and it's available as a sample on our site so we chose a number guessing game because we felt like you guys as developers you could mentally map a number guessing game and you can sort of picture some of the concepts we've been talking about so we've built in a hidden developer mode and this game is public welcome to try this out and I'm going to pray to the demo gods that they don't smite me here but there's a hidden developer mode in which we can set the number that the genie is thinking of and we're going to guess around it so that you can hear some of the strategies that we talked about right okay hey Google let's talk to number Jeannie about 21 sure here's number Jeannie welcome back to number Jeannie I'm thinking of a number from 0 to 100 what's your first guess 15 it's lower than 50 have another guest ah zero I see what you did there but no it's higher than zero 30 I didn't hear a number thirty you're getting warm it's lower than 30 have another guess 17 it's so close but not quite 19 it's higher than 19 what's your next guess 20 are you done playing number Jeannie no great what's your next guess 21 well done it is indeed 21 wanna play again no thanks okay so now it's really interesting to see the interaction but you know a number guessing game is deceptively simple if you just think about it as comparing a number and a guess but it can be designed to be delightful by adding layers of tracking in the game logic so let's look real quick under the hood at the fulfilment logic of number Jeannie now we check a lot of things in the conversation notice that we use a counter for four backs we also track the number of guesses the value of the previous guess and how many times the user gives the same answer now we also consider how far away the user gate is from the answer as the user gets closer to the answer in which the demo didn't work there we provide Rapids reprocess and encouraging sound so try it out yourself and you'll see there's a few hidden gems in there and the way a tree prompts and that throws in a few sounds and you're getting a little closer will far away now we also remember if we gave the user a hint in what direction Beyonce is and we change the prompts and track when the user followed or ignored our hands be sure and try that out too now you can see some of the problems we use in the game we dynamically provide values for the variable characters in the prompts based on the user and the gamestate so I hope we've shown you a foundation of building your conversation repair strategy we talked a little bit about the types of error events to plan for how to use built-ins and other existing tool features to implement in your design and prevent the bulk of errors by anticipating and tracking user progress in context but the key to any strategy for creating a conversational experience especially for when things go wrong is to step back and look at the user's situation don't create dead ends when something didn't work so remember it doesn't have to be treated as an error now they are more Docs and resources available on our site including white papers and a design checklist which includes an entire list of conversation repair check items also take a look at the sample apps that we have open source and github these are also a lot more talked about conversation design tomorrow as well as offer to us so you can talk to some of our teams and because we think some of the best strategies will come from you we want to hear all about what you come up with so as you saw yesterday we announced the actions on Google developer challenge we had a little part in that remember that when you're creating yours that any winning app probably will have a killer conversation repair strategy at its core right and we can't wait to see what you create thank you thanks [Applause] [Music] [Music] 