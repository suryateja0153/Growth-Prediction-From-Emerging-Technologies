 how might quantum computers destroy computer security by utilizing Shor's algorithm last week we made a ton of progress toward our goal of hacking into an encrypted message remember popular forms of cryptography work by multiplying together two large prime numbers and using those Prime's as keys to recover the message so to crack the code we'll need to find the prime factors of a really big number but that would take a classical computer a long time way longer than the encrypted information is probably useful for but Shor's algorithm allows us to quickly factor large numbers using a quantum computer to learn about the outline and big picture of Shor's algorithm check out last week's episode after that come back here because we're about to dive into the quantum portion of that algorithm for that it'll also be helpful if you have some background knowledge about how a Swanton computer works luckily we've got an episode for that too there's a popular notion that a quantum computer is just a bunch of classical computers working side by side in parallel that's kind of true and kind of false let's see how we'll start by looking at one classical computer what's the most straightforward way it could find the factors of a number and well it could check is to a factor is 3 a factor is 4 a factor and so on but if n is big this might take a lot of steps now if a quantum computer is just a bunch of classical computers working in parallel then we could have one computer check if 2 is a factor another check if 3 is a factor and so on then it would only require 2 steps we've split the many steps of a classical computer among the many parallel computations of a quantum computer here's the problem when we say that a quantum computer is a bunch of classical computers working in parallel what we really mean is the quantum computer is in a superposition of basic states which are the kind of states a classical computer could be in remember a superposition is a combination of basic states and there's some probability associated with observing each of them to find that probability you square the amplitude of the number in front of the basic state here we have n basic states and a 1 over N probability of being in each state so the quantum computer is not actually in all of these states it's more like the quantum computer has split itself into n different pieces but when you measure a quantum computer that is asked for the result of a computation it doesn't tell you about all n pieces it in instead it will pick a state each with probability 1 over N and tell you what that state says you can't look at the whole thing just one random state that's a problem for us only two of the n states give really useful information that the number it checked was a divisor of n so the vast majority of the time we run the computation n minus 2 over n of the time the result will just tell you that something is not a factor of n that means our algorithm is no more efficient than checking random numbers to see if they are divisors using a classical computer to harness the power of quantum computation we need each of these basic states the components of the superposition to be working together right now their functioning is separate computers individually searching which is a problem because the quantum computer can't tell us about all these independent states but if there's some kind of underlying structure to the states we can use that to amplify the states with the correct answers in this case the ones that give the factors of a number then when we measure the quantum state we'll have a high probability of ending up with the correct answer in fact that summarized in the tagline of a fantastic blog written by C radical computer scientist Scott Aaronson quantum computers would not solve hard search problems instantaneously by simply trying all the possible solutions at once so instead of checking each number smaller than n to see if it's a factor how does Shor's algorithm find the factors it needs to utilize the properties of its entire superposition and not just a few of its basic states to do that Shor's algorithm actually uses some number theory to transform the problem of finding the factors of a given number into a problem of finding a different number the period of a particular periodic function in last week's episode we outlined the number theory in Shor's algorithm for finding the two secret prime factors P and Q of a given number n that is n is equal to P times Q here's the four basic steps step one pick a number a less than n at random check to make sure it's not a factor of n step two find are the period of a mod n step three check that our is even an a to the R over two plus one is not congruent to 0 mod n step four let P be the GCD of a to the R over 2 minus 1 and n + Q be the GCD of a to the R over 2 plus 1 and n then you found P and Q the two prime factors of n but step two is the obnoxiously long step remember n is the number we're trying to find the factors of an a is a selected number smaller than n we're trying to find the smallest number R which we call the period such that a to the R is congruent to 1 mod n it's pretty easy to find the period of a small example just by checking the powers of a mod n until we get one so if n is equal to seven and a is equal to two we compute 2 to the 1 mod 7 is 2 to the 2 months 7 is 4 and 2 to the 3 months 7 and 1 so the period is 3 but if n is really big then R as the period can be basically as big as n there's no known efficient classical way to find the period remember how we tried to find the factors of n by letting the quantum computer active n parallel classical computers and using each to check a different factor we could try the same thing to find the period we begin with n different states representing the numbers 1 through n then for each state we compute a to the X mod n where X is the number of the state so now the states R is 1 mod n a to the 2 mod n a to the 3 mod n and so on then we just look for the smallest one that says 1 and we're done right that's when we run into the same problem as before we can't just scan all the states at once when we look at the result of a quantum computation it just shows one random state which isn't very helpful but there's something different about this current problem something that will help us the period is a global property of this quantum superposition it's not just a special fact about one or two of the basic state it's a fact about this entire wave of numbers created by the superposition how often it repeats that's the period we can use this to our advantage we apply something known as the quantum Fourier transform to the superposition able to 1 mod n a 2 mod n a to the 3 mod N and so on the quantum Fourier transform utilizes the idea quantum physics to do exactly what we want it uses resonances to amplify the basic space associated with the correct period and the incorrect answers destructively interfere which suppress their amplitudes after applying the quantum Fourier transform there's a very high probability that we'll pick the correct period so how does it work to understand the quantum Fourier transform we'll need to start with a quick visual version of a branch of math known as complex analysis what we'll really be doing is adding complex roots of unity but if you aren't familiar with that concept don't start with a bunch of circles on the first we'll put two equally spaced dots on the next we'll put three equally spaced dots on the next four equally spaced dots and so on notice that we always put one of the dots on the middle right side the zero degree angle start a dial on that special point by the way these dots are called complex roots of unity now let's focus on the circle with three dots we'll move the dial counterclockwise through the points and underneath the dial will form a past consisting of arrows where the direction of the arrow is given by the direction in which the dial points for example with three dots the first arrow Point P then move the dial 1 dot counterclockwise and connect to the first arrow another that points Northwest like the dial move the dial again and connect another arrow pointing Southwest the same direction as the dial notice that after three arrows we're back where we started this is what it looks like on a circle with six dots again after six arrows were back to the starting place okay how is this helpful remember that we have a superposition whose basic States look like a to the 1 mod n a to the 2 mod n a to the 3 mod N and so on let's pick a tiny example like a equals two and N equals seven then the components of the superposition are 2 to the 1 mod 7 2 to 2 mod 7 2 to the 3 mod 7 and so on which is the repeating pattern two for one two for one two for one because this example is so small we can just see that the period of three by looking at it but how can we use our dials to figure out the period will move along the sequence a to the 1 mod n a to the 2 mod n a to the 3 mod n for each term in the sequence move every dial once counterclockwise any time we encounter a one stop and record where the dial is pointing with an arrow let's focus on the sequence two four one two four one two four one the dial with three points is always pointing directly east when we record its values so our path of arrows just runs off to the right but what happens to the dial with four points the first time we encounter one its facing south the next time it's facing west the next time it's facing north and the fourth time we encounter one it's facing east again so our path of arrows has looped back to where it started in fact this will happen with all of the numbers besides three they'll all just make loops near the starting point the distance of the arrow from the starting point is like the amplitude or probability of a state since we are most likely to observe these states at the end of the computation or set we've magnified the correct answer and that's roughly how the quantum Fourier transform works here's another way to think about it pretend you're on a swing with period three sex it swings back and forth every three seconds the arrows from before are like the kicks on a swing at you time as you try to get higher and higher on the swing if the kicks are timed off resonant with the swing natural frequency so anything other than every second then you end up slowing down the swing but if every kick is timed to match the frequency of the swing every three seconds you create residence amplifying the swing motion if we start with a bunch of states metaphorically swing with different periods then only the swing with the correct period will be moving after a while it'll be the state with the biggest amplitude or highest probability of being observed of course there's no actual dials or arrow paths or swings in a quantum computer that's just a visual representation of adding complex numbers which are the amplitudes of waves waves and their crazy ability to either reinforce each other with constructive interference or negate each other with destructive interference are at the heart of quantum physics the dial with three dots is showing constructive interference by making the arrow path grow which represents the likelihood the quantum computer will measure that state the other dials are destructive ly interfering making it less likely will detect them and just because I like to leave things on a down note quantum computers don't really exist at least not in any capacity large enough to use Shor's algorithm to factor numbers bigger than the ones you can figure out quickly on a piece of paper but it's likely just a matter of time before real quantum computers are factoring away see you next time on infinite series hello I just wanted to respond to some of the comments about our first episode on short algorithm so neon Bowl says when N equals P times Q then if the square root of n is not a whole number it umpires that one of the primes is less than the square root of N and one is bigger than the square root of n that's true so what that means is that if you're checking to find all of the prime factors of a number n you only need to look below the square root of n but it doesn't make that big a difference because this n is really really big then the square root of n is really big so it's still a lot of numbers to check all right Bhargav are said what if we had more than two prime factors that's a great question short of algorithm still works it still works for number two more than two prime factors you have to modify the fourth step a little bit but it's not that big a deal I chose to focus on the case where n just had two prime factors because it's a little simpler and because that's what's applicable for RSA cryptography alright finally Bob sees summary of how he experienced this episode made me laugh peace n watch straight through start over pause think pause think watch again pause Google Wikipedia pause google map world please watch again write some Python peek ahead to Shor's algorithm I like this partly just because it made me laugh and partly because that's how I think most people experience math it takes a lot to process all the details and you have to keep coming back to things and try a new angle read about it from a different source sleep on it maybe go for a walk there's just a lot of absorbing that happens in learning mess and I think it's pretty fun all right have a good week 