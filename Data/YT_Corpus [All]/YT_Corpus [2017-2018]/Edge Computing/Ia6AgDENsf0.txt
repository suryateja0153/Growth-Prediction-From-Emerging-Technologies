 so we have seen how to use breadth-first and depth-first search to explore whether there is a path from a source to a target vertex but one can do a lot more with these two procedures so recall that a graph is a set of vertices and a set of edges which are connections between the vertices and these may be directed or undirected now when we do breadth-first search we do a level by level exploration starting at one vertex when we do depth-first search each time we go to a new vertex we switch the exploration to that vertex and whenever we reach a dead end we back up and one of the features of depth-first search is that we can keep track of the order in which we enter an exit vertices in this recursive procedure so now let's see how we can use BFS and DFS to find out more about the structure of the underlying graph so one fundamental property of an undirected graph is whether or not it is connected can we go from every vertex to every other vertex so you can see in these two pictures that the graph on the left is connected because you can go from every vertex to every other vertex on the other hand on the right hand side some vertices cannot be reach from other vertices for example one cannot go from 2 to 7 or from 6 to anywhere else now when we have an undirected graph which is disconnected we are also interested in finding out what the connected components are so we want to group together those vertices which are connected to each other into one unit and find out which of these units are there and how many such units are there and which vertices belong to the same unit so our first target is to use BFS or DFS to identify connected components so this is quite easy to do we start with the node labeled 1 or any other node now we run BFS or DFS from this node and in this process we will mark a number of nodes as visited at this point if there are any vertices which are not visited by BFS or DFS starting from the first node this means that they do not belong to the same connected component so it is easy to show that what is marked visited is equal to the connected component so the connected component containing the start node so now we go back and we look at the first node in the list which is not Mach visited and we restart BFS or DFS from that node so we will get a new connected component consisting of those vertices which are reachable from the first node which was marked and connected now there are still nodes which are running visited we restart from one of those and go on so what we can do now is we can label each DFS with a different number so at the end we can associate with each vertex the number of the component in which it was discovered so let's look at an example of this so supposing we have this graph we begin by having an extra variable in our BFS for example or even DFS called comp to number the components so we initially said comp to 1 and maybe we start our DFS or BFS from node 1 so in this process we will visit 1 2 5 9 and 10 and for all of these we will set component of J equal to count now at this point we will realize that not all nodes have been visited only 5 out of the 12 nodes have been visited so we go to the smallest node which is not visited namely 3 and restart but before we restart we update comp to 2 now we start a BFS or a DFS at node 3 and visit everything that we can reach and in this process we would identify these six nodes as being in component 2 at this point node 6 is still not mark visited so we restart the third round of BFS or DFS with comp set to 3 and identify a third component now there are no more unvisited nodes so we can stock and in there as a result of this repeated application of BFS and DFS we have identified all the components and also clustered them so that all nodes in the same component are associated to the same component number another interesting structural property of a graph is whether or not it has cycles so an acyclic graph is a graph such as the left in which you cannot start at any node and follow a sequence of edges and come back to the node on the right we see a graph with cycles so for instance five nine and ten form cycles there are also other cycles there are several cycles for example three four seven eight as a whole former cycle but there are also smaller cycles within it like three four eight and three seven eight and seven eight level is also a cycle and so on so one of the things we can do when we execute BFS is to keep track of those edges which are actually used to mark where disease has visited now if we have an acyclic graph such as the one on the left you can check that every node that is in the graph will actually be used as part of the BFS search on the other hand if you run BFS on a graph which has cycles then you will find that some edges are not used because when you try to explore those edges you find the target vertex is already visited for instance since 10 is already visited as a neighbor of 5 when we start exploring 9 we do not use the edge 9 10 likewise we don't use the edge 4 8 because it is already visited as a set of neighbors of 3 remember in breadth-first search will go to 3 and X 4 always one step neighbors so we will mark directly for 8 and 7 is visited so when we come to 4 we don't need to use the edge for 8 when we come to 7 we don't need to - 7 8 and so on so there are these edges which are left out now it's easy to see that if we have a graph with n vertices and it is connected and it doesn't have cycles then it will have exactly n minus 1 edges this kind of a graph is called a tree so there are many definitions of trees but trees a tree is basically a connected acyclic graph connected means you can go from everywhere to everywhere acyclic means there are no loops and any connected acyclic graph on n vertices will have exactly n minus 1 edges so in any graph if we explore BFS the edges that BFS actually uses will form a tree and this is called a BFS tree now what happens about the remaining edges well these are called non tree edges and what you can check very easily is that any non-tree edge will combine with the 3 edges already to form a cycle in other words when we run BFS if we find that there are some vertices or some edges rather which are not used in other words there are any non tree edges then this graph will definitely have a cycle so having a cycle is equivalent to finding a non-tree edge while doing BFS what is a non-key edge is this an edge where we come to explore I comma J and find the J has already been Mach visited so we don't go to I quote I don't use I comma J in RP at this so let's do the same thing with DFS and let's compute the pre and post numbers so that we get some practice at this so we start our DFS at vertex 1 and we mark its counter as 0 so we enter vertex 0 a vertex 1 at step 0 so this is the pre number of vertex ago the first neighbor we explore from one is spoon so it has pre 1 3 neighbor pre number 1 but 2 has no further successor so we exit from - so it has post number 2 so remember every time we enter by increment a counter every time we exit the increment a counter so we enter an increment egg exit vertex 2 in one step come back to 1 and explore its next neighbor which is 5 which we enter at time 3 then we move to vertex 9 at time 4 then from 9 we go to 10 at time 5 now 10 has no further neighbors to explore so we exit 10 at time 6 9 has no further neighbors so we exit 9 at times 7 come back to 5 again 5 as no further neighbor so we exit 5 and then finally we exit 1 so at step 9 we have completed processing 1 now we move to the first vertex which is not math namely 3 we restart a new DFS from there so we enter 3 at time 10 from 3 we moved to 4 at time 11 from 4 we moved to 8 at time 12 from 8 we moved to its smallest neighbor unvisited which is 7 at time 13 from 7 we go to 11 at time 14 now 11 has no new neighbors to explore proves both seven and eight have been seen so we exit from 11 7 has no more neighbors exposed so we exit from 7 and we exit from 8 we don't accept remains or if remain we still have to explore twin so we entered 12 bit step 17 then we exit from 12 and now eight is finished so we exit from eight now we come back to four four obviously as no other word to see so we come back to three and finally we exit from three a time 21 at this point six is still not marked so we start a new DFS from six so we enter six at time 22 but six has no neighbors so we exit six at time 23 so this like BFS generates a collection of trees so when we do DFS on a disconnected graph each connected component will generate a tree now if you look at the edges which we did not explore these will again beat edges which are outside the tree so we can draw them in a different color so we have the edge between five and ten which you did not export because we explored five at the ten directly from nine and so on so once again just like in BFS once we have finished DFS if there are non three edges then we have a cycle right so both BFS and DFS on an undirected graph can reveal the cycle through the presence of a non-tree edge so the situation with directed graphs is a little more complicated so let's see what happens when we have cycles and directed graphs so in a directed graph we need to follow the edge arrows arrows along the edges so for example 1 3 4 1 is a cycle because we can go around without changing direction whereas 1 6 2 1 is not a cycle because on the way back I have to switch directions from 2 to 1 which I cannot do so let's do a DFS and see what this can tell us about cycles in this graph so we begin with vertex 1 as usual so 1 has 3 number 0 its smallest neighbor is tuned in the smallest neighbor of 2 is 5 the smallest neighbor of 5 is 6 the smallest neighbor of 6 is 7 now from 7 there are no outgoing edges so we backtrack to 6 from six the only note that we can go to it's to which we have seen before so we leave six now we come to five five still has an outgoing edge which is eight so we come to an eight now from eight we can't do anything so we return from a back to five now five has nothing left to explore so we leave five likewise we leave two finally we come back to one now at one we have explored this left path so now we cannot we don't look there we look in the other direction go to 3 so we explored three three we'll explore four but for cannot go to a tour 1 because 1 is already been seen and so is 8 so 4 will exit so 3 will exit and then one will exit so this happens to be a single connected graph but it has cycles ok so now if we first look at these edges the edges that we have drawn are 3 edges as because now if we look at the edges that have not been part of the graph they fall into three groups so the first type of edge which is not a part of the tree is what we call a forward edge so forward edge is an edge which goes from a node to a node below it in the tree so we have a known from 1 to 6 for examples with this edge he is a tree edge so it's not a tree edge but it's a forward edge because one was above six in the top likewise the node from 5 to 7 right because we actually explored this graph is 5 6 7 so 5 to 7 or not so these are forward edges the other category of edges which are there in the graph which are not in the tree ad backward edges they go up the tree from from 6 there is this edge back to 2 which we did not use because who had already been explored likewise from four back to 1 there was this edge who did not explore because it was already there there is another category of edges which are not there in the tree but which are there in the graph and these are edges such as from 6 back to so this was an edge from a later vertex to an earlier vertex or from four back to one so these are what are called back edges so a back edge is a page in the graph which in the DFS tree goes from a lower vertex to a higher vertex and finally there are some edges which are neither going forward nor backwards but sideways so these are edges like eight to five okay sorry are 8 to 7 and from 4 to 8 so these cross so 4 is not below 8 nor is eight below 4 7 is not below it because they're fourth below 5 and so on so these we call cross inches now it's easy to argue that a cross head will only go from right to left in other words it probably go from a higher number to a lower number because if we wanted to draw an edge like this for instance then this would mean that there was an edge from 2 to 4 so we would explore four through two rather than wait and go back to 1 and exploded thing so we cannot have sausages which go from lower numbers to higher must go from higher numbers to lower edges so now we have not one but three types of non create is unlike the directed case when we had a clear distinction between three edges and non three edges here we have three types of non creators now which one's of these correspond to cycles so if I look at this one three eight so there's one three edge so this one six edge so this one six edge doesn't actually create a cycle because we already saw that this is not a cycle so in order for it to complete a cycle it must be the case that there is a path including the set which forms a directed cycle now it's easy to see that the only situation where this will actually happen is there is a package because if there is a back edge we know that there is a path coming from two down to six and then by following the back edge this forms a directed cycle likewise we know that there is a path coming from one down to four and the following is right if we follow the requisite on the other hand if we look at the other types of edges for instance then we have this path here but is parallel to the other path here right so together these are both two different ways of going from 1 to 6 but they are not affected in the same way we can see that if we have a cross edge like this then we have some path coming from here and some path going from there but again they are just two different ways of reaching 7 from 5 and they are not really a cycle so it turns out by little analysis that only back edges form cycles and this is actually something that you can prove we will not prove it formally but it's argued the way we did this now that a directed graph has a cycle if and only ifs only reveals a package now it turns out that these pre and post numberings are very useful to help us classify the types of edges that are there in the car so for both 3 and forward edges so you will notice that if you go back to this numbering that these things form an interval that you can think of this as from 0 to 15 from 0 to 50 now exploring one from step 11 to 14 I was exploring free from step 2 to 9 I was exploring 5 and so on so if you look at the three and the post number he says I started exploring the number at the tree and I finished exploring at force and everything else that was below happen in between and so for a forward edge the interval above will be smaller than the bigger than interval below because I start I went below during this period and I came back before it ended so for instance the forward edge from 0 15 to 3 comma 6 so the interval 3 6 is inside 0 this is also true for tree edges because in the create also can going forwards I entered the lower load after I entered this so it's starting point will be later and it's ending point will be early so for both 3 edges and forward edges if I am going from u to V then the interval with the start node you will contain the other one so this will be sitting inside this the previous V will be sitting inside pre you post if I'll have this picture so this is the interval Queeny and this is the interval conversely it's exactly the opposite for backward edges I start from a smaller interval and I go to a bigger interval so the smaller interval will be the starting a point with it and the bigger it will be the love ending so if I look at an edge in my DFS tree and if I look at the pre and post numbers associated with the endpoints I can determine whether it's a forward or create or a backward edge and finally it will turn out that for crosses it is the intervals are disjoint so we can see here that we have finished processing for vertex seven before we get to it so there is no intersection between the interval seven eight and four five likewise we have finished processing eight before we went to four that's why it's a cross as they are on different branches of the tree so there is no intersection between seven eight and twelve thirty so therefore a directed graph has a cycle if and only if DFS reveals a package and we can classify edges as being forward edges backward edges or processes by just looking at the pre and post numbering of the endpoints of the edge now it's important to identify cycles because if we don't have cycles we have a very nice class of graphs called directed acyclic graphs these are useful for modeling dependencies for instance if we want to list out a bunch of courses which are being offered and they have prerequisites then a natural way to model this is using a directed graph where the edges represent prerequisites for instance if they have an edge from algebra to calculus it indicates that algebra is a prerequisite for calculus it will not have cycles because we cannot have two courses which are prerequisites for each other otherwise we will not be able to take either course so we will look at directed acyclic graphs or DAGs soon in a later lecture what about connectivity in directed graphs so connectivity in a directed graph is not just a question of having app these edges between the graphs but having them in the right direction so we say that two nodes are strongly connected if i can go from i to j by a path and i can come back from I to J to I by path right so it's not enough to just have edges in some haphazard ejection I must be able to go from I to J and come back from date Y in which case I say they're strongly connected so it turns out that a directed graph can always be decomposed into what are called strongly connected components a strongly connected component has a property that every pair of nodes in that component is strongly connected from every node in the component you can go to every other node in the component and come back so for instance if we look at this strap then the strongly connected components one is this cycle one three four we can go from one to three to four and come back so from a node in this cycle we can come back to any other node likewise two five and six forms a strongly connected component seven on its own is a strongly connected component because we cannot go anywhere and eight also is a strongly connected component because if we leave eight we can't come back to a to the way this graph is structure okay so this graph has four strongly connected components now it turns out that DFS numbering using pre and post numbers can be used to compute strongly connected components a very elegant algorithm is given in the book by - Gupta property bit row and why is it running and if you are interested you can look it up in their book so we have seen some concrete examples of what you can compute there are many other properties that you can compute using B FS ntfs for instance there are these things called articulation points if your graph looks like this where I have some vertex which is a crucial vertex if I remove this vertex this graph falls apart in two disconnected components I can identify such vertices using p FS and D F set in particular using DFS similarly if I have a situation where I have an edge like this where if I remove this edge then the graph gets disconnected then I can again to identify such an edge using DFS now these are important because if these graphs represent some kind of communication network or some road network and these are bottlenecks these are critical points it means if this is an intersection and if there is an accident no traffic can go from any part on the left any patterns right or if this is a network wire if this cable gets cut then the network will get cut disconnect into two components so these kind of properties can also be computed during BFS and DMS so it is important to realize therefore that b FS ntfs is not just for connecting to finding out whether vertex s can reach vertex t you can get a wealth of information and these are linear time algorithms and these are all operations which can be performed during BFS and DFS so very efficiently you can compute various properties of the graph and use these to exploit these to design more efficient procedures or to identify other things that need to be done 