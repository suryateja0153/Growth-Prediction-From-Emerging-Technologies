 [Music] [Music] lecture twelve deadlock detection in distributed systems pre-phase recap of previous lectures previous lecture we have discussed about checkpointing and rollback recovery and also discussed different role by recovery schemes that is checkpoint based and log based rollback recoveries content of this lecture in this lecture we will discuss about basic fundamentals of deadlock detection in the distributed systems also discuss different classes of algorithms such as path pushing edge chasing diffusion computation and global state detection methods for designing the distributed deadlock detection in distributed systems introductions deadlocks deadlocks are the fundamental problem in the distributed system the process may request resources in any order which may not be known a prayer here in the process can request the source while holding others if a sequence of allocation of resources to the processes is not controlled the deadlock can occur so a deadlock is a state where a set of processes requests resources that are held by the other processes in the set that is the deadlock so we are going to now define the system model which we are going to use in the deadlock detection algorithm a distributed program is composed of a set of n asynchronous processes P 1 2 P n that communicates by message passing or the communication network without loss of generality we assume that each process is running on the different processor the processor do not share a common global memory and communicates only by passing messages over the communication network also there is no physical global clock in the system to which the processes how instantaneous access the communication medium may deliver the messages out of order messages may be lost may seem a garbled or they may be duplicated due to the timeout and retransmission processors may fail and communication link may go down all different possibilities can happen because there are different set of processors and processes which are separated geographically and connected by the communication network and they exchange they communicate by passing messages through the communication network which may have these kind of problems so the following assumptions are made the systems have only reusable resources first second assumption is processors are allowed to make only exclusive access to the resources third there is only one copy of each resource a process can be in one of the two states that is running or a blocked in a running State a process has all the needed resources and is either executing our is ready for the excitation in the block state a process is waiting to acquire some resource then we are going to define a data structure which is called a bit for graph which is used here in deadlock a state of the system can be modeled by a directed graph which is also called as a wait for graph wfg in a weight program nodes are the processes and there is a directed edge from a node P I to PJ if P I is blocked and is waiting for p2 to release some resource then there is an edge so we can Express wait for graft using TI n pj so this is the directed edge from pi/2 pj if process P I is blocked and this is waiting for PJ to release the resources so this kind of graph is called wait for graph a system is deadlocked if and only if there exists a directed cycle or not in the wait for graph so for example we can have another process pk now this PJ is now waiting for piqué and piqué is waiting for P I so here there is a cycle in this particular particular graph so here the cycle means a set of waiting processes this is a cycle this is a not why because there is no there is no outgoing edge out of this particular cycle and if any edge let us say PL is like this then also it is a not so this is an example of a cycle or a not and this set of waiting classes is a system of deadlock depending upon the model of resources for which they are waiting so these particular models we are going to consider in the next slides so this is an example of a bit for graph now here the process p 11 up site 1 is an edge 2 p 2 1 this edge is talking about and p 3 2 so this particular process P 1 1 simultaneously waiting for two resources which can be released or which can be given by process P 2 1 and process P 3 2 now if P 2 1 is also waiting for P 2 4 and P 2 4 is also waiting for P 5 4 and P 5 4 is waiting for P 1 1 so by transitively we can say into 1 is also basically waiting for P 1 1 then it will form a cycle and all the four processes involved in the cycle is in the deadlock depending upon the request model now this is a cycle since this particular edge is outgoing so this cannot be and not now preliminaries deadlock handling strategies there are three strategies for handling the deadlock that is deadlock prevention deadlock avoidance and deadlock detection handling of deadlock becomes complicated in distributed system where because no site has an accurate knowledge of the current state of the entire system and because every inter-site communication involves a finite and unpredictable delay so this particular scenario of the distribution or a distributed network in a distributed system makes the deadlock a bit difficult now another method another strategy for ending deadlock is called deadlock prevention is commonly achieved either by having a process that acquire all the needed resources simultaneously before it begins the execution or by pre-empting a process which holds the needed resources this approach is highly inefficient why because it is not always possible to acquire all the resources which are needed for the execution our it will be very costly to preempt a process and release the resources and allocate the resource for the requesting process in order to continue so deadlock prevention is highly inefficient inapplicable or impractical for the distributed environment now another method of handling deadlock is the deadlock avoidance deadlock avoidance in distributed system is method deals with the that the resources is granted to a process if the resulting global system state is safe note that global state includes all the processes and resources of the distributed system so here the resources are allocated in such a way that the resulting global state is safe so however due to several problems deadlock avoidance is also impractical in a distributed system deadlock detection requires examination of the status of process resource interactions for the presence of a cyclic wait so deadlock detection in a distributed system - seems to be best approach to handle the deadlock why because it's becoming a convenient in this model issues in deadlock detection so that is why we are going to discuss only one strategy that is deadlock detection why because it is most practical in the distributed system scenario to handle the deadlocks deadlock handling using the approach of deadlock detection entails addressing two basic issues the first one deals with that the detection of the deadlock and second deals with the resolution of detected deadlocks so detection of deadlocks involves addressing two issues the first one is the maintenance of wait for graph wfg and second is searching this wait for graph for the presence of a cycle or a not so different algorithms will follow different schemes for these two methods correctness criteria a deadlock detection algorithm must satisfy the following two conditions to ensure the correctness of the algorithm first is the progress the algorithm must detect all the existing deadlocks in a finite amount of time in other words after all wait for dependencies for a deadlock have formed that algorithm should not wait for any more events to occur to detect the deadlock second condition for correctness of a deadlock is called safety that is the algorithm should not report the deadlock which do not exist and that condition is called when Tom deadlocks or a false dreadlocks so safety ensures that it always report the correct state of the stable state that is called a deadlock and the second condition of correctness is the progress that means all the existing dead logs must be identified in a finite amount of time now resolution of the detected dreadlocks the deadlock resolution involves breaking the existing wait for dependencies between the processes to resolve the deadlock it involves rolling back one or more the deadlocked processes and assign their resources to the other blocked process so that they can resume the execution in the distributed systems models of deadlocks distributed system allows different kind of resource requests so that means they are represented by different models a process might require a single resource or a combination of resources for its application a hierarchy of request models are described as follows the first resource request is the single resource model in single resource model a process can have at most one host ending the quest for only one unit of resource this is the maximum out degree of a node in wait for graph in this single resource model is one so the presence of a cycle in a wait for graph shall indicate that there is a deadlock so cycle in this particular single resource model will indicate that the system is in deadlock and model in n model a process can request for more than one resource simultaneously and the request is satisfied only after all the requested resources are granted to the process that is why it is called n model the out degree of a node here in wait for graph for n model can be more than one the presence of recycle in a wait for graph indicates a deadlock in n model since in a single resource modular process can have at most one outstanding request the end model is more general than a single resource model let us consider an example consider an example of a wait for graphed in Figure one and consider it as an end model so p1 one has two outstanding resource requests that we have seen over here so p1 1 shall become active from ideal only after both the resources are granted to p1 1 so there is a cycle which corresponds to the deadlock situation why because in an model if there is a cycle that means this is a deadlock that is the process may not be in a part of cycle it still be a deadlock now another example is over here that this example says that a process may not be in a cycle yet it is in deadlock for example p4 4 is not in a cycle but p4 4 is in deadlock situation so it is not part of a cycle deadlock but it is deadlocked the our model in the orbital process can make requests for an English resources simultaneously and the request is satisfied if any one of the requested resources is granted presence of a cycle in a wait for graph in our model does not imply a deadlock in our model so let us consider the example the same example here all the nodes are or node then the process p1 1 is not in a deadlock why because if p3 has finished its execution and reduces the resources it will make the p3 active so the ones the resources are releases by released by P 3 3 it can be allocated to 3 2 so P 3 2 will also become an active after the resources are located so after finishing P 3 2 this particular resource can be can be given or can be allocated to P 1 1 so P 1 1 since it is an ore model so once that this particular resource is allocated so P 1 1 will become an active so it becomes an active it can start its execution and it will break the cycle so in the or model the presence of a naught will indicate a deadlock basically here this particular condition is only a cycle naught a naught so the presence of a not in our model indicates the deadlock the end our model is a mixed model so it is a generalization of the two models and our model and our model a request may specify any combination of and are in the request resource for example in end or model a request for multiple resources can be of the form x + y RZ to detect the presence of a deadlock in such a model there is no familiar construct of a graph theory for that use the wait for graph hence the deadlock is detected using a it's stable property so at deadlock in end our model can be directed by repeated application of the test for the our model deadlock to find out the stable property and why because if the deadlock is nothing but finally the stable satisfying the stable property now another model is called P out of Q models so another form of and our model is called p out of Q model which allows the request to obtain any K available to sources from a pool of and resources it has same expressive power as at as and our model we have seen earlier our p out of queue model lends itself to a much more compact formation of a request so every request in a p out of queue model can be expressed in the form of endor graph and vice versa note that end requests for p resources can be stated as p out of p that means all p resources are required that is the end model and the our model request for the p resources can be stated as one out of p that is an or model so p out of q can be expressed in these two forms of r and n model unrestricted model in unrestricted model no assumptions are made regarding the underlying structure of the resource requests only one assumption that the deadlock is stable is made hence this is a most general model this model helps separate concern concern about the properties of the problem that is stability and the deadlock are separated from the underlying distributed computations classification of distributed deadlock detection algorithm classification of distributed deadlock detection algorithms naps classification nap has classified the distributed deadlock detection algorithm in four classes the first one is path pushing second one is edges chasing third one is definition computation fourth one is global state detection each of these classified methods to detect the deadlock is basically different algorithms are listed over here and these algorithm use this particular strategy that we will see that is for different strategies which will classify different algorithms distributed algorithms they are listed as path pushing as changing this fusion computation and global state detection let us see these strategies one by one by pushing algorithms in path forcing algorithm this equals a deadlock detection are detected by maintaining an explicit global wait for graph the basic idea is to build global wait for graph for each site of the distributed system in this class of algorithms at each site whenever a deadlock computation is performed it sends its local wait for graph to all the neighboring sites after the local data structure of each site is updated this updated wait for graph is then passed along to the other sites and this procedure is repeated until some site has sufficiently complete picture of the global state to announce the deadlock or to establish that no red locks are present the name path pushing here in this algorithm is used because the local data structure is sent along the path to different processes connected by the communication network hence the name is path pushing algorithm so that means the local wait for graph which is constructed by a particular node is sent along the path and once they are collected at all the ends so basically one node will get a complete picture of some site will get a complete picture of the global state and it will announce the deadlock are established that there is no deadlock present this feature of sending around the parts of the global wait for graph has led to the term path pushing algorithms so the algorithms which uses this strategy is called basically classified in this particular methods that is path pushing algorithms that we will see later on excusing algorithms in exchanging algorithms the presence of a cycle in a distributed graph structure is to be verified by propagating a special message called probes along the edges of the graph flow messages are different than the requests and replies of the computation the formation of a cycle can be detected can be deleted by a site if it receives the matching probe matching probe sent by it previously so whenever a process that is executing receives a probe message it discards the message and continues that means if a particular process which is an active process and if it receives a probe so it will just discard this particular message why because the deadlock involves only the set of blocked processes and if the process is working that is not a part of the deadlock sense it discussed the message and continues its current execution only the blocked processes propagate the probe message along their outgoing edges so the main advantage of as chasing algorithms is that ropes are of fixed size and they are small in size hence the overhead of message size is very very minimal and that is the advantage of exchanging algorithms diffusion computation based algorithms in diffusion computation based distributed deadlock detection algorithms deadlock detection computation is diffused through the weight for graph of the system these algorithm make use of echo algorithms to detect the deadlock this computation is superimposed on the underlying distributed computation there is no separate execution for deadlock detection is taking place so if the consideration terminates the initiator declares the deadlock to detect a deadlock a process sends outer query message along all the outgoing edges in the wait for graph these queries are successively propagated that is diffused through the edges of the wait for graph so when a blog process receives first query met is for a particular deadlock detection initiation it does not send a reply message until it has received a reply message of for every query it sent so for all subsequent queries for this deadlock detection initiation it immediately sends back a reply message the initiator of the deadlock detection detects the deadlock when it receives a reply from every query it has sent out global state detection based algorithms global state detection based deadlock detection algorithm exploit the following facts the first is that consistent snapshot of a distributed system can be obtained without freezing the underlying computation that we have seen in Genting Lampert's algorithm now if our stable property holds in the system before snapshot collection is initiated this property will still hold after the snapshot is available or it will be captured in the snapshot therefore distributed dead locks can be detected by taking a snapshot of the system and examining it for the condition of the deadlock deadlock detection algorithms now we are going to discuss deadlock detection algorithm and that is given by Michel and Mariette and this is called Michelin variates algorithm and this particular algorithm is based on s chasing approach which we have discussed in the previous slides so Michelin Marriott's algorithm given in 1984 assumes a single resource model detects the local and global deadlocks each process has assumed two different labels private and public each label is accountant the process ID guarantees only one process will detect a deadlock and that is why this particular method is popular send tokens and control information on the same socket and make use of people guarantees no synchronization mechanism is required in this algorithm this algorithm belongs to a class of SCS in algorithms where the probes are sent in the opposite direction of the edges of the wait for graph when the probe initiated by a process comes back to it the process declares a deadlock only one process in the cycle detects the deadlock this simplifies the deadlock resolution this process can about itself to resolve the deadlock each node in the wait for graph has two variables and they are called label private label and a public label private label is unique to the node at all the time though it is not a constant and the public level which can be read by the other processes and which may not be the unique each process is represented as you oblique V that means the private and the public label where u and V are the public and the private labels respectively so initially private and public labels are equal a global wait for graph is maintained and it defines the entire state of the system the algorithm is defined by four state transition shown in the next figure where Z is nothing but an increment of UV which yields a unique label which is greater than both x and y labels that are not shown to change now another state is called a block state this will block will create an edge in a wait for graph that we will see in the next slide now two messages are needed one resource requests and one the message back to the block is state to inform it if the public label of the process is waiting for now another state is called an activated State activated state denotes a process has acquired the resource from the process it was waiting for now the next is another state is called the transmitted state so transmitted propagates the larger label in the opposite direction of the edges by sending the probe messages let us see all these four different state transitions in this particular picture so this is the block activate transmit and detect you will explain so whenever a process receives a probe which is less than its public label it then simply nodes that probe detect means that probe with the private label of some process has returned to it indicating a deadlock the bubble rhythm can be easily extended to include priorities where whenever a deadlock occurs the lowest priority process gets aborted and hence resolves the deadlock now we have to see the algorithm in more detail the first steps is that every node has a public and a private label both are non-decreasing additionally no two nodes ever have the same private label note X begins to wait on node Y node X updates its public label to be max of X y plus 1 when a node discovers that a node it is waiting on has a larger public label than its own it replaces its value of its public label with a larger one this algorithm has the effect of circulating successively larger public labels in the reverse order of the corresponding weight for graph if a deadlock truly exists then the node will eventually see its own public label on the process for which it waits this algorithm also has a nice property that exactly one node will detect the deadlock this property is important for deadlock resolution in addition it is trivial to modify this algorithm so that upon detection could reveal the smallest channel capacity let us understand this algorithm through an example so just see that here this particular node has basically the label both are same U and V now when it will block then this will this label public label will will increase that is x and y you have to say max of these two a plus 1 so earlier it was 1 and it was 3 so max was 3 plus 1 and that is equal to 4 so 4 is now relabeled here and this edge will come in the block process similarly you just see that if you want to add an edge so you have to take the maximum 4 and 5 is 5 plus 1 that is that is 6 so this will be 6 in the next slide we will see that 6 5 now if you want to add a label like this then 3 + 6 is 6 plus 1 that is basically the 7 so 7 will be made over here now these labels will basically move on the opposite direction of these edges of this is a wait for graph now these labels will move in the opposite direction of these edges so that these labels get updated in the next step of this algorithm will sew so it will transmit 7 and will get updated it will again transmit 7 that is going in the opposite direction to take the higher values of the label and finally when that same level 7 will come back to the same process this process will understand that this is this system is in a state of deadlock because it has detected a cycle now message complexity of this algorithm if we assume that a deadlock persist long enough to be detected the worst-case complexity of the algorithm is s times s minus 1 by 2 transmit steps where s is the number of processes in the cycle now other algorithms which deals with distributed deadlock detection are summarized here in this particular table now as you can see that all these algorithms uses different strategies of the algorithm distributed algorithm design that is all these strategies we have discussed in previous slide that is either they are path pushing strategies of distributed algorithm design as chasing diffusion computation and global state detection so all these algorithms will basically follow that principles which we have covered for example in a path pushing it will it will generate a local wait for graph and push along it path so that a particular single node will have the complete information or a complete global state and then using that global state it will so based on that scenario these algorithms are basically designed similarly there is an edge chasing one example of an phasing algorithm which we have seen similar algorithms are also using with a different resource request models diffusion computation is an algorithm which is using or which is defined on an our request model now finally a global state detection algorithm is given for resource request model which is P out of queue model conclusion out of the three approaches to handle deadlocks deadlock detection is the most promising in the distributed systems detection of deadlock requires performing two tasks first maintaining the wait for graph and second searching the wait for graph to detect whether there is a situation to detect for a cycle or not which will in turn depend model to say that whether there is a deadlock or not distributed deadlock detection algorithms can be classified in four different classes that we have seen as push paths pushing as changing decision computation and global state detection so in this lecture we have discussed one algorithm that is the Michelle and Mariette algorithm for a single resource model and that particular algorithm is based on the technique which is called in s chasing in the upcoming lectures we distributed shared memory thank you [Music] [Music] you [Music] 