 Basically, our cloud is a control point for a multiple of smart devices, and primarily how we’re providing that service is through an Edge Server, right. So, there’s some kind of software agent that runs inside the so-called Edge of the network, and that agent detects smart devices with a series of plugins, right, so there’s a plugin that is designed for, for example, LIFX, which is a certain kind of smart bulb, and a plugin designed for Philips Hue, and so on and so on and so on. And in this way it’s an extensibility model that lets us add in new device connections by only defining a really small amount of code that understands exactly just how that device communicates over a network. The other way that we connect to things is with a cloud to cloud system we call conduits, and conduits lets us integrate devices through their own first-party clouds. So for example, if you have a Nest thermostat, there’s no way to talk to that directly, you know, on the local network anymore, and so we integrate their cloud directly into our cloud. Actually, that service provides quite a bit of moving parts. We’re not only providing, you know, real-time connections to the third-party cloud, but we’re handling all of the user life cycle as well. Our API understands the notion of your end user, and so you’ve gone and made one API call that says I have a user that I call “A” and I would like to add a Nest Thermostat for user A. And we say, okay, here’s a special link just for user A, just to add a Nest Thermostat. Hand that to the user and send them to it, and then go route to Nest's page and they’ll login. And once they’ve done that we are now connected to their back-end and know exactly what their thermostats are and we can associate it with that user and put it in the right security containers, and you don’t have to do anything, right. And, once all that is done you’ll just see a Nest Thermostat show up and now you can send commands to it. It’s now seamlessly integrated with the same back-end API that you’re using to control devices through the hub, and also it’s unified through a similar interface to any other kind of thermostat that we integrate. So, we’re implementing a Nest Thermostat, we’re implementing an Ecobee thermostat, we have a Venstar themostat, and those will all have the same exact software API interface, or very, very similar, right. And we provide a unified interface and also some access to any of the platform specific functionality of that device. So, there’s a lot of leg work being done inside of our cloud that routes the right kind of information to the right device to translate between different protocols or non standards or standards, and then also provide the right security containers to organize all the devices in a way that you can build, you know, the sort of user-facing application on top it. And, in addition to that core functionality, we also provide an API we call metadata API, which lets you apply any custom information you want to any of these things in our platform as well. So, that basically lets you create a little bit of rich user interface on top of these devices. So instead of it just being all utilitarian data where it’s just the core functionality we need to operate the device, you can put custom data on it as well so it lets you render your user interface from the data that’s associated with these devices in the back-end. So, there’s quite a bit of power and flexibility there, and our goal isn’t to totally eliminate the need to run some other database, but to dramatically reduce the number of round trips that you have to make from the front-end to the back-end, so that we can provide as much of the information as you might need to render a screen for example on your user interface without having to go to another web service somewhere else and do kind of a Tango between the two web services. Okay, so there’s a concept in our platform called service classes, and service classes basically let you define a model, or a set of models, for what a device is capable of. They’re a combination of, I’m going to scroll past some text here because you don’t need to read all of this stuff, so what I want you to see is this part right here. They’re a combination of properties, methods, and events, and they’re just defined in JSON, so there’s a JSON file and the JSON file says I have a service class called binary switch, and binary switch is a thing that can be turned on and off. It has one property called switch. Switch has two possible values, on and off. So, just like in programming, properties are stateful. We can write to them and we can read from them, and they represent the current state of that device in real-time, and methods are commands basically to the device that aren’t stateful, so I can say switch on or switch off. Then there are also events, not represented by binary switch, which let’s the device tell us unstateful things that happen, so for example, if you have a motion sensor, it might have a motion event, and that event can be fired anytime it detects new motion. So, defining these service classes as these really simple JSON documents basically defines a template for the basic notion of a binary switch, for example, a thing that can be turned on and off. And that template can now be applied to any device in our ecosystem, and so everything which has the ability to turn on and turn off has the same exact software interface now. This structure lets you define any combination of these capabilities and combine them onto a single device. I’m going to scroll down, there’s a lot of stuff here. I’m going to scroll past all that to show you this diagram. So, for example, we’re modeling a Sonos smart speaker here, and it’s a combination of a binary switch and audio output media controls and media info. Audio output being the ability to control the volume of the speaker itself. Media controls being the ability to change the play state from play to pause or skip tracks. And media info being the ability to see what the media is that is playing. Right, what is the name of the artist, the album, the track, and so on. What’s interesting there is we’ve combined a combination of those interfaces and you can envision a device which doesn’t have exactly those same interfaces, right so, so for example, if you had a bluetooth smart speaker, it might actually only know the volume and be able to skip tracks, that are a common bluetooth set of controls for people to be able to skip to the next track, so it wouldn’t have media info but it would have audio output and media controls. So, basically, this allows us to build this sort of compositing of functionality that might exist on some devices but not on others, or other devices may have additional functionality. Furthermore, as I mentioned, you can take those services and apply them to a combination of different devices in the right combination, so shown here is an example of different brands and different models of bulbs and switches where a binary switch is applied to all of them but, for example, colored light is only applied to the Hue color and the LIFX edition bulbs, so now I can command those two to change color but the others just to change brightness where brightness is applied. Everything is organized into ecosystems, environments, and zones. And so ecosystems represent the largest possible container of things. Generally, you use ecosystems to represent a single product or product line that’s going to integrate together. You know, in your case it might be an entire customer. You’re looking at being able to take one ecosystem of products where you’ve got a smart device in the field and then a combination of other smart devices that that smart device can integrate with or can interact with from smart lights to smart speakers or whatever they are and put the knowledge of those things all into one ecosystem, so all of your service definitions and all of your plugins get loaded into that ecosystem. And then each user gets their own environment. So, as a user boots up and they connect to your connected device, that device gets automatically loaded into a unique environment. That user also connects to other things. Let’s say they connected to a thermostat or a smart speaker. Those things will also automatically get loaded into that same environment. So, you have this sort of convenient container that you can work with to understand what user owns which things. And a user to environment mapping is many to many, so a user can have many environments and so on. There’s a user API that lets you create, as I mentioned earlier, any user. You can call that user whatever you want as long as it is unique to that ecosystem, right, because that ecosystem is representing the full scope of the product anywhere in the world. So, then that user you can refer to as whatever token you want to refer to them as can be assigned access to a given environment, and of course the environment can have many users and the users can have many environments. So generally an environment would represent an entire facility. It might represent two or three buildings, and then you can use zones to organize subsets beyond that. You don’t have to worry about filtering your address space down. You can just say everything in this zone that can turn off, turn off. So, if you want to dim a light bulb you would say dimmable switch dot brightness and specify the brightness and anything which does not support brightness would simply ignore it. If you want to be able to filter down to a certain kind of device separate from what capability set it has, that would be a feature that is coming in a future release called tagging, which we can tag then say this thing is a light bulb. So maybe there’s some other things that feature brightness but they aren’t light bulbs, and we want to be able to say with those, but you can always address a custom set of devices either way. This structure was designed with the idea that it would handle pretty much any situation that could come up. We’ve not seen it done in any of our competitors. They generally just have a flat structure, a giant pile of stuff, and you kind of have to sort it out on your end. But us providing the right security containers and the right ability to customize groups of devices and map those groups, it’s really, really powerful because then we can apply security knowledge to those containers as well and custom metadata to those containers and then be able to issue commands at some custom subset of those devices and so on and so on. So, there’s a lot of power that comes from this very basic idea of building this 3-tiered structure. It also allows you to launch your own, you know, if you need to launch a combination of different products and customers that are totally insulated from each other, you simply just create a new ecosystem, and as with environments, developer accounts are many to many on ecosystems as well. So, you can have multiple developers, multiple ecosystems, and map them according to whatever projects they are actually working on. Here is our developer portal. And, essentially what you can do from here is you can manage all of your ecosystems. You notice that I have I think two ecosystems in here. I can manage them and I can switch between them. I’ve been working on an ecosystem. I can manage my set of service classes. Here I’ve registered some service classes, binary switch, dimmable switch, and so on. And, you can kind of see you know exactly what those look like in here and be able to understand the, hold on, there we go, people to understand the capabilities of each one. Registering the service classes gives the system a little bit more knowledge about what the devices do, but to be honest from a development standpoint, you actually don’t have to create service classes. They’re simply a suggested format for how you interact with the devices. The system will support any arbitrary commands that you pass through it even if they aren’t defined. It simply won’t suggest what you could do because it doesn’t know what the capabilities of that service are. Here I’ve mentioned you can manage clients. Basically you can use clients to create either an application or a server, so you can have direct server to server communication through what we call a client token, and your application is connected through a secure token that can be rotated out over time, not through a specific user’s account. We also have a webhook API in here as well, so you can go in and create basically a real-time call back to your server every time an event happens in a certain ecosystem. And, you can actually create as many of those as you want, so if you have eight different servers, you want to get notified when this happens so you can create eight different webhooks right, and so every time a light changes its state, or anything happens in the environment, we’ll actually give you a real-time call back on your server. The inside of the ecosystem, as I’ve mentioned, there’s always a set of environments. Here I only have one environment where we’re going to test it, but inside that environment we have these devices. And so, right here I can see. Right here I can see all the devices and its really actually kind of nice because you can actually see all the capabilities of the device mapped out. So, I’m going to show you the, I’m going to show you the LIFX light bulb here. So’ I’m going to grab a light here. This is LIFX right. And so if I hit this binary switch interface, because it knows the services that it’s capable of, it automatically suggests that I might want to set this property to on or off. And when I set the property to on you see the light lights up over there, that light actually turned on. And, similarly if I hit this left one, this LIFX left set its property to on, you see that light turned on, and there’s this little animation that happened in the portal as well. That actually is the result of the system detecting the state change of the light, not because I set it. So, the light actually does not respond, is not turned on, then this little light bulb will not switch on. But more importantly, there’s a textual representation of it you can click that of the state of that device. So, I’ll show you kind of what I mean by that, and just to kind of prove that it works, I’m going to jump up here to, I’ve got two Sonos devices here and I’ve got the Sonos interface open, and so I’m going to send some commands through to let me resize this through Sonos, apparently I can’t resize that. So, right now if you look at the media state on these, on this office Sonos, it’s set to stop, so if I hit play you’ll actually see these two Sonos speakers turn on in real time and you’ll see this is on, what’s the name, Staying Alive from the Bee Gees. So, I’m going to go over to the Sonos interface and I’m going to skip to the next track, and notice all these interfaces updated in real time because of that, so I got, you know the, apparently Greatest Hits, hold on a second. So by clicking into the Sonos interface, this is really cool too, we get an actual live log of those things, so let’s say I pause the music, you’ll see the media states change, the media info has changed. I’ll play it again and we can see the real time stream of that come through. I’ll skip tracks once more and boom here’s all the information about the new track appearing as well. So you get this really nice stream of data that comes off the device. That’s available then through our webhooks API and that’s available through another API which I haven’t talked about yet, which is our WebSockets API. So you can connect WebSockets directly to your mobile app and be able to have the app be, you know, be real-time responsive to these changes as well. This interface here basically gives you direct access to, you know, similar to the other interface with a little bit more rich, giving you direct access to all of the custom properties. I can actually go in here and change, you know, the volume of the music. I can go in and change, you know, skip tracks and so on. You see here there’s a section called metadata. This things called office Sonos. The label that you see is actually part of the metadata on the, you know, the metadata interface, but our UI knows about that and it pulls it up here, but I can actually go in here, you would normally do this programmatically, but we got this for, you know, just easy development. I can actually go in here and add some custom field. Right, and associate that with, with this office Sonos. So, this kind of capability is accessible through the API for the device, and like I say, you can write any custom information you want to it. We have support for custom data metadata scopes as well. You can actually decide whether to supply the information directly to everyone who looks at this device or to only this specific user. So you can write a custom property that’s user specific so this user looks at it they see one thing, this other user looks at it they see another thing. You can also do it at an app specific level as well, so that if one application is doing the custom data they see a different view of it then when a different application is viewing it. So, let’s say you had a management interface versus a user facing interface that was defined. They can have custom scopes metadata as well. So the metadata system is really rich. It’s a very nice way to apply data and it’s simply a matter of writing, you know, an update to that record. So whether it’s the device, the ecosystem, I’m sorry, whether it’s the device or the environment or the zone, you know just applying custom data to it is really, really simple. 