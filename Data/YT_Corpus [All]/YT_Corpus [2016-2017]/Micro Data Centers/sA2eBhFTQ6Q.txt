 okay so welcome back how many of you were my first talk about an hour ago or 45 minutes ago you poor poor bastards well welcome back we're gonna talk about building micro services actually what we're gonna what would be more appropriate is to talk about building cloud native our troops we're gonna build cloud native applications of which half has to do with micro services my name is Josh long it's up there if you have questions email feedback etc I'm happy to hear it also also please QA devoxx that PL send questions I'm happy to have them you must have some questions I have questions and I was paying attention so so you know come on out and say hi I think that's it there's gonna be yeah good okay so right my email my Twitter handle code is up there if you want to see it roughly we're gonna be doing what I'm gonna be doing is we're gonna build we're gonna look at how to use spring cloud which builds on top of spring boot to build micro services we're gonna go pretty fast I'm gonna cover just a small fraction of the possible things you can do again my amazing slides which I worked very hard on or online so if you want those those are there I am as I said before Josh long I'm a contributor to spring boot spring clouds for negation Vardhan activity blah blah blah blah my books these days are tend to focus on boot and spring cloud and cloud foundry these are technologies that are used to enable agile development to enable building applications that work well in the cloud and I worked for a company called pivotal pivotal is where spring lives these days now these are these technologies that you see on this it's a bright light can we the technologies that we see on that slide today are technologies that we hope will make it easier for developers to build applications and get to production quickly right it's all about reducing that time between having a concept and getting it into production into customers hands as quickly as possible today we see a lot of people moving to the wide world of micro services how many of you've heard of micro-services micro-service okay so it says it's a it's an architectural style right and there's a lot of different reasons that people move to this architecture the principal one is I think Conway's law it's this idea okay my friend oh my it's it's this idea that um software is a reflection of the organizational structure that it serves I've heard this alternatively stated as if I have two different teams working at a compiler invariably my compiler will be a to pass compiler if you think about modern websites that we know about today like Netflix like Amazon how many of you know what Netflix is Netflix they're a streaming video service okay and they're um they do TV shows and movies and so on on the Internet as a concept in terms of streaming video there is pornography then Netflix then by less than half YouTube okay so Netflix is huge it's crazy I mean that list is pretty ridiculous right Netflix has succeeded because they made it very easy to be agile to be able to move as fast as possible they said they have different business functions and they need to be able to deploy software continuously and see that that software grows as fast as possible so they broke apart their code and made them into smaller singularly focused services these services move at the speed of each vertical in the business and that and and of course this brings other benefits for example it's easier to scale these kinds of services because you can just add you know copy the service and start them up you don't have to you know scale out a co-located monolithic application it also meant that they could use the right technology for the job I've heard but I nobody's ever confirmed it you know I this is just a thing that I've heard on the streets that there are other technologies besides Java and spring now again nobody's ever proven it you know can't be proven but maybe there are and maybe in some case you might want to actually use those technologies right specifically when we talk about persistence and data again being able to choose the right technology for the job is very important so Netflix moved to this microservice architecture they created a light they created a when we talk about the cloud native architecture actually talked about two different things scaling your services and scaling your data and we're gonna talk about scaling your services today specifically that's micro services okay it introduces complexity and so we're gonna we're gonna start from the beginning at startup spring at i/o just like just like we did last time okay goodbye to this and we're gonna spend some time today looking at this section of the start that Springs right over the cloud section so I'm gonna do what I did last time I'm gonna build a quick application called the reservation service same as before JPA h2 actuator great I'm gonna hit generate oops I'm gonna rename this actually I'm gonna call this reservation service and I'm gonna hit generate and this is gonna give me my first REST API we're gonna re-implement it because I mistakenly threw away the code for my for my last talk yeah we are goodbye oops good and I'm gonna open this up and we're gonna write a quick rest service and then we're gonna build infrastructure to support cross-cutting concerns involved in scaling out involved in adding more services again people are scared of the micro service architecture because they fear that the friction the complexity involved in having lots of moving parts it's going to prohibit them from moving quickly and that's actually quite quite quite the contrary it is worth stating however that you may be better off starting with a what we call a monolithic application and use that as a chance to discover the boundaries between your modules your components so we're gonna start with you know for a demo of course I'm gonna start with a micro services first approach I'm gonna go here and we're gonna do the same as same thing as we did last time when we say class reservation and it'll just be a at ID at generated value and again I hope you saw my talk on spring boots but we are using spring boot here so a lot of the the noise that we have to worry about when we build services just goes away now we can focus on the business concern okay I'm gonna say at entity great like so and I'll build an int or in repository reservation repository extends Jay a repository reservation like that and I'll say ok and I'll say that I want to create a some dummy data ok so we'll have some records in the data in the database and the way I'm gonna do it is I'm going to create a beam of type command line runner and the command line runner will get started when spring boots starts up there it is there again right and all I'm gonna do is I'm going to say arrays dot as list yeah good I don't know I got nothing names for each X n you know for each one save new reservation ok there we go pass in the right name Josh okay and then of course this is Java so I'm gonna create some stuff for Java just for Java not be Java okay I need a two string naturally so ok we should now have an application that is going to start up it'll have five records in the database we're gonna print all the records that we get back we're gonna say for each one that comes back print out the information fabulous now let's start this up and see what we get just to confirm that everything's working and then we'll start to introduce a client in order to support the client again this is just one service calling another service but in order to support that you'll see that there are some cross-cutting concerns that are also non-functional requirement these are things that you need to promote healthy resilient services but that aren't particularly fun so spring tries to make them as easy as possible to get done and out of the way as quickly as possible so what did we do wrong here did I create my oh I haven't created a resting point so we're gonna build a risk controller class reservation risk controller and we're gonna say request mapping and it's gonna stand up and just expose the data and it's simple format as possible ok like that I'm gonna say return this dot and I'll say at our wired reservation repository like so and there we are good and we're gonna start again ok so we'll see this endpoint now serving traffic and you know serving all the information from the reservations in point awkward good here we are refresh there's our data now let me talk about building micro services the first cross-cutting concern the first non-functional requirement that becomes very important when you start adding more services its configuration I find configuration in this case refers not to the wiring of objects but instead to what we call 12 factor apps tile configuration the database passwords the locators that create all these things that change from one environment to another you saw on the last as we as we looked at this molesta and the last talk that you can easily run a spring boot app and if you go to the desktop here like so and you say a reservation service and then you do maven d skip test sequel clean install you saw that it's very easy for me to build the code and then run as a jar that's what I've got here after all and I can do Java - jar you know demo generated whatever reservation service and if I want to override the the properties for example the database and the the S you know the the host and port of course I can go to application that properties and I can say server port or I can say spring that data source URL and on all this stuff are I can say server that SSL for example all the stuff is stuff that it's very interesting and very very powerful to be able to configure from application up properties but I could also use application llamo yml okay so in that case it would have been server port like that you know blah blah blah or if I want I can keep that configuration outside of the process I can say - D server port equals 88n and that overrides the property in the in the property file in the jar same thing if I have a touch application not blah blah blah if I start the application up and the application that llamo or application up properties are in the same directory those values will override what's in the jar also I can do this I can say export server underscore port you know equals whatever right 80 30 and that'll override server dot port inside the configuration so this is very convenient but again if you start lots of instances and lots of services it's gonna get painful to have to manage this configuration each time there are a couple of things that we don't have good support for here first of all what about encrypted passwords a lot of regulatory environments require that you have when doing at you have to do at rest encryption which is to say that passwords stored in the file system should be encrypted and then only in flight between when the code is loaded and when it's actually used to create the connection should it be decrypted right that's a very important thing second of all I want traceability I want to be able to see oh yeah some guy didn't just log into production drunk and make a change and then break things right I want to see who made changes I want to see when it was made I want to see what did he change and what she changed and be able to roll it back if I need to right the thing is that if I have a lot of services and that is after all the goal right as you build larger larger apps you should create more services it's easier that way right as I have more services I want to be able to change configuration centrally so you have a lot of different requirements all of it kind of come together and we're gonna talk about a solution it's called the spring cloud config server so I'm gonna go back to spring initializer here and for my first trick we're gonna say config service and then I'm gonna go here I'm gonna say give me the config server okay so that's this thing right here and I don't need h2 don't need JPA and I'm gonna hit generate and that's gonna give me a little jar and again I could do what I'm doing in Java here using the groovy CLI you'll you'll no doubt remember from a last talk that it's very very convenient to build all of this stuff using reusing cuvee so I'm gonna do it from Java but just keep in mind that you could do it from this spring spring boot CLI as well and it's actually markedly smaller my friend Peter is gonna have a talk later this week about how to use these services in a cloud environment in particular pivotal cloud finder so you'll see that it's even easier to stand this stuff up you don't actually have to write this every time you build a new service you have to get this rest of you right once get it right once and then we use it you'll never have to worry about this again I'm showing it to you now so that we understand what's in what's happening so the here is the spring cloud config server in order to use it anew did some configuration I need to tell it great your name the application name is called config service ok I need to tell it to talk to a config server I mean sorry a repository of configuration information remember the requirements we want traceability you want to see who made changes to what we wanna be able to rollback well it turns out that git is actually very very good at that right so what I'm gonna do is I'm going to point it to a desktop a local repository on my file system but it could be an HTTP github URL or get lab or whatever and I'm gonna say use this git repository on my desktop in my config repo folder that configuration lives here right so CD CD config repo and you can see I'm gonna do get in it great get status get add and I've got a few files here but you know you're gonna see that even if I cat all the files I have these pretty silly few lines of configuration I don't really need the configuration I just want to build to demo some stuff so I have to create some values just to show you that we could okay so I'm gonna do get add I get commit and what this is gonna do is it's gonna stand up a a proxy sort of a an intermediate service called the config service that will talk to the configuration files or live in this git repository all my other micro services will talk to the config server proxy and they'll get their configuration from that so this config server proxy thing can do decryption it can do you know it can do password protection and all that stuff and it has the ability to essentially change things live I can actually change things in my configuration and then trigger the change in my applications as they're running without having to restart centrally right this is very very powerful so we've done that what else do we need I think that'll do again this is the code I need to actually write some code of course so there's my code you're welcome and I want to tell the config server to run on port 80 8 8 8 that way my other services will connect to localhost colon 8080 date and they'll find this service ok good let's see go back to this command alt d demo application and while that's coming up we're gonna teach our reservation service how to get its configuration from here so first thing we're gonna do is we're gonna bring in this dependency from the from the maven pom it's called the spring cloud starter parent and it's how we can find all of the dependencies for spring cloud which again very much like the spring boot starter parent is you know managed for us by this dependency you don't have to worry about getting the right versions and all that stuff you just bring in the dependency and it'll it'll just work so we're gonna say spring cloud config client okay and I don't need to worry about the version thank you and then I'm gonna tell my code I'm gonna tell my reservation service that it needs to have a name as well so it's gonna be called spring application name reservation service and this name is very important we're gonna use this name over and over for a lot of different things the first thing that we're gonna see is that it's going to be used to load configuration right so there is reservation service type properties or reservation service dot yamo whatever it is you know those configuration values are what this micro Service wants to use that's how it thats what its gonna need to connect to that the next thing we want to do is say spring cloud config URI is HTTP localhost you know 8 8 & 8 now of course I could do something like this I could say config server like that and that's an environment variable right and that'll say use this environment variable or if it's not available to do that but for our purposes let's just keep it simple so we can keep keep track of what's happening and this information is the only kind of configuration you're gonna have in your different micro services everything else will be loaded from the config server itself because this is configuration that gets loaded before the other configuration we need to put it in the bootstrap phase so we're gonna rename this file to bootstrap type properties and indeed that's what most of our services are going to do is they're just gonna have booted up properties and so on to remember by default spring boot is gonna start this application up on port 8080 right and if you see what we've got here cat reservation service it says server pup port is gonna be 8,000 so we're gonna we're gonna run or win this application on 8000 now right it's getting its configuration information not from my local jar or anything in the in there but it's getting it from the config server you can see what the config server is giving us by going to the REST API that it provides so 8 at 8 and I can say reservation service master ok and there's the information there it's saying okay I'm going to get the configuration specifically for this micro service called reservation service from this config file it's gonna get message and serve it up port and then all micro services will get their configuration from application up properties now application that properties is generic every micro service will get the configuration in that application that properties file only the service that identifies itself as reservation service will get this configuration so in this case server dot port 0 means find a random unused port and use that but then the more specific configuration says I want to be on service port 8000 specifically so this overrides within the application net properties this is very convenient for having general-purpose configuration and then very specific configuration now then I've got this handy message ok so let's let's expose that as a as a resting point in my code here we'll just go back and what I want to do is I wanna inject the message and display it ok so I'll say value message string message alt enter and I'm gonna say request mapping message string get message sure say return this stunt message and I want to be able to change this message live ok this is a silly example but what we're gonna do is we're gonna set it make it so that whenever I change this message in the config server I want to be able to redisplay the new value without restarting the application okay so I'm gonna redeploy this component and we should see that when I go to for test message it's gonna print out hi KC and delicious delicious BBQ take two right so a local host reservations is no longer there it's on port 8000 there's my reservations just like before but now if we go to message you'll see that I get that string that comes back from the config server I want to trigger a change so I'm going to go here to the reservation service I'm gonna say Adam like this this is a github text editor it's pretty legit I'm a fan and I'm gonna say pull in okay and then I'm gonna chain get commit my change right so updated the message now if I go back to my config server port 888 it knows of the change immediately but my wrist service does not right I want to I want to change the rest service which high as that value but I don't want to restart it I wanna be able to do it in a central way so the easiest way is if I go to my rest service you'll recall that I added spring boot starter actuator this is the set of metrics management health endpoints things like that when you have spring cloud it also registers another endpoint called refresh so what I can do is I can say curl - D empty bracket means a empty post HTTP colon localhost 8004 slash refresh and what that's gonna do is it's gonna see that that I've changed the value here this key is what changed and get and now when I go back to my code here I can see the values there already right I didn't have to restart the app right nothing is nothing has changed I didn't have to change anything what happened is that this controller got wrapped in a proxy and then it was discarded whenever i trigger the refreshed event that goes through and it finds all beans that had this annotation I can connect my spring cloud microservices to an event bust based on rabbitmq and then send a message on to the RabbitMQ and then every controller every service connected to that event bus will re refresh themselves automatically so one message you can we reconfigure a thousand services live right in flight and the best part is I'm doing this with an it's a pretty simple example but imagine instead a bean for a custom data source like this right I'm gonna say at value you know my the DST URL whatever right string come on Josh you can do this there we go so like if I was doing that and I said at refresh scope up here that would trigger a refresh of this beam so all the code that injected a data source including all the stuff that's using the data source would get the new data source they wouldn't get they would not get a null pointer it would just do the right thing now that's one cross-cutting concern okay so this is just one I think that's fine but we should now build a service one build a client to our reservation service so we're gonna go back to our start touch friend IO and the first thing we need when we start adding more services is the ability to make it easy for these services to discover each other again if you're running these services in the cloud and services come to light you know if their services are constantly being started and stopped based on load and based on demand and capacity you don't want them to be coupled to the actual host and port of these services additionally you want a way to do something called client-side load balancing now client-side load balancing gives you the ability to build services that can do routing in the client as opposed to at the router or at the ad admin level for the for the actual DNS and the reason you want to do that in a client is because you as a client are in a much better position to make a decision about why this client should do you know what to do in a certain in the case of certain outages or so on so for example suppose I'm a client to my reservation service and the reservation service goes offline or one note with the note I'm talking - goes offline I want to be routed to the next one great what about availability zone awareness suppose I have a service and it's deployed on AWS and I want to be able to route all my requests to that service in the availability zone that I care about I don't want to call across the ocean when I could just call the ones near me again that's very very common what about multi-tenancy if I have you know certain ranges of customers and they're all handled by these services over here and not those over there again that's a decision I want to make as a client to the service it's not something I can program in my router very easily so to support that use case what you do is you use a service registry and there are many options for service registries we're gonna use one called the Eureka service registry with with it's what Netflix uses okay by the way Netflix very very big spring boot users and now if you come to our other conference which isn't as cool as this one but it's pretty ok it's called spring one you'll see that they're actually using spring cloud so this is a simple way to consume a lot of the Netflix bits that helps them scale and again they're using it I think that's pretty cool imagine imagine if Apple said oh yeah well we have this API but that guy uses our API and makes it even better so we're gonna use his code to talk to our own API it's kind of what's happening here right so I'm gonna say I'm gonna give me I'm gonna say give me a Eureka service there are other options in fact there's console support and zookeeper support and there's a organization here called for Finance IT that's got a nice stand outside and many of these contributors many of the contributions that support integration with that kind of service registry come from for finance they're out there on the on the floor so say hi eureka service good stuff and i'm gonna hit generate again this is gonna act as a sort of phonebook okay it's a it's a way of asking questions about the state of the system where does the sort where do these services live are there any available how many you know where what are the host and port what are the capabilities perhaps right you can use again any kind of service you want if you're using console consoles written in go right so you don't want to you can't use spring boot to create your own console service you just have to install it and point your spring boot micro-services or your spring cloud micro services to it but since Eureka's written in java we're gonna use that to actually install the eureka service okay it's gonna look pretty much the same as before i also want to make it a spring cloud config client so I'm gonna do that and I'm gonna remove this I'm gonna open up application net properties and I'm gonna do what I did in bootstrap that properties in my reservation service I'm gonna say great you rika service and just as before application of properties will be renamed to bootstrap top properties and then I'm gonna open up demo application and I'll say at enable Eureka server because I have to write some code otherwise it's cheating and here we go so again what I'm gonna tell it to do is to get the configuration about where it lives and which port and all the stuff from the config repo and we can see that that information says that it's gonna start up on port 80 761 ok localhost 87-61 and there's my service registry okay this is console this is a human wetware friendly administrative view there's also a REST API and what we want to see is we're gonna as we're developing this app is that there's gonna be applications registered here so this is a human friendly dashboard you're also gonna see when we go back to IntelliJ that there's a big giant huge stack trace in my console and the reason is because Eureka is upset it's unhappy with both me and you as people Eureka is after all it's the beating heart of your service ecosystem they it's gonna be used by services to discover each other and to find out where they live if it goes down you're in trouble right so it's important that you set this up at a highly available fashion it's pretty dead simple to do but in the meantime it's gonna throw lots and lots of exceptions and be very upset with us and you might even see a big red error here in the dashboard so let's see what the exception is there it is and it's gonna say where's my replica where no right so um that's fine we're gonna let it be upset it's still gonna work it's just one node okay good so now that's up and running let's go teach our reservation service about how to register with Eureka now again you Rica's one service registry console and zookeeper or other service registries if you think about what we're trying to do we're just trying to figure out how to map service IDs to hosts and ports so if you're running on a cloud like Cloud Foundry which is open source and lattice which is a distributed runtime for containerized workloads those systems already know where these services live so they can already answer the same question with Eureka and with console and zookeeper the service as it gets started has to call the service registry and say yeah I'm here register me as being available on this host important but a cloud like Cloud Foundry or lettuce they don't need to be registered they already know they started the app in the first place in any case no matter which implementation you're using you'll have a discovery client API it's the same API for all five different choices and there's probably more coming so you get a clean consistent abstraction so we're gonna tell our reservation service to be a client to Eureka okay and then we're gonna say at an able discovery client and then we're gonna restart carefully yes I want to restart and stop and rerun drink some water there's actually a more specific annotation that says at enable you Rica client but again this is just a meta annotation that is itself annotated with an able discovery client so if you just prefer to be generic and not care then just say unable discovery client and you get the same result so our service is now up and running as we as we expect right so reservations and within about 30 seconds or so we'll see it get registered here in the dashboard so we're gonna give that some time in the meantime we're gonna go you can make the expiration time by the way smaller if you like but for our purposes we'll leave alone oh look the console just said it's doing what it's doing its rear edge' stirring apps registration service so now if we go to here we can see that it's registered itself whoops as reservation service and that it lives on this host & port you can't see the bottom left of my screen but this is my host name my my local machine is Jael and on the left on the left it says JL : 8000 I'm the very bottom left corner of the screen okay so there's one instance that's up and if I wanted to go to and I could click on that link and so on so it knows where that service lives and now I can as a client I can programmatically ask it where does that service live let's build that client okay let's build our first reservation client we're gonna say reservation service reservation client and I'm gonna say that I want to be a config client just like before I want to use the Eureka support I want to do a micro proxy using Zul I want to have smart declarative interface and convention centric clients for rest services using fain I'm gonna use hystrix to manage to kind of keep us sort of a stateful band-aid around my suit my service calls because again something might go wrong and I want to have that support there and then that's it right that's enough for now I think it'll do so oh and I also want to have web support because I can and that'll do let's do this hit generate reservation client command-v we're gonna do a lot of things in here so our service the first thing we're gonna do in our service is teach it where the config server live and teach it where the Ricoh registry are so just as before we're gonna take bootstrapped up properties command a command C command V and I'm gonna go to this file in my reservation client right here and I'll say rename this to bootstrapped up properties okay again all I'm trying to do is say that this is a client to the other service I want to now demonstrate some progressively higher level ways to talk to that API right the first way of course is to just create a programmatic or to use the discovery client API directly so I'm gonna say discovery client I'm gonna inject the discovery client abstraction and I'm gonna use that directly to call you know to find out from the service registry where services live so I'm going to say that enable discovery client great and I'll go down here and I'll say create a new command line runner and again the callback the contract for this is I'm gonna be registered when the application starts up and when the application starts up it's gonna call this method it's a callback interface and it's gonna pass in public static void main string arguments array it's also a nice fit for for lambdas okay so I'm going to inject a reference to the spring cloud provided discovery client object and I'm gonna say DC dot get instances and that's I'm gonna say give me all of these service instances for the reservation service okay so this is get instances and it's giving me a list of service instance objects back and I'm gonna say for each one that I get back let's print out the host the poor etc and they and the service ID so I'll say string.format like so and I'll say host and port and then I'll say aside I'd get service ID s iodide get host aside get port etc okay so that should be very very simple if we run this we'll see the application should start up and it'll find the configuration information from the reservation service it's using the right hopefully it's using the right discovery client implementation because we've added the spring cloud starter Eureka support we added that jar and there we go we found that it's got one instance of that service that lives on this host and on that port so that works right that is certainly good I mean that's a start but we're not really getting the benefit of client-side load balancing I still have to make the decision on which instance to use here and plus more often than not I'm gonna want to take that host and port and then pass it to a rest client right that's what I'm trying to do is call another service via rest so I'm gonna create another a command line runner and in this command line runner we're gonna use the rest template right so how many of you know what the rest template is rest template so the rest template is a client that was introduced inside of spring 3 oh it is a way of making rest calls from one service to another and it's dead simple it makes common HTTP invocations a one-liner right and the nice thing about it is that you can add interceptors you can do gzip compression you can do ooofff you know authorization header intercepting you can do all sorts of cool stuff in our case we're gonna make it so that if we make a rest call and we give it a service ID it's gonna look that service up in the registry find the first available instance that's that's useful and then give us a valid host import and then call the service when I say find the first available instance I mean it's gonna do software-defined load balancing just like we talked about before we want that choice about which node to use to be something that we can configure and the way Netflix do this and the way we're doing it is to use something called ribon ribon is a software-defined load balancer it provides different algorithms that you can use to route your requests based on certain conditions or certain clients I use cases and case we're gonna settle for the default which is just round robin load bouncing okay so I'm gonna say return args I'm gonna say R T dot exchange okay and I'm gonna say I want to make a call to HTTP reservation - service again this is not this is not a HTTP host import this is the service ID in the service registry and that's gonna be plucked out and then magically replaced with the correct host import we're gonna make a get request we're gonna pass in no because we don't we're not making a post so there's no body to send and then we need to tell our rests client which service to call I'm in which data to return and how do we turn it and this is where we kind of run into a kind of a problem with Java's generics so Java generics at runtime Java does not know that an interface or it doesn't know that an instance variable that has a generic argument like a list of string if you ask Java at runtime using reflection what the string parameter generic parameter for that list is it doesn't know that information gets washed away when you compile and run the code that's erasure you need to create a dynamic subclass so if I said list of string x equals new ArrayList of string parenthesis parenthesis curly bracket curly bracket like an anonymous inner class that instance would have its generic information so in order to tell our rest template to return a list of reservations we need to pass in a parameterised type reference now this brings up a kind of a sticky point I need something it can be it can return remember what I talked about earlier in theory and again it's never been proven but in theory there are other technologies besides Java and spring so you cannot rely on having the server-side types for your client sure I could in this case but do I really want to know I want to keep myself decoupled from the structure of the of the service so I'm going to create a client-side representation of the object that's gonna be on the server on the service it's gonna be the same kind of object it's just I'm not gonna have the JPA mapping annotations and I'm not gonna any of that other stuff I'll just do that and I'll say another constructor great and I'll have to string okay so there we go so now I've got a local entity that it's just gonna it's a POJO nothing nothing in particular so I'm gonna say is I want to do a new parameterize type reference of list what sorry yeah that's I think that's the JSON mapping that's gonna map so the question is what is the nor giving constructed for your it's not spring man thanks though this is Jackson so um let's see spring actually can instantiate beans that have no argument constructor and reg argument constructors nope no problem easy to specify that so okay good I'm gonna return that anonymous instance variable and it's gonna I'm gonna say to the rest template give me a list of reservations back so I'm gonna say give me the body and I'm gonna say for each record that I get back I'm gonna say R and then I'm gonna print out the information just like we did last time so I'm gonna say pass in the R and then print it out and indeed you know this is kind of wasteful I could just do this right good so we're gonna get all the information back and the nice thing about this approach is that it's it's a it's a you get to feel like you're working with a type system but you're actually making a rest call and you can you can if you want get the rest body that comes back the response entity that comes back from here and check the instance variables in the status codes and the headers and if you want to do that that's great but you also get the the ability to deal with services pretty transparently right this is actually fairly minimal I'm doing it all in one line because I don't know why no reason if you did it in two lines it's more readable good so we're gonna start that up and we should see the same you know we should see exactly what we expect which is all the information coming from the service so there it is reservation ID 1 blah blah blah and then there's the reservation name etc ok so that works and I actually kind of liked this approach but we can do better right we can go a little bit further we can say interface reservation client and what I want to do is I'm going to use fain to create a rest client by convention again the previous approach gave me the benefit that I I was using a type system but I also could see the underlying HTTP calls if I kind of want to ignore that altogether and move up a little bit higher in the abstraction hierarchy I can do that here so I'm gonna say feign client I'm gonna say feign this is a Netflix project as well call the reservation service and then invoke the endpoint called in other URL reservations and use method request method get' okay and that's gonna be cool and in order to turn that on I have to say at enable feign clients okay so this is just gonna turn on that support for me and now I can build a third implementation of a command line runner that will use vein so I'll say feign client feign or reservation client okay RC and I'll say return our eggs like so RFC get reservations that for eh dot system.out.print line and now we'll see the same data twice we'll see all the records from the service printed out using the rest template and then print it out again using the vein client and that'll be here cool so there is there's one two three four five whatever and then there it is again and then of course there's my command line matter good so now we have three different ways of doing the same thing you can see that no matter what level of comfort you want to work in you have that ability and it's doing load balancing for you so if there's one or many different instances this will correctly handle that use case what it won't handle is if there's zero instances that's the first thing we need to think about and the other thing is that we also need to think about how we can act as a as a service that actual clients like like an iPad or an iPhone can talk to write Netflix does this a lot as you can imagine they have 600 different micro services each of which talks to each other these are called mid tier services and so our reservation service was in this be a mid to your service the client on the other hand the client on the other hand for example iPhone or iPad contacts the edge service and this edge service talks to these mid tier services and you know forwards the requests and maybe does some transformations and then returns a response the reason they do this is because they have 600 different micro services and many many different types of clients iPhones iPads Xboxes Playstations Smart TVs you know anything you can imagine they have different clients and they these clients all have different kinds of security constraints they'll have different times of use cases some of them can handle more chatty protocols some of them can handle less either way it's up to the edge service to transform or proxy or secure the calls from the client into the backend right into the mid-tier so we're gonna stand up the first way to do this the first way to handle this is just to maybe use a proxy right if you've been following if you--if you're up on your Ghostbusters mythology right zoo then you know that this cutie pie remember him this is the the gatekeeper from ghostbusters anybody here know ghostbusters yeah this is Zul the gatekeeper right and and then she this crazy person is the keymaster right and the edge this is our gateway service right this is a service of kind of forward requests to the other services and for common cases maybe I just need to proxy all of my mid tier services to the client any html5 application for example will have this use case where they cannot talk to different services and different host and ports and they don't want to change every back-end or mid tier service to have an origin policy that supports every new client right so they just create an ED service and proxy the requests that way so if I want to have that this will do right this would be enough so if I go to localhost Reservoir we on right now I wonder port I think on a 30 cat reservation client properties 8050 right so I'm gonna say 80 50 and if I want to call you know my reservation service I should just be able to say reservations oh I didn't we start awkward so you need to restart in order for that to work there we go and there's my back-end mid-tier you know I'm a mid tier service again I'm not calling the reservation service directly I'm calling my edge service and it's proxying the request to the register reservation service if I had a service in my registry called foo service then this would forward the request to the food service as well so all of my mid tier services are available here this is fine for maybe you know common cases you can secure this you can add whatever you want but maybe you want to do something more maybe you want to actually change the results that get sent back to the client perhaps you want to make it less chatty perhaps you want to transform the results that get sent back whatever so we can actually do that as well and we're gonna demonstrate now how to make potentially unreliable service calls a little bit safer so first thing we're gonna do is create a reservation troller we're gonna say class reservation names rest controller again this is kind of a silly example but it does I hope demonstrate the point which is what we want to transform the information that we're getting back and what I want to do is I want to call the backend service but I want to have some smarts about what happens if that service isn't available so I'm going to say reservation integration and I'm gonna say reservation integration integration there you go I'll say at request mapping and I'll say reservation underscore names or - names and I'm going to do is I'm gonna return a collection of strings not the actual names themselves right so not the actual reservations themselves I'll say reservation integration dot get reservation names like so and here we'll write some code to do that for us okay and create method get' preservation names great here's this and what that's gonna do is this again we're gonna inject our faint client in this case reservation client and I'll say we return this dart reservation client dot get reservations dot stream dot map and then for each reservation called reservation colon get reservation name collect it this is all just Java eight awesomeness okay so I'm gonna say return a list of strings based on calling get reservation name from each collection into that comes back if I were making one or more calls right now I would want to have that happen concurrently and this is an amazingly good place to care about reactive programming this is a great use case for example for something like rx Java so I could make these two calls concurrently and then very cleanly elegantly convert and zip you know join the results back up and then send them back at the same time now this will work except as we talked about earlier in the situation where this client is trying to make a call to a service where there are zero instances right one or more this will work just fine it'll-it'll round-robin and it'll dispatch to the right endpoint but if there are zero then it's gonna it's gonna fall apart so what we want to do is have it do the right thing and gracefully great degrade so we're gonna use something called the the circuit breaker pattern okay how many of you read Michael my guards amazing book release it where he talks about the circuit breaker pattern amazing amazing what could you get a chance the idea is that I want to stop traffic I want to stop something that might cause trouble from knocking down my entire system it's an it's an example of degrading gracefully there's a guy named Fred George out of the UK who gives a great talk about this and he compares the human body to a set of micro services and or he compares micro services to the human body he says it would be absolutely crazy if you cut your finger and then you blue screamed right it's nuts and it's a great point you want to have something that degrades graceful you want to do the right thing Netflix does this a lot as well they have a search engine and maybe the search engine is down and so they'll they'll show recommendations from around the web instead but they do something they don't just throw an exception in the users face the goal here remember is to promote resilient services again they have Netflix example has 600 different microservices you don't know it's impossible to guarantee that you're gonna have high availability for every service instead they build software that is immune to failure that is tolerant of failure they embrace the fact that failure will happen and they build software that is resilient to it Google - right Google has two million data sent two million servers very very beefy machines all around data centers all around the world two million of them there are people that go to work every day at Google and just collect dead machines that's their job it's a it's a fact of life things are gonna break they're gonna die don't plan for one server to always be there you know aging Cockcroft former devops ninja and card guy at netflix he talks about this whole time he says treat your servers as cattle not pets they shouldn't have names right you should you should feel free to shoot it in the head and take it away not not that you should do that to anything but you know what I mean so fallback method we're gonna say when this when this method gets called and something goes wrong call this other method and it's gonna be called fallback and I'm just gonna be turn collections dot empty list great and all that's gonna do is it's gonna do something it's gonna return nothing instead of you know an exception right and I'm gonna say in order to enable the circuit breaker I'm gonna go up to here I'm gonna say at a naval circuit breaker fabulous okay and then that should do it I think right so let's see if that goes I drink from a water and again what this is gonna do is it's gonna I'm gonna make sure that if something happens and you make a call to this endpoint and it fails it's gonna throw an exception and this circuit is gonna open up no more electricity will be allowed to pass through it that way you won't compound the problem if you're trying to call a service and the service is down you're just gonna keep blocking you're just gonna keep blocking on up wasted effort why bother instead route them to some sort of fallback thing and then try again later on maybe the service is up but give the service a chance to breathe to come back okay so if I go to localhost ad what is it 50 now reservation names will see that that service brings me it's just strings right that's my service great and if I go to this reservation service is working what I'm gonna do is I'm going to go to the reservation service right here and I'm gonna exit the reservation service okay so do I have an exit in here this is actually a hard stop oh well that's not great I'm gonna restart this as a process that I can actually exit correctly from as opposed to brutally brutally exit you know just killing it run here we go and that'll take a few seconds and while that's coming back up so I can show you that we're gonna get one more thing done so we can see what we're about to do I'm gonna create a dashboard okay so I'm gonna go to start doctoring at i/o and when I want to when I come back when that demo comes back we'll do the demo and I'll show you that there's actually a circuit that's gonna protect the traffic from getting out of hand but I want to see where these circuits are so I'm gonna create a dashboard I'm gonna say hystrix dashboard and I'm gonna go down to here I'm gonna say give me the history dashboard great hit generate and here's this command whoops Sean finder command V hystrix dashboard open now let's see is my service free registered with Eureka there's the client there's the red arrows talking about earlier reservation service seems to be registered that's fine fine oops so that's the empty ArrayList right but the service I just killed it and it's gonna come right back up when it comes back up you'll see that the names are there right so I killed the service it's gonna come back up and they'll automatically read it'll open the circuit in order for me to visualize these circuits I need good dashboard so that's what we're gonna do here same as before I'm gonna say sort main resources bootstrapped up properties and I'm gonna say open bootstrap that property is command a command V I'll save okay say at enable hysterics dashboard and then that should be it right that should be all I need hysterics dashboard yep okay and by the way the reservation names are back right so the service came down the data disappeared it showed an empty array a list I brought the service back up now the data is there great in order to see all this happening I want to actually launch my history dashboard and see you know where are these where the system is having trouble maybe an operator intervention is required right so this is very very convenient so this is started on port 8080 fantastic localhost 8080 for such hystrix dot HTML and there's my little endpoint and what I'm going to do is I'm going to point it to a server sent events stream that's being emitted by this circuit breaker on port on my servers on 80 50 right again if I have you know a dozen micro services I want to aggregate these streams into one thing and to do that we you would use something called turbine right that's this thing here turbine and turbine mqp turbine presents an aggregated stream and turbine AMQP integrates it so that you can actually aggregate using rabbitmq for example as a message bus as a synchronization fabric but our case we've just got one client one service so we're gonna say great look at the server sent events stream from this one service and hit monitor and i'm gonna open this up command shift M I'm gonna move that to the left command shift and move that to the right and you'll see as I make requests on this service on the left on the right I'm making a lots of requests commander commander command are you can see a moving average on the left of the traffic going into that served in get reservation named as I stop as I take my hands off the refresh you see that the traffic drains off right and things are green things are happy the circuit is closed and traffic is successfully being routed through you can also see also two other stuff like the mean the median you know percentile all that stuff now let's go demonstrate what happens if we take the reservation service out of the game again so this time I'm gonna exit which is what I wanted to do right so exit and immediately this is gonna fail and you can see on the left it's oh it's closed now right or open rather so now on the left is its blood red something is wrong so I can visualize in one place what's happening and how this is happening okay so what have we talked about not very much a little bit there's actually quite a bit more what I would love to what I'd love to do next time I see you my friends is to talk about single sign-on using spring security and spring cloud security for OAuth so you can do you can say here's a rest service it's protected by this identity provider either github or Facebook or or you can use spring security off as an identity provider as well and then that can talk to you know any back-end identity provider like Active Directory or LDAP or Pam or Kerberos or whatever it's very simple it's declared if you say at enable off the resource that's one thing that we haven't gotten to talk about here spring cloud also provides spring centric integrations for a lot of the cool AWS yeah a lot of cool AWS api's so they're you know the sqs message queue is now exposed as a message visitor container very much like the RabbitMQ mr.solicitor container or the JMS message lutheran container or the Redis message lister container or the you know whatever right so a lot of different pieces there and stuff that we don't even have because this is all the GA stuff but right now we've got caught in a console and zookeeper stuff that's actually being set up and some of the cool stuff that I will be able to talk to you about next year but it's we're developing it right now is moving to a messaging based micro service model right so if you're doing stream processing for doing big data if you're doing continuous batch processing you're not dealing with rest you're dealing with events coming over a message bus and you want to string together a you want to coordinate lots of different services that are based on message queues Kafka for example Netflix uses Kafka for billions of event every day and spring integration Spring data and spring XD which by the way there's a talk on spring XD this week so definitely check that out all support kafka for example and rabbim q and whatever so again that kind of style of architecture is very very very powerful you can get the same result by using spring negation today but having it nicely instigator with spring cloud is something I look forward to we also didn't get to talk about the cloud connectors which are a little bit of into sort of a little bit of decoupling between your injection and the infrastructure services like your data sources your rabbit your message queues your your emails and all that stuff your send grids etc all these backing services that you may want to couldn't consume when you run inside of a cloud a platform as a service like Heroku or Cloud Foundry or AWS or whatever um I think my friends that that is it that's a very small look at what's new and what's happening inside of this project again Netflix and others are using it Ticketmaster how many of you heard of Ticketmaster nobody oh well there there are a company oh yeah there are a company in in the States and they fifty million dollars every hour all that the entire service platform is based on spring Boonton spring cloud giant big giant webs like Netflix they're basing on spring Boonton spring cloud so again a lot looks wrong one no there we go a lot of opportunity to scale here a lot of opportunity to win I hope it's clear from what we've just seen that this doesn't actually this isn't a cloud it's a set of tools for building apps that work well in the cloud but as you saw I just built everything in local host right you can run this anywhere you want the whole point is to build apps that scale well and usually that means the cob but it doesn't doesn't mean you're locked into a a cloud or anything like that um Jing quia thank you so much my friends 