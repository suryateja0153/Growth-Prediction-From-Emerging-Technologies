 I don't care what your politics it is but I'm pretty sure you agreed this guy has swagger right you were here to essentially be a little bit more like him I happen to like this guy a lot but I think he has swagger and this is what this talk is about let's get moving so first thing is let me mention to you that it's in order to have Tony be part of this presentation with me Tony is the VP at smart beer for swagger he happened to have created invented swagger and still involved and and the best part is a lot of you know me and you might have even heard about this this talk and this work that Muhammad and I from IBM research here started but what's cool is 20 he told me yesterday I'm gonna add a few more things and I was like cool we'll chat about it today and what he showed me just blew in my mind so much so that we kind of like decided okay instead of doing the demo that Muhammad and I had as part of the talk we're gonna use his demo so you're gonna see this I promise you if you were doubting swagger listen to Tony it's a lot of pressure by the way yeah okay all right okay well thank you very much for that really easy setup so who here uses swagger API yeah some people not enough people let me start out with a couple of things I'm gonna first talked about swagger is it's really just a mechanism for describing api's it's for explaining what the contract is between a consumer and a service right seems like something pretty simple we'll go through that more in detail I think this guy can explain what Cloud Foundry is sure I'll try meaning now you want no I think I think I think we'll get to it or a tight timeline let's get to it yeah let's get to it because I think what we want to do is get to the point where we were past your demos these guys know about our foundry was quit was skip to it and characterized so back to this okay so back to what Suarez people when they say what swagger they say well it's a pretty UI a UI is part of it it's it's a very interesting part of its actually in my opinion not the most powerful part of what swagger is but at its core swagger is a contract for api's right not a strict contract a little looser we'll talk about that in a minute if it is if an API is correctly described in swagger it should be enough to both produce the API or consume it right it's important it's not enough to model it or make it look pretty or make Doc's it's really enough to consume it and understand everything about it so if you say that you call something and you get back a horse object you should get back a horse object instead of a cow object right so we want things to be really clear so that consumers don't have to guess there is a very rich toolset ecosystem out there there's thousands of projects on github some of them are better than the ones I work on maybe but there's lots of things to help you get things done because it is a contract and once you have a contract you can do amazing stuff and very importantly it is a the swagger specification was the foundation for something called the open API specification which means we donated a smart bear the company behind swagger donated the spec to the Linux Foundation so that lots of people can jump on and and contribute to it in a neutral fashion and move it forward as a standard for describing web services so that's really exciting I can go into that in much more detail later but now that there's all this pressure for a demo let me get towards that first so if you want to be a consumer of api's you have a producer for that matter you have a couple of choices what do you call what is the API endpoint what is a the parameters all that sort of thing you can read the docs so you see on the right-hand side service broker Doc's here version 2.8 very nicely created but still created by a human and still have to be read by human a machine can't understand those very very easily right if you want to consume it you have to have a nice SDK if you're lucky sometimes I got dependencies you don't like it's not the language you like whatever everyone complains about SDKs and sometimes I don't blame them the parameters the inputs that go in what is a payload that comes in all of that sort of thing and then as a provider meaning the producer of an API making all this stuff and describing it as hard making SDKs is even harder because you don't always have the ability to write 50 different languages of of client SDKs users are great to have but they're they can be annoying especially when you're not doing a good job because then they say well you didn't do this or this is wrong so that's all hard and also in general boilerplate blows I don't need to say much more about that so um swagger can help in a number of ways there's different techniques for producing api's you can write code first a lot of people are doing this thing called design first and once you design an API you can generate automatically would write the right tooling clients and servers and that your job then is really to work on business logic right and that's a lot more fun than writing plumbing so if you've ever written routing tools and integrated some new framework that has lots of bugs that's not fun like your boss is gonna be happy if the business logic works really well so swagger is trying to help solve that and iterating right making changes to your definitions having to code follow it everything being up-to-date being able to iterate quickly that's a really big deal and smarter helps with that some of the tools the things that swagger can help with the interactive editor you see here I'm gonna show more about this but it's a mechanism you do a design first API meaning I will use a syntax validate against a schema in here and I can design and visualize that API as I want as I work on it inside you can see some of the the constructs of us of a swagger definition or open API spec definition I mean here there's a path called catalog there's a summary right it's human understandable this is not a hard syntax to understand if you've ever tried to create a wisdom by hand right like this is a dream come true here we're saying that the description for the operation what kind of code it produces or format it produces in JSON a description of the responses it says it's an array I don't need to check and see if it's an object array it's telling me exactly what it is I'm in and then I can just really explain all of these different aspects of what the what the API wants right and there's a great ecosystem of tooling and I'm gonna walk you through this here is a screenshot of a project that I work on called swagger hub and it helps give you the ability to kind of centralized these definitions and then bring them into your application life cycle right so why does this matter to this project cloud ramen well let's say that you are in the business of creating a new a new service right there's things that you need to do in order to produce a new service to consume and fit in the ecosystem that you're all working within you need to do a couple things implement the broker API so that something can connect and get a proxy or information to connect to your service you need to implement the service and then you need to make an SDK so that those your consumers can actually call it right so let's wha let's walk through how a swagger working inside swagger hub can help out with that this is amazing demo that he totally said yeah so so I guess in some ways to set up usually I would go through explaining Cloud Foundry and things like this and I figured please keep it most people here you should probably know about Cloud Foundry already but the important thing is that why Matt and I we created a bunch of description for a different part of CF and what you're gonna see is one of those description and what Tony was able to do with it and hopefully that will convince you that we should take all of CF and add swagger to it so you'll see all right so since I'm lousy at typing and talking at the same time I made a little screen cast but but I want to walk you through what this is so this is a product called swagger hub you can go to it it's it's a free tool for API lifecycle management design build deploy and integrate and so what I'm going to focus on is the the process of taking well written definitions and turning them into a real service right so the first thing here is if I go in here and I search for CF demos I have three definitions that Mac's actually built or Max's team built and these are explaining different aspects of services right we take this one the CF broker here is a definition that is effectively the interface so he's gone and described how you need to connect to the broker interface you need to implement this to to to be compliant with a 2.5 API you need to implement every aspect of this of this API now you can go through again you can read Doc's by hand you can make all these endpoints you can say okay there's a slash catalogs path I need to add this there's query parameters I have to do all these things but he's gone through and done the hard part which is described it in this in this definition format and here you can see what it looks like I can look in the UI and kind of scroll through it and here's the service instance API right so these are all mandatory correct me from wrong they're mandatory operations that if you want to make a compliant service they have to implement okay so because they're all described I can do something pretty neat I can go and do something called fork this API right and so when I fork it I'm gonna bring a copy of it it's pretty much analogous to from the source code point of view I'm going to clone essentially clone this definition and bring it into my own project right and by bringing it into my own project I can now do something with it because so imagine this is a read-only one i'm - now materialize or instantiate this API right so here I bring it into my own project I give it a name a version I can choose whether it's public or private and then it's done okay so that's exciting all right so now I have my own copy you can see the URL change it's under my username eye or I actually don't know how you pronounce it but now at this point I have a copy of this so now remember I said that swagger has a whole tool chain for generating code and the code can be generated and you can do different things with it I can generate a server and then download it I can generate a client and download it but that workflows not that great in that every time I make a change I download it then it'll files what files do I merge and so in in swaha what we did is we made a mechanism to generate code and push it directly to repository ok so I'm going to show you what that looks like if I click this gear there's something called an integration and there's different integrations here I can choose I'm gonna focus on github and so what's going to happen is is as I create this integration I'm going to link my definition directly with github and the code generator so notice there's different generation targets here so I can generate code in all these different formats but since I'm creating a broker I need to generate a service or a server that's going to respond to rest requests so I'm going to because I'm a creature habit and can't learn a new language I'm going to generate a jax-rs version of this service of course I could do different for languages like I do go I could do a PHP if I wanted to Ruby but here I'm gonna do a jax-rs version and when it generates code I get a couple of options all right so the worst thing would be if I'm generating code I'm pushing it into a github repository and then I go and I implement something and then I I generated again I'd blow over all my business logic right so that's not the idea we want you to have control over the code that you actually implement so I can here say if a file doesn't exist go ahead and create it if it does exist leave it alone right so that's what this is here this is called a provided path there's other things I can do like have fully managed paths so it just is like if I'm going to rename a model I need to blow it away put make a new one let's let the co generous own that and then files that I want to ignore right so by creating this iteration now every time I hit save what will happen is the back end will go generate the code it'll sync it with the github repository and then push it right and so the beauty now is that without any doing any coding now I now have this project CF broker and a generate server write explains where it comes from links to the open source so you can tweak it and do whatever you want and it actually will completely run so now imagine all that plumbing that I normally have to do all this routing that sort of thing it's just been done for me so it's probably really small you can read it okay so I clone this repo I can immediately build it and with any luck I can actually run the server okay and you have a fully working server which we can launch I can jump into a browser I can view the swagger definition and then I can even make a call to one of the endpoints in this case the catalog endpoint right and of course this doesn't do me a lot of good because it just says magic but now note here this is the implementation I just clone this and just read it so this all got pushed to github all I have to do now is implement these methods and in this case here there's a catalog method I implement this the framework has taken care of all of the plumbing so that you just work on the business logic and an implements and then at that point if I do every method I have a fully working broker applique right so no code or anything like that but kind of this whole control and then so the beauty of this mechanism is that the interface that you must implement right the framework and all the plumbing to the routing and the parameters and all the options get-get-get done for you and your job is this one thing which is implementing that interface okay so now I've got the broker I can do the same thing with my service and then plug it into the pipeline and then I've got a working application really quickly you don't have to work inside of this particular language you can work inside of any of the supported languages really easily all right I think I cool so what you saw is essentially somebody implementing a serviceworker without having any knowledge pretty much about the details of serviceworker just by going to the specification I mean this is the power of swagger right obviously to any new swagger very well but you saw the steps that he did it's not unlike anything you could do so what we were trying to do with CF swagger which is the incubation project is just sort of like motivate people for doing this kind of things I mean if this is not enough motivation for you then we have even more so one of the things that we try to do in the project CF swagger is to look at how we could essentially document most of Cloud Foundry at least all of the external APs and then obviously as Tony was asking the question is you know just describe it you want to have value you want to bring value to the different projects so if we focus again on the serviceworker what we found out is in addition to the demo that Tony showed which is essentially now all of a sudden all of you can go and implement your own serviceworker very quickly in different languages as well which is the great part and keep it in sync with every time the serviceworker is updated one of the obvious question that came about for us was as we operate since I work for in morbid as well work for IBM when we run service workers on bluemix one of the big issues we started having is compatibility of the service workers because as the specification got updated not all of them are using swagger because that didn't exist on at that time most of the service workers have to manually go update their service workers to support the new API so one obvious thing that we could try to find out is can we know which service worker is supporting which version of the API and that's what we did so we started looking at essentially creating what we call the test compliant kit for service workers in in some ways it's similar to if you're familiar with Java and you know in the past when Java had GSRs and they provided also a test compatibility kit that CCK that you could run against your implementation of the GSR it's the same idea except guess what we implemented that TCK without writing a lot of code we wrote a generator of the TCK so every time the specification gets updated similar to how you know what Tony showed you where he generates a server we also created a generator so part of the swagger ecosystem is to allow the creation of those tools so that you can take the Swiper specification that you have for your API and generate something useful such as a TCK such as the server's also charge client code so we did that what we had to do as part of our specification which is the same specification that Tony used is to add a little bit of extensions to it so for instance we added this X version extension to essentially specify that this particular operation in the specification got introduced at version 2.6 so obviously you have to start at one particular version so what Tony showed you is version 2.5 and if you go to the version 2.6 then the new specification for that has these small extensions and this is all about it so as part of Tony designing the swagger specification and now with the open API they kind of looked ahead and saw that there's going to be cases where people want to add something extra to the specification because you know you can't really think of everything ahead so these X dash are ways for you to essentially add a new annotation to the specification so we did that and then you another one is point since dependencies because one of the one of the things that we want to do in the TCK is to run it and be able to specify that oh when you try this Walker against this dck it failed at these operations so that way we'll know that the Booker did not implement the version but also which operation failed but obviously because the operations can kind of depend on each other this is a way for us to say there are dependencies of course operations so that's another one that we added this is kind of like a high-level overview there's actually a video of the demo not sure we have a lot of time to cover the whole video but there is a github I'll point you to it but the way to think of it is that we take the swagger specification like we have here and we use this thing called go swagger there's different sort of clients for a swagger in different languages we happen to have implemented all of this in go but you could have implemented it out of other ways and what we essentially created is a way to generate a TCK out of the swagger specification plus a series of templates for what the TCK looks like so what ends up happening when you run the generator is you get a new TCK or a test compatibility kit which is essentially a series of Ginkgo tests right so similar to how the rest of Cloud Foundry if you're familiar with say Diego or or Bosch agent or washing it a lot of the components that are written and go we use uncie's ginko and Omega framework to generate test cases so those test cases become the TCK and then you can take that and then spin up your serviceworker and run the test against that serviceworker there's very minimal specific configuration you have to do but you essentially do that and then at the end we tell you which version so this is the demo what I'll do is I don't have time for the whole demo but I will open it up and then show you towards the end what's happening is that we we show you here like how all of this thing gets set up and towards the end like I think maybe around here you can see that we run the test and at the end we you can see here where we specify that like for instance right here that the number of tests pass and that the TCK compliance is 2.6 but in 2.45 it's also 100% compliant if you go to the whole demo we show you how we take a service worker and modify it so that it is compatible with one version and then we make it uncomfortable or you start in you know not compatible with 2.6 because there is like a parameter that gets introduced into that six that is optional and then when you run the test it shows you that the test failed on this one and then you implement that run the test again and it passes so this is all available in the github project so I'll let you we have a pointer to this video so that you can take a look at it but we did more so let me get to that so what we also I guess this I need to get to so what we also did was to to look at well what else existed like this right to do a test compatibility kit also turns out that bluemix had a little bit of a set of tests that they ran against service workers but it exactly has the problem that we've been discussing where if you have a description and you're generating things from the description that you avoid the test was stuck in version 2.3 and why is because we basically IBM hired an intern and a set of interns to implement the test and then they implemented at the time they did their internship and then it's stuck there so you can now hire more engineers to go do more of that work or if we go with our approach every time you regenerate so that's that's the value of swagger right and we're not saying we're gonna replace engineers so it don't you know that's not the message here but there are series of things you know boilerplate code things like test where you are looking at a specification and you're trying to implement that or the server-side piece of it or the client-side piece of it we can fix that problem for you right we can make it a little bit easier so obviously one thing we wanted to do I come from research marmot is in research we did a survey to sort of figure out where people have their pain point and whether or not this would be a useful thing to them and what we found is most people thought it would be very interesting and most people from the results and you can find all of this online we're not doing anything like this they were essentially either implementing their own tests like we're doing in bluemix or some of them were not even doing that so you would bring on a service broker that you see in your platform i support version 2.6 and you have no idea if that service worker is gonna support that version or like when next version 2.7 how many of your service workers are implementing the next version right so so those are the issues that we found out so you can go through the survey and and you'll see that overall most people thought that they would be it would have they found this work to be useful so what I want to ask you and we'll stuff for some question is you know go explore you know not only swagger but also the CF swagger it's essentially if you do a search for CF swagger you'll find it it's github.com cloud foundry incubator CF swagger and then let us know I mean come to the slack you know you'll find a channel also called CF swagger and and let's discuss so let me thank you and see if you have any questions that we can try to help answer so thanks very time don't be shy there's a microphone even if you like you think it's useless - that's fine - no wait right another perfect demo max I guess yeah you did it yeah all right well thank you very much thanks a lot [Applause] 