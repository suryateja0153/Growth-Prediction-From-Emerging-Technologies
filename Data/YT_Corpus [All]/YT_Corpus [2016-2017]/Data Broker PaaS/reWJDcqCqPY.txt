 okay let's get started so thanks for joining us today so we're here to talk to you about on-demand service provisioning with bosch 2.0 so I'm Alex Lai I work for pivotal in London I'm Greg I work for pivotal in London on the cloud for Andrew services yeah so we've spent the last few months building cloud foundry service brokers the provision you know infrastructure resources on demand and so we're going to tell you about some new features that we've used in Bosch that enable us to do this and also the features in cloud foundry they kind of tie this all together so this in a talk about the Bosch internals I think there's good talk about that earlier today but we're going to be talking out it's like people who develop services for cloud foundry but this is going to be interesting for the application developers who want to know a bit more of what happens when you run CF create service so I'm sure this email will look familiar to any app developers in the audience especially those that work at typical large enterprises so this is an example of an app developer asking for a Redis service to be provisioned for them by ops they probably can't walk over to the desk where the ops team sits the ops team might be in a completely different office they've got to specify exactly what they want in that first email and often you'll get an email that looks like this coming back in asking for your like cost center or business approvers yeah like we don't want to worry about this no one wants to worry about that and so we want you know databases in like three to five minutes we don't want it in three to five days and if you get something wrong you have to go through the cycle over and over again it's really painful so then along comes Cloud Foundry and improves everyone's lives immeasurably right so so who's run this command before who's run CF create service okay that's most people as good so I'll go every quickly just to break it down the first argument to create service Redis cloud for Andrew looks up the external service broker URL for the Redis service offering forwards the request to it the last parameter is just a name that you make up so that you can reference the service later it's the middle one which is interesting to this example shared VM so implicit in this plan name is that we're going to be doing an example of a multi-tenant service plan so Redis is single user not natively multi-tenant to achieve multi-tenancy we're going to have to start up Redis processes on the same virtual machine yes so clarity really helps us with our applications but still behind the scenes anything kind of to do with managing services it doesn't help you and this is quite a hard problem to solve and so you know especially when you've got stateful services and you start to manage disks and persistence so we're going to walk through a scenario where we want to do this for a multi-tenant Redis service so first you need somewhere to run your service so you go and get a VM from let's say AWS you've got a copy over the Redis software you've got to set down some convict on the VM including things such as port you've got to start the Redis process and then importantly you've got to monitor it so that it stays up you're going to need a persistent disk if you want to use Redis is persistent modes to store state but wait someone else wants another Redis on the same multi-tenant service so yeah we need to start off another Redis process on a different port with different configuration possibly and then we also need a place to store that on the disk and then actually if you want to spin up another one you probably need some kind of orchestration on that VM to handle bring it up Redis processes taking them down you know what happens when someone wants to delete their service instance you have to handle that in this agent we still need monitoring if you have too many registers and you have this noisy neighbor problem where Redis one is taking all vs. twos memory how do you handle this so to solve some of these problems we should just give everybody their own Redis this is referred to as a single tenant service plan where each Redis instance process runs on its own dedicated VM you still need the virtual machine you still need to run and of course monitor the Redis process and you still need the persistent disk the configuration gets a little simpler you no longer have to do stuff like make the port or the location on persistent disk to store data anything other than static you're on you're gonna have one Redis on this machine you lose the noisy neighbor problem too now you've got to automate provisioning these single tenant virtual machines so how do we do this we use Bosch so I'm sure it seems like most of people in the room know this but it's preferred way in cloud foundry for managing deployments it manages the full lifecycle of software rights concerns with packaging your software deploying software running software and upgrading software it supports multi cloud so you've got vSphere AWS as your OpenStack cloud stack google google compute pretty much all of the main infrastructure providers so really this means that you can focus on your code and not the infrastructure you know because we do love Bashan Cloud Foundry so so this slide shows one pattern you could use to develop a single tenant Redis using Bosh we're gonna have four virtual machines three Redis VMs and one service broker when the broker receives a create service request it's gonna very simply allocate one of the pre provisioned Redis virtual machines from the pool and market is taken deep provisioning is a bit more complicated when someone gives up their instance you're going to want to recycle it because you're not gonna get anymore so you've got to scrub the stay off the persistent disk rotate the password probably bounce the process as well you'll probably need an agent kono kata Don the VM to do all of this um the upshot of using an approach like this is your operational story is a lot simpler the entire service offering and every instance are described by one bosch deployment but the big problem of course what happens when someone tries to create more than three instances oh it looks like instant creation will fail co the service broker would have noticed that the he only has three to give out and when you ask for the fourth there's none left so we're right back to here we have to send another email to the Cloud Foundry ops team and say can we increase the number of registers we have available on the platform and so why should developers be doing this so how about we deploy resources on demand so we use boss to do this and what would this look like effectively I mean CF crates service is a boss deploy and so let's take a look at what this is going to look like so a Bosch deployment is described by a Bosch manifest every deployment has exactly one manifest so the first job of a service broker that wants to deploy things on demand using Bosch when it receives a create service request is to generate a Bosch manifest then it creates the deployment by just sending that manifest to Bosch we then we don't care like we love Bosch we love what it does but we love that we don't have to think about it Bosch will just converge the state of the world into what's describes in your manifest there are a few problems with generating bosch manifests with code though that we're going to go through now so in a bush wonder a manifest some of the Aya's abstractions leaked into the manifest and it results in a as specific manifests and also you have a lot of stateful IP bookkeeping so the service broker has to handle giving out IP addresses and putting those in particular manifests and it also has to worry about running it over multiple availability zones so you in Bosch Wando manifest your handcrafting you have a diversity zillion structure and so this is lots of work and you know results in quite complex service broker architectures so this is a snippet from a Bosch one style manifest another kind of show of hands how many people have written Bosch manifests ok that's almost everyone again that's good so this is just a snippet it's not the whole thing obviously we're gonna highlight some of the issues but generating these first of all look at that static IPS blog you've got to keep a stateful representation of what you haven't haven't already assigned it forces the service developer to perform part of the role of a network administrator another snippet from the same manifest this is the concrete network definition specific to the CPI we're on looking at the cloud properties block at the bottom you can see that it's AWS now it's not a not a huge deal but you're gonna need a code path per CPR you want to support someone brings our new CPI and you have five service brokers let's say that are all doing this you've got a push and update to all five brokers it can become a pain similarly you've got cloud specific stem cell definition stem cell names even and virtual machine definitions so what comes along Bush to doe write songs of our problems it makes our lives a lot easier service developers and also anyone that will be running Bosch releases you know it's great and so really it's not a a to delay release as you might had earlier it's like a set of incremental features that have been put into Bosch over the last six months and then aiming to keep some backwards compatibility so let's go through some of the new features in in Bosch do some of them are a lot older than others because like Alex said they've been trickling in over a long time so static IPS have been optional for some time now if you omit them Bosch will dynamically assign an IP per job from whatever range you've configured from the networks and no more bookkeeping there was a kind of old trick people did for one job to discover another let's say you've got an errand that registers a service broker with Cloud Foundry and needs to know the service brokers IP address you you would in the past give the service broker a static IP and copy the IP into the properties block of the errand that needs it well we now got this feature job links that allows one job to discover facts about another such as the IP at a templating time so you never need to use static opiez in any circumstance that I can think of certainly CPI specific resource definitions to those subnets and BM types we saw earlier in the snippets these have all been moved up to a global cloud configuration manifests now only reference resources by their abstract name these names are then concrete defined in the cloud config the power of this is that manifests are now completely portable across different clouds no more code changes when someone wants to support a new new CPI in their broker it's all just done for you similarly like Alec Alex already said there's now first-class AZ support you don't need to do the trick anymore where you stripe the jobs across a ZZZ manually you define which a ZZZ you'd like to stripe across in your manifest and boss handles everything for you so this is an entire Bosh to manifest it's short enough to fit on one slide and down the bottom you can see an example of resources being referenced but not defined in the same manifest this manifest is portable to any Bosch director on any CPI much easier to generate encode for us lazy developers yes so this is all documented on the Bosch IO website so these are some of the main like features and so you can go to these links to check it out we're point upload the slides afterwards so you can get these links but it's quite easy to find on the site so what we're going to do now is you know went away taking these concepts and built like a example how you build a service broker so we're going to take a look at like the CFC Li life cycle and look at how that orchestrates Bosch tasks and I as we know resources so bear with me a sec well I try and get it out of this into a video yeah we're probably gonna have to flick through every slide again when this is done great okay yeah just play this here okay so what we're going to be doing here is using Redis as an example again and the first thing we want to do is see what's available to us in the marketplace I'm just gonna stop there since see if I make a little bit bigger so great okay so we can see that we've got an on-demand Redis broker and we've got a dedicated Redis plan available and so what we're going to do is create a service and this will use the Cloud Foundry async provisioning feature and so what cloud controller does is sends a request to the service broker the service broker accepts it and then the cloud controller will keep polling the service broker saying is it done yet so you can see what's happened here is that the service broker has created a Bosch task this is a new boss deployment for Redis so this is Yano provision a VM you can see here the Bosch is talking to the IRS to provision this VM and so what this results in in AWS is a new VM coming up you as expected with Bosch and so here you can see that we've got a t2 was at t2 Micro yes there's a really small Reddy's instance suitable for like a development use case so now a Bosch will lay down the Redis software like we described earlier and it's gonna monitor make sure that all those processes are healthy and so once it's done that or we'll come back to you know report success and in the meantime the Cloud Controller is still polling the service broker saying you know it's my service instance ready yet and so here you can see that it's still in progress and within a minute we should have it have it created successfully and so you can see that we've easily gone from cf great service talking to the service broker and then resulted in a new radius deployment so let's have a look at how we could reconfigure this so you've got your own dedicated Redis you know that was really easy but you might want to fine-tune some of the configuration so we're going to push an example app this example app allows us to read and write from Redis also check out the rightest configuration so you can see here that we're just pushing it and binding it to the service and so once we have the application up and running we're just going to make sure that Redis is healthy and we're just going to try and write some data to Redis so you can see next so the video might be on the point but we've effectively got the application running and bound and now we are going to issue a command to Redis to write some data which was a success so next we want to try and change your configuration so we're gonna we've chosen the max clients Redis which you can see in a sec by default this is set to 100 and so we want to limit how many people can connect to our Redis and by default we're gonna set the max clients to 10 so this is something that as a developer you might want to put constraints on in your service so what we're gonna do is do this update service and pass in an arbitrary pram again you can see a common pattern here right with the service brokers received a request generated a new manifest send it to Bosh and then Bosh has community started the deployment and it is going to update the deployment lay down in the new configuration and so let's see run the max clients command again and see if that's changed and so yet boss has done the deployment and we've changed the max clients to 10 so this is giving the CLI user a lot more power around how they manage their service so finally we're going to look at switching Redis over on to a high memory VM so a use case for this is like your apps running out of memory in Redis and you want a new a new bigger Redis right it's quite common so you do this through a plan migration so we're changing over to a high memory plan and I think you might be shocked to this but we're gonna use Bosh again to upgrade the deployment and what this does behind the scenes as is detaches the disk from the old Redis VM and it will bring up a new high memory VM here you can see we're going for like an r3 large and then you know Bosch is going to reattach the disk and it'll mean that we have pretty easily switched over the VM type all using the power Bosch and the service broker effectively just becomes a manifest generator and instructs Bosch so that's kind of the end of the demo but you can see this is quite a powerful experience for CLI users now so let me try and get back into the slides [Applause] so that demo was made entirely using shell scripts that look like they're creating watch deployments but really they no no no I'm kidding it was it was recreated using entirely features that are available in open source Cloud Foundry an open source Bosh so you could make something like this today yep so this Santa comes back on track great so this is fantastic for app developers this gives up developers more control over provisioning and managing their stateful services than ever before crucially it even gives them the ability to provision and manage hires resources which quite possibly they won't have done before this can move organizations to a more DevOps oriented culture so you can see that we can offer these cool experiences around managing of services from the CLI so today you would probably use like arbitrary parameter configure this so we're gonna help look at example here where we're scaling a cluster right so you might want to have a Cassandra service and all of a sudden you want to scale the number of seed nodes in your cluster so you could pass an arbitrary pram that would get through to the service broker and here we're saying we want five seed nodes so the service broker would then receive this it would generate a new manifest just increasing the instance count and deploy this so this is pretty awesome because now the CLI user the app developer is in control of you know scaling their cluster dynamically as they see fit it's currently we do this often through plans so you change your plan you know which isn't great and you know we currently have no control for app developers often when your service gets upgraded right so if you're changing major versions of your service you know your bump you might be changing your Redis version and it might have braking changes so at the moment as of a weird cycle between operators and app developers to let them know there's new software available and they're going to be upgrading on this date but you could move this over to allow the application developer to have some control of when they get to upgrade their service so you can see here that the we would use laboratory params to pass in you know upgrade command we could generate a manifest for the new version of Redis you know all controlled from the app developer so we're just going to look at it like is it time for a richer Cloud Foundry service experience and what would this experience possibly look like so these next few slides are not using real CFC ly commands that using potential CF CLI commands that achieve the same things as the previous slides did with arbitary parameters so what are the advantages to making CF upgrade service a first-class citizen well for one unifies the UX around upgrades if you had lots of services lots of service brokers offering upgrades with differently named RPG params that can get confusing and frustrating for the CLI user if upgrade service was a first-class citizen it's implied that CLI users app developers would be able to discover their upgrade path as well using the CLI rather than poking around in Bosh and asking service developers so that's that's a thing that potentially could be explored in the future similarly and same UX argument as before but for scaling scaling the instance count of clustered services is extremely common currently it's often accomplished through having lots of plans the advantage of doing it through an arbitrary parameter is that you deep clutter the services marketplace you don't have so many plans if the service developer wants to offer a large range of instance counts they can instead just pass that responsibility to to the app development so while this all sounds pretty awesome it does really make some huge operational challenges so imagine you've got an organization that's creating you know services you create 50 registers you create 50 Cassandra clusters you've got a ton of boss deployments and Basch deployments mean like resource usage so the boss deployments we use your iers resources which you get charged for or it might use your internal you know vSphere again you're going to need some way of monitoring who's using the resources how much they're using are they efficiently using them you know does this development team really need the biggest Cassandra cluster another example would be quota management and chargebacks that's like a common request around services how do you manage this and then effectively as you're going to see your AWS bill ticking up and up and up you know you want might want some quota management around that so when I mentioned earlier that app developers having control of Aya's resource provisioning was a benefit for them it could also be considered a risk from the point of view of operators it's possible using all of these features today to build a very flexible service broker that puts almost full control of I's resources instance accounts etc upgrade life cycle even into the hands of app developers do operators want to permit a service broker on their platform that allows app developers to stay on an arbitrarily old version of Redis forever and then upgrade to the newer one using an unpredictable path do they want to permit service brokers that allow you know indefinite scaling of nodes probably not so the balance to be had here and this is a new challenge for operators yes so with that you know we hope you would given you something to think about especially with the last few slides and I believe we've still got a bit of time if some questions if anyone had a in the back left the example service poke you saw and this was not yet open source Hey yes so the failure so the question is around like Bosch failure which is quite an interesting scenario where the box deployment might not succeed and you might have some leftover resources that need to be cleaned up there you would need if you're building a service broke like this you'll need you know lots of logging and metrics and feedback cycle to operators if something did go wrong so there's also a UX element to this so when an asynchronous service provisioning or or update or deletion for that matter fails the service broker can send back some message that gets displayed on the CLI so again it's in the hands of the service developer do they download all the output from the Boche tasks and expose that yeah the app developer that's maybe that's some that's for the people who product wise these things too to decide anyone else okay great well thanks for listening and just [Applause] 