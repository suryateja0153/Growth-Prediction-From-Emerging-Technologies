 hi my name is Chris champion and I'm an embedded technology specialist for the programmable Solutions Group Intel today I'm going to talk about how to use authentication and encryption with area 10 SOC FPGAs and we're going to run through an example using volatile keys the authentication and encryption flow can be split into three stages in the first stage the developer goes ahead and creates the programming file for the FPGA as well as the bootloader the outputs from this stage are a programming file the SOF file as well as the ub bootloader binary these two deliveries are handed over to the Information Security Department InfoSec will go ahead and create an aes 256-bit key and that will be used with the quarters convert programming file executable to encrypt the programming file into an encrypted RBF file another output from the convert programming file is the fuse file needed to burn the keys into the FPGA additionally the AES 256-bit key can be used to encrypt the bootloader and this procedure uses the secure boot encrypt executable if you're also using authentication then an sha 256 bit key has to be created as well this key is used to sign the bootloader image and the output from this is an encrypted and signed bootloader the third stage is the programming stage the inputs into this stage of the fuse file the encrypted FPGA RPF image as well as the encrypted and signed bootloader the programmer will use the ekp file to program the volatile or non-volatile fuses in the fpga the RBF file will be copied across to the boot media and the encrypted and signed bootloader will be concatenated into four distinct images and also copied to the boot media in my example I'm going to use the three separate stages of the flow if you don't have any restrictions as far as information security is concerned or you're just evaluating the flow then it is possible to perform all three stages on the same computer so we start off in the developers environment and as you may recall there's two files that are needed to be handed over to the secure key vault at information security those files the programming file which is the SOF file as well as the bootloader images self and my example have already got the programming file so it's just a case of making the bootloader ready to be handed over so let's start by entering in a meta command shell and we'll then launch the BSP editor to customize the bootloader so in the usual way I'll make a new board Support Package and I'll point to the handoff directory within my implemented project now when creating a board Support Package you'll notice that there are some options for signing and encrypting the bootloader these options are great if you're trying out the flow or if you're going to do everything on one computer because I'm separating the flows into three stages I'm actually not going to use these options but just to stick with the default bootloader creation so let's click generate to generate the required files now that the bootloader source files have been created it's just a case of making the bootloader now usually we'll make four copies of the bootloader to install into an SD card however in this instance we actually just want to create one image the concatenation of the four images will happen after we sign and encrypts the bootloader so by using the environment variable mkp image use single image equals one this creates the single image for us now that the image has been created we have a binary file here you boot with device tree binary mkp image bin this is the file that will handover along with the programming file to Information Security the second step of the flow is in the secure environment we've got the two files that we need from the developer and the first time through the flow we need to create some keys the AES 256-bit key is communicated to the tools just from a text file so here I've got an example of a text file with a key key one and as you can see here I've got a 256 bit numbers the key we also need to create a key for the authentication and for this I'm going to use open SSL so I'm generating this ECDSA key I now have a PEM file which contains the pair of public and private keys this file along with the AES 256-bit key are your secrets so these need to be kept securely now that we have all the files that we require let's go ahead and do some encryption so it starts off by creating the key file and the cryptid RBF file so for the key file we run the Quartus convert programming file utility I would point to key one in our key file we take the input soft file and then we specify the output key file the next step is to encrypt the programming file into an encrypted RBF so again for this we use Quartus CPF using key 1 and I'll create an RBF file for handover to the programmer the final steps are to encrypt and sign the bootloader so let's start off with encryption for this we use the alt secure boot encrypt option we take the bootloader binary file as an input I give the output file a name we now want to sign this binary so we'll take the output from the previous command and put it into a signing command so now we're done from an InfoSec perspective we've encrypted the programming file we've then gone ahead and encrypted the bootloader as well as signing it we now have some files that we're going to hand over certainly we're not going to hand over our keys but we are going to hand over our encrypted and signed binary the encrypted programming file as well as the file for programming the keys into the fuses now we're into stage three which is the programming environment now hello the files are the encrypted key file the programming RBF file as well as the bootloader binary file we need to make four copies of the encrypted bootloader image for the boot ROM so let's go ahead and do that now with alt image cat now that this is done we need to copy the bootloader as well as the programming file into the non-volatile device and in my case I'm going to use an SD card so let's first copy you boot into the alterior partition on the SD card and copy the RBF file into the fan partition now our SD card image is complete we've now got a complete SD card image and I'll go ahead and plug that into my board now the final step is to program the fuses once the fuses have been programmed we should then be able to decrypt both the FPGA image as well as you mood so launch the quarters to programmer so let's detect the board first at all and for the FPGA portion of the device I'm going to select our ekp file to program the keys so the keys I've chosen to program other volatile keys this means if I power off the board the keys will be lost in production you can backup these keys with a battery or alternatively you can burn the volatile keys into the FPGA but let's go ahead and program the volatile keys I also bring up an rs-232 terminal to see the output from the board at the moment the board is powered up but the keys aren't programmed so the boot ROM is unable to decrypt the new boot image however as soon as we program the keys the boot ROM can then decrypt the image and go ahead and boot you boot new boot is now writing the RBF file to the FPGA and because the FPGA has the AES keys it can then decrypt that image and successfully configure the FPGA to continue the next step for production would probably be to burn the volatile keys this way the device can be set to only boot from the encrypted images and as well.all 10th occasion can have the digest stored in two fuses in the device the process for doing this will be the subject of another YouTube video 