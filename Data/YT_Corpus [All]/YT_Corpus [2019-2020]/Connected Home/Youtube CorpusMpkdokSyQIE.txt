 [Music] good morning everyone thanks for joining us on day three of i/o to talk about thread and Google cloud my name is Ken Barnes I'm a product manager on Google Cloud IOT core and I'm Jonathan Hui principal software engineer at Google Nest and VP of technology for the thread group so we're super excited about this session today and to tell you a little bit about things that are happening in thread and IOT core before we get started can we just see maybe show of hands how many of you here have heard about thread before okay most one yeah pretty good Jonathan and what about IOT core or use Google Cloud in any way before also pretty good okay so if you haven't heard about them don't worry we're gonna give a little brief intro when we get started here if you have I think we have a really really exciting session today because we are going to be demoing for the first time MQTT and tcp over a thread network all the way up to the cloud and we're also going to be showing co-op communication to IOT core but before we get started I want to talk a little bit about what are requirements for the device that we're gonna build and demo today are and how they differ from maybe some of the current IOT devices whether they be smart home or commercial buildings that are on the market so for the devices we're gonna build today we want them to be very very low-power so this means not just having long battery life but also being able to work on very very small batteries for long amounts of time next we want no proprietary hubs or gateways we don't want to have proprietary application layers or require users to install new hardware for every single device that they buy and finally we want I P all the way to the edge so we want our devices to work with the existing internet standards and protocols that we know are secure and are comfortable working with but before we get into how we're going to do that I want to talk about the state of wireless products and I think this is true whether you're talking about smart home smart buildings industrial wireless products I think it really runs the gamut so today we have a lot of devices that are using Wi-Fi using 802 dot 11 and this works great for many classes of devices if you have a camera a smartphone or laptop something where you can recharge the battery you need to use a lot of bandwidth Wi-Fi is great but for devices that need to be very low-power Wi-Fi isn't as good you need to either be able to recharge the device frequently like your laptop or phone or you need to do a lot of tricks to end up making it be very low-power over time the other issue with Wi-Fi is when you start having lots of nodes so especially for your average consumers home wireless setup if you want to connect every single light bulb or light switch in your house you're gonna have an issue doing that with your traditional router and still have the rest of your devices work so we know that even though there's a lot of good Wi-Fi infrastructure in place it's probably not the technology we want to use to build our next generation wireless and IOT products so I know what a lot of you might be thinking well there are good solutions out there for this today we have Bluetooth we have ZigBee we have z-wave a number of wireless technologies that will help us build lower bandwidth but lower power consumption and also scale to large numbers of nodes in small spaces however while these do address a number of the issues that we're looking for if they have one critical fallback and that's that they need lots of these IOT gateways so they since they depend on their own radio technologies usually proprietary application layers and tightly linked application backends you can end up in situations where if you have multiple products from multiple vendors or even in some cases multiple products from the same vendor where you end up with a whole host of these devices connected to your router at home or it can be even worse in industrial or commercial IOT settings and while this does work from a technical perspective I think it hurts user adoption in a couple ways one is it drives up costs if you need to sell a gateway with the first light bulb that your customer buys or the first whatever your product may be you're probably more than doubling the cost for that very first entry point next is it creates confusing user setup experiences nobody wants to have a lot of these or go through having to learn the differences between setting up a Wi-Fi device versus a Bluetooth device versus a sigma device and finally and I think what the largest problem is is it encourages silos so the manufacturers of these gateways want every product to work with their ecosystem and so we end up with silos of functionality as opposed to real Network interoperability like we want to build so I think these are some real problems but luckily were pretty close to having a solution to help with it so we were facing these exact problems that Callum was talking about at best where we wanted to build products for the connected home where we were keeping users not only comfortable but also safe and secure we wanted to build solutions where our devices could communicate securely with each other to cloud services and see users via their mobile devices we also wanted to have those devices to be very low power because we wanted those devices to last for years on very small batteries but as we evaluated existing communication technologies we could not find a single technology that satisfied our requirements so in 2014 nest along with a number of other companies founded the thread group the thread group is a nonprofit organization with more than 100 member companies from around the world and the thread group is responsible for defining and maintaining the thread protocol specification it serves as a market education group for promoting the use of thread in connected products and it ensures a great user experience through a rigorous and meaningful product certification program so in summary the threat protocol is an open IP based low-power secure mesh networking technology for connecting IOT devices it supports the same IP technology that drives every internet connected device but is designed to support very low-power applications including devices that operate on coin cell batteries now for the radio thread users I Tripoli a two 2.15 dot four it's the same radio that's been used in ZigBee for fifteen years using an existing widely deployed radio allows thread products to achieve fast time to market as well as leverage existing economies of scale to achieve low-cost solutions now with the network layer thread uses existing IETF standards for supporting the Internet Protocol version 6 or ipv6 over a two 2.15 dot four radios a technology called 6lowpan now thread support for the Internet Protocol is a key differentiator and most existing technologies do not support IP so why is IP so powerful well first it means that we can build solutions that utilize a number of link technologies including Wi-Fi cellular and thread and have all of those devices communicating with a common single application layer end-to-end without needing to build and maintain application protocol gateways and at the same time it means we could have a single network that can support multiple applications simultaneously IP makes it easy to deploy new applications and it was a key reason for the success of the internet and thread extends that benefit to low-power devices and specifically for this session it means that we can build battery powered devices that communicate securely end-to-end with Google Cloud IOT core without any application layer in between ok so now we've seen how we are going to use thread as the radio technology to build these products and we also know that thread is going to give us a underline IP layer link which means we can use just about any cloud back-end that we want to to connect these products and leverage data from them or interact with them but let's talk about first what we need to think about when we choose a cloud product or choose a cloud to use there are a lot of options out there and I think a lot of them will probably satisfy what we're going to do today but there are two big things that you want to think about first is security and the second is scale so security is always important in IOT it's a very often written about topic I'm sure I don't need to tell people at i/o about all of the high profile leaks that have happened or botnet attacks that have happened but what is going to drive more security in IOT I think starts with identity and having a strong underlying identity for our products so we want to make sure that whatever we choose is going to allow us to put a cryptographically strong and unique identity on the boards that we're gonna use in the demo today an X is scale and I think there's a few things to think about when you are thinking about scale in the context of IOT one is we are thinking about large numbers of devices so over time we think there might be you know millions or tens of millions of devices that we might sell into market and need to connect to this cloud so we need a solution that we know can scale up to very large numbers of devices but we should also realize that at the very beginning your IOT deployment or solution might be just like ours is on stage where you have just one or two devices and for this reason you want whatever you choose to scale from an economic perspective when you still have just a few devices in market so to do this today we're going to use Google Cloud IOT core IOT core is Google clouds managed service for connecting IOT devices to the Google cloud network it provides two important things that we're going to show today so first is device identity provides a mechanism for distributing key based identities to devices so every device will end up with its own unique private key as well as the corresponding public key trusted in IOT core these keys can be used in a couple different ways to connect and authenticate to the system and jonathan is going to talk more about that later the other thing it offers is a protocol bridge and support for common I owe t protocols like MQTT and HTTP and what this protocol bridge is completely serverless and will scale with our application so it's easy to connect just a few devices to it and will only have to pay for those cut the bandwidth used by those couple devices but it will also easily scale up to hundreds of thousands or millions of devices deployed all over the globe without us having to change any code or deal with managing the backend but connecting the devices to the cloud isn't the whole story we need to actually communicate back to the devices or leverage the data that they're sending to us if we want to build an actually useful application and luckily Google cloud can help with this - so we're gonna today try to leverage all serverless tools that will scale elastically with your application the same way that I just talked about IOT core doing so the first thing that we're going to use a Google cloud pub/sub so all data sent from IOT devices into IOT core end up as a message on a cloud pub/sub topic pub/sub if you're not familiar with it is a scaleable message bus to build event-driven server lists or micro service applications so you'll never have to worry about scaling for Peaks or dealing with losing data the next thing we're going to use is cloud functions so a cloud function is a small snippet of code that can be written in a few different languages that are supported right now and it allows you to do event-driven development so this function can fire every time an event occurs or at a regular interval in this case we're going to use it to process each message in each event that comes into our pub/sub stream this will make it easy to again scale our application but also build it and finally we're going to use cloud fire store the fire store is a flexible no sequel database hosted and managed by Google Cloud and you'll see the query system and real-time update nature will make it easy for us to build this application but also in the future build a mobile application or other application that leverages that data Google Cloud has dozens of other services that can help with building your application but these are the few that we're going to use for the demo today all right so let's get to some of the fun stuff and actually show you how we can build some of it now as mentioned thread support for IP makes it possible for a thread device to communicate securely and end-to-end with IOT core in the middle there is a thread border router that's responsible for forwarding packets between the thread network and the public Internet and note that the thread border router simply Ford's IP packets at the network layer and does not need to implement any application layer logic or proxy in fact the thread border router has no knowledge of MQTT or HTTP making it easy to deploy new applications without having to update or maintain application layer proxies in between now three years ago here at i/o we launched the open thread project open thread is an open source implementation of thread and it is the same implementation that's used in nest products including the nest hub max that was announced here at i/o the open thread project is hosted on github and licensed under BSD three and it's seen widespread adoption open thread has been ported to more than 10 different 802 dot 15.4 radios and you can find example drivers for each of those in github now in today's demo we'll use the Nordic NRF 50 to 840 system-on-chip we actually brought a few of those here with us today for use in our demo so let's take a look at them on stage you'll see a couple dev boards on the right and then a USB dongle attached to a Raspberry Pi on the left these at the NRF 50 to 840 is built around a 32-bit ARM Cortex m4 but 256 K of RAM 1 mega flash and they're really intended for low-power low-cost applications and these dev boards are publicly available which means you can go home and play with and replicate everything we've done on stage today alright so let's get back to the slides alright so let's get started with mqtt now for those of you that don't know MQTT stands for message queuing telemetry transport and is one of the most popular transport protocols used in IOT applications today MQTT implements a published subscribe model on top of tcp/ip now in this example we'll walk through how to build an mqtt over thread endpoint that communicates securely and to end with IOT core we will leverage third-party software for networking we'll use lightweight IP or l web allowing us to leverage application frameworks that have already been built on top of l WIPP including MQTT for security this example leverages embed TLS and a jot c library for security and for the artists will use free artists well let's walk through some of the code so here's the main control loop that runs on the thread device it's pretty simple it starts by establishing an MQTT session - IOT core and then it sits in a while loop publishing telemetry events every two seconds so let's dive into the connect method first the first step is to specify the mqtt connection parameters MQTT uses TLS for transport layer security so we have to set up the private key and certificates for use for TLS we also need to specify other mqtt parameters such as the client ID and keepalive values now at the bottom the device must also prepare a JSON web token let's take a look closer look at what that JSON web token is now as Callum mentioned IOT core provides a device identity system a JSON web token or jot is a compact URL safe means of presenting representing claims and is used for device authentication with IOT core Ajanta is composed of three sections a header a payload that contains a claim set in a signature the header and payload are JSON objects and the header consists of two fields that indicate the signing algorithm and the type of the token the example here uses RSA but IOT core also supports elliptic curve now the payload contains a set of claims that is signed using asymmetric keys IOT core requires three claims the issued at which is the timestamp at when the token was created the expiration that is the timestamp when the token stops becoming valid an audience that contains the cloud project ID where the device is registered and then finally the signature contains a cryptographic signature of the concatenated header and payloads so in CRO encode creating a John looks like this it leverages the John Hsu library and we first create the object then set the signing algorithm for the jobs we add the issued at expiration and audience claims and finally we call jot encode stir which generates the signature and writes it out in the proper encoding so that's how we generate a client's authentication material for IOT core and more generally the MQTT connection parameters the next step is to perform a dns lookup for the MQTT endpoint in this case mqtt google api is calm now with the IP address for the mqtt endpoint we can then initiate an mqtt connection so that was connected pretty simple so now let's take a look at how to publish telemetry events using MQTT in this example the telemetry events are really simple temperature the first step is to format the payload in this case using JSON and then we call mqtt publish with the payload and specify an mqtt topic of slash device's slash MQTT - device slash events MQTT - device specifies the device ID and events indicates that this is a telemetry event that's it pretty simple so now let's take a look at what this look how this works in a live demo in this demo we'll be using a Nordic dev board as the MQTT endpoint the Nordic dev board communicates securely end to end with IOT cores MQTT bridge now the thread border router will use a Raspberry Pi with the Nordic USB dongle and for the cloud application will have a simple cloud function that processes telemetry events and saves them to a fire store database so let's take a quick look at the physical devices again just just so the dev board in the middle is is will be the one that we use for the MQTT endpoint and that will communicate wirelessly via the raspberry pi and to end with IOT core so now let's switch over to my laptop and show you some live demos so first thing i'll do is actually pull up on the cloud side just kind of show you the cloud function here so the cloud function listens for the topic temperature events and each time that it's triggered it simply decodes the payload which includes the temperature data and puts that into a fire stored at abase it's a very simple cloud function and then in our fire store database here we have a collection that's just for this demo and then we have a document for the mqtt device itself and of course we have some data that you know set to zero for now now if we go over here I have a console open to a raspberry pi so as you know the raspberry pi is the thread border router if I do and I have config you'll see at the bottom the WPA 0 interface you the network interface that represents the thread network as you can see the thread network itself appears as a standard linux network interface just like Wi-Fi or Ethernet now what I'm going to do next is start a TCP dump on the WPS zero interface so we can kind of see some traffic that's going over that thread Network now what I have also attached to my laptop is the mqtt endpoint so I'll open a terminal there and it has a very simple remember this is an embedded device so it doesn't even have you know a proper terminal but it has a very simple CLI and I do IP a turtle is this IP addresses of course nothing's listed yet because it's not connected so if I bring the interface up and start thread the thread service and wait a moment you'll see now that it has IP addresses because it's now connected to the thread network and has obtained the unnecessary information to configure those IP addresses and finally I'll start the MQTT service go back over to the TCP dump there first thing you'll see is an NTP request response that's the device itself synchronizing with global time and then after some amount of time you'll start to see TCP traffic that TCP traffic is the mqtt session itself of course we can't see the payload because it's within a TLS encrypted session but this is to show you there's actual TCP traffic happening you'll see messages have pop up about every 2 seconds and you'll see the actual data being presented here live and every time it receives a new message you'll see that field popping so that's it so that was our first demo demonstrating mqtt talking end-to-end securely with IOT core all right awesome Jonathan yeah I believe that is the first time publicly that we've demoed any TCP protocol and MQTT over a thread network so that's pretty exciting going all the way to IOT core and then up into our very simple database application so that's really great but MQTT and tcp are still require a fair amount of power this would maybe be good for a device which has mains power is connected all the time but that you still need a low latency communication back down to like a light switch or light bulb but now let's think about a much more constrained device I talked about at the beginning wanting to be able to power a device on just a small coin cell battery so let's talk about using co-op with IOT core so if you're not familiar with co-op it's the constrained application protocol and it's a specialized web transfer protocol that's made for basically exactly what we want to do very constrained devices and using very small amounts of power co-op is designed to be a lot like HTTP and it implements the widely used rest model so servers make resources available under a URL and clients access those resources using the familiar rest methods like get put post delete co-op was intentionally designed to resemble HTTP to make it easier for developers to build applications with it but there are some differences so at the network layer you can see it's exactly the same ipv4 or ipv6 and that's exactly what's going to make it easy to use with our thread network but the primary difference is on the transport layer with co-op will be using UDP as opposed to TCP and because of that for transport layer security we'll also need to use D TLS or data Gramm transport layer security which is specifically designed to function similar to TLS and provide similar levels of security for UDP connections and finally at the top we'll use co-op but from a developer standpoint this should look mostly like accessing http interfaces unfortunately IOT core not natively support co-op but because co-op and HTTP are so similar it's very easy to build implement or use one that's already out there stateless co-op - HTTP proxies so in this case what happens is we'll use the proxy URI option in co-op an option and co-op is basically the same as a header in HTTP and we will include information about the URI of the address that we would like to access we would like the proxy to access for us and what will happen then is the proxy will initiate and make the HTTP request receive the response from the server and then return the response as a co-op response which is a little different than HTTP but this allows the co-op endpoint to use a restful HTTP service pretty much as if it was accessing it directly but still getting the benefits of low power design and and co-op it's important to note that the coffee HTTP proxy jonathan will talk more about code availability later but the one that we'll use in this demo is available for you to go download and run it's completely stateless so it should scale very easily with any application using coop and the IOT core HTTP bridge so without further ado let's get into it and then see it happen yeah let's see how we can build a co-op endpoint that communicates with IOT core now as with the MQTT example thread support for IP makes it possible to communicate securely and to end but compared to the MQTT example one difference is the introduction of the coop proxy that Callum was talking about now it's just to remind everyone the proxy provides pass-through authentication passively to IOT core relating device credentials directly to IOT core and the proxy doesn't do anything to validate it the incoming co-op payload is converted to the required format for IOT core HTTP bridge and the responses from IOT cores HTTP bridge will be returned to the client with an appropriate co-op response code now here's the Software Architect you may note that the this appears much simpler than our MQTT example this example runs in bare mental environments and does not include an artist this example also does not include a third-party IP stack and other application frameworks the coop protocol is actually used within thread itself so this example can actually leverage the same co-op implementation that's within open thread so in short what makes this example really attractive is the ability to operate in very constrained devices that have limited memory and code space again the code has two high-level functions the first is to establish a secure connection and then followed by publishing telemetry events via that secure connection so let's take a look at established in that secure connection first for simplicity this example uses a hard-coded IP address but we could have done that using a DNS lookup as in the mqtt example we also need a to setup the security credentials for establishing the secure session here we use a pre shared key cipher suite finally we call ot kept secure connect to establish the D TLS session so let's take a look at the coop HTTP proxy implementation in this demo in this example the coop proxy listens on a specific path slash GCP and the proxy tra option includes the request URI path that the co-op proxy users when translating that request on behalf of the coop endpoint and it includes things like the project ID device ID and the publish event action so with co-op we use the post method to publish telemetry events the first part of generating the coop post request is to set up the coop header this includes specifying the path GCP and the coop proxy your re option along with the publish event sub path that indicates that this is a telemetry event so let's dive into that proxy or I option a little more now first we format the proxy URI path that the coop proxy uses when translating this request again including things like the project ID registry ID device ID and then we include the jot which includes the claims that specify the issue that expiration and audience claims that we talked about earlier we then pass that proxy or I string to job create for encoding and signature generation and once we have the jots we add that to the coop header in the proxy or I option so that was generating the coop header with a proxy or I option now let's take a look at the coop payload itself again it's pretty simple here we format the telemetry event data in JSON format as we did in the MQTT example and then we append that to the payload of the coop message pretty simple so now with a complete co-op request message we can send that request to the co-op proxy so now let's take a look at again how this looks in action again we'll use a Nordic dev board that's operates up this coop endpoints and that Nordic dev board communicates wirelessly again via the raspberry pi serving us that spread border router difference here is that rather than communicating directly to IOT core it is communicating with the coop proxy the choir proxy then stateless lis translates that message into something that IOT core can understand which is HTTP now in the cloud side again we use the same exact cloud function and fires to our database as we did with the mq GG demo so let's go back to my laptop so here it's the same screen that I left it you can still see the mqtt device still publishing data every two seconds but I have another document here which is for the coop device itself and of course because I haven't turned it on that data is still set to zero now for if I move back to the console real quick again TCP traffic flowing through the thread border router on the thread interface and on the on the desk here if I pick it up here's the coop endpoint it's a Nordic dev board and the difference here rather than being plugged in just to show how low power is this this def board actually is powered off point cell battery right so all I'm gonna do is turn the dev board on you'll see some green LEDs hopefully blinking and what you start to see here is again an NTP message for this device to get global time you start to see some UDP traffic up in the console that's that was the detail last session itself being established and in this case it is event triggered so if I push a button here you'll see UDP messages and those UDP messages actually are the coop messages being transmitted by this device through the thread border router and if I switch back to the firestore database the coop device information you can see now that that counter value is being updated each time I press the button pretty cool so that was the coop demo now what we've shown is to thread devices talking through the same border router using standard IP technology in this case we are talking to the same service and the same ultimate database but the important thing to note here is we could just as easily have been talking to two completely different backends these can be two devices from two different vendors but there are up or interoperating at the network level and going through the same border router without having to worry about or have any knowledge of each other so I think that pretty much wraps it up hopefully this shows how you as developers can think about and use thread and as border routers become more prevalent you can worry about just building your devices and having them talk to your back-end services wherever they might be hosted using standard IP technologies so if you want to see the tutorials and code they have it posted for both the demos at these links and if you have questions Jonathan I will be right outside afterwards so thanks very much [Music] you [Music] 