 hello everyone welcome to the second day of the labs of the kisket global summer school so so far you've learned how to work with single qubit and multiple qubit quantum states and in the lectures for your second day you discussed grover's algorithm and particularly talked about how it works in your lab you'll build grover's algorithm in kiskit so this discussion is going to show you a little bit about the kinds of problems that are involved in the lab and how you can tackle those problems so let's switch over to my screen here on my screen here you can see how i have a list that i'm trying to show you with 13 items grover's algorithm from your lectures you might remember shows you how to solve the problem of unstructured search using your quantum computer now if i gave you this list and i told you using a classical computer to find the marked item in this case that's the item with the red color on the end it would take you at least in the worst case as many items as there are in the list so you would have to go through each item and let's say if you started from the left you would need to look at all 13 items in the list in order to get to the number that's marked and then eventually to say i found the number on a quantum computer the promise of grover's algorithm is that you can find the marked elements in a list in square root of the number of items in the list so how does this work you might remember again from your lectures that the structure of grover's algorithm looks like this so this pictorial depiction shows you how grover's algorithm looks like the following block diagram with a hadamard gate that takes all your qubits from the zero state to a superposition state and then a series of operations so the operations you learned in the lecture are the oracle operator which which we have in that first box and a diffusion operator which is simply a reflection operator sandwiched between two hadamard gates and the idea of grover's algorithm is that you can do this roughly square root of the number of items in the list times and you should be able to get the result with pr with high probability once you do a measurement pointing to the marked items in your list so let's go through these in some detail you might remember that the job of the oracle is to take you through uh is to show you exactly which elements in the list are marked and the way to implement that oracle as you might remember from lecture is to actually take a matrix that looks exactly like the identity matrix but has minus ones at the indices where elements are marked so for example you might see here the index that is corresponding to this particular point is marked so i have a minus 1 here the matrix starts off with size 2 to the n by 2 to the n because your circuit has n qubits and at the end what this matrix does is mark the state that corresponds to this particular index so this is the the first index within the matrix so the oracle as you've seen here starts out looking like an identity matrix and then you'd mark with minus ones the elements in the diagonal that correspond to the ones you might you'd like to mark in a list okay so that's how the oracle looks the diffusion operator is also very similar so it's two hadamards a series of hadamards on all your qubits sandwiching one particular kind of operator again this matrix looks exactly like the identity so very similar to the oracle except this time the marked element is always the very first element and you might remember from your lecture this is how we implement the reflection operator and the reflection operator sandwiched between these two creates what we call the diffusion okay so now that you've seen how the two uh the two pieces work the question becomes how do you implement this in kiskit so let's switch off our screen as always your lab is going to be delivered as a zip file this zip file is going to be the the exercise that you're going to work with so as always you start by extracting that zip file looking in the folder there should be an exercise called exercise 1 within that zip file i'm going to use jupyter notebook as i did yesterday to show you what's in this notebook and if i do that this is what the notebook looks like when i open it so the structure is exactly like i showed you in the slides before where you have growers algorithm and you're going to build the the pieces of growers algorithm that make it work so here's a phase oracle for example where you're going to build uh the this the code for the circuit that the matrix that makes the phase oracle work and then here's the diffusion operator where you're going to write out the code that builds out that matrix eventually we help you put it all together so the grover algorithm has several pieces you're going to first create a quantum circuit with n qubits you're going to determine the number of rounds of grover's algorithm so you might remember from your lecture that the number of rounds is determined according to this expression that we've listed up here for you and then you're going to apply hadamard on all qubits and then do the repeated uh application of the phase oracle and the diffusion uh and the diffusion operator so these these operations you do them r times and r is the number of rounds that are determined by this uh this expression here and in the end you you do a measurement of this of all the qubits and see what states are measured now we we are looking for the particular instance of progress algorithm where we're looking for two marked states and those two marked states have length six so this is a six qubit grover algorithm and the indices of these marked states we tell you are 1 and 42 so the answers are 1 and 42. now you take these marked states uh and you use them to create effectively a grover algorithm circuit that takes six qubits and has the marked indices that are 1 and 42. so you don't need to change any part of this particular cell however you do need to fill out these components the diffuser and the phase oracle and once you're done as always we've created a section for you where you can submit your work this time before you submit your work we've also created a cell for you where you can see exactly what happens when you execute the quantum circuit and how the results look in terms of visualizing them on a histogram so i hope you have uh you have some useful insights as you're working through this exercise uh something that might be useful for you to look through is to use this execution and visualization tool repeatedly until you get the right results so going back to our slides what i would like to do is finish off by telling you that there is a textbook chapter called grover's algorithm that has very useful tips that might help you in this process so if you just simply look up kiskit textbook reverse algorithm you should be able to find this chapter which shows you a few things one of which is how to implement those oracle and diffusion operators using gates in the lab you're implementing them by using matrices and converting those matrices into kisket operators however when it comes to running them on real devices you really need to think about how to implement these operators as gates so you can see examples of how to do that for a few qubits in the kisket textbook and we encourage you to look through that chapter 