  - You know, I've tried to get ahold of him and he's just, can't, he's always mod by fans. (upbeat music) - Welcome back coding with Qiskit. I'm your host Jin. And if you're joining us for the first time, each week we go over a different quantum algorithm in this series. So be sure to like and subscribe. In this episode, we're gonna be talking about how to do chemistry simulations using a quantum computer. Using a technique called the Variational-Quantum-Eigensolver. One of the most exciting potential uses of a quantum computer, is to be able to simulate chemical reactions, so that in the future, we can discover new medicines and materials more efficiently. So how does a quantum computer help in simulating chemical reactions? Well, chemical reactions are all about comparing energies. A higher energy molecule will react with another molecule, if the end product yields a lower energy state. So suppose we have three molecules, AA, BB, and AB. If I can compute the ground state energies, of these three molecules and AB is the lowest, then the simple picture is that AA will react with BB to form AB, and this reaction will happen. Unfortunately, every time we add a particle to the system, the computational cost grows exponentially. But this is where a quantum computer is useful. Because our quantum computer is quantum, every time we add a qubit to the system, our computational space doubles. So what is the VQE then? The Variational-Quantum-Eigensolver, is an algorithm that makes use of the variational method used in quantum mechanics. And if you're not familiar with this, that's no problem. Essentially what this means is, we can estimate the ground state energy of a system, by making an educated guess of its way function, which represents the molecule. We then vary our way of function until we get a minimum value of the ground state energy, given our model of the Hamiltonian. A Hamiltonian is just a mathematical description of the total energy of a system. It can describe the energy of a molecule, a ball on a spring, or a qubit in the transmission line. So the VQE is a hybrid algorithm, where the quantum part computes the energy, and the classical part optimizes the variational parameter. A simple use case of the VQE is to compute the interatomic distance, of a molecule like lithium hydride. So we can change the interatomic distance and use the VQE to compute the lowest energy at each distance. So the energy profile will look something like this, and at each distance the VQE can compute the lowest energy. Then the distance that gives the lowest energy, yields the actual interatomic distance. So let's break down the steps of the VQE. First, we need an educated guess of the wave function of our molecule. And this is going to take into account things like the geometry of the molecule, the electronic orbitals involved and the number of electrons involved. And we need to somehow encode this information into the qubits of the quantum computer. The energy is a function of some parameter that we can choose. For example, the geometry of the molecule. And our educated guess is known as an ansatz. And the process of encoding this information into the quantum computer, is a process known as mapping. So the second step is that, our quantum computer will perform a series of measurements, in order to calculate the energy of our molecule, given our ansatz. Finally, the energy is returned to the classical optimizer, which then updates the ansatz. once the energy at this interatomic distance converges to a minimum value, the algorithm then moves to the next interatomic distance and the algorithm repeats. All right. Let's see what this looks like in Qiskit now. Okay, so first thing I'm gonna do is enter my environment, Conda activate coding with Qiskit and this is where I have Qiskit installed. And one thing I actually need to install now is PySCF. And this is a Python package that enables us to do chemistry calculations. So within my environment, I'll just do pip install PySCF. (soft music) Okay. And I'm gonna open up a Jupyter Notebook. (soft music continues) All right. And I'm gonna open up a new Python 3 Notebook. So at this point, I'm gonna import a lot of packages, but I'll walk you through each one. So first of all, I'm gonna implore NumPy as NP, this is my basic Python numerics package, import PyLab, This is just for some plotting and plot copy. This is convenient to have. And then from Qiskit, I'm going to import a bunch of things. So basic Aer, this is going to be for my quantum computer simulator, from qiskit.aqua import Aqua globals and quantum instance. And these are the tools from Aqua, which will allow me to run my experiment, from qiskit.aqua.algorithms import NumPy Minimum Eigensolver. So this is a tool that will give me the exact energies, based off of a classical calculation. And this will just give me some values that can compare the VQE simulations to. And then I'll import VQE from qiskit.aqua.components.optimizers import SLSQP. And this is gonna be my classical optimizer that helps me update my ansatz. From qiskit.chemistry.components.initial_states (keyboard clicks) import Hartree_fock. And this is gonna be my initial ansatz that we will then optimize over, using VQE. So that gives me a decently good initial guess from qiskit.chemistrycomponents.variational_forms import UCCSD. And this is a tool that helps me vary my Hartree_fock guess into my VQE ansatz. So that does the variation and converts my initial guess into my ansatz. chemistry.drivers import PySCF driver who's gonna help me set up my molecule.chemistry.core import Hamiltonian qubit mapping type. This helps me do my mapping. So now I'm gonna set up my molecule and we're gonna be modeling lithium hydride. So the syntax here is, I'm gonna type in H for hydrogen, and I'm gonna input the distances in 3D, where my H atom is going to exist. And then the curly braces is the dimension where we can vary. So we're gonna be varying the distance between lithium hydride in the Z direction. (soft music) Okay. And I'm going to set the distances that we wanna calculate the energies at np.arange. And we're going to look at distances from five angstroms to four angstroms and intervals of 0.25 angstroms. An angstrom is just 10 to the minus 10 meters. I'm gonna just set up some arrays to store my energies in. So this will be the ground state energy calculated by VQE. I'm gonna also calculate the energies, from our initial Hartree_fock guess, and this is our initial guess that hasn't been that hasn't been optimized by our VQE. So it's a close guess, but the VQE will get us to a closer value to the actual value. And then the exact energies, which is gonna be calculated by our NumPy Minimum Eigensolver. This is our classical solver, just so we can get a baseline for how close our answer is. So now I'm just gonna set up a loop where I'm gonna loop over various distances and compute the VQE. (soft music) Okay. I'm gonna just print what step I'm on, just so that I know where the calculation is. All right. Now I'm gonna set up my experiment, experiment. So main part of my experiment is to set up this driver and this is going to just set up the experiment for me. So I'll call my PySCF driver, put in my molecule, and this is where I vary the distance and compute the energy at each distance. And I need to input the basis, which is how my driver will represent the electronic orbitals. And I'll use a basis called the STO-3G. Okay. So now let me set up my quantum molecule. (soft music) Okay. So I'm setting up so that I can do my classical assimulation. And as I said before, as we increase the size of the molecule, this takes longer and longer for the classical computer to run. Now let me set up my Hamiltonian. This represents the energy of my system, and into this, I need to input my qubit mapping. And this again is how I encode the information of my molecule into my quantum computer. (soft music) I'm gonna use a mapping type called the parity mapping. And here I'm doing a little trick that helps to speed up the calculation called a two_qubit_reduction. I'm going to also freeze the orbitals within the molecule in the core that don't contribute to my bonding. So this also helps speed up the calculation, and I'm gonna do one last trick where I reduce the orbitals that don't really contribute to my to my calculation either. I just notice orbitals won't contribute up really. Okay. So now let's run this core's operator. So I use the operator to run my classical calculation. Let's get back the exact results from the NumPy Minimum Eigensolver. (soft music) (keyboard clicks) Run run this and then just get back the exact results. (soft music) Exact result. This is my classical calculation. This is so, I can compare my VQE results to the exact classical result. Now let's code up our VQE section. So I'll define my optimizer SLSQP. And I'm gonna tell it to try 1000 times before converging, and set the maximum number of tries to 1000. The initial state will be the Hartree_fock state. And this is going to take a few arguments Operator. This has to do with just what the molecule looks like. Numorbitalsoperator.molecules import from number of particles. Means I entered a qubit mapping, (soft music) Two_qubit_reduction. Qubit reduction. All right. Now let me set up my variational form. This is how I take my initial state, and I do the variations in order to find the minimum energy. So I used the UCCSD. UCCSD. Now to do this orbitals CoresOperator.moleculeinfo number of orbitals, particles equals operator.moleculeinfo, particles. Okay. Initial state is gonna be the initial state i, justifying that will be the Hartree_fock. (soft music) Qubit mapping operator. Mapping two_qubic_reduction that's my two_qubic_reduction trick. (keyboard clicks) And my algorithm is going to be the VQE. (keyboard clicks) Okay. And I'll plug in all these things I just defined. My auxiliary operators. All right. Now, let's plug this into what's actually gonna run our experiment algo.run. And we're going to use our quantum instance to run it. Use the basic error simulator, and we're gonna use the StatevectorSimulator. (keyboard clicks) Okay. One last line. So equals operator. And we just wanna process the results that we get. (keyboard clicks) Result. All right. And then from this VQE result, we can get all of our energies. So I will, exact energies append my exact energies exact all time energy VQE energies (keyboard clicks) and Hartree_fock energies. (keyboard clicks) All right. So let's go ahead and run this code. See if it runs, maybe there's some typos. Okay. It looks like I have a typo. Let me just hunt down where that is two_qubit_reduction. I think that should be two_qubit_reduction. Let's try this. Okay. Looks like I found another typo. This should be exact result. Oopsie! All right. So my calculation is done here so let's go ahead and plot what we get. So Pylab.fock distances, plot the Hartree_fock energies, label them. Hartree_fock, distances. That should be distances. The VQE energies, label them VQE (keyboard clicks) distances the exact energy from my classical computation. Okay. And let me just label my axes. pylab.xlabel enter atomic distance. pylab.ylabel energy.title lithium hydride ground state energy. And let me just put the legend of the upper right here. Okay. Oopsie! (soft music) All right.Here we go. So what I'm plotting here is the ground state energy, as a function of interatomic distance in angstroms. So we can see that we can start with the Hartree_fock energy, this is our initial guess in the blue curve. And then the VQE actually starts with the Hartree_fock and then finds a better answer. So minimizes the energy, which is shown in the orange dots here. And in our simulation our VQE actually finds the exact ground state energy as calculated by our classical simulator. So what we're doing in our calculation here is we're pulling apart the lithium hydride molecule, and we're calculating the ground state energy at each distance. So the distance that gives us the minimum energy in this plot is the actual interatomic distance that exists between the lithium and the hydrogen atoms. So to recap this episode, we use the VQE algorithm, to simulate the ground state energy of lithium hydride. And this is important because for larger systems, this becomes very difficult for a classical computer to solve. However, a quantum computer can help us speed up this process, and help us discover new materials and chemical reactions. Next week, we're gonna be talking about an extension of Grover's algorithm in order to solve what are known as satisfiability problems. Thanks for tuning in this week and be sure to like and subscribe. see you next time. Jin out. (upbeat music) 