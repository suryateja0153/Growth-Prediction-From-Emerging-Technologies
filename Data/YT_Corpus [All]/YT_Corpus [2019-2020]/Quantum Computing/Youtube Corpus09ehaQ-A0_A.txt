 hello my name is Maria and today I will tell you about some really great tools that we created to help people there on quantum computing so earlier today you heard a lot about quantum computing and you have to admit that it's a very exciting topic there is also this idea of it being able to solve the problems that are impossible to solve now so this means that there are a lot of people there who really want to learn quantum computing what can we do to teach them to help them learn the first step towards teaching people is creating materials that they can use to learn themselves on their own so we all move that learning with the teacher is awesome you can be guided you can have your questions answered but not everybody has the luxury of having accessed as a mentor in fact I'm pretty sure that vast majority of people learning quantum computing these days are on their own so we need to be able to help them and there are a lot of materials on the internet that cover quantum computing I mean it's 2018 after all there are books there are videos but a lot of these materials have some disadvantages first and if you're reading a book or you watching some videos it's my definition passive learning you consume information but you're not very engaged with it there are resources that over active learning but there are very few of them and really you cannot master a concept or an algorithm until you have actually tried to apply it to solve a problem to implement all the reason and it doesn't really matter if this is a quantum algorithm or a classical that's why the courses on classical algorithms always have written assignments they have labs they have ways to implement things to make sure that you have actually internalized them second let's say you have found some exercises to practice on for example books books have exercises but what if the book doesn't have the answers or hints I have a very specific book in mind it's the one which everybody recommends to people who start learning quantum computing it has lovely exercise but it doesn't have answers so if you have solved the exercise and you want to check if you're correct or if you're stuck on an exercise and you need a hint well congratulations you're stuck so what we are trying to do we're trying to remedy those issues we created a project called quantum Carter's named after this practice used in martial arts I heard from people who actually tried martial arts that it's a terrible name but I've never done it myself so works for me so the cutters are sets of programming exercises on quantum computing that you can do using a sharp each card offers a set of tasks of increasing complexity on one topic each task has to be solved by writing some code so it's active learning you try to do something actively and the most important part is that the car does have testing framework which takes your solution runs it and evaluate it to figure out whether it's correct or not so the cutters implement all the principles of good learning it's learning by doing they give you immediate feedback and there is increase in complexity of the tasks you attempt but there are also answers for the tasks in the code so if you're stuck you can go to see the answers and figure out what you have been doing wrong or in what direction you have to be thinking the coders project is only about a year old so far we have 17 Coty's on different project on different topics they cover a lot of topics that would usually be covered in an introduction to quantum computing materials started from the very very basics like the gates that are used in quantum computing like teaching you to recognize the correct gate or the situation to fairly advanced topics like Grover's algorithm between I talked earlier today about Grover's algorithm and it's actually my favorite example of what we can do to teach people because it's one of the very famous algorithms in quantum computing a lot of people have heard something about it usually it's something like all right it's this algorithm that can speed up database search that level of detail but once you actually go in and try to implement it and try to implement it to solve a certain problem even a simple one that's when you start to figure out how how is it that it works what are the things that nobody mentions and trust me there are things that books don't mention and kind of the more you play with it here the more you start to understand that maybe a database search is not the best application for this algorithm the kata are all open source and freely available available for everybody to download to learn themselves to teach other people in fact they're open source so a lot of them were contributed by people outside of our team and they're available online as Jupiter not books now it's time for demo well I like to live dangerously this is the Carta which teaches new to solve problems with Grover's algorithm I did mention that is my favorite right so let's take a look at how this works okay it doesn't minor technical malfunction now it does so I'm running this locally it's also available online but I didn't want to run the risk of dropping internet connection or something exciting will exist so it's a Jupiter notebook you see there are some instructions in the beginning on how to initialize the carton basically it lots and packages that we will need to evaluate your solutions and the first part is writing Oracle's for the problems that you're trying to solve so what does a Grover algorithm do basically it's given an implementation of a function which takes binary input and gives you binary output 0 or 1 indicating whether this input is the solution to the problem you're looking for or not and the goal of Grover's algorithm is to find any input that will produce the value of function equal to 1 it's basically trying to reverse-engineer the function without knowing what it is so the most interesting thing about it is actually implementing this Oracle that it uses because you cannot use a classical implementation of the function to get this speed up that Grover's algorithm gives you you need to declare and to describe the conditions on the input which will give you the answer so it's really looking for so boolean satisfiability problems are actually an excellent example of the problems that can be solved using proper search because they map to this binary input binary output really really well binary input is just the values of the boolean variables that you assign to the very two variables and the output is the value of the function so the easiest example of a set instance that you can do is this one the and expression of two variables so you see that the first task gives you a very simple task it describes the inputs to the operations that you will implement it tells you what the goal is what's the transformation as it's done as it is done by your code should be in some tasks it describes the return if the operation has a return but this one is a transformation so there is no need and since there is a code cell in which you actually write your code it gives you the signature of the operations that you need to implement and here you can write the code I have this I have seen this task once or twice before so I should be able to write some code for it and run it by visiting the cell executing the first cell takes a little bit of time but after that it's much faster ok it actually tells me that the code I wrote is incorrect purely for demonstration purposes I assure you so this is actually a compilation error it will also tell you if your solution is can be compiled but it's incorrect and this one is actually fairly easy to resolve it's just a missing semicolon and then we're on zest so again sustance success so yes i indeed know how to solve the first task so arches is the second task offers a slightly more complicated task it's an org formula which is very similar to end but in quantum it it takes a little more effort to solve I could go on solving these tasks just because we have a lot of time from cutting the previous talk short but really I wanted the conscious of lunch coming up soon so let's just walk through the tasks so you see the next one is another example of the formula then we get to more complicated formulas in which you need to actually combine some of the pieces you have implemented earlier and use them as building blocks and then fairly soon they get to the sad problem itself it gives you definition of what is a salt problem how it can be represented then it explains to you how this task gives you the input how it is represented because representing such problem is you need to have to have some data structure which represents it and then on and on and then you get a full thought problem with arbitrary number of clauses then the second part of the carton he offers you to implement Grover's algorithm using the Oracles which you have done in the third section so this is one of the major principles of the Coty's the next tasks build on the previous ones or they covers the topic from slightly different angle but usually in the end of the kata you need to be able to put everything you have learned together and in the end you have to implement the algorithm and see how see to make sure that it works even if you don't know the number of inputs to see the number of solutions there's a formula okay does anybody have any questions at this stage because in the second part I will be talking about something slightly different okay excellent work me return to the presentation mode so now that we looked at the tools that people can use to learn quantum computing of their own in the second part of my talk I will tell you about how we used the quantum Carter's and other tools to teach students quantum computing and I will also how you can get access to source because I excellent materials just in case you want to teach somebody so this winter we taught the course introduction to quantum computing at University of Washington Martin will tell you more about it after lunch it was a major effort by a lot of people in the team and it was a very interesting experience just you know to give you something to look forward to and meanwhile I'll give you an overview of the materials we created for it that we are happy to share with other teachers so here is an overview of course materials basically it was a ten week long course so we had 17 lectures and we have slides from those lectures we had written assignments that come with the solutions we had six programming assignments which I will be talking about in much more detail we offered a big fan subset of quantum Carter's as Webb's so the material which students can use to learn the actual programming necessary to do programming assignments before they continue to do programming assignments and also there were final projects which we offered that students do in teams so we need programming we need programming projects razors and final exams but again Martin will talk more about it I shouldn't steal his spotlight here is a brief overview of what topics we covered in the lectures you will see that these are topics that any introductory course on quantum computing will have in fact this course had a lot more information than some of the courses will have so it was a ten week course and repeated who we had actually several universities already using these materials for teaching their courses and one of our partners took these materials and they basically took a lot of these materials which are more introductory except for a transform I think which is a bit more advanced and from these sections they only took first algorithm and they made a great course they didn't feel short on materials then there are written assignments they are tasks based on theory and applications they don't involve any programming so basically it's a task which is given to you on paper and you return a write-up of it it's also manually graded fortunately I was not involved in grading them there are four written assignments they cover different topics of the course we gave approximately one assignment for two weeks and then there are programming assignments that's what really made the course stand out because hands-on component is always very valuable and it's always done in normal computer science courses but in quantum computing it's a bit harder to do to do it so the loveliest piece about it is that the tasks are automatically graded our teaching assistants loved me for it because I mean there are only so many times you can look at Sharpe code for Grover's algorithm to grade it and it's not a lot of times so they are very similar to cicadas I will show them a bit later and the games they cover the same material but they are designed to accompany the written assignments for example if you have a task about a circuit like the one shown here it's really easier to just do it on paper and if you if you have a task for example about drawing a circuit it's it's down paper but if you want to do something a different angle programming assignments are excellent for that so how we did it we taught the lectures to introduce the theoretical material then we offer Dakota or several on these topics for people to practice and internalize the topic and then we followed it with a graded and programming assignment now it's time for another demo I will show you the programming assignments themselves just to continues the trend i started who is talking about Grover's algorithm this is programming assignment from week four in which we covered Grover's algorithm we also happened to cover Fourier transform on that week we had basically a snowpocalypse and it was a long week to cover so you can see the structure of the project here it's very similar to structure of the colors you have the file with the tasks you have the file with reference implementations which you can see just to check yourself how it is graded and you have testing harnesses the file with the tasks it's similar to what Bettina showed us earlier and this is how the car does look when they are in project mode as opposed to notebook mode and this file is the only ones that the students get when they get the homework you see that it has a little introduction telling you what topics are covered and what Coty's should be solved before attempting this material and then we have the tasks and again they look very similar to the Coty's they give you the inputs to the tasks the output or the goal of the task in the signature and you have to write the code here so basically how the workflow looks like we give this file to the students the students work on it fill in the blank spaces and at the end of the week and once the assignment is due they send it back to the teaching assistant them's a teaching assistant takes this file the students file substitute it into the project build with it actually I can pretend that I'm a very lazy student and this is the file which I submitted really should have put more effort into it but you know other commitments so this file builds and then if you switch to test Explorer mode you will see that it has the ten tests one test per task and if you do run all tests you will see that all ten of them failed okay I guess I'm not getting a good grade on this one so the grading part can be automated even further because you can do this quoting over files and substituting them and running the tests on them you can do all of this from command line from a script which is what our teaching assistants need so basically the one thing you care about is how many tests passed this is basically the grayed out of ten one things that we are considering [Music] improvements on well obviously a lot of things can be improved like I'm I want to do a refresher on the tasks I want to do more tasks and maybe a little simpler ones because we got a lot of feedback on these materials basically since the tasks are too hard which I understand I can error on the heart on the side of being too hard sometimes one being seen in this whole set you notice that the car does come with the tests if you are trying to solve them you get your feedback immediately and you don't need to think about how to verify your code when you have this programming assignment you only given the file with the tasks you're not given the testing harness the reason why we're doing this this way now is that the testing harness uses the correct solutions a lot of times there is no other ways that you can test the solution other than compare it with the correct one and these solutions are all in the open you can just look at this file find your correct solution we cannot really give out a graded assignment which comes with solutions built in this is not how it's supposed to work so this is why we had to withhold as a testing harness for now I think we can do better than this and package the testing harness so that it doesn't expose the student to the reference tasks but also doesn't require them to write testing harness upfront because writing testing harnesses is not trivial and most students just cannot do it in the very first week that they have seen this whole quantum computing scene yet I think this is it for the material that I had for you so any questions as there is a micro coming up the implementation is hidden when in the cut is in the notebook rather than in the project because you said like essentially the project which we are seeing here is the same that we have in book format like here it's essentially a different front-end for the same thing because that you have seen in the assignment so I can show you the repository where cicadas reside github repository you have seen the links previously and for example if you look at the same Grover's algorithm there is the same solution violent project file and it has the reference implementation file which has the answers so in the notebook format they are hidden purely by virtue of just not exposing people to this file structure just because Jupiter notebook you look at the notebook and it's it doesn't show you the rest of the files in that folder but if you go to the repository you can get access to these files so for programming assignments we can do the same thing we need to package those files tighter like build them up in India well at least so that the students can still like disassemble the DLL and reconstruct what was inside for it but honestly if they do that they deserve that great thank you any other questions I guess this is it then thank you for listening to me 