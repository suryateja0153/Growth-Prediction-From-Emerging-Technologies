 hello everyone and welcome to the fourth lab of the kisket global summer school this lab is going to be a summary of the material that you've learned in the past two lectures in lectures three and four where you went all the way from understanding quantum fourier transforms quantum phase estimation and then using both of these to build up shore's algorithm so this lab is focused on using shor's algorithm for the specific goal of factoring a number and you'll go through the exercise of factoring the number 15 into its factors 5 and 3. so let me begin by walking you through the lab very quickly i will share my screen now as always we will begin by unzipping the the lab4 zip file and opening jupiter notebooks i'll just drag and drop the exercise file and open it in my browser window now you may notice uh lab four shores algorithm has similar references to yesterday those are fourier transform and phase estimation i've also included another reference for you the schwarz algorithm section of the kisket textbook which i think you'll find helpful as you work through this lab the goal of the lab is to take you through the entire sequence of factoring 15 into its uh into its factors and so the building blocks that you'll be using are effectively going to make up this block schematic that you're seeing here so the idea here is to initialize your qubits apply hadamard gates onto the measurement qubits at the top apply these modular exponentiation blocks and in the end do an inverse quantum fourier transform as you might remember from the lectures this is exactly the schematic of quantum phase estimation and so effectively what you're doing is implementing quantum phase estimation where that unitary u is interesting for a specific application here for factoring numbers so there are four steps as i've mentioned we initialize our qubits we apply the unitary we do an inverse fourier transform and finally we do our measurement and do post-processing so the goal here is to walk you through the steps so you'll write the code to initialize the qubits we have included code here for you that you do not need to modify for doing modular exponentiation of this form a to the x modulo 15. now 15 is here because this is the number that we're factoring a is the number that is co prime as you've learned in the lectures co-prime with 15 and x is the power of that modular exponentiation so we've given you this block in order to use for your modular exponentiation building blocks but what you will have to do is write out the sequence of how that applies in your individual circuit and target qubits once you do this uh you'll you'll implement the inverse quantum fourier transform just like you did yesterday uh you can either do this manually by writing out the gates yourself which is a good way to remember what the gates are or you could use kisket's built-in uh circuit library and you can just immediately call the quantum create transform object from there a note here if you're going to use kisket's built-in quantum fourier transform object just remember that you need to do the inverse quantum fourier transform which means you need to think about whether or not swaps are involved in this case you don't need the swap gates to be involved to do your work okay and finally we've put together a block here that that compiles your program so we have the initialization we have the modular exponentiation the inverse quantum fourier transform and finally the measurement and this code calls the sequence of steps with four qubits in the measurement four qubits in the target register and the coprime number that we're looking for in this example is seven i would encourage you to work through different versions of this problem by maybe changing a to be a different number that is co-prime with n you might notice in the block that we've given you up here a can be any number 2 7 8 11 or 13 and depending on which value of a that you choose you'll get different results now you're graded on a equals seven however i would recommend trying the others just to see what the outputs are and how you can infer the factors from them in the end uh i've also put in this block here that helps you see uh what the guesses would be uh doing the classical post-processing effectively from the measured numbers so hopefully if you have everything set up right you should see the factors three and five coming out of this block of code and that's it 