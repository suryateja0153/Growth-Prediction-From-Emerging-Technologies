 um yes so the point of this lab for me i what i want to get you doing is going on to the real quantum devices that are being offered as prototypes and to use them and to use them to do actual useful and interesting stuff and the most useful and interesting thing you can do with the devices at the moment is to do science because if you want to do an application then you have to contend with firstly the size of the device but also noise noise in this context is a bad thing the errors get in your way they cause you not to have exactly the kind of output you want but for quantum arrow correction noise is what it's all about and if there was no noise there would be quantum no quantum error correction so uh yeah noise is something that is is a good thing essentially for quantum arrow correction and so we can study that noise we can try and work out how it transforms our circuit how it appears where it comes from what kind of effects it has and i think one of the best ways of doing that is using quantum arrow correction because it's a technique that is designed to interact with noise also if you think of the era [Music] which is something that we are working towards um they will use quantum error correction and in fact if you look at what they do in on the the level of the device pretty much every operation that is being applied is an operation dedicated to doing quantum error correction an application is effectively a side gig that a fault tolerant quantum computer does uh in um well as well as its real job which is doing quantum error correction so if you want to know how well a photon quantum computer can work if you want to know that our hardware that we're building now is compatible with that goal of building a fault quantity computer then we should see how well it does error correction um so you've already learned in the lab in the lecture sorry uh about quantum equation you've learned about the repetition code and you've learned about the surface code and so you can start thinking of ideas of how to implement those and what kind of tests you might want to run and what you might want to find out about when you when you run it and see how it actually interacts with real noise in the wild um one thing you'll find is that uh well the the smallest surface code needs 17 cubits and we have more than 17 qubits on some of our devices unfortunately not the publicly accessible ones but even so they're not laid out in the right way for doing a surface code in terms of applications if we want to do c knots that the device can't directly do we know ways of taking gates we have and combining them to make other gates that we need but it means taking many gates and combining them and when you do that you also take their noise and combine them and make huge noise monsters that you don't want to put anywhere near your error correcting codes so even though we have enough qubits we don't have the connectivity to run surface codes but we can run repetition codes on all of our devices including the publicly accessible ones and i even have a paper or papers actually running repetition codes on publicly accessible devices so this is something that that you can also do something you can try it's something you can use to try and understand the devices and perhaps even understand some of these noise processes more than the people who actually built the devices and do actual real science even if you're not academics you can do real science using your knowledge of polymer creation and the devices that we have but there is something missing in your knowledge in order to be able to do this effectively and that missing thing is what we're going to look at in the lab which is uh some of the tools that kisket has and some of the problems that you will have to solve in order to do experiments like this and the problem that you'll have to solve is is the one that we'll we'll use as um the grading in the end okay so um often when we begin looking at anything that we're doing with quantum computing we don't start by running on a real device we start by simulating it but as i said noise is key to quantum error correction so the fact that simulations usually don't have any noise is kind of a problem in that regard because we're not going to get the effects that we need to get now so one thing that we can do in this case is then simulate noise we can simulate them being bad even though we can also simulate them being perfect and kiskit has plenty of stuff in order to help you with that and you'll find lots of resources online to tell you about the voice models so this is not a lecture on noise models but um they exist and you can use them so i'm gonna import noise model which is the object we use in python to hold noise models and a couple of different kinds of well a few different kinds of error powerli errors depolarizing errors thermal relaxation errors are all kinds of typical ones paulie errors are where you probabilistically do an x y or z the polarizing error is um actually it can be described in terms of power errors but it's a more general but it's a well it's depolarizing yes um it's it's a fancy thing and thermally relaxation errors are an even fancier thing they model um thermal effects relax so uh the zero on the one state in in an actual real superconducting cubic device the one state has more energy than the zero state and so there can be processes that cause that one to decay down to zero and this is um the way that we model those kinds of errors and i'm just going to make a simple function if you don't want to think too much about it you don't have to and this function is going to make a noise model so basically i'm going to have a noise model which has two types of error it applies depolarizing errors to any controlled knots that it finds in the circuit and also when you measure when you measure you'll have a thermal error so the measurement will have this process which causes some decays of ones to zeroes and these are parameterized by probabilities so there's some probability which acts as the probability that these errors will occur on the controlled knots but the thermal errors are parameterized by a set of three times so t1 and t2 are time scales for this um thermal process and we don't really have to go into the details of these um and uh the final time tm is the amount of time it takes to make a measurement so if t1 and t2 are infinity then that means that the time scale of relaxation is is infinity and it doesn't matter how long it takes to make a measurement you will never see this process happen uh but if they are not infinity if they are something finite like for example one then uh if you take a finite amount of time then you will see this process happen so if you take a time of one you'll probably see it happen quite a lot but if you see a time of zero if you take a time of zero then you're so quick that you won't see this noise so these are just default values the default value here is that you don't have any um probability of a of error honestly not and the default values here are t1 and t2 just being one and then what matters is the ratio between t1 and d2 and um and the the time taken for measurement so you don't have to worry too much about units and here i've got the the measurements are infinitely fast so this default value is also going to give us no errors here okay so this is some syntax which makes noise models i won't go into into too much detail let's look at it in action actually of course i have to execute that cell otherwise it doesn't exist and let's do a quick circuit this is a circuit in which we do an x on one qubit a controlled knot between another two qubits and nothing on this cube so what is the outcome of this well what does the x do it flips a zero to a one what does this control not do well it does nothing you probably um you might notice that because it's acting on a control qubit which is in state zero it's not going to do anything so in terms of actually um a circuit is pretty useless but we we're using it to look into the into the noise so let's now run it if we run it without noise then we see a one on the qubit that he x acted on and a zero for the two qubits that the control not acted on and then another zero so now let's run it um with noise but we'll just turn the noise on for the controlled not gates and what we find here is that we get various different results so this runs it 8 192 times which is a nice round number and um in each case we still get this one here uh from the x so i don't need to highlight them all but it looks like i will and on the other side for the qubit that has nothing happened to it we always get a zero it stays in its zero state but the other um two qubits the ones on which are controlled not act they're no longer in their their zero zero that they should be but they're equally likely to be one one zero one zero zero or um one zero i've got those two you know now so they have just had complete noise so it's not actually a controlled not happening there it's just random nonsense so here you see some noise if we had this noise being more reasonable strength we would see that uh the the right answer is very much the most likely answer um the idea of them getting both flipped is is the less likely answer uh so now let's do it for a range of measurement times and we find that the shorter the time the more it comes out the answer is supposed to be so this is very heavily biased towards the right answer and there's a few cases where this one instead gets flipped to zero so this measurement error is occurring on all the qubits and um well i think i'll put the blind down the sun seems to be coming in so the measurement error occurs on all of the qubits uh it but it's only that last qubit the one with the one or the first cubic that is getting effective and the reason why is that the the way that we define this is that it's going to cause relaxation errors uh ones to turn into zeros and it doesn't really cause zeros to turn into ones so um this is the only one so this is the only one getting affected uh there's a few cases in which this one goes down to a zero but if we up the amount of time we take for the measurement to much longer than the time scale of the relaxation then we find basically that they have all decayed so it's a random process of decay but if you run it long enough you get to this fixed point okay now that is noise and so that's something that we might want to have uh as a tool in our pocket when we are looking at um error correction experiments because we want to simulate noise and um compare how our simulations of noise compare to real noise on devices now we want to run repetition codes so as i said repetition codes are codes that can run on current devices and as such we have tools in kiskit to help you do that we have this repetition code class which creates repetition code we have graph decoder which does the decoding and we have these other decoding methods which are not so scalable but they do have their their uses in fact in a in my first paper doing a repetition code is lookup table decoding that i that i used so let's import those things uh we just need to decide how many code qubits we have so how many times we're actually going to repeat the message and how many measurement rounds we're going to do and um with current devices we can't measure the same qubit more than once so the fact that we can only measure the same qubit once means that we can only measure uh our ancillar qubits one time so we can only do one round one repetition of the process so let's set up a code a repetition code object that is um has four repetitions and one round and this has an attribute circuit which has a couple of circuits in one of these circuits is for if we're encoding a zero so we're repeating the zero and the other one is for when we're encoding a one so here is the circuit for zero you'll notice it's in the beautiful text based form that's because uh these underscores really don't agree with the uh the fancier one but uh it's always nice to be a bit retro isn't it so here we have our code qubits and we have our adzillas and you can see for example this ancella is uh has two controlled knots on it controlled by um two different code keywords cube tokyo with zero code qubit one so it's measuring parity over those two exactly the way that we described in the lecture and then we have various um bits where we're taking them out so there's all kinds of technicalities that you don't have to cover uh the only difference with the circuit for one is that we have these x gates which flip all of the keywords to one so that we're repeating once across the code units rather than zeros um so let's now run them so if we want to run them we can use execute and execute uses takes either a circuit a single circuit or a list of circuits but uh what we are getting out of um this object is a dictionary of circuits so okay this is just pythonic technicalities but we have to convert that uh list into a dictionary in order to run it so but um the code object does just have a method get circuit list which does that for you so we'll turn it into a list called circuits and then we run them and then we see what happens oh actually we've got a we've gotta extract the results because this is a job object and also the the code object has this method process results which makes the results look um more sensible from the format of quantum error correction so let's do that and actually instead of doing all of this every time we could just make a function which would extract list run it extract the results so let's do that in future so if we were to do that with an empty noise model we would get a result that looks something like this and um what we're seeing here is these results are the results of the three ancillar cubits so they're telling us these parities we've got four qubits and so we're we've got three measurements where we compare the parity of the first and the second and then the second and the third and then the third and the fourth and uh we want those all to come out zero telling us that we've got even parity and everything's okay and this is what exactly what's happening here then at the end we measure all of the code qubits so that's four measurements but when we measure the code qubits um we can also extract that parity information we can manually look at the first and second keywords and say are they the same or different and then write that parity out and then we can look manually look at the next two and see if they're the same or different manually write that out so uh that's what is done here that's what this second block of three means it's also look it's also parities but these aren't directly done by the ancillars but they are extracted from the final reader and then these two are just telling us what um the logical value is uh on each of the ends so when we measure the code cubits it's telling us what the first code qubit was and the last code cube it was and the reason why it does that on two of them and not on all of them or one of them or any other combination is because they have nice properties for the graph decoder which you can find out about in some of the the further reading so you find out um so yeah for these cases where there is no noise then all of these parity measurements come out as being everything's good because there's no noise to make it bad in both the case of encoding zero and including one um and these ones that reflect the logical readout are zeros when we're encoding a zero uh and ones when we're encoding a one but if we were to put some noise in there we would find that things change a bit so we would find that um so these are just some of the most common results uh for a a noise model with i just put some controlled noise in a particular strength and you find that the most likely result is the right one but you also see right here is a case where an error flipped one of the qubits and therefore caused two of these parity checks to report that something is going on but it didn't do anything other than that uh sometimes it causes one power to check to flip because it's on the end but it also causes the logical value to flip so they always occur in pairs which is nice um and then that's why we choose to take the edges um but yeah you can read about more about that more in some of the the further reading so from the results something that we need to know the most is the probability of a logical error so what is a logical error it means if you gave someone this as a result and they knew exactly what format this was in and you said okay this is the result that i got from my quantum computer after i encoded a bit value and stored it you for a while using a repetition code what value did i store can you guess um then someone has to do this process of trying to work out from this result uh what you encoded and they'll probably see well one of these parity checks is reporting something went wrong over on this end and this value corresponding to the same end i'll probably then not trust that as much but over this end everything seems fine so let's trust this value i think you encoded a zero yeah you're right uh but what is the probability that you're wrong because this is not just a game that you play with your friends it is um what we need to do in order to do full-time americans uh so we can create a decoder object using kiskit which will just do the decoding for us we'll solve this problem for us and um then we can run this get logical prop um method in order to to solve this and we find in this case the probability of getting it wrong is very very small on the order of 0.02 whether we're encoding a zero or a one and this is less than the uh the noise so it is less likely than the noise which is good it shows that things are going well in the world which is what we like and if we had the noise lower then we would find that our error correction process is even better now we've got even more different um so by by decreasing the error or by increasing the number of qubits we should get better at correction so by calculating these values for different sizes of code and different noise model then we can get and for different qubits on a device we can learn how the noise is going to affect um that process we can learn about the noise now why what is that qubit doing why is that cuba doing something a little bit weird what hap why when i add this qubit does everything go a little bit strange you you get insights into devices you can then compare these with the noise models that we uh we extract from them you can see if they're covered in the noise model or is this some other kind of noise that doesn't seem to be covered there is this some sort of a mystery that needs to be solved now this is something that i found when running repetition codes for papers that i've written i found results that don't seem to make sense so the exact opposite of what i would want and then i can look into that mystery and try and solve it now i get some insight about what's actually going on and i see um the physics of the noise which is something that we can really study at this time it's very interesting thing that we can do at this point in quality so uh if you want to see some more examples of that then you can check out the the papers i have so i've got one um from a couple of years ago and i've got one from just this year and uh there's also the relevant chapter of course of the kisket textbook uh that you can look into to see how you do this um but there is one puzzle you always have to solve when you are running on real devices and this is that you have to really know your device you have to know where its qubits are which qubits talk to which other qubits and um plan for that so that means you have to not just let the transpiler do things on its own but you have to think about the process of transformation for that we need to load our ibmq account and we need to get our provider and let's have a look at the biggest device that is publicly available which is ibm q16 melbourne so we set up the back end object uh in this way and so i'm often glossing over the code a bit because this is not sort of a lecture in python and you know you can pause and you can go back so you can look at these things in more detail and you'll have the notebook to look into explicitly and of course you can always google the syntax google anything to get do provider dot get back in control c go and google that with kids kit and they'll tell you all about all about that well hopefully so we've got these called jupiter tools which give us nice insight into devices um once it runs it will show us something pretty so you can see everything about the device for example that it's not on today um but i'm not gonna run anything on it so that's not a big problem uh so this is it's coupling map this is a qubit um it's called zero this is another qubit it's called one and this is a cubic call 14 and zero is only friends with one and fourteen uh it is only possible to do controlled knots between 0 and 1 or 0 and 14. it's not possible to do a controlled knot directly between 0 and 13 you have to come up with some of these transpilation tricks if you want to do something like that and so if you ever run a circuit which has a single qubit uh that is involved in controlled knots move more than three other qubits and you run it on melbourne then those controlled knots in your circuit do not directly correspond to the control knots being applied on the device because there's just not the possibility there is no cuber on here that can talk to four others um as an example so and this is an example that's pertinent of course for the surface code so there would have to be a transformation process there uh which would for example if you wanted um qubit one to talk to four others maybe you'll make it talk to zero two and three uh but also 14 and then when you make it do it with 14 you swap you're a swap gate on 0 and 14 to move the state of 14 over here and you can do a controlled knot and then you do another swap to move it back but that swap is a non-local process which is also making the noise non-local something that was a single qubit error when you do a swap becomes a multi-qubit monstrosity uh so this is why it's hard to do um quantum equation experiments even if you have enough cubits um yeah so this is the coupling back we have but one thing we can do is um we can do repetition codes because repetition codes mean we have to have a code qubit talking to an ancillar qubit which talks to another code qubit which talks to another answer queue but we store from another code cube it would source to another and silicon and so on and so forth it only needs a 1d connectivity so we just have to find a line that's stretches across the device and then we can do it and the only thing that makes that problematic is this seven being on its own so if you wanted to go if you just went zero one two three four five six eight seven or you painted yourself in a corner so you have to make sure you don't do that so it's a puzzle to solve and obviously it's an easy puzzle but it's a puzzle um so let's do some transpilation sorry so d equals eight is the largest code that we can do on here because that means we have eight code qubits and one less than eight which is seven uh and silicubit so that's 15 and the number of qubits on this device is 15 so well that's a simple curriculum uh so let's do a dig with it so we've created now a d equals eight code object we have uh taken the circuits and made them into a list and i've called these raw circuits because um they're not the circuits that the device is actually going to run for that we first have to transplant so let's look at that transformation procedure first let's have a look at the circuit now if i did the circuit diagram it would be huge so let's not do that instead we could just look at what gates it has it has so if we look at the circuit encoding a logical one um it has eight x's required to flip the eight code qubits to their one state it has 14 controlled knots because there are seven ancillars and each of them has two controlled knots in the stabilizer measurement that is involved in so that makes 14 and we have 15 measurements because we measure all the qubits and there are 15 of them okay now let's transpile it so transfer so we're going to make a new list called circuits and circuits means we or we're going to go through the circuits in raw circuits we are going to transpire them and we're going to put them into this new list so the circuit at circuits zero is going to be the transfiled version of raw circuit zero and circuits one is going to be the transpiled version of raw circuits one and to transpire we just say transpire and we do have the circuit we want to transpile and we have the back end that we are transferring so it's a device that we are making the circuit on which it can run because this differs from device to device because the coupling map differs from device to device okay i haven't run that yet have i so let's run it and so we this is what raw circuits one was the circuit for logical one and now let's see what the transport version is okay let's put a barrier in there fair enough that's mostly just that's not really a physical operation so i don't care and uh what has it done to our x's we had eight x's and now we have no x's well actually we do so uh from a physical stance so x is kind of like an abstract concept of the game um in terms of the physics of the the gates uh they it usually describes things in terms of u1 and u2 and u3 operations which are just single cube operations parameterized by numbers and um that is the language of device speaks so instead of calling it an x we have to call it u3 with three given numbers which corresponds to an x so that is just our x's we still have 15 measurements and what about our 15 controlled knots well we have at least 15 controlled knots so that's something uh so why do we have 71 controlled models well um earlier i told you that if um we try and remap so if we try and move the qubits and what the states of the qubits around uh we use swaps so in order to take a circuit which can't directly be run on the device and make it so it can be directly run on device we use tricks like swaps and swap gates are not something that the device can run naturally it has to be expressed in terms of the gates that can be run on the device naturally one of those is the control knob so with three controlled knobs you can make a swap so to swap and then spot back that costs six controlled knots so it's fairly expensive in terms of the controlled knot cost uh so what we're seeing here in the increase in the number of controlled knots is that the transpiler has used some of those tricks to make it so that the device the circuit can run on the device and this may be because when the when we give it the the circuit it maybe thinks of um co the first code qubit is zero and then the second code qubit is one and the third code qubit is two and the fourth code qubit is three and and uh and then once we have run out of code qubits it starts thinking of the next lot of qubits as the ancillars and it realizes hang on i can't entangle zero the first code qubit with i think it's then perhaps um eight the first i need to do some trans filing and it finds that it finds ways to do this it finds ways to jig jiggle things around uh in order to make it work but the trouble is that it could find a way that didn't require any remapping it didn't require any controlled knots but the trouble is in general finding out if a circuit can run on a specific device and then making that happen without doing any uh remapping without doing any swap gates or other such tricks is is a pretty hard problem so it's not one that the the transpiler tries to do with complete accuracy instead it goes the other option of adding in control uh so if we are very opinionated about the fact that we don't want it to do that then we have to put in the hard work ourselves or we know it can run on that device because we just looked at it and saw it could so let's tell the transpiler that information so that it does not have to um think um yeah so if you want to know more about these ways that we can remap gates then you can find um some of these tricks in more circuit identities uh so we do so we do this by so in getting the compile the transpiler so we call it a transpiler rather than the compiler to be a little bit technical um so i compile usually takes something abstract uh like a programming language and then expresses it in a more basic form like in the machine code that actually runs on my computer but uh a chat we call it transpilation because we have a circuit which is a perfectly valid circuit and we turn it into another circuit which is a perfectly valid circuit so it's not going down in abstraction it's just being converted into a language which is more um suitable for the device that we're using so that was just an aside really what we need to tell the transpiler is which qubits we want to on the device we want to play the role of which qubits in our um in our circuit and uh this is the way i do it here so i basically i pick the line that i want to use so this one that goes from 6 down to 0 and then 14 up to 7 i manually use my hands to write this list six down to zero then 14 up to seven and then i give this to this function that i've made um which just goes through the qubits in my circuit and then creates this dictionary initial layout which will pair up the code in my circuit uh so this is um a particular code in my circuit in my circuit and this is uh so in um repetition code objects you have as a attribute the the quantum registers so that's what i'm using to do this but um you in in circuits in general you have that attributes the quantum register so you can do this also for for circuits and then i make correspondences between the code in my circuit so a particular code qubit in this case and one of these numbers in this line so if you did this for j equals zero it would be saying code qubit zero is the qubit at position zero in this line which is this one and then it would be saying that link qubit zero the first ancillar is the qubit at position two times zero plus one which is one the one which is five in this line and then for j equals two you also j equals one you get that code qubit one so the next code qubit is um at position two in this line so four and so on and so forth so remembering that this is index from zero so this is position zero position one position two and so on now so you're explicitly saying i want this particular qubit in my code in my circuit sorry to be this particular qubit on the device and you have you build this list of of pairs and as a dictionary and that's something then you can give to um to the transformer so here this code this qubit which is in the quantum register called code qubits and is code qubit zero is going to be six and then the next one along my line which is five is link qubit zero and the next one along my line which is four is co qubit one and the next one along my line which is three is link qubit one so on and so forth with this we can put that information into the transformation process and what we find is that the number of controlled knots is 14. it has used that information uh to not do any of these transpilation remapping swap game tricks and actually use the qubits that we wanted to use so we know when we get results from a particular qubit we know that that is going to be exactly the cubit that we think is okay so now a task for you we used to have a device called tokyo it wasn't a publicly accessible device but one thing that is publicly accessible and still accessible is fake tokyo now it's not like a fake back end that can be used for testing and in this case we're testing compilation so let's use as our back end fake tokyo you won't be able to run anything on fake tokyo because it's fake um but you will be able to use it in terms of compilation because it does have information about tokyo including the coupling map which is this correspondence of which qubits can talk to each other um and that's what the transformation is based on uh so this has 20 qubits and this is their the coupling about zero can talk to one and five one can talk to two and seven and six eleven can talk to five ten six twelve sixteen and so on and so forth this is this is a couple of months so this is um four can talk to eight and three can talk to nine it's not that four can talk to eight and three uh in fact four cannot talk to three so this is that when i say talk to i mean you can do a controlled knot which covers both of those qubits uh which is the cubic form of talking uh well except for when they talk via noise which is uh not the kind of talking that we want now so this is what tokyo looks like and it has 20 qubits so what's the largest um instance of quantum of a repetition code that we can run on tokyo well uh we would need if we had a d equals 10 code that would need 10 codequeuits and 9 anceloquy bits which is 19 which is less than 20. for eleven uh we would need eleven co qubits and ten and sellers which is twenty one which is too much so a d equals ten code is the best that we can do requiring nineteen cubits 19 qubits along a line now how do you do that okay let's just do blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah okay uh the fact that the coupling map of this is so weird makes it a not entirely trivial problem um it's not too hard it's a puzzle it's a nice puzzle that you find in in magazines that middle-aged and older people are very fond of um so if you if you find it hard give it to your parents and they can probably do it for you uh or anyone else so also sometimes when this is run if you run it in the quantum experience you'll find this weirdness underneath don't worry too much about that if you worry if you if you run other places you might find even more weirdness um it's these fake what these fake back ends well you know they're not the things that most people are interactive all the time so they're more likely to have bugs so let's run our d equals 10 circuit so we we say d equals 10 we set up a repetition code with d equals 10 we extract the circuits let's look at the circuit for a logical one it has 19 measurements it has 10 x's and it has 18 controlled knots that's what it should have now let's just take a line well let's just take let's say that we want qubit 0 to be our first code qubit and qubit one to be our first and seller in ancillar and qubit two to be our sec next code qubit and then three to be the next stanza and four to be the next code to it and uh five to be the next down seller this is obviously not a workable plan the transpiler is not going to like this uh because um some of those connections are not there and by the list we find that well the number of control knots it takes is 83. in fact you might get different numbers because i think there's a degree of randomness 85 this time the luck was against us we want it a few more times maybe we'll get less maybe if we run out enough times i don't know if you run it enough times you'll still have the wrong line um so you're you're still gonna be unlucky but uh yeah we see that this is bad so what we need to do is replace this we need to replace this with a line unbroken line that does not overlap itself does not cross itself it goes across the device and covers 19 cubits you need to find that and once you find that you can run a 20 cubit repetition i'm sorry a 19 cubic repetition uh well in theory at least this is fake this is a fake backhand so you don't want anything but if you were to look at the other devices that we have and try and run repetition codes on them you'll have to solve this problem for all of those devices if you look at devices we will have as we go forward you will have to solve this problem in order to run repetition codes so this is the task that i'm giving you to um to solve this transformation problem for this specific instance and also you might want to try different lines across the device in order to get different insights into the noise so working out how to do this is is a good task um and so i would suggest you do so what you then need to run is uh of course import the grading tools and do this and you will be submitting your circuits one that you've got out of this line this section here uh with your name and your email and so on and so forth so it should be exactly from here all you need to change is this line so actually i've not got given you a lot of kids kit that you have to do you have to more think about how your your code corresponds to your device but i have given you a lot of kids kit that you can use to use these useless knowledge of quantum equation that you have learned to do actual science and i i hope more than solving this puzzle i hope that is what you do as a result of this lab so uh that is all i wish you a good weekend whether you do it whether you use it doing real science using genuine quantum devices or you know playing animal crossing or something have a good 