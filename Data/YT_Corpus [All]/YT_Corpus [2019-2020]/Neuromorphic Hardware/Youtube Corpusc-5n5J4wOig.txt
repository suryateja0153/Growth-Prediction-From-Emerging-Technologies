 [Music] well thank you for coming out today and to listen to an old guy talk about an even older computer we are here to talk about the ENIAC most people in our field of course have heard of it most people don't know much about what it is you may have heard it was the first computer or he may have heard it wasn't the first computer or you may have heard the patent got invalidated because they stole all the ideas the reality is that it is a very rich history and it is a very interesting machine and it was a very very influential machine now we're not going to really go into all of the history aspects of it today we're going to talk more technical terms about it in particular we're going to focus on this simulator that I wrote the the motivation was simply I wanted to understand how the ENIAC worked and I felt the best way to do that was to write a simulator of it and to get down to as low a level as I could get and so that's what we're going to be talking about today so let's see if the clicker works aha so this gives you kind of the usual rundown of what the ENIAC was all about the story essentially is during world war ii as artillery manufacturers are producing new guns new propellants new shells we need to calculate the tables so that when you're in the field you're not solving differential equations to figure out where to point the gun you want to have a table that says ok if I'm shooting in that direction the wind is blowing that way it's that far away and the humidity is this I need to point the gun there and these tables took a tremendous amount of computation and of course the way you compute something is with a computer except the thing is that in the 1940s the word computer was a job title these were people doing computing the US government for both this purpose and for the purposes of code-breaking sought to hire as many mathematicians as they possibly could yet with a war going on of course all of the young men who had just been studying mathematics were off at the front so we have this wonderful competition between divisions of the government to hire all of the young women who had been studying mathematics and they're doing these calculations mostly by hand on adding machines and one of the researchers at University Pennsylvania named John Mauchly came up with the idea of essentially building a machine that was strapped together a whole bunch of adding machines and he recognized that it would be even faster if use vacuum tubes and so this was the birth of the ENIAC being a war you make a proposal to the government that can help and they say great have some money and go do it whether or not they could have gotten the money in peacetime is another question but it began in 1943 by early 1944 they had some prototype stuff running by the summer of 1944 they pretty much had it worked out what they were going to do and had turned over a lot of the work to other engineers and technicians for building it it wasn't until late 1945 however that the machine was completely finished so it didn't actually get used during World War two but interestingly the first task it had was a project that was also sparked by World War two the Manhattan Project Los Alamos had some heavy calculations they wanted done and so they came out during the winter of 1945 and used the ENIAC to do some of those calculations one of the interesting points about it that a lot of people will make is that you couldn't program it the way we're used to programming modern computers you had to rewire the machine to program it and that was true as it was initially built but here's the thing if I can wire a solution to any problem why can't I wire a solution to the problem of being a CPU and that's what they did so in 1948 they implemented a CPU on a traditional and sequential instruction execution CPU and it was used that way until its retirement in 1945 1955 so this is actually going to come back and be something important in a minute as you might guess it changed the balance of performance on the machine quite a bit to do this all right so this is the famous picture of the ENIAC that was taken as part of the publicity this was taken and released in the press release when it was dedicated and announced to the public in early 46 and you can see in the picture that this goes back a long distance into the room you've got some people standing around to give you a sense of scale the whole machine looks something like this not obviously this is a bit too small for most of you to see but if you want to come and take a look at it after the talk you're welcome to this is a small 3d printed model of the ENIAC and these stand up pieces that the soldier is standing by in that picture are the switch panels that were originally put on for function tables and that's where the instructions were stored when it was later run as a conventional computer right here we have punch card input an output the only i/o on the machine no screens no mice these are the two guys that really kind of led the project the first one that I mentioned before was John Mauchly on the left he was a physicist at the University of Pennsylvania and he was very interested in a variety of kinds of problems that were extremely numerically difficult problems one of his big interests was whether how do you predict the weather well we know the differential equations for fluid mechanics but if you're gonna do a 24-hour forecast by hand it's gonna take a lot more than 24 hours so this is one of his motivators in this the fellow on the right J presper eckert was a graduate student at Penn when they met fact Eckert was teaching a sort of workshop on electronics that Mark Lee took and Eckert was let's face it an engineering genius he was one of the top electrical engineers you can imagine he invented all sorts of cool ideas and really put it on extremely solid footing and it was one of the few reasons the machine was successful we have these wonderful statistics that always get quoted and the second one on that list of it had about 18,000 vacuum tubes that was more than anything before it in fact when they first proposed the machine they had proposed a slightly smaller version that would have about 5,000 tubes the government folks went to the experts mostly in my team and said what do you think of this proposal and the response was there's no way that machine will ever run the tubes will burn out too fast but Eckert realized the mechanisms that were involved in a tube burning out and was able to design around it it was able to operate the tubes in a way that would minimize their burnout and furthermore to extend the usage life of it as their parameters changed over time so these kinds of design characteristics were really what a car brought to it as you can see it had the blazingly fast clock of 100 kilohertz okay now that's not gigahertz it's not megahertz a kilohertz is one millionth of a gigahertz this gives you some sense of the speed of this machine it took about two hundred microseconds to do it in addition that's why we often will hear quoted the figure five thousand additions per second as we're gonna see that's not the most accurate way to look at it because it was a very parallel machine these last three points here I really love those um being someone who grew up in a world of 5 volt TTL thinking about a computer that uses 150 kilowatts of power with 29 distinct power supplies in 78 different DC voltage levels is kind of frightening especially when you look at the schematics and all the numbers are three-digit numbers you know it's like this one's negative 290 volts and this is positive 540 volts in it's like okay I'm used to five volts that I can touch and be safe but this obviously was a quite a beast of a machine the basic architecture of it is consisting of these units now what you have and you may have seen a little bit of this in the picture are these racks that go around the room now they're not quite our standard modern 19-inch racks but these racks are roughly 2 feet wide so they're a little bit wider than our typical 19-inch racks they're about 8 feet tall and there's 40 of them so if you spread this thing out you would have a wall 80 feet long by 8 feet tall and each one of these racks is a unit of the machine it has some functionality relative to the whole machine and this is kind of an inventory of those units the bulk of the actual computation is all taking place in the accumulators and that's what we're gonna focus most on today but we also have a high speed multiplier that took three racks it was built around good old-fashioned multiplication tables the same ones you learned in second grade because it was a base-10 machine Borton decimal there was a divider square root er the function tables that I mentioned before which were connected to these switch panels and then the interfaces to the i/o devices the punch cards now this is how the machine was laid out from kind of a top-down view and you really can't read it very well but the these are the labelings of all of the units over here we have the initiating and cycling units the initiating unit its primary role was twofold one was to control the sequencing of power when you started it up and it was also to sort of synchronize the initialization of a program and the interaction with cards both punching and reading the next unit the cycling unit is basically the clock we have the master programmer I'll say a little bit about and then around here are intermixed the accumulator is the multiplier divider square reader and so on this space inside of it was 32 by 16 feet now they rearranged the layout slightly when they moved it to its permanent location in Aberdeen Maryland and they had a newly constructed space for it when they moved it it was one of the few spaces in the area that had air-conditioning so late in the life of the ENIAC people started dragging their desks in there during the summer and using it as office space you know no matter how impressive they're still going to be good old human nature coming into play now some of the things about it that were really unusual from our modern eye is that there was no concept of memory the way we think about it we think in terms of a large array of individually addressable locations that are read and write the enact did not have that the only volatile memory you had available were the accumulators so you basically had 2010 digit numbers as your volatile memory so to kind of think in terms of how it was like programming this machine think in terms of restricting yourself to 20 integer variables if you can't solve atomic bomb problems with 20 integer variables you're not good enough to program the ENIAC okay that's a little overstated but yeah can I get the idea um the other big thing about it that I like to point out is how parallel it was all 20 of those accumulators could be operating simultaneously so even though a single addition would take one five thousandth of a second you could be doing 20 of them at the same time so it was a very very parallel machine in fact I love this quote by LEM ER this was a highly parallel machine before von Neumann spoiled it and this reference is to the conversion to sequential instruction set execution because von Neumann is actually one of the key drivers behind making that conversion lemma had used the machine for some interesting number theory stuff and had really taken a lot of advantage of its parallelism and so he was kind of disappointed when they switched it up and made it purely sequential the other thing that I'll point out and this may not mean much to some of the younger folks in the audience but this basically is like a dataflow machine okay now if you go back to kind of the 70s 80s timeframe that was one of the big buzz words in the industry was data flow and that was going to save us from all of the problems that we had with various bottlenecks and it was the new thing well it wasn't really all that new because the ENIAC was the data flow machine and the idea of data flow if you're not familiar with it is each unit when it completes an operation it sends a signal that can initiate the next operation so in effect you do an addition not when the instructions say but when the two data values that you're adding become available so it's driven by the availability of the data not by the instructions and that's the way the ENIAC was operated so the parallelism of course is a big deal because I'm trying to understand how the machine works I'm trying to get a feel for what was it like to program what were the traps involved for programmers when they were dealing with it we're all used to the problems involved with parallelism the easiest way to make a programmer cringe is to say it's a timing problem anytime concurrency gets involved we all shudder and and kind of grit our teeth and go okay I can get it I can do this so I wanted to get a feel for what that was like on the ENIAC well obviously if I really wanted to truly get the experience I would need to build some parallel hardware for it and while it's still one of my to-do list items it didn't seem all that practical for a first approach of course I could just write code ordinary sequential code and just sequentially go through each one of the unit's doing what they do but I went ahead and decided to kind of take the middle ground and go ahead and use the concurrency we have available in a lot of our languages and to hopefully take advantage of whatever parallelism the hardware underlying it gives me and so that made it a very natural fit for the go routines in the language go you know of course I could use conventional pthreads or something like that but goes model is quite clean and I liked the idea of having the portability that it would also give me so that was one of the motivating factors there so what happens is each of these units in the machine is simulated by usually two go routines that are operating in parallel and the way that works is the two routines are handling different sets of input now to give you a little bit of sense of what we're getting at here remember we said you rewire the machine to program it so that means that if I want this adder to be adding a value that comes from over here somewhere I've got to have a cabling connection that brings the data from the source to the destination that data as it's coming in over some kind of a terminal on the destination is just going to be a sequence of pulses and so these pulses are the input to the units there are pulses that indicate begin an operation and then their pulses that indicate data those are the control and data pulses that go into one of the go routines that routine doesn't do very much except set some state variables for the unit kind of represents the internal flip-flops of the unit in fact if you go through and read some of the technical documentation and you look at the source code you'll see a few places where there are variables that are named after certain circuits in the original the other go routine is taking the input from the clock which is another series of pulses originally I implemented this as one routine per unit and I realized I had a little bit of a problem because the result of a clock signal could turn into a control signal that I would transmit they would come right back into one of my other inputs and unless my communication channels had some buffers in them I would have deadlock if I put buffers in it how could I be sure that things were synchronizing the way they were really meant to so I went ahead split in two do the two units for that reason as I said that pulses are transmitted now this is another bit of Eckert's genius he said I'm going to make all the pulses the same control pulses data pulses clock pulses they're all going to have the same shape the same characteristics the idea is that there's no reason I can't use some data as a control signal and when you open up that possibility you get the possibility of conditional flow of control and that's what makes it Turing complete so those fit very naturally into a channel model of communication in fact the way it's set up is that messages over the channels represents pulses in the case of the control lines where there's only one signal being transmitted for a given line it's just a 1 or a 0 in the message in the case of data the terminals are actually 11 lines you've got 10 digit lines and a sign similarly the clock trunk has a 10 or 11 signals so those I decided rather than create the skew that would be involved with sending a different message for each pulse I basically take the 11 lines and treat them as bits of a word and just transmit an integer so that becomes the way in which the data transmission is emulated and again the idea is to get as close to the way the real machine worked so that in looking at its behavior I could understand what was going on with real machine and if I have a little bit of time I'll mention some of the results that came out of all of that so here's the clock it's a rather interesting clock in a lot of ways remember I said it was a hundred kilohertz basic clock so each of these time units here is 10 microseconds a sequence of 20 of them constituent are constituted or I'm looking for a period that's known as an addition time that's why we say that additions take 200 microseconds and in that we have a set of pulses here's 10 pulses that kind of fits since we're using base 10 there's interleaved between them a set of 9 pulses and we'll see how that's used in a minute we've got four sets of signals here with one 2 with 2 and one with 4 it turns out that with those I can construct any digit I want if I want the digit 5 I turn on the 4 and the 1 or the 2 twos in the one got a few options in there's this one prime pulse that's kind of special we probably won't have time to get into the details of it but the really inch in this is this pulse right up in the top it's labeled the central programming pulse this is kind of what we would think of as the clock in more modern terms this is the rate at which operations are taking place so the thing that initiates an ad the thing that starts a multiply it's always going to be synchronized with that central programming pulse so in the simulator basically what I've got is a set of channels that go directly from the cycling unit the clock generator to each of the units in the machine it consumes clock and so that's done as a real simple little fan-out kind of routine that just says okay I'm gonna receive a message I've got a list of places to send it I'm just going to send it all of them and it turns out there's also some handshaking I'll explain in a minute so here's an example of the way in which we connect the signals now this particular photograph was taken from an exhibit at Fort Sill in Oklahoma they have a subset of the ENIAC on display there unfortunately they haven't exactly hooked it up in a way that is real they've just plugged a bunch of wires in and gee look and one of the things that is kind of inaccurate is the mixing of these different types of trays in practice the ones with these individual connectors the ones that have the alternating black and white backgrounds those would run across the tops of the control panels sorry take away those run across the bottom of the machine the other ones with these multi pin connectors would run across the tops of the control panels the multi-pin connector ones were where you carry data and then the ones with individual pins like these were where you control signals now the interesting thing is these are buses you can plug lots of different connections into one of these things that ties to all of these other connections a bunch of them might be transmitters and you get basically get sort of a wired or behavior they might be receivers in which case they're just getting whatever one of the transmitters is doing so the fact that these configurations aren't fixed that the programmer can choose whatever they want for the configuration means I've got to have a fairly general mechanism in the simulator to allow you to sort of connect as many transmitters and receivers as you want to one of these buses and so that little structure turns out to have been kind of a fun part of the project where I end up with this collection of these trays and so kind of matching the physical machine there is an implementation I think it's 10 or 20 of each type of tray and within the tray what you do is you have an array of connections that have been connected to it identified as transmitters and then you just simultaneously listen for a message on all of those channels any one that you get you then turn around and pass it on to all of the receivers this you've got and so when you have the commands that do the configuration saying plug a wire from here to here that goes into the trays as here I'm a transmitter to this and here I'm a receiver to this now there's one aspect of this that is slightly different than the original in the original the wires in principle could carry signals in both directions now was never really used that way and so I figured it was safe to go ahead and in the simulator treat each one of the channels as unidirectional so this is kind of the discussion about how those trunks work now let me mention the handshaking in the original machine when the clocking unit the cycling unit transmitted say a central programming pulse throughout the machine then of course each unit would respond to that it would potentially as a result send out other signals now the design of the machine was such that before the next pulse the next cycle of that hundred kilohertz clock we could rely on all of the circuits having finished what they were doing with that first pulse if you're writing code running on a time-sharing operating system it ain't so predictable and in fact that turned out to be an issue that I ran into on some platforms it seemed to run quite stable on other platforms it would fail tests and digging in I was finding things like oh this signal was happening before this signal when it should be the other way around so I swallowed hard and said okay I'll go ahead and implement a handshaking mechanism so the idea is that if I receive a clock signal I'm not going to send back the acknowledgment until I have finished with anything I'm sending and gotten the acknowledgments for those and then I'll be able to send my acknowledgment back so that ends up actually throttling the speed of the simulator a bit and some people are a little surprised to find that the simulator actually runs slightly slower than the original machine yes the original machine was quite slow but this simulator is even slower but again it gets down to that working at a very low level ok so how did the accumulators work as I said this is where most of the computation takes place and the way it is set up is each accumulator source 10 decimal digits and it does so by you using a 10 stage ring counter and the ring counters were implemented in these plug-in modules that would plug into the back here and so you would have on the machine a vertical line of 10 neon lamps one of which was illuminated that was the value of that digit then you had 10 of those columns next to each other it was the 10 digit number and then we also had a sign a plus or minus sign and of course you look at that and think AHA they're doing sign-magnitude nope they're actually they've got a sign and they're doing tens complement it's kind of a weird combination but of course that means you know like two's complement additions don't have to pay attention to sign they do the right thing the inputs to the accumulators are labeled by these Greek letters alpha 3 Epsilon each one of those represents a channel over which I can take these 10 digits in parallel and add to whatever is in the cumulated currently the outputs are labeled a and s the a output is an additive output and the S output is a subtractive output the idea is that if I want to add I'll transmit on the additive output and whoever receives it will get that added to their current value if I'm subtracting I'll output on the S output and then whoever receives it will get the difference and the way it does it is by sending the number as it's stored on the a output and sending the complement of the number over the S output for each of 12 different operations you can trigger on an accumulator you've got switches that let you set what that operation is going to do and basically you can either say I'm going to receive on one of the inputs or I'm going to output on one or both of the outputs or and you got to love this they've got a no op it turns out that no op is actually used fairly often on the ENIAC you've got a couple of other controls one of which says if I'm transmitting do I clear the accumulator after that same control if I'm receiving I actually get an extra one added in and that has to do with the nines versus tens complement may remember and go all the way back to your freshman year in college when you were taught about ones and twos compliment once compliment you flip all the bits for two's complement you'll flip all the bits and add one same sort of thing happens with nine in tens complement to get from nines complement to tens complement you just add one and so that correct setting is about adding an extra one for that the other thing we've got is a nice little repeat mechanism so if I want to add 3x to Y then I don't have to set it up as three separate operations I can set it up as one operation which X is transmitted three times and Y receives three times so small integer coefficients in your equations don't actually have to go through the multiplier you only need the multiplier when you're multiplying two variables together so here's how the whole thing works this gets us into those pulses I was talking about these are the two lines from the clocking diagram with the group of ten and the group of nine now if I think about a digit say it's value is four then I want to transmit four pulses out the a side for that digit I want to send the 9s complement of that which would be five pulses out the S side the reality is I'm always going to be sending mine pulses it's just which of them are going out the a in which are going out the S so the cleverness is well what we'll do is we'll take the value in that digit feed ten pulses into it that causes the ring counter to go all the way back around to where it started and in the process of doing so at some point it's gonna go from nine to zero and what happens when we go from nine to zero we set a carry and it turns out if you think about it for a second the carry is exactly when I need to switch from outputting on one of the terminals to switching to the other so we start out sending out the S port as soon as the Kerry hits we switch and send the rest of the nine pulses out the a port and this is how we read information from the accumulators there's easy enough to figure out how to make it add but how do you read the information out that wasn't as obvious people were used to using these sorts of counters in fact Eckert had a lot of experience people doing nuclear research had these decade counters that they were using for measuring radiation but of course the information that you got out of the counter was always a human being looking at the lights how do you pull the information out and use it somewhere else this really clever approach is what they used and what I'm gonna do right now is in the simulator illustrate that in operation so here is an image of the simulator what I've done is I've sort of zoomed in on one section of the machine depending on what you're doing with it this view of the whole machine is a little bit more impressive especially when the lights are moving and doing all sorts of fun stuff but right now we're going to be looking at just a few parts of the machine in particular the leftmost unit in this figure is the divider square reader and then immediately to its right are a set of seven accumulators and the first three of those accumulators are what we're going to be using right now the other thing I'll point out here is that in the lower left-hand corner of this image is a representation of a control box in fact it's got some photographic remnant of the real thing and this is what the control box looked like this is a 3d printed production of it this one is actually set up to be able to plug it into a simulator running on a Raspberry Pi and actually control the ENIAC the neat thing about this was it really showed a great deal of foresight into the questions of debugging one of the most important things that this lets you do is single-step the machine in fact you this switch lets you control what level of granularity your single stepping is doing and had a long enough cord you could walk around the whole machine so you could walk up to any accumulator and just sit there and go aha there's the mistake so what I'm gonna be doing right now is doing the on screen version of that right down here and so this is how I'm gonna be controlling it right now I've got the clocking mode set that every time I hit the pulse button one addition times worth of activity is gonna take place so initially I'll hit the initialize button which sends out a pulse that is meant to start the first stage of the computation and in this case the first stages are loading some values in now if you look carefully the first accumulator that second panel here now has a couple of values in it that weren't there before the first digit is moved up one place and the this next digit over here is moved up five so we've stored the number 15 in this accumulator I'm gonna hit another pulse and what's going to happen is in parallel when a load of value into both of these and in this case the value loaded into each of those is 27 so we've got 15 in the first accumulator 27 in the other two and what I'm going to do now is go through that step by step of how it transmits from one place to another the additive outputs going to go into one of the other accumulators and the subtractive into the other so I'm going to simultaneously be computing the sum of fifteen and twenty seven and the difference of fifteen and twenty seven so let me switch the clock now to the single pulse mode and we now begin this sequence so here if you look at the one on the left all of the positions have moved up one spot that's one of those ten pulses and as we're going through those ten pulses you see that some of the things are also causing things to climb on the other two accumulators and the lights underneath are the carry lights so they tell you when it's going from one to the other once we've resolved all of the carries we now have in the second accumulator of some of forty two and in the third accumulator the difference of twelve so when you're operating the ante act that's basically the way you're doing arithmetic is you're counting pulses on a per digit basis and if you can't figure out what went wrong you've got your debugger actually kind of like this kind of a debugger which we had this on real computers or modern computers Latian sights I sometimes tell folks that especially my students it it's not a real computer if there's not blinking lights I mean let's face it we haven't had good computer since the pdp-11 have we okay so the next piece of this that I want to mention is the master programmer the idea here is that yes it's fairly easy to build a sequence of operations where the output terminal from one operation triggers the next operation but how do you go about doing repetition how do you do conditional operations the master programmer is the equipment they put in for that purpose now it's not as completely general as we usually think of in terms of a typical stored program types area scenario where you've got a jump instruction and you can organize them however you want but it was very flexible it contained ten counters of six stages each these counters these six stage counters represented phases of a computation and so every time you advanced that you would go to the next phase of the computation for each one of those phases you had counters that you could set to be a simple limit on how many iterations to perform total of 20 digits worth of counters and you could kind of reassign them to different different ones of these six stage counters as needed so you could really build these very complex nested loop structures if you wanted another neat thing that happens is we have these interesting cabling structures here but we have special adapter cables that we'll take one of those multi pin connectors and break it out into eleven of the individual control connectors and since the pulse shapes are exactly the same we can take a digit output and use it as control so for example if I take the sign output I can use that to discriminate between positive and negative so the conditional values that they used in fact the term they used in the manual was magnitude discrimination was to determine the comparison of two magnitudes and it was typically or one of the most common forms was in terms of the sign was it positive or negative so by introducing a data signal into the control structure you could generate a control pulse only if a certain result was negative or only if it was non-negative and by doing that you got condition branching and that of course as we know turned out to be the key thing once you had that you had turing completeness and that's why they were able then to look at building an instruction set decoder well in fact they actually had some clever use of the master programmer in the original thoughts for the instruction set decoding where they would use what amounted to the sixty different outputs from the stages as in a sense the instruction decoding so if you were had an instruction set of sixty or fewer instructions you could implement it directly on the existing hardware now it turns out what they actually did in practice was they decided they wanted a more rich instruction set so they added another component that would take a two digit number and break it out to a hundred connections and they call that the converter unit so that's what was actually deployed the other neat thing about this is that if I take instead of a sign a digit and feed it into one of these six stage counters I basically get what any old Fortran folks in here what we call a computed goto essentially you take the value of this integer and it selects one of six possible actions there's an example in the technical manual that takes a pair of these six staged counters and divides it into two groups of five and then you've got now ten options from a single digit so one example of using this is calculating say a table of squares and I'm not gonna go through a lot of the detail of this I'll just suggest that if you take a look at the slides later and you want to kind of figure out how this works we're not actually squaring anything we're just using everybody's favorite relation from highschool x plus 1 squared is x squared plus 2x plus 1 and neat little things like 2x well we just use the repeat mechanism on the accumulators to do that okay this by the way is how you would wire up that problem this is in effect your source code the switch settings are indicated by values in these boxes and then the wiring is indicated on the top and bottom the data trunks up here and the control trunks down here and this is the way in which you would typically specify a program they had a few other variations on this but this was a very direct one because now you could take that walk into the machine room and wire it up and one of the ways this was frequently done was one person was stand in the middle of the room with the papers and call out accumulator 12 program 3 switch setting alpha and there would be a person standing if that can be lit and turn the switch and you would have this whole room full of people programming the machine that way as you might guess bugs in the form of plugging in the wrong cable or setting the wrong switch those were pretty common okay I've already really kind of mentioned this so I don't want to spend too much time on that I do want to mention a little bit about how this user interface came about that I showed you what you saw was just the graphical part of it there's actually also a command-line interface which is really from the codes perspective the main interface and it's a very primitive sort of a thing you know I am an old-timer in that regard why type 3 characters if I can type one let's face it there's nothing wrong with a variable called I so it's got a very simple single letter commands and abbreviations to refer to the unit's so for example if I'm going to set a switch setting the command is s I'll specify which switch and then a value and so you get this nice little three fields in the line which looks a lot like assembly language in fact I was comparing notes in discussing this work with another person who had done in ENIAC simulator and he liked that format so he converted his to use it and between the two of us we started calling at the ENIAC assembly language so it turns out then if you want to have a configuration file that wires up a whole setting it's just a file you read that look like commands that the users typed so nothing special in terms of configuration files so how's the graphical stuff done well a long time ago I reached the point where I decided I was done dealing with graphical libraries every one of them's a different none of them are any good I'm going to let tcl/tk do the job for me so all I do is create a child process running wish which is the windowing shelled from tcl/tk I set up a couple pipes one that becomes its standard input one that becomes a standard output when I want to do something on the screen I just shoot commands down and it happens on the screen when somebody pushes a button on the screen it just sends back a message that happens to be exactly the same format is what would happen if you typed a command at the command line window the beauty of this is it's completely portable TCP TOS tcl/tk has been ported to virtually everything and I don't have to think about anybody else's graphical environment I don't have to think about anything it does it all for me so this has kind of become my standard way of doing graphics the other thing that's kind of interesting about this is where did these images come from there's no actual photograph of the machine that looks like that but there are lots of photographs of different bits of the machine so I actually went through scoured many hundreds of photographs and found like the best photograph of this right here in this part right here in this part right here and then pasted them together in two units and then I wrote a custom ray tracer to generate the depth so that's how that prospective image came about all right let's see believe yeah here's a couple of examples of it running my favorite one is the one on the right if you remember a little device called the chip a few years ago it was a Kickstarter they ended up closing up a little arm machine that's it running on its little pocket thing meant to bring it with me and forgot now I promised this have kind of come full circle so I need to talk about one more connection between going the ENIAC and it starts with this guy right here hairy husky husky is probably one of the most influential and least known figures in the history of computing he only passed away recently at the age of 101 his role on the ENIAC was as the designer of the interface units between the ENIAC and the punch card Cardon punch later after the design work had been done in the machine was under construction the team began working on their follow-on project the edvac and he was a part of that after the war he took a sabbatical and he went to England where he was at the National Physical Laboratory and if you've followed the history of Alan Turing you'll know that's where he went after Bletchley Park well Huskie was intrigued at some of Touring's architectural ideas for building computers and he pushed the folks at NPL to build a sort of small pilot version of this work well a project kind of started and fizzled while he was there but after he left him that same project got resurrected and produced a machine that we now know today is the pilot ace very interesting architecture if you study it after that he comes back to the u.s. he goes out to California and is the lead engineer on the development of a mission called the SWAC the standards Western automatic computer National Bureau of Standards built two machines in these early days and he was the lead for the one on the west coast after that he joined the faculty at the University of California Berkeley now while he was at Berkeley he had several notable students one of his PhD students was Nicholas spirit the person who then went on to do the languages Pascal modulo Oberon one of his master's students was this fellow right here Ken Thompson who of course as we know went on to work on the multix project at Bell Labs then and Bell Labs dropped out of multics he said let me find something interesting to work on and as he puts it he found a little-used pdp-7 he was going to do space exploration type stuff the space war games and decided that I need to build me a little operating system and that was Unix and of course we all know from there he had developed the language be Dennis Ritchie added types to make it C before he retired ken was working for Google as one of the key developers on go so that's how it actually comes all the way full circle all right any questions all right well I think we've used right at an hour so thank you very much and have a good rest of the day you 