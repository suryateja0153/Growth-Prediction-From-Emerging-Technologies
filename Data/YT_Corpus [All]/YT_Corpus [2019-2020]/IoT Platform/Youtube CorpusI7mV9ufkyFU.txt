 We're here on the On.NET show and.  Hold up, hold up. I'm the host.  Oh geez.  Let me take this one. On.NET show today, we have Richard and Jose talking about.NET core with IoT. Join us. [MUSIC].  Welcome to another episode of On.NET. Today, I'm joined by Richard Lunder a PM for the .NET core team and Jose Perez, who's a developer on the.NET core team and we will be talking about IoT with .NET core 3.0 preview.  Yeah.  Right.  Definitely.  What do you have for us today?  Well we've been working on making it so that developers can write applications for these tiny little devices. It cost like $35 to buy one of these and there's so much you can do. So we wanted to talk to you about that.  Perfect and that's a Raspberry Pi right.  These are Raspberry Pi 3s, you may have heard that the Raspberry Pi 4s were just announced. I put it in order for the pre-release order, but they're not coming until August sometime.  I think they are already shipping, but they sold out very quickly.  Maybe. Yeah. The place I went to said it was pre-order, but we don't have those.  Well, we'll still can make things work with other thing, right?  Absolutely.  Perfect.  So maybe I'll start with a few talking points. Yes.  Yes.  So let's get to the the PowerPoint. Everyone loves that.  Everybody loves PowerPoint.  Yeah. So Jose and I will walk you through this. So the basic idea is this was a Raspberry Pi, this is what it looks like which you already saw, but this is what it looks like from a chip perspective. So the thing that says Broadcom on it, that's the actual chip, it's an ARM chip and it's got four cores on it. There's several variants that are in wide use. They have like one point something gigahertz clock on them and between half a gig and four gigs of RAM.  That's like three times my first PC in 2001.  Right. But I think the takeaway is these are no Cloud servers, this is not what Azure is running on for example. So you kind of have to think about your software a little bit differently.  Okay.  This is the whole space in which IoT lives. So the devices on the left that Del block box and also the Raspberry Pi, that's what we're enabling with Dynacore. The devices on the right are important devices in this space, but Dynacore doesn't run on those. So it's just we're not really competitive with those in any real sense, so we're not trying to beat them or anything like that, but this is just a way of thinking about the ecosystem.  Sure.  The Raspberry Pi has all these electrical pins on it. This is actually what we're going to be talking about today. They all have very different purposes and we have APIs to program all of them.  Rights. I think that's the difference with.NET core. 3.0, right? The fact that we can control the pins, unlike the previous versions where you can have access to those, right?  Yeah. Do you want to talk about that Jose?  Yeah. So .NET core in running on a Raspberry Pi, that's not a new thing. It's actually not new for 3.0. at least. But on this same 3.0. wave even though it's not really part of the framework, it's going to be installed via NuGet package. But we're building this new library that's actually in GitHub it's open source in.NET IoT.  That's the repository, right?  That's repository. Basically what that library will allow you is to be able to control these 40 pins on the Raspberry Pi and that actually works with other microcontroller boards. So it's not just exclusively for the Raspberry Pi, this is just the one that's most widely spread for used.  Yeah. Also maybe you said this, this library will work all the way back to .NET core 2.1.  Right. That's important.  Yeah.  Technically actually to. 2.2.  Sorry 2.0.  Right. But that's not in support anymore, so that's somewhat irrelevant.  So 2.1 that's the point right.  Yeah. Yeah. Cool.  One other interesting fact in there is right now we've just talked about Raspberry Pi, the big one, but there's also like the Raspberry Pi Zero, so like the smaller model. Because our library that controls these pins is targeting.NET standard, so that little pie, that small pie can run.NET core, but it can't run Mano. So our library will be able to run in there as well. So we will be able to get, like that little microcontroller also has pins, so we'll be able to control those as well.  That one is five bucks.  Yes.  I did order one when it came out.  Yeah.  I haven't used it yet, but I need to find a purpose for it.  I have one on my desk. Okay. So just super quickly. The basic idea here is that you can program these pins and basically you're just sending electrical pulses, you're turning the pins on or off. Then depending on what you have if it's something that's purely electrical, then it will turn the light on or off just from a pure electricity standpoint, just like light bulbs in your house. Other devices you can have on there like this pressure and temperature sensor. When you turn the pins on and off, it's more like data protocol that you are sending. You have to send electricity as well, but that's more of a constant on sort of thing. Then you talk to it and say please give me the temperature right now.  Right. Then you could also read from that device. So that device will send you data and send you the temperature and so that you can read it with or something like that.  Yes. So this is the most simple version of it, which is basically you have one wire that's coming up to this resistor that's giving it the electricity. If that one pin is on, it goes through this LED, then you basically make your way towards ground and the wire on the farthest right is ground. So this is just a simple electrical circuit, it's no different than electrical circuits in your house. If that resistor wasn't there, the LED might like burst and shatter, not actually, it just might burn out after a while.  Sure. Okay.  Actually, do you want to explain this?  Does the most simple circuit is just having an LED in the breadboard as Rich showed in the previous slide, but as we can see here, it could also be very messy. You could have a lot of cables going on and as Rich like to say, Visual Studio is not really going to help you with this even though it's very good at organizing code, but not cables. But anyway, so in the in the left, you can see a breadboard, that little red device over there in the middle of the breadboard that's a temperature shield. So what's going on here is that that temperature shield is providing some data back to the Raspberry Pi and then the Raspberry Pi is reading that temperature data and then passing it through another device that's also in that breadboard which is an LCD display. So to be clear, these two devices are not talking between each other, the LCD is not reading the data directly from the temperature sensor, but your code running on the Raspberry Pi is driving both devices. So that is thanks to the.NET IoT repo.  Right. This LCD display. It's really dumb, it has no computational capability on it at all, there's no code that you could put on there to tell it, "Oh, just read from this or this temperature sensor," it's just a stupid device.  Right.  Yeah.  Yeah.  Okay. So it'll be good to talk about why we did all of this work in the first place. There are really three reasons. One is we wanted to make it possible for.NET developers to create these kinds of applications. We wanted to make it so that companies that build IoT hardware could actually target the.NET developer market because it's a very large one, it's one of the largest developing communities in the world. The last thing is we have lots of friends in the Azure org and they came to us and said, we'd really like to make IoT work well and target .NET developers, so I guess actually this is a case of Microsoft targeting the .NET community. So we've been working super closely with them to make all of these devices work well for their scenarios. So in terms of what we have in .NET core 3.0 preview, obviously we have full integration with these Azure services like IoT Hub and IoT Edge, we support ARM 32 and Arm 64 across a variety of Linux and Windows versions and we have Docker images for all of that stuff. So if you want to have the container lifestyle, you can totally do that with all this. Everything we talked about. We support all the device protocols. Yeah. Do you want to talk about the cool things that we've built?  Sure. So there's two main things that are built in the.NET IoT repository. The first thing is the actual library that's driving this pins, but the other thing that's built in there it's what we call Device binding catalog. So these are like wrapper classes that use the IoT library in order to control more complex devices, so like LCD displays, or temperature sensors, or pressure sensors, or what not like even motors or circles. So we already have a bunch of these device bindings already available on the.NET IoT repo. Here like the example that we have in the slides are they are just a color LCD display and then the other one is an E-ink readers similar to the displays that the Kindle devices have or the e-readers. So we're able to drive those using these wrappers so that the consumers of our library don't really have to talk necessarily, maybe they just want to drive a temperature sensor, so they don't want to have to know all the protocols of how am I supposed to talk to this specific temperature sensor. Maybe we already have that binding in our repo, so they can just ingest this would be a different NuGet package, but they would just ingest this NuGet package and then just use a class called temperature sensor.readtemperature or something like that.  So you create an obstruction for all the underlying implementation so developers don't really need to know every single API for every single vendor, right?  Yes. Yeah and it's a little bit like how, when with server .NET framework we provided these rich APIs over what was fundamentally p invokes into Windows. It's kind of the same model again, like some of the details are different. We also built these robots, that's another scenario that totally works. We have several libraries. So all of the GPIO and related APIs are in the System.device.GPIO library. On NuGet, these wrappers that Jose was talking about there in the IoT.device.bindings. NuGet package and all the sources are on dotnet/IoT. One key thing to note is that the first package is like just a normal, supported by Microsoft package just like System.Collections kind of thing.  Yes.  This IoT.Device.Bindings is a community supported library. All the sources in this dotnet repo, but it doesn't have the same level of support. So we intend to continually both expand the number of bindings in it and also improve the quality over time.  Right.  But it is our community supported package.  Okay. Do we have documentation that helps developers see how they can use it?  In the repository.  Okay. Brilliant.  Okay. So that was the presentation. Now, do you have any questions before we get down to demos?  No. I mean I want to see this thing working right?  Okay. So let's start with the first one. So yeah, we had to do a little bit of work to get this working earlier today. So let's obviously amp this up a little bit. So what we have here is, let's get rid of this. So what we're going to be doing is driving, this is really simple.  Do you mind me holding?  Yeah, that would be good. So that's this guy and this is called an LED bar, and so it's basically a whole bunch of LEDs that are all in a single unit, but you still have to drive them as if they were all separate. That's where they're all these crazy resistors are that are kind of like bent and crazy because I've taken this with me to various places.  So this here is the LED bar.  All right, yeah.  Yeah.  Okay, so now what we should do, is we should actually go look at this code, and I'm just going to quickly walk you through it. So what this is, it's basically saying, here are the set of pins that are relevant for this particular program, you don't have to write your code exactly this way. This is how I choose to write it. For this particular program, cancellation is important. We don't need to go into too much detail on that. I created a class called AnimateLeds, and what it does, you should kind of see here, is it allows you to create an animation over a set of LEDs, so I've got: FrontToBack, BackToFront, MidToEnd, EndToMid, MidToEnd, LightAll, DimAllAtRandom, so these are all are just little animations.  Like Christmas lights, so I can use this one to [inaudible].  Yeah, sound like.  Definitely.  I had a particular thing in mind, and so I wrote all this actually incredibly simple code. So.  I see where you're going.  Yeah. I'll just show you like the most basic one which is, I don't know why that happened. Here we go. FrontToback, all it does, is it says, we can ignore this crazy stuff. Basically, it just says, "Do a sequence of zero to the end". That's more or less what this says.  Okay.  Then sequence just says, "For each over this IEnumerable of pins and then CycleLeds." Then just what it does, is ignore the cancellation thing. It just says, "For each pin, put it high, and then Sleep for LitTime". That's how long it's going to be up. Then it says, "Make it low and then Sleep for DimTime".  Right.  So it allows me to create this animation where it's lit for a certain amount of time and then dim for a certain amount of time and then it gives up and goes to the next animation. That's basically how that works. So how about-  Looks fairly simple so far, I mean.  Yeah. Actually, first I'll run it on the Pi itself. So that's this guy, and we were doing some crazy things before this. So Led-bar-graph, that's where it is and I just happen to know everything about this one. So this is just where it lives. There, and it's even working. That's always positive. So this is kind of my kit display.  I think you can see.  Yeah, I think we can see close enough, and then I have some console spew to say-  What it's doing.  -what's going on.  Nice.  Then eventually after I'm satisfied with it running, I just press "Control C" and the thing ends, and the nice thing about it is, the way that programs written, is all the lights go off when I press "Control C". Now, let's go back to, this box here, this terminal window is me SSH into that particular Pi. So I have a terminal window and so the Pi is literally controlling it from there. But let's control it from Visual Studio, and I.  Code.  Sorry. Yeah, Visual Studio Code. That's right.  We both jumped on this one.  Don't put me in sort of-  So you're running .NET Core 3.0 on a Mac.  Yes.  Using code and [inaudible].  Yeah. Actually, I'm going to run it just a tiny bit longer. So you can see what's going on. So it's a very similar sort of experience here where you can see this console spew there. I'm actually going to set this break point. This controller write, is the main, the primary call into the library that Jose actually built for us, and so the cool part here is, I'm going to press "F11", I'm going to step into to that method and, now through the magic of Source Link. If I can move this guy here. So if I hover over this, does that work? No apparently not.  It doesn't show you.  It doesn't show me, but this is actually.  You can see now Call Stack.  This is, we are now in System.Device. Gpio, DLL in this particular method, and so this file actually got pulled down from GitHub, over the network. I actually don't have this code. Well, I kind of do, but not in a way that VS Code found. It pulled this code over the Internet and so now we can actually step through this. So one of the things that, and that was very simple method call, so that's over. Actually now we're into this other one.  Yeah.  So one of the things is, that we actually did a show on this like a year ago, it was me and Peter [inaudible] on the show, and we were showing somewhat similar things. There we had some rappers over some community native libraries. It turns out that those were not the best plan for us to productize for all these customers for two main reasons. One is they were all native codes, so we couldn't have this nice stepping in and stepping out with a nice C-sharp kind of view, because you would have been a native code and then you wouldn't need a C++ tool set and all the craziness, and a bunch of that was GPL licensed and now this is all MIT licensed. So you can do literally whatever the heck you want.  The important thing here, is that if you find a bug as you step into things, then you can actually go and fix it and then continue doing it. While you're opening your-  You can fix it or if you're fairly sophisticated, you can figure out what is the problem and then file an issue on the dotnet/IoT repo and then it will fix it.  We are an open source. We will take the odds.  Yeah, totally.  That's why [inaudible] , because you find a bug, you fix it via pool requests and then you carry on with your work. That's brilliant.  Exactly.  It is. So this is working pretty well. One of the things we noticed in general, is we have actually a lot C++ code in the overall product and we progressively been moving into C Sharp, and then when we do that, the level of community contribution for that component-  Goes up.  -goes way up. So that should not surprise. There are no surprises. Yes, so that's kind of what we've been building. Now, what we're doing, is we're just making more and more, here's another display. We're just making more and more scenarios.  Okay. Fantastic.  Yeah.  So we'll just see a little more coming out in the coming weeks and months and then hopefully by September, I think we should be seeing things stabilizing and going and ideally.  Yeah, technically our calendar is kind of trying to align as close as possible to.NET 3.0.  Okay.  So we have been releasing the same previews, when.NET Core releases previews and we plan to do the same thing for GA.  Perfect.  Yeah. That's the plan.  This doesn't sit up straight in any way.  Well put. It's still running and it's executing through VS.  What it needs is a 3D printer, to print some bits there to hold it in place.  We actually have built. So we have this, it's was too much to show on today's show, but we have this stand for these LED matrices that we built.  Right.  So there's four of them together and we built a back for them and some people on our team, who are into 3D printing, they're like, "Yeah that was a nice first try." Good try there, but you really need to 3D print like a real back to make it look professional and have a little place for the Pi to go, to make it awesome. So we're actually headed that direction.  Perfect, and you can bring it to the show next time.  Yeah, totally.  Well, thank you very much for coming today and hope that our audience found this useful and I would like to encourage people to go and try out and I think everything is on GitHub right?  Yes.  So we've put links under the videos, so you can go and find all the information you want and.  Yes please.  Yes dotnet/Iot is the place to start.  Right.  Well, thank you very much guys.  Thank you.  Awesome. [MUSIC] 