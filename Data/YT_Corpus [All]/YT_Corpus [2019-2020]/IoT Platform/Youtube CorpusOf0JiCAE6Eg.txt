 [Music] my name is Dave Smith I'm a developer advocate here at Google working on IOT platforms and today I'd like to spend a little bit of time talking to you about how you can build cloud services for smart devices and how you can integrate those services with the Google assistant we're gonna walk through some components of an example cloud service solution and then we'll discuss a little bit of how you can connect a service like that to the assistant for smart home device interactions all right so let's get started so voice assistants have accelerated adoption of smart devices in the home they've become the common thread that enables different manufacturers to work seamlessly together inside of one space now the smart home API enables developers to integrate their cloud connected devices with the Google assistant and leverage the natural language processing that's built into the assistant for processing queries and commands for those devices that are in the home smart home is part of actions on Google which is the wider platform designed to enable conversational engagements with users through assistant enabled devices however smart home uses a more simplified model of interaction that abstract away some of the conversational pieces of a typical to voice action just out of curiosity how many of you have developed using the actions on Google platform before okay so for those of you who have you're familiar with some of the conversational interactions that typically take place when building an action and using smart home you're gonna see that some of that is simplified quite a bit developers don't really have to interact with the request and response model of talking to the user we focus more on the devices so with smart home integrations we focused on creating a clear and structured interface for devices devices are broken into device types and traits which provide a well understood schema for reporting those device capabilities to Google you can see an example of two of those device types here on the slide in the light device and a thermostat device and we have many others as well within these individual device types these encapsulate a series of what we call traits that define what the capabilities are of that device so for example with the light that device can be turned on and off you can adjust the brightness or you can in some cases maybe modify the color setting whereas for a thermostat you have the capability of modifying what we call the temperature setting okay and then within each individual trait these are further subdivided to provide individual attributes that describe the state of that particular device so for example with the thermostat the temperature setting trait defines three attributes for that thermostats mode like heat or cool or off or auto things like that the temperature setpoint as well as the ambient temperature okay so we we put all these things together to define what we call the device schema to provide known device types interactions with the Google assistant now having such a well defined schema enables the assistant to bring highly intelligent interactions about how they process queries and commands because it now has a strong understanding of what those devices are and what those devices can do in other words with smart home we we allow Google to handle the conversation so that the developers can focus on the devices the Google assistant also adds contextual understanding to your devices through the home graph home graph is our technology that understands the relationships between structures rooms users and devices home graph is what powers our ability to understand user queries in context of the environment and be able to translate that back to individual devices it enables us to say things like turn on the upstairs lights or what's the temperature in here by providing that relative context between the user and the devices around them all right quick show of hands how many of you in here own a assistant enabled device in your home whether that's a smart speaker like a Google home or a smart display like Home Hub that I have up here okay good good good now for those of you who raised your hands how many of you have at least one smart device in your home that is connected to that assistant device okay good good so about half maybe a little bit less so what I'd like to do here is I want to quickly show you a demo so that everybody is on the same page of what this actually looks like in practice so up here I have a Google home hub and I have a nest thermostat and I'm just gonna walk through some very simple interactions of how we can interact as a user with the assistant with one of these smart devices so let's quickly switch to the demo the mics back on alright so wake up my devices here alright so well as a user I've installed both of these devices in my home and I can I use the Google assistant to set these devices up add them to rooms in my home and do all these pieces associated with the home graph that I just described and what that enables me to do as a user is walk up to my device and say simple queries like hey Google what's the temperature on stage it's currently 71 degrees so this is the smart home API in action right basically what's happening is Google is connecting to the partners cloud service in this case nest and it's asking for the current state of that particular device and then reporting that back to the user notice also that I'm referring to that device by its location in this case on stage and this is because the assistant has assigned that device to the room using the home graph when I initially set it up now because the home graph knows that this display and that thermostat are both in the same room I can also make more relative queries like hey Google what's the temperature in here it's currently 71 degrees we get the same result right similarly we can send commands to these devices to make a change hey Google set the temperature to 65 degrees okay setting the stage to 65 degrees and we can see the adjustment also made on the thermostat as well so this is again using that smart home API but in this case Google is sending a command to that partner cloud integration to say you need to adjust the state of this particular device and in this case is providing a new set point okay now even here we can make we can use Google's natural language understanding to make more natural queries at the same time hey Google make it a little warmer you got it warming up the stage okay now the other nice thing about integrating your devices with the Google assistant is not only do you get this voice interaction but on assistant surfaces that have you I like this smart display or an Android phone or an iOS device you can also interact using the touch UI so for example you saw it for just a moment but I'll bring it back up quickly I can look at the view of that device on this display and I can interact with it directly to make that change on the device as well okay now all of this functionality is built into the Google home app into Google assistant devices and all you have to provide is the interaction of how to ask your devices for information and how to manipulate them through commands and we're gonna talk a little bit more about how all that stuff works so let's switch back to the slides the mics off all right so there's two things that I want to go over with you here today and the first that we want to discuss is let's talk a little bit about how do we actually build a cloud service that communicates with devices so quickly just kind of showing you a diagram this is essentially what you just saw in the demo right the user can interact with this an assistant enabled device and that assistant device will interact with your cloud service in order to communicate with that particular device so the smart home interaction is a cloud to cloud integration okay which means as a device manufacturer you have to provide your own cloud service for users to register and manage their devices and then the smart home actions platform can integrate with that cloud service using a series of web hooks to control and access those devices we'll talk more about that in a little bit now depending on where you are in your development process you may already have this functionality in place for your devices but I want to explore a little bit of what an example might look like if you were to build this device cloud service on Google cloud so this is an example architecture using services from the Google cloud platform as well as from firebase that we use to fulfill the requirements for the smart home use case now the sample code for what I'm gonna show you is on github so I recommend that you take a look at that after the talk it's an end-to-end sample that includes the cloud service as well as client applications for mobile and web interactions with sample devices all that stuff so in this sample architecture we have cloud IOT core which enables secure device connectivity over MQTT or HTTP we're also using firebase which enables easy client application development for mobile and web through their series of native SDKs we also get access to firebase authentication which adds the ability to provide user identity and access control over all of this data now in this example devices report their current state through IOT core which then bridges that data into pub/sub and through to cloud fire store using firebase authentication and fire store we can build client applications that expose that data directly to users for device management and then users now have the ability to control their devices and they do that by updating the data in fire store which then triggers commands back to the devices through IOT core now this means that in this architecture fire store becomes the primary source of truth for all of your device data and that's going to become really important when we start talking more about smart homes so I'll come back to that a little bit later on but just keep in mind for now that cloud fire store is that central point where all of the data is accessible for all of the devices okay so why cloud IOT core IOT core enables secure connections to Google cloud for resource constrained devices okay think all tiny $1.00 microcontroller less than a dollar type devices right generally speaking if you're building something like a smart light you're not gonna want to put a quad-core processor in there running embedded Linux I hope instead you typically want low-power devices that have very low footprint and all of those things so we use cloud IOT core to enable those devices to connect directly to Google cloud and that's done two ways the first is using MQTT which is a low overhead protocol that is design is ideally suited for IOT devices or low bandwidth devices okay we do also support HTTP but generally speaking most users of IOT core are using the mqtt protocol primarily for this reason the other and probably more important reason is for authentication so we need to make sure that these devices have a secure connection to Google cloud and as I mentioned before generally speaking we try to get the smallest lowest footprint cheapest device we can into these smart home devices whatever we need to to supply the use case this often introduces constraints on both the CPU as well as memory primarily memory right the cheaper the device the less onboard memory it's gonna have in addition to this IOT solutions really to be secure need a mutual authentication solution okay it's not enough for the device to be able to trust the server that it's connecting to it's just as important for the server to be able to trust the devices that are connecting to it in an IOT situation okay so we need have mutual authentication going between these two pieces generally speaking you would solve that problem with something like a mutual TLS stack on your device or on your client however typical mutual TLS stacks require way too much memory for a microcontroller in a lot of cases whether it's the stack itself or the fact that the client is also responsible for housing the full certificate chain that it has to supply up to the server all of that stuff can blow out the memory of a microcontroller very very quickly so cloud IOT core is designed to solve this problem by creating an asymmetric authentication between the two it still uses TLS 1.2 to authenticate the server to the devices so IOT core still presents certificates it can be validated on the device and all that stuff but the devices authenticate themselves back to coyote core using a much simpler public/private key authentication making mechanism using JSON web tokens or jots okay basically what happens here is when an IOT core device is connecting to the service it signs a jot with a private key that is stored privately and securely on that device and then provides that jot as the password for the connection to IOT core over MQTT or HTTP the public key is shared at provisioning time with IOT core so it can use that public key to validate that the information coming in from this device is valid it is the device ID that it's claiming to be and all of those things so we still have a secure authentication mechanism from the client device back up to the server but it's using a much more lightweight process that is more easy to fit into these constrained embedded devices than a full-blown mutual TLS all right one of the advantages of using firebase authentication for user identity and access control is security rules does anyone develop using firebase in here okay just a few people firebase is an amazing platform it is built on Google cloud but it adds a bunch of additional developer services that make it really really integrated seamless and easy to use and one of those is firebase authentication integration with datastore using the security rules so with security rules we can seamlessly integrate user permissions to access the firestore data using a very simple declarative rule syntax without having to write any code right and this syntax allows us to validate based on the authenticated users and the information that we have about them what types of data in the database should they be able to access right and this is a basically a snapshot of the firestore rules from the intent example that we have which allow us to control that only authenticated users should be able to access device data and they should only be able to access the devices where we have marked them as the owner of that okay now the logistics of how all that happens is you can look in the sample code but the basic idea is with just a couple lines in the rules we apply that over our entire database okay so it's very simple it's very seamless it's easy to do we can also restrict not only user access but users ability to do things like create new devices right so that we can mediate the process of device registration and we'll talk about that a little bit more in a minute okay along with fire along with security rules one of the other primary advantages of firebase is the ability to build client apps as I mentioned before so this is a screen shot of the mobile app that comes along with the end-to-end example this happens to have been written in flutter using the native flutter SDK that's available for firebase firebase also has SDKs for Android and iOS and on the web we have SDKs for react angular and many many more right so it's a very easy system to integrate for front-end applications both on the web and on mobile okay and this enables you to very quickly create properly functional applications to enable users to authenticate access their devices manage them control all of those types of things now the mobile application in particular is actually quite important because it's part of a critical path for device provisioning it allows users to activate and register their devices so I won't ask for a show of hands this time but I'll bet that those of you who mentioned that you have activated a smart device in your home before more than likely you had to download the mobile app from that manufacturer to provision that device whether it was on your network or with your account or any of that this is a very common pattern because it's a device that we can pretty much assume that all users will have with them right some devices can do this on the web most of them use the mobile app so let's dive a bit deeper into the device provisioning process and how we might do this with something like cloud IOT core so within IOT core I mentioned before that devices use this public private key authentication mechanism when they connect to the service so one of the things that's the OEM where the factory is responsible for doing is producing that key pair and ensuring that the public key is shared with IOT core and the private key is securely store on that device before it's boxed up and and ready to ship that basically creates the initial device association to say that this is a valid device this is its ID or serial number or whatever you want to provide that can be done by the manufacturer but then at some point later when the user actually takes this thing out of the box we have to have a way for them to prove that the device they have in front of them that they're trying to register is a valid device that we know about okay one of the ways that you can do that is you can share that same public key with the user so that they can provide that public key during device registration and allow us on the backend to validate that the public key matches the one that's in IOT core for that particular device ID okay there's a number of ways you could do that in terms of how that information is shared one example which is how we do it in the in the example code that I mentioned to you earlier is you can bind that public key to something physical on the device like a QR code and this is a very common provisioning method that's used by a lot of smart home vendors one of the nice features of this functionality is that it actually enhances the security of the device as well overdoing provisioning methods wirelessly like ble or mdns or some of those others not that there's anything wrong with those but they require additional layers of security to make sure you can prove that that device is the one you're talking to right when you physically bind this data to the device you can guarantee that the user has to have physical access to the device in order to register it okay so you can bind all of that data maybe you want some additional metadata like the device serial number or anything else but the public key in this example is the one that's most important you can encode all of that onto the device using something like a QR code and then because all of our mobile devices have cameras you can use the mobile application to scan that QR code gather that information easily not asking the user to type it in or anything like that I just scan the QR code submit that device information up to firestore and then our back-end service can then validate that information so the user basically submits a request to register this device with a particular device ID and public key and then in the backend we can validate with IOT core oh yes that device ID does exist here's its public key and that actually matches what the user has just given you okay so we know to a reasonable degree of certainty that the user actually has the device in front of them if they're trying to register okay and then from there we can create the actual device node assign that user ID as the owner and then the user can see it in their mobile app on the web okay so that's kind of a quick overview of the example code I encourage you to take a look at the code we also have a couple of blog posts out on that that are linked from the repository as well to kind of give you some more detail on the nitty-gritty of how all that was put together so let's shift gears a little bit now and talk a little bit more about now that we have a cloud service built what does it mean to actually integrate that service with the Google assistant how do we get the interactions that I just showed you before with a smart display or a smart speaker or devices like that so this diagram kind of outlines the basics of how the Google assistant expects to interact with your cloud service when you're integrating the smart home API integrating with smart home basically requires you as a developer to implement the pieces appear that are in yellow which boils down to two primary elements the first is account linking which is represented by that web sign in flow that you see up there at the top and the second is intent fulfillment which you see between the cloud services there in the system so we're gonna talk about both of these in a little bit more detail here starting with account linking so account linking is a process that initiated from within the Google home app that enables users to authorize access to those devices so some of you have probably experienced this before but just kind of talk through the idea if a user wants to enable their smart home device through the assistant they go through the Google home app they decide they want to add a new device and they click that they want to link their existing account from some other vendor like nest or whoever to the Google assistant that triggers a sign-in flow through this account linking that enables them to log in as that part using the account that they had with that partner device and then authorize that the Google assistant can have access to all of the devices that are man by that particular account what you're seeing here is just a screenshot of the account linking implementation that we have provided and again in that end-to-end example that's on github so smart home account linking really boils down to three primary elements now for those of you who are familiar with OAuth 2.0 this is going to look very familiar because basically what we require of your service is to be able to expose to us an OAuth 2.0 compatible endpoints so that we can do an authorization code flow with your cloud service okay so that that basically means we need to be able to handle the authorization step which is the user signing in and granting access and then later on in the process providing access credentials and refresh credentials which again is a typical auth flow for those things they're real so in the example if you were to go and look through the example code on github we've implemented this in the following way so the authorization step we interact with firebase authentication which is really nice because it means we don't have to have write much code to do this firebase authentication handles this part of the authorization flow very well the user can sign in using the same account and then we can use that users ID token provided to us by firebase as the authorization code that we can provide back to Google okay very little code involved in this part then later Google will pass that authorization code back to our cloud service asking us for what's known as a refresh token this is basically a persistent token that should be valid as long as the users account is linked to the assistant okay so this is something that we on our side need to generate return and then we persist it in firestore now in the example if you look through the source code which you'll see is that we actually used the same jot standard to create the tokens for this purpose that IR to IOT core uses to authenticate devices this is the same standard in case you're looking at the code once we've created this refresh token we can then return that back this is a token that now authorizes Google to periodically request access credentials from our service known as access tokens so this Refresh token will be passed back to your service during after the account linking process periodically to get what's known as an access token access tokens are short-lived they expire at some time in the future which is why this process happens periodically so that when that token expires you can give Google a new one and so on and so forth okay so similarly when we get this Refresh token it's our responsibility to validate that the token we received matches the one we persisted for this particular user if it's not it's an invalid token and then if we if that does match then we can provide an access token and then later on that will be used in future requests for intent fulfillment that we'll talk about in a minute for accessing actual device data okay the last piece to account linking is at some point the user may decide to unlink their account from the assistant when that happens you'll receive a disconnect message and your cloud service basically in our example just needs to destroy the token that we considered valid as a refresh okay there are a number of different ways to implement this and in a lot of cases you can even use even use third-party services that support OAuth like all-zero or maybe you've already got this in your application but this kind of gives you an idea of how we built it in the example code in case you want to see what this might look like implementing it for yourself alright let's move a little bit now to intent fulfillment so smart home intents enable users to access and control the devices that they've linked through voice interaction as well as through the Google home you I remember I kind of showed you both of those as we were going through the demo smart home intents the fulfillment basically requires that you handle three primary intents a sync intent a query intent and an execute intent so the sync intent is basically provides information to the assistant about what devices this user control the query intent allows you to return the current state of a particular device and the execute intent is what you'll use to modify the state of a particular device okay so let's look at these in a little bit more detail maybe there we go so the sync intent is sent automatically after account linking is complete so this is the assistance attempt to ask your cloud service what are all the devices that this authenticated user controls and what can those devices do okay so your job is basically to respond to this intent by providing the metadata about all of the device types and the device traits associated with the devices under that users account right so in this example the user might or we might return a response that says this user has four light devices in their account all four of them can report the on-off trait but only two of them support brightness right something along those lines so this is a kind of metadata that you provide in response to a sync now generally speaking syncs are not performed on a regular basis by default a sync is only performed when the account is linked okay and this this can be problematic if this is the only thing that your service implements because it means that if the user adds a new device they have to actually unlink their count and relink it again to see the new device okay now we mitigate this by enabling you to call a method through the home graph API called request sync so if inside of your application users add new devices or remove devices or maybe just the devices that are there change capabilities in some way you can use the home graph API to tell the assistant to request a new sync something has changed we need you to send a sync again and when that happens you'll get the same sync intent so that you can respond with the new set of data the new set of devices and capabilities associated with that particular user okay so request sync is very important because it enables it enables users to have a seamless experience between the Google assistant and your application and not forcing them to manually rethink or relink their account or anything like that just because they bought a new device right and applied it to an existing account all right so the query intent query is responsible for reporting the current state of an individual device or a set of devices in this case the assistant is asking you from some more specific information about what is this device current is the light currently on is the thermostat set to 20 degrees or 25 degrees right so in this case your response is going to provide back the actual values for all of the device traits and attributes that you provided that this device was able to report inside of the sync this includes whether or not the device is online or offline if you're tracking that kind of status okay the query intent is typically triggered when the user navigates to a particular device from the Google home app or maybe through voice when they say something like what is the temperature in here right as soon as that request is triggered then the this intent is going to be sent to your cloud service and you need to send that back with the result okay now both the sync intent and the query intent in the end-to-end example that we've been discussing both of those only have to go so far as firebase right because in the architecture that we've created firestore is the source of truth for all of this data so I can get all the information I need about what devices a user owns what they can do and what the current state of those devices is simply by talking to firebase I don't have to actually go all the way and do a round-trip to the devices which is very important because it enables those queries coming back from voice to be instantaneous right you're not seeing this long latency while we actually block waiting for something to go all the way down to the device and back okay so this enables a much quicker interaction with the Google assistant the execute intent enables you to modify the state of your particular devices based on a user command so this basically comes in and describes a set of traits that should be updated for a given device or a given set of devices and these can be provided in a group so you can get an execute intent that says you should modify on/off and brightness for these three lights okay and then you do all of that in a single set that basically is what allows us to be able to make some of those more complex queries like turn on the lights upstairs there could be six lights from three different vendors in that particular group and this enables us to make sure that that all happens in will command okay the response from an execute intent is a little bit different because we're not actually telling the assistant any more information about the devices we just need to tell the assistant whether that succeeded or not so you can tell it for any particular one of those devices did the command succeed and succeed really means that you know it got down to the device the device made that change and reported that it was successful back to you okay so this is a case where you might actually be talking to cloud IOT core directly depending on your application okay in the sample we don't actually do that we modify the state of these devices through fire store and because of that the responses back from the device that a change has actually happened is asynchronous so in our example we actually return a different state than success which is pending pending tells the assistant that yes that a command is expected to succeed but we haven't seen it yet okay you can also tell the assistant if you know for some reason that that command failed because of an error or maybe because the device isn't reachable because it's not online okay so all that information can be reported back as a result of an execute intent for each individual device and then as you might expect this is the type of intent that your cloud service will see when the user walks up to this device and says something like set the temperature to 52 degrees all right that's going to be packaged up as an execute intent and then sent down to your cloud service okay now one additional piece of information here that's relatively important to implement it's not required per se but provides a much better experience similar to request sync is there's another API call through the home graph that we call report state if the device changes state locally for some reason maybe it's a light switch and they actually walked over and flipped on the switch I know it's weird to think of but it actually does happen or maybe they change that state outside of the assistant right maybe the in your client application or through the web they modified the state of that device this is something where that state change isn't known automatically by the Google assistant and by default this is not a huge problem because whenever the user wants to ask something you'll generally initiate a query any way but queries have latency to them so what you can do to improve this experience is implementing the report state API where anytime one of those local state changes happens that you're aware of you can report that state change to the assistant by providing the exact traits and values that change for any given device this can drastically reduce the number of query intents that your service sees because if there are recent state changes on a device Google assistant can actually look those up locally without having to ask you again okay in addition in cases where like in our example that I mentioned before where state changes in response to commands might be asynchronous so you can't actually tell in response to an execute whether the command succeeded and so you return pending instead reports state is the way that you can basically tell the assistant ok that command has actually changed okay because it happened in an asynchronous way you can call this API this is the new state of the device okay so report state is really helpful for confirming those successive pending commands and in reducing the latency between those potential queries by notifying the assistant of those changes as they happen ok that's pretty much it so just to quickly summarize we talked about cloud IOT core as a way to securely connect constrained devices to Google Cloud we added firebase as a way to easily build those authenticated client apps to give users access to those devices and then we included the Google assistant as a way to provide intelligent interactions with those smart home devices [Music] 