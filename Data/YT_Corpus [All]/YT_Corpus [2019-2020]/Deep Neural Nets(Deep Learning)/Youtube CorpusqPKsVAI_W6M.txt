 oh hello and welcome to another beginner's guide to machine learning with ml5 jazz video this is a video you're watching it and I am beginning this journey to talk about and think about an attempt to explain and implement convolutional neural networks so this is something that I refer to in the previous video where I took the pixels of an image and made those the inputs to a neural network to perform classification and this is I've did this in earlier videos with pre trade models and I mentioned that those pre trained models included something called a convolutional layer but my example didn't include a convolutional there so ml5 has a mechanism for adding convolutional layers to your ml5 neural network but before I look at that mechanism what I want to do in this video and in the next one is just explain how what what are the elements of a convolutional neural network how do they work and then look at some code examples that actually implement the features of that convolutional layer I'm not going to build from scratch a full convolutional neural network maybe that's some other video series but I'll do it someday we're gonna use the fact that ml 5 the ml 5 library just makes that possible for you in the first part I will just talk about from the zoomed out view what a convolutional layer is then I will look at this with code this idea of a filter in the second part I'll come back and look at this other aspect of a convolutional layer called pooling I hope you enjoy this and you find it useful and I'll see you I'll be back in this outfit at the end of the video let me start by diagramming what the neural networks looked like with ml 5 neural network to date and all in the videos that I've made so there's been two layers a hidden layer and an output layer and then also there's some data coming into the neural network and in this case in the previous example it was an image which was flattened so I use the example of 10 by 10 pixels each with an R a G and a B so that made an array of of 300 inputs all these all these pixel values those are the inputs and those go into the hidden layer but just for the sake of argument let me simplify this diagram and I'm just going to consider an example with four inputs I'm going to consider that example as having five hidden nodes hidden units and then it's let's say it's a classification problem and there's three possible categories so when I call the function ml5 neural network it creates this architecture behind the scenes and connects every single input to every hidden unit and every hidden unit to each output so this is what the neural network looks like each one of these connections has a weight associated with it each unit receives the sum of all of the inputs times the weights pass through an activation function which then becomes the output which then all of those with those weights are summed into the next layer and so on and so forth so this is what I have worked with before while in the previous example I was able to get this kind of architecture to work with image input and get results that that produced something if the output this can be improved upon there is information in this data that's coming in that is lost when it is flattened to just a single flat array and the information that's lost is the relative spatial orientation of the pixels it's meaningful that these colors are near other colors something in what we're seeing in the image has to do with the spatial arrangement of the pixels themselves in two dimensions in order to address that we want to add into this architecture I really spent a lot of time drawing this diagram which I've now good at mostly a race we want to add something called a convolutional layer so in this video I want to explain what are the elements there are units nodes neurons so to speak in a convolutional layer but what are they and one of the word that's typically used is actually called a filter which makes a lot of sense now convolutional neural networks can be applied to lots of scenarios besides images and there's a lot of research into different ways that they can be used effectively but I'm gonna stick with the context of working with images because the word filter really fits with that we're filtering an image how is this layer filtering an image so the idea of a convolutional layer is not a new concept and it predates this era that were in now a so called deep learning and if you want to go back and look at the origins of convolutional neural networks you can find them in this paper called gradient based learning applied to document recognition from 1998 section to convolutional neural networks for isolated character recognition and here we can see this diagram which is I'm attempting to kind of talk through and create my own version of over here on the whiteboard itself this is also the original paper associated with the EM mist dataset a dataset of handwritten digits that's been choose umpteen amounts of times in research papers over the years related to machine learning I know I'm going back and forth a lot here but let's go back to thinking of the input as a two dimensional image itself so this two dimensional image and let's not say it's ten by ten let's use what the M Ness data set is which is a 28 by 28 pixel image and of course now much higher resolution images are used and this is what is coming in to the first convolutional layer this image is being sent to every single one of these filters a filter is a matrix of numbers and let's just for example let's have a three by three matrix each one of these filters represents nine numbers a matrix that's three by three you could have a five by five filter or and so on and so forth but is sort of standard size or a nice example size for us to start with is three by three each one of these filters is then applied to the image through a con evolution --all process this by the way is not a concept exclusive to machine learning this idea of a convolutional filter to an image has been part of image processing in computer science and computer vision algorithms for a very long time to demonstrate this let me actually open up I can't believe I'm gonna do this but I'm gonna open up Photoshop so here I have in Photoshop and I've opened this image of a kitten and there's a menu option called filter this word is not filter by accident there's a connection so all of these types of operations that you might do for example like blur an image these are filters convolutions applied to the image i'm gonna go down here under other and select custom all of a sudden you're going to see here i have this matrix of numbers this matrix of numbers in photoshop is exactly the same thing as this matrix of numbers I'm drawing right here each one of these filters in the convolutional layer represents a matrix of numbers that will be applied to the image so let me actually just put some numbers in here this particular set of numbers happens to be a filter for finding edges in an image and you can think of it as these are all weights for a given pixel so for any given pixel I want to subtract colors that are to the left of it and emphasize colors that are at that pixel and above and below this draws out areas of the image where the neighboring pixels are very very different interestingly enough I could switch these to 0 switching the filter to have the negative numbers on the top you can see now I'm still detecting edges but I'm detecting horizontal edges if you go back and look at the cat that I had previously versus this one you can see vertical edges versus horizontal edges so there are known filters which draw out certain features of an image and that's exactly what each one of these filters does if all of the nodes of a neural network can draw out and highlight different aspects of an image those can be weighted to indicate and classify the image in certain ways the big difference between a convolutional layer in a neural network and what I'm doing here by hard coding in four known filters is that the neural network is not going to have filters hard-coded into them it's going to learn filters that do a good job of identifying features in an image this relates to the idea of weights I think so if I if I go back to my previous diagram where every single input is connected to each hidden neuron with a weight now the input image is connected to every single one of these filters in a way there are now nine weights for every single one instead of learning a single weight it's going to learn a set of weights for an area of pixels to identify a feature in the image all of these filters will start with random values and then the same gradient descent process the error back propagated through the network adjusting all the dials adjusting all the weights in these matrices and all these filters works in the same way so in the ml five series I haven't really gone through and looked at the gradient descent learning algorithm to adjust all the weights in detail I do have another set of videos that do that if you're interested but the same gradient descent algorithm that is applied to these weights is applied to all of the different values in each of one of these filters incidentally just to show a very common convolution operation to blur an image blurring an image is taking the average of a given pixel and all of its neighbors so here you can see if I give the same weight to a 5x5 matrix of pixels around a center pixel and then divide that scale is divided by 25 because there's 25 that's averaging all the colors if I click on preview blurred not blurred blurred not blurred of course there are other more sophisticated convolutions like a Gaussian blur you can take a look at Gaussian blur and some ways to pronounce it you could take a look and research what that is but again I'm not going down the road to look at common image processing convolutions instead talking about that except of a convolution as applied to an image in the process of a convolutional neural network just to take this a little bit further I'm going to demonstrate how to code the convolution algorithm in p5.js in truth ml5 and tensorflow GS are going to handle all of the convolution operations for us and creating all the filters we're just going to configure a convolutional layer from a high level but I think it's interesting to look at how you might code an image processing algorithm in p5 I have some videos that do things like this previously but let's look at it in this context so I took a very low resolution 28 by 28 image of a cat this comes from the quick-draw data set which I've made videos about before and I will also use to see if we can create a doodle classifier as part of this series and all I want to do is apply a convolution to that image so first I'm going to create a variable and I'm going to call it filter so this is going to be our filter and I'm going to make it a two-dimensional array so let me just put all zeros in it to start so this is the filter and let's go with that one that looks for edges the cat image is actually quite low resolution just 28 by 28 pixels but I'm drawing it at twice the size I want to write the code to apply this filter to the image and draw the filtered image to the right I'm going to create a variable called dim for dimensions and just call this 28 and then I want another variable to store the filtered image and in setup I can create that image this creates a blank image of the same dimensions as the original cat drawing then I can write a loop and this loop is going to look at every single pixel from for all the columns X and all of the rows why I wrote int there because I am half the time programming in Java but one thing that's important here if we're going to take this 3 by 3 matrix and apply it to every single pixel of the original image if we're applying it to that first pixel 0 0 there's no pixel to the left and no pixel above it it doesn't have all of its neighbors so there's various ways around this I'm just gonna ignore all the edge pixels so the loop will go from 1 to dimensions minus 1 now there's a lot more work to be done here just to apply this filter to any given pixel I think a way that might make sense to do this is to actually have a new function I would call the function filter let's just call it convolution I'm gonna write a function called convolution it receives an image an X and a Y and a filter and it returns a RG it returns a new color so the idea of this function is that it receives all the things that needs it receives the original image the filter to apply to it which particular pixel we want to process and then we'll return back the new RGB value after that after that pixel is processed and the reason why I'm doing that in a separate function is I need another nested loop to go over the filter so I need to go from I need to go from 0 to 3 0 1 2 columns in the filter 0 1 2 rows in the filter and it would beginning to be quite a lot had 4 nested loops right in here now I probably shouldn't have some of this hard-coded in here the number 3 and that sort of thing but you can imagine how you might need to variables if the filter size is flexible now we have it really sort of like sad fact which is true about most cases where you're doing image processing with some framework and in this case our framework is JavaScript in canvas and p5.js and the sad fact is though even though all of this is built up all this discussion is built upon the fact that we are retaining the spatial orientation of the pixels we're thinking of it as a two-dimensional matrix of numbers the actual data is stored in one array and so I've gone over this in probably countless videos but there's a simple formula to look at if I have a given XY position in a two dimensional matrix how do I find the one dimensional look up into that matrix assuming that the pixels were counted wrote by rows zero one two three four five six seven eight next row you know twenty eight twenty nine twenty thirty one and that formula is let index well I need to do that before this nested loop because I'm looking at that right now I just want the center pixel that XY let index equal X plus y times image dot with so this is the format you getting about it makes sense right because it's all the X's and then the offset along the Y's is how many rows times the width of the image but there's another problem which is that in JavaScript in canvas for every single pixel in this image there are actually four numbers being stored an R a G a B and an alpha the red green and blue channels and the alpha channels channel singular so each pixel takes up four spots so this index actually needs to say times four so guess what you know it's going to make a lot of sense I'm gonna need this operation a lot let's write a function for it index I'll just call it index and it receives an X Y and a width and it returns you know what the width is never gonna change in my sketch so I don't want to be so crazy as to have to pass it around everywhere so let's just going to pull it from a global variable return X plus y times image dot with and that's not image it's cat dot with okay so once again this is terrible what I'm doing but I'm just saving myself a little bit of heartache here and there so this index ooh mmm let's call this this pixel it okay this should be x for this pixel is that function index XY now I have something I could do to simplify this but I might as well write the code for if this were a full RGB image this is a grayscale image but it has all the channels in it the thing that I need to do to perform this convolution operation is to take all of the weights the numbers that are in the filter matrix and I need to multiply each one times the pixel value of all of the neighbors and their corresponding locations add them all up together and maybe divide by something if I'm if I want to sort of like average it out but in this case I actually don't want to divide by anything I'm just gonna leave the weights or the weights or the weights are their weights and actually this right here is irrelevant I don't know I need to do this inside the loop you'll see in a second I think it's gonna make sense so I need some I'm gonna make a sum of all the our values a sum of all the green values and a sum of all the blue values all right wait a sec wait a sec wait a sec let's actually I think this is gonna be make more sets look go from negative 1 to 2 you'll see why I mean I'll explain why and negative 1 to 2 let's do that instead and maybe it's more clear to say less than or equal to 1 less than or equal to 1 because and let me draw this diagram once again if this is pixel 0 0 this is pixel negative 1 negative 1 this is 1 comma 1 this is 1 comma 0 this is a 1 comma negative 1 I guess I'll do them all [Music] so you can see that the neighboring pixels are offset by negative one and one and negative one and one so the pixel X value is X plus I the pixel Y value is y plus J and then the pixel index is call the index function X which returns the actual index into that array for pixel X and pixel Y and actually maybe it makes more sense for me to just say that I don't necessarily need separate variables it might actually be just as clear just to put this right in here so now I just need to add the red green and blue values of this particular pixel to the sum so some are plus equal image dot pixels at that pixel index and then G and B G is the next one and B blue is the next one and let's add a plus zero here just to be consistent so ultimately what I'm actually returning here is our is some our G is some B and B is some good some of us our G is some g and b SMB so this is the process now of adding up all the pixels I've gone through every single pixel in a 3x3 neighboring area and added up all the reds greens and blues and returning those back but I'm missing the crucial component which is as I'm adding all the pixels up in that area I need to multiply each one by the value in the filter itself incidentally I should also mention that this what I'm the operation that this really is is the dot product and in an actual machine learning system all this would be done with matrix math but I'm doing it sort of like longhand just to sort of see the process and look at it what should I call this in the filter like the factor now I need to look up in the filter I comma I J only here's the thing because I decide to go from negative 1 to 1 negative 1 to 1 the filter doesn't have those index values it goes 0 1 2 0 1 2 so this has to be I plus 1 J plus 1 so it's all six of one half-dozen to the other whether I go from zero to two there and do the offset in the pixels but the point is the pixel array I'm looking actually to the negative and positive to the left and right but the filter is just a three by three array starting with zero zero in the top left so now I should be able to x factor and there we go I have the full convolution operation now I might've made a mistake here I think this is right when I run it we'll find out if I made a mistake I'm take I'm I'm summing up a 3 by 3 neighborhood of pixels all multiplied by weights that are in a 3 by 3 filter oh but I actually have to call that function here now which should be relatively easy because all the work was in there so if I say let I'm just gonna call this RGB equal convolution the cap at the giving X&Y with the filter then the new image which is called filter oh ho I have to look up it's okay no problem the pixel is index XY and then filter and so I have to look up the one-dimensional location in the new image and then at dot pixels at that pixel is the RGB the red value that came back plus 0 plus 1 plus 2 green and blue and then if all goes according to plan I should be able to draw the filtered image at offset to the right with the same size I did miss something kind of important which is that if I am working with pixels of an image in p5 I need to call load pixels so cap dot load pixels filter load pix and thence I haven't changed the pixels of the original cat image but since I changed the pixels of the filtered image after it's only just called update pixels and now is the moment of truth never never good when I pressed the snare drum button to run the sketch whoops all right well I've already got an error cannot read properly load pixels Oh filter filter filtered that should be filtered also this isn't right create canvas the size of the canvas is times 10 times 2 times 10 remember the image is just 28 by 28 let's try this again well a little bit better didn't get any errors I'll see it image do I need to give it a hard-coded transparency of 255 yes oops so uh it was fully transparent so I'm not pulling the transparency over I could pull it over but I just know I don't want to be transferred look at that look at how it found the oh oh look at this that doesn't look like it's finding the vertical edges pixels that are different to the left it looks like it's finding horizontal edges even though I've typed this out in a way that visually these negative ones appear in a column it's actually those correspond not to the J index but to the eye index so I think one way to fix that would just be to swap it here and and maybe I just like a more elegant way of doing this but this now if I run it this way you'll see ah look at those horizontal edges so now we see how this convolution is applied to the image the difference in the neural network here the convolutional neural network is we're not hard coding in specific filters that we know highlight things in an image the neural network is going to learn what values for the filters highlight important aspects of the image to help the machine learning tasks at hand such as classification so it might draw out you know cats tend to have you know years that appear at a certain way and this kind of filter like brings that out and then leads to the final way final layer of the network activating with a high value for that particular classification so just to keep my example simulating the neural network process a bit more let's just every time I run it give it a random filter because that's what the layer would begin with just like a neural network begins with random weights and learn to the right weights the filters begin with random values and it learns optimal values so right here in setup I'll write a nested loop and give it a random value between negative and one in truth there are other mechanisms and strategies for starting for the initial weights of a convolutional neural network but picking random numbers will work for for us right now just to see so every time I run it you can see we get a different result image that is filtering the image in a different way okay that was a lot and I think it would be good to take a break so this was my I think that's the the first part of my explanation of a long-winded attempt to answer the question what is a convolutional neural network so the first thing to look at is the convolutional layer that's where it's made up of filters and so this video timid to explain that and I think we could take a break have a cup of team talk to your pet or friend or plant or something better take relax and then then if you want to do you want you could come back and in the next video I'm gonna look at the next piece the next component of the convolutional layer the pool of the an operation called pooling or more specifically max pooling and then I'll be able to tie a little ribbon and put a little bow on this explanation about convolutional neural networks and move towards actually implementing one with the ml 5 built-in functionality alright so uh maybe I'll see you in the future and have a great rest of your day good bye [Music] you 