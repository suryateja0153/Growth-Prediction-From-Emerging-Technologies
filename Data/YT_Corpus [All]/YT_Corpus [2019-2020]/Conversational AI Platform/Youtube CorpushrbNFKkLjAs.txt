  [MUSIC PLAYING] Hello, and welcome to our breakout session at TechEd 2020. My name is Thomas Miller, and I'm a product owner at SAP Conversational AI. I'm joined today by my colleague, Akshay Thakare, who's a development expert in our team in Bangalore. Hey, Akshay. Are you all set for the demo? All set Thomas. We have a great set of demos lined up for today and I'm super excited to share it with our audience. How about you? Yeah, same on my side, Akshay. And I'm quite sure our audience will feel the same way after seeing the demos. You bet it. I'll go fire up the demo engines. I'll see you in a second. Great. So while Akshay is firing up the engine, I will briefly tell you what demos that we have lined up for you. So firstly, I will walk you through our platform, and then hand over to Akshay for his first demo, where he will show you how to use remote entity enrichment fetching. And then in his second demo, move on to show you how to consume and validate data from your pulse memory. And then, finally, for the last demo, I will take over again and I will show you how to use dynamic scripting to use verbal scripting to create dynamic messages. As you can see, we have an agenda, which is really packed of demos that will show you how our low-code features can improve your bot developer experience. So let's get directly started, and I will quickly walk you through our platform. To get started, and to set the stage for upcoming demos, I will briefly introduce you to our stock management bot, and at the same time, use this opportunity to walk you through our platform. The first tab you see here is the Train tab. In the Train tab, you can maintain intents and entities. Intents are sets of expressions that represent something an end user would say, for example, for a greeting or a goodbye. Entities, on the other hand, are key words that you would find in the expressions. So for example, we have some gold entities that are detected automatically by the platform that can represent, for example, a distance, an email address, or a location. And of course, you can define your own custom entities. This bot doesn't have one yet, but in the next demo, Akshay will create the first custom entity of this bot. The next tab we take a look at is the Build tab. The Build tab allows you to define your own skills. So there's, for example, a skill here, a fallback skill that is triggered whenever there is no other skill that can be executed. And we also have here as a predefined skill, the greetings skill. Let's quickly take a look. Inside the greetings skill, you'll see some Read Me documentation for the skill. Apart from this, we have triggers. Triggers are conditions that are evaluated to see if a skill is to be triggered or not. So, for example, in this case, we have the trigger conditions if the greetings intent is present are if the goodbye intent is present. Furthermore, there are requirements. Requirements define entities that must be present for a skill to be able to execute. In this case, for the greetings, we do not have any requirements. But also, you will see in the upcoming demo that we will define a requirement for the skill, for our newly created skill, and that we even will validate this requirement. And finally, we have the actions. Actions are then to be executed once the skill is going into the execution. So in this case, for the greetings, we would have, for example, a text message saying hello. But you can also choose other types of UI elements, like a button, a carousel, a list. Furthermore, in actions, you can use an action to connect an external service. For example, to call an API endpoint. Furthermore, also you can define the fallback channel where you can forward the conversation to a human agent. And you can finally also define some updates to a conversation, like go to another skill or manipulation of the memory. The next tab we take a look at is the Connect. The Connect tab allows you to connect your bot to an external channel. The channel that we will use in this table is the Web Client, which is integrated into the Fiori Launchpad. I already pre-defined it to save a bit of time. You can also use other external channels, like MS Teams, for example, or Slack. And finally, the Monitor tab. In the Monitor tab, you can monitor what's going on on your bot. For example, you can check utterances that are coming in, look at some statistics, you can even analyze the training of your bot and enhance it. And you also have capabilities to look at conversations that happened in the past. So now to wrap this up, let's briefly jump to our Fiori Launchpad and see this integration at work. So what we see here is now is SAP Conversation AI. Here, we can open the Web Client. And this is the channel that we defined for our demo. Let's open it. And since our bot is only capable of greeting so far, let's try this. Hello. And we have our bot responding to this. And with this, I will now hand over to Akshay to start his demo, showing you how to create a custom entity. Thank you, Thomas. I'm super excited to show our audience our newest feature, remote entity enrichment. In a nutshell, this feature enables you to fetch metadata for the detected entity via rest APIs, and use this information to construct replies with zero code. So without further ado, let us jump into the first demo and see how to set up remote entity enrichments. We have our FLP window open. And you can see a list of products, which are available in our S/4 system. Let me click on one of the products, say, centrifugal pump. And we see more information about it, example, its measurements, who created this entry, and the plant where it was manufactured. Our goal is to bring this information directly into a CAI chatbot's memory using remote entity enrichments. To do this, let us navigate to the bot which Thomas had created. Now, under the Train tab under Intents, let us create a new intent. Let's call this intent, query-materials. OK. And let's create this. Now, under query materials, let us add a few expressions-- show me centrifugal pump. Another one could be, show me ball bearings. OK. Now that we have two expressions to begin with. As we have seen the FLP window, one of the products was centrifugal pump. So let us tag this as an entity product. So centrifugal pump has been tagged. Now let us start ball bearings, as well as a product too. OK, that has been done. Now let us navigate back to the Train tab. Let us go to Entities. Let us select the entity we want to enrich, in this case, it's product. Let us click on Enrichments. And here we see the option for remote enrichment. Select this option. And let us click on Validate. Now, for this demo, we have set up a cloud platform destination, which is connected to our S/4 HANA system using SAP Cloud Connector. Let us see how we use destination and enrich our entities. To do this, let us go to the API Service Configuration. Over here, let us change the HTTP verb from POST to GET, and let us enter the destination and the part to where it would service. So as you can see here, I've selected-- I've typed in destination call forward slash, S/4 HANA SSO which is the destination name, and then the part to our oData service. One thing to note here is that I've kept the default authentication type. That is no authentication. This is because we are using a cloud platform destination, and the authentication details are set in cloud platform itself. Now we'll test if this works. Just click on the Response Customization tab. Over here, under Test your API service using mock data, we see two fields-- the value and language. The value is a query parameter that we can pass to our backend service. And in this case, it is the material name. Now, we must note that during runtime, the value being placed here is the raw value of the entity detected in a user utterance. So we'll set the value as centrifugal pump. And let us use the language as the default language, English. Now let us click on Test. As we can see, we get a API service response from our backend in which we have the metadata, we have plant name, material name, batch, et cetera. But this is a lot of data to process. Let us drill down to the most crucial information about the material, see the name of the manufacturing plant. To do this, let us go to step two. Customize the response to only keep the data you need. The box on the left is where you can enter your filter query, and the box on the right shows you the filtered results. So right now, we have filter from API service response body. And now let us drill down further. Let's go to d dot results dot-- let us take the first element of the array And to see the results, let's click on Transform. As you can see now, we have the metadata information and the root level of a result. We get the material, the plant, the batch, and other information. Now, by clicking the save button, we can conclude that we have successfully enriched our product entity. Next, we'll look at how to consume the API responses for remote entity enrichments using bots memory. Let us jump right into the demo and see it working. Let us go to the Build tab and create a new skill, show products. Now let us add a trigger for the skill. Let's go to triggers. Let's see. I would like query material to be present. And in addition to that, I would like my entity product to be protected. This OR condition needs to be changed to an AND. And now let us go to the requirements section. We would like the product entity to be present. Let us name it as product in memory. Now, let us add a validator for our requirement. Our validator is used to handle errors, like say our identity was detected, but could not be enriched. So to handle this, we would like to show an error message to our users. Let us see for our centrifugal pump. We would always like information about its plant name. So let us add that condition over here. Let us see the plant name. If it is absent, then we would like to send back a reply to our user. Let's click on Send Message. Let's send back a text message and put in the message that we want to send back. In this case, I would like to send back, could not find product, the raw value of the entity which was detected, is there any other product you would like me to look for? And let's click on Save. Let's click outside and let's go to the Action tabs. And add a message, which is to be sent back to the user once all the requirements are fulfilled. So let us add a condition to trigger them as, say, query materials. In that case, this is optional since we already had added it to the trigger. Let us send back a text message. Let us add this. I would like my first line to be bold, so let me enable markdown. And let me make the first line bold. Let me click on Save. So here we are accessing the memory and the product enrichment, or the product material. And from that, we are printing out the material name, the plant where it was manufactured, and the material type, or its category. One thing to watch over here is to reset the conversation memory, as for all the subsequent user utterances, these same results would be shown. Now, to test this, let us quickly go to the FLP window and let us search for a product that I always wanted, show me a Porsche 911 Turbo. Oh, no. The 911 couldn't be found. Let us search for something more reasonable like centrifugal pump. And there we have it. We have information about the centrifugal pump, like where it was manufactured and which category it belongs to. Next, Thomas will show you how to supercharge your port. Over to you, Thomas. Thank you, Akshay. And for our final demo, we will combine the features of custom messages with variable scripting. This will allow us to use logical expressions and functions applying the handle bar template language to create dynamic messages. To do so, we have to create a new skill. Let's name it, list-products. And then inside the skill, we define a trigger, which in this case, should be again that the intent, query-material, is present, but at the same time, we want to exclude a product. So this means if the intent is detected, but no product, then we would use an API service request to query a list of, like in this case, the top five products to be retrieved from the oData service. Authentication is not required in this case, since we're using single sign-on. As message type I choose custom, custom allows me to pick a template of any predefined message type and then manually modify it either way I like. And this is the special strength of this, I can now apply handlebar helpers to dynamically influence the content. So in this case, what I will do, I will take a helper called eachJoin which will iterate over a list. And the list that I want to iterate over is the API service response from our oData call above. So now I only have to specify where to find the result list in the oData response. And then I can iterate over it. And I just have now to define as well where this iteration ends by closing each join. And I'm done with this. And inside, I can reference now the objects that I'm iterating over directly. So what I can do now here is I can specify MaterialName which is an attribute of the result. And this will be the title. As the subtitle, we will just use the MaterialTypeName Image does not exist, so we can just remove it from this list. And now, let's do something really cool. We will now add a button to this card element. And this button will now show details. And this can be done by using a postback and providing in here as value an utterance that will then help us display exactly this material. And this can be achieved now by just saying "show a MaterialName". Type is postback. So let's remove the rest here and we are already done. So let's go to our Fiori Launchpad and try it out. So here you can see again a blank screen, fresh conversation. And I would just say, show product. So I'm not specifying any specific product, in this case. And we see the list is coming up. And now let's pick the centrifugal pump, our favorite. I click Show Detail. And voila, centrifugal pump with all the details is displayed. Did we spark your interest in creating your own first chatbot? On this slide, you will find all the resources you need to get started, and also further resources to continue on your journey. And in case you want to reach out to us, SAP Conversational AI after TechEd, please feel free to get in touch with our solution owner, Sebastien, directly. And also make sure to check out our special offer on SAP Shop. And finally, if you want to continue your learning experience also after TechEd, please consider subscribing to the SAP Learning app. You will find all the information that you need here on the slides. And with this, we are coming to the end of our demo pack breakout session. Many thanks to you for your interest, and for attending the session. And also, many thanks to Akshay for the great demos. Stay safe and enjoy the rest of TechEd 2020. 