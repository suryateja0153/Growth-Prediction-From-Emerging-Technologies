 Okay! So, let's get started! Let's assume that you are a simulation modeler and you work for Amazon and Jeff Bezos calls you personally because they're gonna build a new warehouse and says Ben I'll give you all the information. Where the conveyors are gonna be, we've got it all planned out, but we need you to verify that it's a good design. Can you please build a digital twin for me, he says. Jeff! No problem! I've got AnyLogic and I know how to use the Material Handling Library so I've built you a digital twin. And you go off and do that. You drag and drop things over. You put everything into place. You do your verification validation of the model. Everything works fine. Everybody is happy the model is a great representation of reality. And, then it's March 2020 and the COVID-19 pandemic hits the globe and Amazon has a lot more work load to do than usual. Jeff Bezos calls you again, he says: Ben, we're gonna extend that warehouse, we're gonna double its size, everything is going to be shuffled around, we've got a new layout, the experts have it all worked out. You built that digital twin, right? Can you just put in the new data and let us know how it's going to perform. And, it is then that you realize that ...mmm. Maybe I didn't build quite the digital twin. More like a static digital twin. Because you would have to go back into the model and re-wire everything, rearrange everything, redraw everything from scratch. But, Jeff Bezos expects results tomorrow! So, what to do? But, before we get started let me briefly introduce myself. So, my name is Ben and I have over 10 years experience in AnyLogic and simulation modeling. I started using AnyLogic in my PhD and for over eight years now I'm working as a industry consultant. So, I created models for manufacturing, healthcare, there was space defense, even a goldmine in the Andes Mountains. So, lots of different things which is a lot of fun. A couple of years ago I joined McKinsey to bring simulation modeling to management consulting because I thought that's that's a loophole, nobody is using it there, or very rarely. So, that was a lot of fun as well. And, two years ago I created my own company and I'm now serving the same types of clients. Building simulation models day-in day-out, which is a lot of fun. Recently though I also started doing something a little different with a partner, Goldratt Research Labs. We developed a library for AnyLogic which you can download now and it helps you create amazing user interfaces for your AnyLogic models. So, very easily, with drag-and-drop, simply you can create models that look like modern apps. You have animations, things floating in and out... So, that was a lot of fun as well but, let's get back to where we are supposed to be, which is not material design. But, we'll talk about the Material Handling Library. The library that you get with AnyLogic. Okay let's get back to our example where Jeff Bezos is calling you and basically saying I need results tomorrow for the new warehouse. Wouldn't it be nice to simply take the data of the new layout and where everything is and how it works together and let the model self configure itself instead of you dragging and dropping it would just be a click of a button! So, this is what this webinar is about. Typically you work with what I call a snapshot of reality, you have a static set of information of where the things in your system are and how they interact and you kind of hard-code that into a model with drag and drop and manual setup. Then you add some live data or flexible data, like how many packets are coming through, what the failure rates are, things like that. Typically you do that and you get something that I would call an aesthetic digital twin. So, in this webinar we want to learn how to create a true digital twin one, step further, where the setup information is live data as well: where the machines are, how it all interacts. And you use that to create a model automatically, self-configuring from the data. Then you feed in your live process data as usual and you have that dynamic twin and you can rerun that as often as you want with a new configuration set up - just load the new data. A machine has broken down, just change the data; a new machine is arriving into your facility, just change the data. That's what this is about. Okay before we discuss what we're gonna do in this webinar let me briefly state that we're gonna use the Material Handling Library of AnyLogic but the principles you're about to learn you can apply to any other model using any other library. So, no matter if you build a pedestrian model, or just a normal process model, an agent-based model, it doesn't matter. The reason why we chose the Material Handling Library is it's probably a little harder to apply to than the others. A couple of smaller caveats that you need to be aware of. So, that's why we chose to use this library. If you master this one, you'll master the other ones easily. So, let's have a look at what we're planning to do. We're gonna build a model that's completely data-driven and it will include a couple of machines here. So, we'll have machines processing packets and these packets will be transported between machines using either conveyors or little forklifts. And, we're gonna split this up into three chapters or three sections. First, we will create our machines and products programmatically. So, we'll have machine agents, put them into a spatial relationship and make them produce products. In Chapter two, we're gonna add the conveyors programmatically, again from data. These will self configure to be set up between those machines. And then in Chapter three, we will add those transporter forklifts that can navigate in free space. So, what we'll not do is drag and drop conveyors manually [or] drag and drop transporters manually. We'll do it using a data-driven approach, or self-configuring approach. Okay, so we're almost getting started now, just one final note on some prerequisites. So this webinar is gonna be a little bit more advanced. It's not for the absolute beginner of AnyLogic. So, I do expect you to understand simple Java coding, syntax. It would be good if you understand object-oriented principles to a little degree and also that you just know AnyLogic a little better than just having started yesterday. If that's the case there are lots of other learning materials out there to get you started and also just feel free afterwards to reach out to me with any questions that you have. Also, in this final model that I'm showing you here, you see actually, I'm using a special UI from that library I mentioned earlier. In our... in the model that we're gonna build together, we'll just use standard AnyLogic components. So, it will be completely copyable by you. And then, last but not least, in the model itself, I'm using my own little naming convention. Don't get confused by it. I think it's very appropriate to use it. It's very simple that variables have a V underscore in their name, functions start with F underscore, stuff like that. So, don't get confused. Good! So, time to get started. Let's start with chapter 1 where we will create 3 machines, and products that need to be produced at those machines, programmatically from data. Ok, let's find out what we're gonna achieve in this chapter. We're going to build a model where we have three machines that live in two-dimensional space but we'll animate them in 3d as well. And what we have is that we'll create product agents in a source object, they will find their first machine, they will have a work plan, they will find their first machine, they will move to individual machines like this one, queue, do some machining, and then either move on to the next machine or just completely exit and finish. Each machine processes these products. And all this will be driven by a database file. So, let's start from scratch. I have a new model open, create a new model, and then create a new database. The database that we create we'll have five columns: just a unique ID and name, position values and then just another column for the cycle time. So, let's fill it with three machines at specific positions and let's just give them some cycle times. It's just important to note that for our purposes will keep the database tables fairly simple but obviously you can extend those principles and make this self-configuring model as complex as you like, make those machines as complex as you like. All data driven, we just define the name and position now. Alright, so the next step for us is to create machine agents from this input data. Normally, in AnyLogic, you do that directly via populations, but in our case we'll keep the control and we'll do it manually. So, for now, create an empty agent machine and then populate it with a 3D shape, a 3D animation shape, and parameters that match our database table. So, I used a pasting machine here. I added my parameters that match my columns and then on main, you simply create an empty population of that agent type. So, I call my populations pop machines, I make sure they're empty, and now we're gonna create our machines manually using a little bit of Java code. The reason for that is, normally, you can say load it from database and then map your parameters from the database, which is all nice and well, but we need to keep full control over our machine agents. i.e. in which network space and in which layer, level, they're gonna live. And, we'll get to that later, but, for now, let's just create them manually. Okay, so I've created a little function: f_CreateMachines which goes into the database, loops through every entry, and creates our custom machine agent, puts it into that population, and then, crucially, I also change the position based on the database. Notice also that I've created another function: f_InitializedModel and we'll use that for various steps later on. For now, all this is doing is calling our f_CreateMachines function and, in order to actually create the machines on startup of Main, let's initialize our model for now. And, let's see what happens. So, if you run the model now you see three machines have created being created, we have the little animations at the positions, and if you go into the individual machines, you see the parameters being filled. So far so good. The next thing to do is to create a Product Agent Type. A simple normal agent type. The only thing you need to make sure is, in the properties, to say in a flowchart this should be a material item because we're using the material library. That will basically turn on lots of characteristics that our products will need. So, once you have that, make sure to create another population on Main where we're gonna track our all our products, and that will also be initially empty, and then in the product itself we're going to add a couple of things: a little animation, like a box, and then, more crucially, we're gonna have a little collection of machined agents. These are the machines that we want or still need to do as a parcel, as a product, and it's a linked list. So, that means it's like a to-do list of machines to do. We're gonna add a little v_CurrentMachine, that is the machine I'm currently at, just to keep track of it, and then MachinesDone, another linked list to track all the machines that the puzzle has done already. More importantly, we're gonna add a little function f_CreateWorkplan. This one, very simply: we're gonna create our work plan of machines. So, we're gonna say I want to visit between 2 and 10 machines and then for each one of them we're basically adding a random machine from the list of our machines, from our population of machines. So, we're gonna fill, at the start of the model, we're going to fill our machine collection with our work plan. Now, if you would start the model now, nothing would happen. We still need to create some products and we do that using the simple Process Library where we're gonna use a source object and create products. So, let's create a source object, createProducts, with a random rate. We will create them. Make sure that your new agents are product agents. You can just keep the dimensions for now and then we also gonna add them to this custom population. Then we have an exit block where we say when product agent arrive here, let's find the next machine. What we're going to do is we're going to take the machine from the products machine to-do list. So, basically where do I need to go next. And, then we're gonna send that parcel there and we're gonna see how that works in a second. But, before that let's also allow products to finish their lifecycle. When they have finished their final machine we have an enter block that takes them from the machine and then we just destroy our products in the sink. So, how can we link this then send our products to the next machine? We need to have some process in our next machine as well. So, let's do that next. So, in our Machine agent we'll have a simple enter block: arriveAtMachine which takes products. Nothing else happening here, we have a queue with maximum capacity where all the products will be queuing and then we have a simple delay which assembles or does something to our products at this machine using the cycle time. I keep that two seconds for now actually because otherwise it gets too busy. And, then we need to update the little tracker in our product. So, when a product enters we'll say I'm now at this machine and we will also at the same time remove this machine from the to-do list because you're already here, a little sanity check. It's always good practice. And, then, when we exit this delay block, we'll tick off the machine. So, we'll take our current machine and put it into the machines done list, that's all we're doing. And then, the next step is we'll check do I have another machine in my to-do list? If yes, I will go to that machine. So, very similar, I find my next machine, which is the first in that to-do list, and then I'll put myself into the arriveAtMachine enter block at that next machine. So, basically I'll pop up here again. If I don't have another machine, I just simply exit, go to main, and the fromFinalMachine, and I end up here, and be destroyed. So, if you run this model, it should also work seamlessly. So, still doesn't look like much but we can see products are being created roughly every second, they find ways to the machines, and then each individual machine is doing business and you can see things are either going one way or the other. So, hopefully, so far, this was smooth sailing, this is very standard setup, very standard stuff. Now we're going to start actually creating some spatial layout programmatically and we're gonna start with our little machine because we gonna have to want a little arrival Bay, a little departure Bay, a couple of other spatial points around this machine, and we're gonna want them to be created programmatically so we can actually use them later on. So, let's get started! First of all, unrelated to that, I'm gonna add a little rectangle here in the background where if the user clicks on it he's basically taken directly into this machine and we'll also display the name of this machine using our parameter. Okay, as the next step, I've now added some spatial objects, I've added a rectangular node, a couple of point nodes around my machine. So, we're gonna have a viewing area, a leaving area, a machining area, where the actual machining is taking place, and then for later on we also add some points for the conveyor end and start points but that's gonna be in the next chapter. However, if you are careful, you might have noticed I named those things node_QueuingFAKE and also all those elements are invisible. If you run the model, you're not gonna see them, they're not gonna be part of the model. I'm now starting to do some tricks and this is one of them. I don't... It's not actually possible for you to create some spatial objects using the drag-and-drop method, like we did now, and then, at the same time, some of them data-driven and combine them. That's not possible. As soon as you drag something in this is like a static network of spatial relations is created for you and it is finished by the time you start the model so you can't get into it anymore. So, upfront, you have to make a decision, do you want to do everything dynamic or everything static, and obviously we want to do everything dynamic but I've created those little guys as little fake... fake, how do you say, placeholders and you're gonna see why in a second because now we're going to start creating our spatial objects programmatically. Let's use a function and a good number of variables. So, I've created a function f_CreateSpaceMarkup and for every of our space markup guys over there, I've created a variable of type RectangularNode, for our leaving node of type PointNode, for machining nodes and these are now both visible and not fake. So these are going to be our actual spatial markup elements and we're gonna create them at the start of the model programmatically using this function where we will actually instantiate our node_Queuing in this example. A point nod... A RectangularNode, we're gonna instantiate it and then we're gonna set its position and size and line color characteristics using our fake equivalent. That's why I use those guys and this is like a little trick to make your life easier because some elements you don't actually need to do fully data-driven, they are static. These areas don't change for a machine so you might as well keep them here and be able to play around with them at design time but still be able to have full control over everything using this kind of code. Now, once we've created those markup elements the last thing is we need to add them to what's called a network and you might not be aware of it but normally when you drag in spatial elements, AnyLogic creates a network for you in the background automatically and adds those guys. That's what I said earlier, this is already done and finished once you start your simulation model. For us, we need to do this manually manually and we're going to do it on main which is where we're gonna have our network. So, I created a variable of type network which is going to be the network that we will be using, that we have full control over and I also created a new function f_CreateNetwork which basically just instantiates our network inside that variable and what we need to do in our initialize model is we need to call this first. We'll create our network then we'll create our machines. Now, the next step is, once we've created our machines, we actually want to create that spatial markup for every machine, so I've created another function f_CreateMachineSpaceMarkups where I simply loop across every machine and call our new f_CreateSpaceMarkup function for each machine. And, this machine's space markup, obviously, I need to do after I've created our machines. So the order of things here is going to be very important. First, we'll create our network, then we create our machine agents, then we create the spatial markup in each machine, and the last thing we need to do is to initialize the level because that's one of the things that AnyLogic added recently. You can have levels above each other. And, again by default every spatial element that you drag in is added to the to the AnyLogic ground level but again we want to have... we need to have full control over everything now so we need to create our own level as well and add things to them. So, very similar let's create another variable of type level and have another function f_InitializeLevel which instantiates a level. We are saying please show this in 2D and 3D and then, very crucially, add our network. The network that we've created previously. The network in which all our spatial things will live. Add that to the level and only then initialize the level and after that initialization, everything is basically frozen and you can't change it anymore so this needs to happen at the start of the model and we're gonna add it to the actual overall presentation of mains so it's actually going to be visible at the animation. So, in the f_InitializeLevel er... InitializeModel the last step we need to do is to initialize our level. And now, one step back, if we go into the machine, into our space markup creation function, once we've created all the elements the nodes and point nodes for each one, we're gonna have to add each of those to our network on main. We can use the add all function for that. So, once we've created the machine agent we then create the spatial mock-up for each machine agent we add it into this network and then as the last step we create a level, add the network into the level, and initialize. So, when you run the model now, you will actually see our little click thing but also you can see now these spatial markups and remember these are now the programmatic markups that you created, you can see v_Network and v_Level are filled. If you go into a machine, you can also see the markup, it's actually below the rectangle now but it's there. So, the last step that we now can do is actually link our process chart with our programmatic special markup. So, let's do that. And, this is now the nicest thing in the process chart, where you specify animation. You can always just say where should it be. For example, here we're saying agents should arrive in our queuing node and, very importantly, make sure that you now use your programmatic nodes, not the fake ones here, and also very often you need these little checks because at the very very start of the model these might still be null because they're not initialized. But, typically, that's not a problem, so you're basically saying if these things exist, if they have been initialized, please animate there. Same for the queue, you can just select an agent location for the queuing. In this case, no queuing and so on, you can do this for all those elements. And, once you've done that, as a last step, you need to also specify, or tell your products, once they're being created in that source, where do they actually belong to, to which level. So, on creation of product we're going to say set the level of that product to be part of our programmatic level on main. And, lo and behold, if you run the model now you'll see your parcels actually popping up in our programmatic spatial world. They'd be machined there instantaneously, hence they don't pop up, and then they jump directly to the next machine. So, at the moment everything is just visible in this little rectangle but it's working, it's alive, and we'll fill it up in the next phase much more. You can also add a 3D animation to see this in 3D space and we'll do that for the next phase as well. Okay, so that was quite a lot to take in as chapter 1 but there are lots of things that are going to repeat from now on and it's really important for you to just follow the the principles, understand the principles, of what's going on. Especially the networking and the level stuff, and initializing things. So, let's have a look at the next chapter. Chapter 2 is going to be exciting because we're going to add the first material handling elements, really, the conveyors, and we're gonna make them connect between certain machines so packets can actually use them. Let's get started. Okay, welcome to to Phase two. In this phase let's have a look at what we want to achieve. As you can see, we will build conveyors in this phase, programatic conveyors which will take parcels from one machine move it to another machine. You can also see it in 3D and these conveyors will be custom agents defined by us. We'll have a conveyor population inside of which you have a little flowchart where conveying is happening using a custom created conveyor that is loaded form a database. So, let's get started! First of all, in the model that we have so far I just added a little 3D window and a little bit of view area navigation so we can more easily navigate around. As you can see, in the final model that I've just shown, you can obviously add as much UI around that as you want. So, the very first step for us in this phase is to actually create a database table again that we can load our conveyors from. So, it's a very simple table, just three columns, a unique ID column, and then I'm specifying for each conveyor that I want to create, from  which machine is it coming from and to which machine is it moving to. And I'm using the following key setup for that so I can easily with a drop-down select the machine ID from our DB machine table. So, each of those unique IDs now pops up here. So, I want to create two conveyors programmatically. One going for Machine 0 to machine 1 and one going for Machine 1 to machine 2. Not more for now. Alright, as a next step, let's create a new empty agent type MyConveyor. This will be the agent holding each individual conveyor and let's duplicate the database setup with the parameter setup so we have int ID parameter and then two parameters, p_MachineOrigin and p_MachineDestination of type Machine, actually, so we're gonna map this integer number to actual machines in a second and let's create another population on main, our popup conveyors. And, as before, let's keep make that a population of agents initially empty, let's not load any parameters yet, we'll do that manually. Alright, as you can see we're picking up speed now because lots of things are starting to duplicate. So, I create a new function f_CreateMyConveyors and, in it, I loop through my database table and for each row I now pull out all the individual data, the ID, and now I'm also pulling the machineOriginID and translate it into the actual machine from pop_Machines. It's just a little trick here and then finally when I have my actual origin machine, my actual destination machine, I actually create the MyConveyor agent and map those three parameters that we've created previously. Now, obviously, we need to call this function together with the other functions that we've created and it's very important again the order of initializing our model and calling these functions so before we initialize any level, which is always the final step, we create our conveyors, now. If you start our model, we have a lovely filled population of conveyors now. Conveyor agents each with those individual parameters filled and the Machine parameters are actual machines now. Alright, so, let's actually create a conveyor now. So, typically what you do is you drag a conveyor object in here and start drawing it and adjusting shapes. Normally you will do that on main, things would snap together, you will create a conveyor network. We cannot do that here, we wanted to have it data driven. So, we use the same trick as before, we create a variable inside my conveyor which is the actual conveyor path so this is this actual guy here but initially it's just going to be empty and on startup of that agent creation we will actually fill this with the function f_CreateConveyor which creates the actual conveyor and now we get into a little bit of Java here where first of all we create a new conveyor path, then we do all sorts of things to it, then it gets even more complex with something called markup segment lines but let's pick it apart. And, a really useful way to understand what's going on here is to actually use the AnyLogic help. If you open the help and search for conveyor, you will eventually come across an entry that has this AnyLogic 8 engine API addendum and that's always very useful for creating data-driven stuff. So, this API basically tells you what this object is and then how to construct it so if you don't know yet I strongly suggest you get used to this standard Java documentation and how to read it but here we can see how we can construct a conveyor path with just an empty constructor, in this case, and then we also have a list of all the methods that we can do with this conveyor. So, this is what we're doing with creating a new conveyor path and then we're setting all sorts of characteristics for it, which is nothing else as what you do when you drag in this guy and set the characteristics yourself like the width, the initial speed, stuff like that. So, in our case we say this conveyor should belong to this agent it should be an obstacle for free space navigation so later on our transporters don't crash into it, we set the width and speed what type of conveyor it is and so on. And then, as a last step, we also say, well, where should it be positioned in space. So, a normal conveyor can have lots of little sub segments if you double-click you can have all those sub segments that make up the entire conveyor. Programmatically, you can do the same. In our case, we're going to say: create a markup segment line that makes up our conveyor and it should only be one markup segment line. Again, if you go into the help, read up on markup segment lines, you can see how it is constructed. In this case, with six arguments that are, unfortunately, not well documented but what this means is the X position of the starting point, the Y position of the starting point, the Z position, and then the same three things for the end points. So, in our case we create a new markup segment line that starts where our origin machine conveyor starting node is. So, the X position of that machine. So, if we remember, inside machine we had those node viewing, node machining, and then also the conveyor start, conveyor end nodes which are these guys here. So, conveyors basically start for conveyor start here and end here, relative to individual machines. So, now we are saying dear conveyor please start at the origin machine and and at the destination machine. So, programmatically we now force conveyors to be between those two machines and then as a last step we basically say take all the segments that we've created in this array of segments and add it to our v_Conveyor. So, once we've created this function back in main where we create the myConveyor agents all we need to do is basically say for the conveyor agent we've just created please call that function. Now, if you start your model and navigate into an individual conveyor agent, they'll now see the v_Conveyor is is filled as active and is an actual conveyor. Not much more to see for now. Okay, so, similar to what we did before with our space markup, space markups when you combine them they automatically create a network. With conveyors, it's the same if you drag and drop several... conveyors and make them snap together AnyLogic not only creates the conveyors, actually, they... it creates a conveyor network as well and all conveyors must belong to a conveyor network. So, we do the same programmatically. So, let's create a new variable on main of type conveyor network, keep it empty for now, and then when we create our conveyor agents, once we've done all of that, we fill our v_ConveyorNetwork. So, we create a new conveyor network, say it should belong to this main, give it a name, and then we look through each of our conveyor agents we have previously created the v_Conveyor inside that my conveyor agents so now we're manually adding it to our conveyor network and then we just make sure that we add that to the presentation as well. That's to ensure that the conveyors are actually shown properly and then as one last step when we initialize the level. Remember, previously we added the network, the spatial network, to the level, now we do exactly the same thing with a conveyor network before initializing it. So, that makes sure that our spatial network is added, our conveyor networks are added, and then we have our custom level. Now, if you run your model now, actually you see the conveyors already. One between machine zero and machine one, one between machine one and machine two and they're also there in 3D but if you look, nothing is actually happening functionally, our parcels are still jumping between machines and I hope it's obvious why that is because in the conveyor agents themselves there's actually no flow chart that tells products what to do. So, let's build a simple flow chart for our conveyors where we say parcels enter through an end a block, arriving at the conveyor, then we queue them as usual as it could set up with a maximum capacity, make sure the enter block ...block you actually set that the agent type is a product and then now we use a conveyor block that's where the magic is happening the actual conveying is being done. So, in this setup now we can actually say with a drop-down list there's nothing to see, also with that selector box there's nothing to see but we can switch to the dynamic mode and say the source conveyor should be our conveyor, our v_Conveyor, and same as for the target conveyor. So, as soon as a product arrives in this convey block we say please take whatever conveyor we've defined here which we've defined here. So, obviously, you need to make sure that this function is called before the first product arrives at this conveyor otherwise it will throw an error but in our case that's always the case because we call that on startup of the model. Now, once we've done the actual conveying, obviously, you can make this more complex if you want to, we'll have a another check similar to what we had before, where the product should go next, if it has another machine, it should just then arrive at another machine, at its enter block, otherwise we just send it to the final machine block on main to be destroyed. Now, with this setup we still are not actually sending any products here, we need to do that in our machine process flowchart and we're going to change it slightly as you can see here. So, after we've done some machining, first we check if there was another machine as before and then we check is there actually a conveyor from this machine where the product just finished to the machine where the product wants to go. So, for that I'm basically calling another boolean function f_HasCorrectConveyor, give it this product, and in this function I'm now using a little, well it's not trick, I'm basically checking something. So, first of all I create an agent link on my machine, the connection to the conveyor, to the myConveyor, it's gonna be just a single link and I make it bi-directional. So, I'm saying in myConveyor, please create a similar connection, conn_MyMachine, and when you click OK, that will, I have already done that so in your machine that will create... So, sorry, in your machine this will create a similar connection myMachine. So, this is now in myConveyor it has created that element. So, now a conveyor has... knows about its machine that it's linked to and a machine knows about the conveyor that it's linked to and the default definition is that a machine is linked to its downstream conveyor. That's how we're gonna interpret that. So, now in our function do we have of the correct conveyor we are checking do I have a downstream conveyor being the machine then I find out for the product that's now coming is there a downstream machine and does that downstream machine also have this. So, I'm returning true here if there is a conveyor between this machine and the machine that the product wants to go to. So, if this returns true, we, basically, now send our product into the downstream type of conveyor. So, we go into this machine's conveyor and push the product into the arriveAtConveyor and this will make it move along the conveyor to the next machine of that product. So, once it arrives remember it just goes into its list and is then starting the machining at the next downstream machine. If there's no conveyor actually found, that might also be happen happening based on your data setup, we simply ask before just beam the product to the next machine. Now, as the last step, when we create the MyConveyor agent on main... while we do that, after we've created it, we also need to actually make the connection form the conveyor that we've created to the origin machine where the conv... where the conveyor originates from. Now, if you run your model now, you will see we have our conveyors moving, we have parcels moving along the conveyor from machine 0 to machine 1, from machine 1 to machine 2, but there are still also parcels going between the other possible paths and these are being built. So, you can also watch it in 3D, if you look into the machines, you will see some of them have found a conveyor, some of them do not find a conveyor, and if we look into the conveyor agent itself, you see the flow chart. You'll see what's being conveyed at the moment and where things are moving to next. Now, you can play a little bit more, if you want to you can animate other things in the MyConveyor, like the queue, and you could say that this should be animated at the actual origin machine. So, here, now, I'm basically saying if the conveyor is full, products have to queue ahead of it, where do I want to animate that, and, I'm saying well if you do have a machine, which should normally be the case, go into that machine and use the conveyor start node. So, just in front of where the conveyor starts, we just drop everything and animate it there. And, you can do that for the other blocks as well in a similar fashion. Ok, so, let's summarize: we've created a database table where we specified our conveyors - from where, to where they should be going. We have an empty population on main, we fill it with a function to create those conveyors, loop across the database table, add our MyConveyor agents, fill the parameters, and then, crucially, inside that MyConveyor agent we have the actual conveyor itself. We created, at the start of the creation of the agent, we set all the characteristics, we set the spatial objects, you could have more markup segments see if you wanted to, and then you just need to be careful on main that you create a conveyor network as well after you've created all the conveyors, add the actual conveyors to it, and then, as a very last step, add the conveyor network to the level that you're creating, ini... initialize that and you're good to go. And then, obviously, as before, use local flowcharts with enter and exit blocks. Okay, now, with chapter two we've added conveyors. Now, it's time to go into the last chapter to add free space transporters as well. So, whenever a packet cannot be picked up or transported by a conveyor, we'll now ask a transporter to do that for us. Again, data driven. Let's have a look! Okay, so, in this phase let's have a look first at what we want to achieve. This time, we're going to build some free space transporters, they're gonna have a home location and they're gonna pick up the parcels that cannot be transported by the conveyors that we've set up. So. they basically pick up everything else and move it to where it needs to go. Again, it's going to be data-driven, so we're going to have a database table that specifies them and then we're going to create them using code. So, let's get started! Alright, so, let's have a look. The thing that we're going to build eventually is going to be the transporter fleet element that specifies transporters and one thing that it needs for the transporters is a home location. So, let's create a home location programmatically first. And, we're going to use the same trick that we've used before where we're going to use a fake rectangle that's going to specify an actual rectangle. ... One thing in this chapter is we're gonna speed things up because some things are very similar to what we've done before, so don't get confused. So, I've created a transporter fake node, invisible, we're not going to use it, we only want its dimensions. We're also going to create a new empty variable node_Transporters it's going to be a RectangularNode. And, this is going to be using the coordinates of this guy. The way to do that is as previously, I created a new function f_CreateTransporters on node and here I actually fill my nodeTransporters with the position and size of this fake rectangle and then I add it to our network. So, now remember the network is... must be initialized before we finish with the level so now ordering again becomes important. In our main function, f_InitializeModel, we're going to call the f_CreateTransporterHomeNode before we initialize the level. So we're going to do that here. So, first we create our node add it to the network, inside that function, and then, as a last step, in f_InitializeLevel, we add the network to the level and initialize that. Alright! The next step, as before, a new database table, this time for transporters, similar setup as before. We're going to set up a fleet of transporters and each row is going to be one fleet. So, in this row we say we want three transporters as part of that fleet that are able to serve packets going from machine zero to machine two. In this fleet, we want two that serve machine zero exclusively if a parcel needs go for machine zero back to machine zero. So, it would be transported from from this node back to this node by a transporter and so on. You can make it as complex as you like. So, let's start creating agents. First, we're gonna create an agent called MyTransporterFleet and each instance of that agent will represent one row from our table and you can just leave that as a normal agent. We will not turn this into a transporter agent yet, we'll do that later. As before, let's create an empty population for this transporter fleet on main, pop_MyTransporterFleet, Let's make sure it's a population and initially empty. So, again, we'll use... we'll load it with data and then, in the agent type itself, make sure you have parameters that reflect the database table. As before, the machine parameters should be of type Machine. Let's add a new function to create transporter fleets And, as before, we will loop through the database table, adjust the parameters, find the right machine agents, and then simply create individual transporter fleet agents in that population and we will call this function now after we initialized the level. And, the reason for that is that the agent itself is not going to be a transporter and it needs to live inside the level inside of the network. It needs to be part of it, so it needs to be created after the level has been initialized. Remember, with the conveyors, we link them using an agent link to the machine. We'll do the same with a transporter fleet so I've created a conn_MyMachine which links to a single machine and it's bi-directional. So, inside the Machine class you will get a conn_TransporterFleet. So, each machine knows about its conveyor, downstream, and it's transporter fleet that can take stuff away from this machine. We will establish the connection when we create the transporter fleet. So, in the f_CreateTransporterFleet, after we've created the actual agent, we go into the agent and connect its connection to the origin machine. So, again the assumption is that a transporter fleet always belongs to where it starts serving packets from. If you run your model now, you see we have our population of transporter fleets populated. Nothing else is happening yet with those because there's no behavior specified but if you go into them, you see the parameters being populated and it's connected to an individual machine. Alright, so let's actually start implementing some behavior. In the transporter fleet, we'll add a super simple flowchart where packets can arrive at the transporter fleet, we will animate them at the leaving node of a machine because they are about to be transported away and we have the same setup as before where the packets afterwards are basically being beamed to the next machine or to the exit location. So, at the moment it is still lacking actual transport behavior but we can now make packets move through those agents. Now, the way to actually push them into the transporter fleet is err... we're going to amend the flow chart in the machine. So, once a packet comes through and checks first if there's a conveyor, so it prioritizes those, but if there is no conveyor, we then check, well, is there maybe a transporter fleet at this machine that could take it. So, in this case we're simply checking if there is a connection to a transporter fleet and if so, we transfer the packet to that transporter fleet arrival port. So, then arrives here and is doing whatever it's supposed to do. Now, notice this time we are not doing an advanced check here, if the transporter feed can actually take the packet to the destination machine, like we've done for conveyors. You can do that yourself, it's a nice little exercise to duplicate that for transporters as well. If you run your model now and you go into a transporter fleet agent you will actually see packets coming through, not really doing anything yet but at least visit... visiting the transporter fleet and then being beamed to the next machine. So, now we're almost ready to implement some actual transporting here. So, let's create a transporter now. Remember, this MyTransporterFleet agent is not going to be the transporters itself. Each fleet agent has several transporters so we'll create a TransporterType agent type from the Material Handling Library, we'll call it Forklift in this case, and then just go ahead and create it. And, then make sure you add a little forklift 3D animation so we can actually see it there. Also, then just double check in the properties of the forklift that it does indeed say Use in flowcharts as: Transporter. This is crucial to tell AnyLogic this is supposed to be a transporter with collision avoidance and that kind of self-awareness. Then create,  as before, an empty population of forklifts in your transporter fleet so each transport fleet will have a population of forklifts according to this quantity but make it initially empty and make sure that you click this 'Show Presentation' button, if it's clickable, and make sure you see the presentation in your transporter fleet so everything will be visible, eventually. Okay, so, now is the time to actually start dragging in the transporterFleet element from the Material Handling Library and set it up properly so the capacity, well, first of all let's say these transporters are going to be free space, they can just drive anywhere, the capacity we can now easily define by the quantity parameter from the database, and then, crucially, the home location must be a rectangle or rectangular node that is part of our global network and part of our global levels. So, that's why if we create this rectangular home location up front because now we're going to tell all the forklifts, where you're living, is in that rectangle. So, you have to dynamically navigate to Main and take the node_Transporters, not the fake one but the one that we created programmatically, and this needs squiggly brackets because you could actually specify several home locations as a comma-separated list. The rest we can leave, all we need to do now is to say whatever transport agents you create, please create forklift: 18 types, and then please also add them to this prepared custom population pop_Forklifts so we can actually visit and have a look at those guys. If you run the model now, you will see forklifts also in 3D, they should be there. If you can't see them in 3D, go to your forklift agent click on the animation object and make sure it's clicked to be shown in 2D and 3D. So, here we are, and if you then go into the transporterFleet agent, you can see three forklifts for this fleet in the transporter fleet, and also in the population. Obviously, not doing anything yet. So, after all this preparation work we can now finally say, please, if a parcel arrives in the transport fleet, move it by a transporter, use the fleet that we've just created, the transporter fleet, and the question now is where should it be going. So, first of all, make sure when you send packets into these enter blocks that AnyLogic actually knows what's arriving here are product agents... packet agents... and... and then in the next step we can say the transporter should take the packet agent and move it to whatever packet agent is arriving, that's the agent keyword. We go into its outstanding machines to do, we get the first one where it needs to go next, and we get that machines node_Queueing, not the fake one, but the actual one for queueing. So, the transporter will now drive the packet to its next machine's queuing node and that's all there is to it! Now our transporters actually pick up packets and move them to where they're supposed to be and basically relieve the conveyors and do the jobs they're supposed to do. If you go into the transporter fleet, you will now see transporters actually being busy and doing the job they're supposed to do. So let's summarize again. We created a new database table that specifies our transporter fleets, we created those and then, crucially, inside of them we created the actual transporter fleet with transporter agents, in this type... case, forklifts, we use the moveByTransporter to use that fleet, move it to wherever the packet needs to go next, and one of the critical things and kind of tricks that you need to do is you need to create a home location for your transporter fleet that is part of the programmatic network. Hence, the very first thing we did before initializing the network and level, was to create that node_Transporters, adding it to the network, then initializing the level with that network, and as a last step create the transporter fleet and set everything up. So, that was that chapter now you have a functioning self-configuring model with conveyors and transporter fleet. Alright! You've done it! We've done... added free space transport us as well. Hopefully giving you all the principles that you need to create other material handling elements or elements from other libraries. So, let's now open up to questions. Here you're able to ask any questions and we're gonna use the remaining minutes to answer the best questions. In terms of next steps, what I recommend you do, is simply try this yourself. We'll send out a recorded version of this, obviously. It'll also be available on YouTube, so you can pause and try to follow the steps. It was fairly fast paced but there was a lot to cover and then just extend those principles to what you need to get done. And, if you want to reach out to me there are lots of places you can do that via my website, there's a YouTube channel that I'm filling with little nugget videos. I'm on Twitter, LinkedIn and StackOverflow, so you can find me lots of places. Alright, let's get to the questions! 