 [Music] hello in this video i'm going to cover how binary file structures work via a basic overview of the portable executable file format follow the principles seen in this video and then complex binary file formats such as jpegs zip files pdfs exes and dlls and more will be far easier to not only comprehend but also read modify and even generate from scratch in your favorite programming language let's get started text files are probably the most common type of binary file that i work with these type of files lack an enforced structure outside of limiting the byte sequences allowed a computer only understands zeros and ones humans are the ones who apply meaning to those zeros and ones for example a bunch of folks in the 1960s 70s and 80s decided 0 a hex or 10 decimal equals a new line while 41 hex or 65 decimal equals an uppercase a etc the outcome of those early efforts became known as ascii much of it adopted into unicode and used by the majority of systems today to the computer though they are just bits and bytes of data specialized software called text editors transform bytes or sequences of bytes into human readable characters and enable modification of text files however there are many files that cannot be viewed or modified in a text editor in a way that makes sense let's take a look at one of my favorite structured binary file formats the portable executable or pe file format is used by microsoft windows to load compiled binaries such as exe's dlls system drivers etc into ram and run the code found within the pe file format itself is a bit obscure fairly complex and has a rich history dating back to the ms-dos era in the 1980s it is also mostly well documented and contains a wide variety of storage structures and is still very much a relevant file format today there are also a number of powerful custom tools that make the format more accessible for various purposes combined these things make the pe file format an arguably good choice for a video on binary file formats the most basic tool needed is a hex viewer or editor for general purpose viewing of binary files on windows i use the free portable edition of hex editor neo the best text editors also include tools for binary file structure analysis but those features usually cost money there are some free general purpose binary structure parsers analyzers out there like kaitai struct however in my opinion specialized free format specific tools are the best way to dissect and analyze each specific format rather than a general purpose binary structure analyzer for the pe file format itself i use several such specialized tools pe view is my go to viewer but i also use puppy cff explorer dependencies resource hacker and of course cubiclesoft winpe file we also need a calculator when working with binary files a calculator that can rapidly convert between various bases is a must-have while speedcrunch is my favorite general purpose calculator with history capabilities i actually prefer to use the windows calculator when working with binary files because it does conversions more quickly between decimal hexadecimal octal and binary next we need a set of sample files or artifacts to examine each binary file format tends to have various edge cases and a good artifact library will cover most of the more obscure edge cases for example i've created a fairly large github repository of pe file artifacts that anyone can use for research purposes ideally any file format you work with will have a similar artifact library available somewhere readable source code someone else has created for parsing a file format is also a good idea to have on hand if only to peek at it's very likely that someone somewhere will have had more insight into a particular area of any specific file format github is of course useful for finding specific keywords unique to the file format and turning up source code and related projects last but not least we'll need at least one specification on the file format itself most binary file formats have official specifications but some of the specifications are locked behind legal agreements unofficial specifications created by a community of reverse engineers can be a good starting point fortunately microsoft publishes most of the pe file format specification in the windows api documentation file format specifications are inevitably long boring walls of text that get quite technical and at this point you may wonder what good is knowing about how a file format works well if we know how a file format works we can modify the file possibly in ways that the original designers nor anyone else ever thought to use the format for most of the time we hear about the bad things people do with binary file formats such as embedding malware however there are plenty of valid legitimate and perfectly legal reasons to modify binary files here are just a few positive examples of using the pe file format in ways it wasn't really intended for we can apply changes to exes and dlls to enable a newer application to run on older versions of windows or to add new functionality such as patching an executable to turn it into a portable app that runs from a thumb drive on any pc or even to fix a bug microsoft is clearly okay with modifying executables in binary format because they do it themselves on occasion and here's someone crazy enough to write a full-blown cpu emulator for older 16-bit windows 3 programs in the new executable in e file format any format files won't run natively on 64-bit intel hardware because the hardware itself no longer includes the 16-bit intel 8086 8088 instruction set now that we have all of the pieces we need let's start analyzing a pe artifact i'll start with a hex editor to just get a feel for how raw data looks hex editors are useful tools for looking at the raw data of a file here we can see a dll in hex editor neo like most text editors it displays the starting file position on the left the hex code for each byte in the middle and an ascii representation on the right most binary file formats start with what is known as a magic number or a file signature magic numbers are not really numbers but a specific sequence of bytes that indicate that the file is probably in the expected format for example zip files start with the string pk because the creator of the zip file format was phil katz founder of pk ware incorporated most gif images start with gif 89a sqlite databases start with the string sqlite format 3. this could obviously go on for a while in fact there are entire tools dedicated to identifying files based on their contents rather than their file name such as the file command on linux but let's get back to the pe file format a pe file starts with a dos mz signature or magic number this is because pe files are actually made up of two separate executables an ms-dos executable stub and the main pe runtime the ms-dos stub is a leftover from the windows 95 days when programs might include both the ms-dos runtime and a win32 runtime in the same executable as far as i know no software really ever used that feature because 32-bit programming was vastly superior to 16-bit programming so while the dos stub is an unnecessary appendage these days it can be used to fingerprint the compiler and linker used to produce an exe or dll every exe and dll starts with a regular ms-dos header until 3c hex bytes in the d word which is a fancy way of saying 32 bits or 4 bytes at this location points to where the real ne or pe header starts pe files store integers in little endian format which means the lowest byte first the highest byte last since intel cpus are little indian the windows loader on intel chips rarely has to do ndn transformations as it loads a pe file into ram jumping to the byte in the file specified by the d word we can see the four byte pe0 signature if this were a 16-bit exe for windows 3 we would see a 2-byte new executable or n-e-signature at the location instead of a pe signature while hex editors are mostly useful to check something specific in a binary file it's getting a little bit difficult to follow the mess of bytes so let's jump over to our first real tool pe view pe view is my favorite tool when it comes to pe file structure analysis it's blazing fast never crashes keeps strictly to showing the actual structure of the pe file format and closes file handles when it should unfortunately it only works well with 32-bit pe files and has only had limited support for 64-bit pe 32 plus files for the last decade on the left side in pe view we see a tree structure on the right side we see data specific to the selected portion of the tree this tool takes care of many tedious details for us including rva calculations which i'll cover in a moment the windows loader is responsible for loading an executable and each dll that is referenced into ram mapping sections into virtual space applying relocations and of course checking files for validity all prior to executing a single instruction 16-bit dos executables by comparison were exceedingly simple in design they had several major flaws in that only one executable could run at a time with the sole exception of very fragile terminate and state resident or tsr programs but back in the 1980s ram was extremely limited and very expensive so running just one program at a time made some sense also an application crash usually meant rebooting the whole system as dos would get overwritten in ram due to no separation of kernel and user space there is also no usable mechanism to reuse code in dos windows aim to solve the code reuse problem with dll imports which we'll get to in a bit pe file format exes and dlls are compiled binary computer code and data that are structured in a semi-flexible way which allows for all kinds of use cases when loading and running and executable the goal of these semi-flexible structures is to maximize the likelihood that the windows loader will succeed in loading each file now let's drill down into the first two major structures of the pe file format pe sections and the pe optional header first let's look at pe sections each pe section is 40 bytes long and appear immediately after the pe headers as sections are loaded into ram the privileges for each page of ram is set according to the pe sections flags or characteristics pages can therefore be protected at load time with separate read write and executable permissions any violations of the permissions will cause a page or segmentation fault and the os will terminate the application in short having different sections is an application safety mechanism if you want to learn more about windows page allocations and permissions check out the virtual alec and virtual protect windows apis other modern os's like linux have similar page allocation and permission functions let's look at data alignment for a minute data alignment sometimes called byte alignment is making sure that the next byte of real data starts at some particular multiple of bytes this is done by padding the data with zero bytes out to the alignment value many binary files use data alignment for various reasons but are usually structured that way for improving performance when loading the files the alignment requirements in the pe file format are thereby designed due to various cpu architecture hardware requirements quite a few cpu architectures require code and data to be perfectly aligned just to run an application however some cpu architectures like intel cpus will run applications if code and data are not aligned but will have reduced performance while windows plus intel sometimes referred to as wintel is the most common combination of os and hardware for the pe file format microsoft has experimented with plenty of other cpus over the years where code and data alignment are required pe files are designed to be aligned to different boundaries mostly for performance reasons on intel platforms for example pages in the windows os tend to be allocated in 4 kilobyte chunks therefore pe file sections tend to also be aligned to the page size of 4 kilobytes the pe file format also makes extensive use of bit fields binary file format designers tend to use bit fields to help reduce the size of the file and or improve overall application performance bit fields are a chunk of data usually one two or four bytes long that are sliced up into individual or chunks of bits each bit position represents something specific if it is turned on most specifications also have reserved bits that are never used for anything and should always be zero looking at bit fields manually is fairly slow and error prone so tools that map the bits to human readable strings are quite useful here now let's look at the second major structure of the pe file format the pe header the pe header is split into the standard header and the optional header the standard header supplies what type of machine the executable is compiled for how many pe sections there are the size of the optional header and some flags despite the name the pe optional header is not optional in exes and dlls the pe documentation refers to executable files as images the pe optional header contains all kinds of pointers that describe the rest of the file this header is also where we get our first taste of rvas within the special pe data directory table despite the official microsoft documentation saying pe data directory entries are all rvas they're not actually all true rvas while the official documentation on the pe file format is a good starting point it is flawed by intentionally misleading readers at times and even excluding important information at any rate the pe data directory of general interest to most people is the import table this table tells the windows loader which dlls are required by this executable and what functions from those dlls need to be mapped into the process space the windows loader is responsible for loading those dlls as it loads the process and those dlls may reference other dlls and those dlls may reference other dlls and so on entire tools like dependencies exist that look solely at import and export tables in executable images which can be useful to determine what's missing on a system when the os doesn't load a particular image so let's find the import directory table in this file by using this rva reference found in the pe optional header data directory a rva or relative virtual address is a number that represents a relative location in ram that's added to the base image address we are looking at these files from an on the sidelines point of view which is an important distinction when dealing with rvas that is we are looking at the raw file data on disk while the windows loader and the application will be looking at data and code loaded into ram the first step to finding the position on disk is to walk the pe section list looking for a section whose range contains the rva value once the section has been found we can calculate where in disk it sits by subtracting the base rva to get the difference then we add the raw data pointer value to the difference to locate the starting position on disk this mapping exercise is useful to show how a computer program can locate and extract information from a binary file on disk of course pe view does the rva mapping for us and also conveniently extracts the import table structures the import directory table consists of a zero terminated array of dlls to import and where to put the imported addresses the import lookup table for each referenced dll is a zero-terminated array of ordinals or hint name rvas of functions to import for a specific dll the import hint name table contains a bunch of aligned ordinals and names referenced by the imports lookup table the import address table or iat contains identical data to the import lookup table until the file is loaded into ram when the file is loaded into ram the iat is overwritten with correct addresses in the loaded dll that points to the start of each imported function the iat is how windows allows for code reuse to make applications smaller but it can be used in other ways for example the iat is regularly referenced online when dealing with remote process injection or creating executable hooks normally when the executable code calls an imported function it loads the address from the iat and then calls that address a hook is where an address in the iat is ultimately replaced with another address then whenever the executable calls the function it loads the address from the iat however the address it loads actually points at the hooked function instead of the original function this allows custom behavior to be created to get the application to do things that aren't normally possible tool kits like microsoft detours easy hook min hook and even cubiclesoft win pe file simplify the process of hooking the iat through various means hooking the iat is just one example of modifying an executable for some specific purpose note that the order of the import table types is not important and import table types can even appear in different pe sections rvas generally allow for a lot of flexibility on where table data is stored within a file the decision on where to place directory information within a pe file is mostly left up to the authors of compilers and linkers while most binary file formats don't have the level of complexity that pe files have many do have the concept of pointers that point to specific places within a file moving from just viewing and reading any binary file to actually modifying the file is a significant step that carries some risks beyond checking magic numbers at the start of the file the windows loader has a number of other mechanisms to make sure it is loading a valid executable image one of those mechanisms is the pe file checksum located in the pe optional header a checksum in a binary file can be as simple as adding the bytes up in the file to something more complex like a crc 32 or sha-256 in the case of the pe file format the pe checksum is a slightly modified variant of the ms-dos checksum algorithm which just adds up bytes it's not a particularly good choice for a checksum and the windows loader tends to skip checking it if its value is zero however the pe checksum is required to be correct and non-zero for windows drivers and various critical files the algorithm for the pe checksum is not included in the pe file format specification nor anywhere else on microsoft's website for whatever reason other file formats like zip files use a crc32 to verify that the file is not corrupt zip file reader applications like 7zip will usually verify a checksum before they extract the file's data when modifying binary files it is a good idea to update all the related bits of information inside the file in addition to the desired change so the modified file remains valid when read by various software and tools in the future copying or backing up a binary file before modifying it is also a good idea in case the modifications corrupt the file well that's the basic structure of the pe file format and how binary file formats in general are designed we covered tools artifact libraries specifications pointers to various locations within files data alignment data tables checksums and more even if the pe file format itself hasn't been interesting to you binary files are just files that consist of highly organized data structures with the relevant specification in hand and a few tools analyzing and understanding existing binary files becomes a piece of cake with the techniques shown here various tools and libraries can be built to modify existing files in unique ways and also create new files from scratch or even entirely new formats from the ground up for your specific application hopefully you learned something new today be sure to like and subscribe and thank you for watching [Music] 