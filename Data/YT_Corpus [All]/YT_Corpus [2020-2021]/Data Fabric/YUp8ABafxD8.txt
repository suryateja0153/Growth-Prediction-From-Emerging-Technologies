 [Music] [Music] welcome back so we were talking about replicated state machine and we talked about how to order transactions on them and now we also talked about failures fail stop failure and there we saw that t4 if you assume T of them will fail then T plus 1 servers are needed to tolerate that now let's talk about visiting tolerance so again we have 4 copies of the same state machine and now let's say one of them decides to behave arbitrarily so it's a Byzantine node so now a transaction comes now all the 3 nodes will give you the correct value that are not affected by a Byzantine but the one that is Byzantine may not answer you or may answer you wrong so how do you decide so client will have to do a majority based decision so client will say whoever is whatever is the majority saying I will go with that so in this case the correct value 3 will be decided by the client as the correct value to a correct answer to its query now if 2 of them does fail as Byzantine and two of these presenting guys are under undergoing the effect of the same malware so they decide to actually fool the client with the same value now we have a problem because majority voting will not work anymore because there are two seven answers and two three answers and the client will not be able to make a decision so now again so let's say we want to try this algorithm as before now I have R 0 and R 0 has been given this local IDs but the Byzantine node may or may not give it any ID or give wrong ID so in this case let us assume that the Byzantine node decides to keep quite and not given your spawns so so then you basically get the majority of the candidates and then you use timeout to decide that the fourth answer is not coming and then you decide the majority is this so I will I will based on that I will give it a UID so in this case one point four was the highest so you give one point four it worked so one node being Byzantine and not giving any response did not affect your ability to give ID to a agreed upon ID to the transaction now suppose the this other guy the Byzantine guy wants to behave more maliciously so he wants to confuse you so he gives you a an ID but he chooses a small ID because he doesn't know what idea others are choosing so he gives you an ID let's say minus five same issue that the algorithm says that you have to take the UID as a maximum among the all the local IDs so even if it says minus Phi with no problem one point four is still Dyess so I am going to choose one point four no problem right so this also would what if this guy gives you large ID right so he gives ten now based on the algorithm now you have to decide on that idea of ten for everybody else now this is fine as long as there is only one transaction otherwise if this happens again for our one again the this guy can actually give you a large ID and make our one have a different ID but that doesn't make any difference because all the be all the other guys will decide the same ID for each of the transactions now that idea might be dictated by by the presenting node because he is choosing very large ID or it may be one of the ideas that these three guys give so that will not be a problem so to tolerate tea players in this case you will need three t plus one so we assume that one note goes with 19 so we need three times one plus one that is four servers so that's what we saw there but when we saw two failures we saw that three times two plus one is seven but we had only four that's why we were not able to proceed and so two T plus one servers need to participate in the replication protocol so now so now you understand a little bit about the state machine replication and B models for different kinds of faults so in case of hyper ledger we this applies only to the ordering nodes the ordering nodes are involved in making ordering decisions and they have to tolerate Byzantine failure provided the designer of the blockchain decides that there is a possibility that this ordering nodes are not necessarily extremely highly secured there may be patches that are missing and therefore they may be infected by malware or or it may be taken over by some rogue entity and therefore they are not going to work behave properly another possibility is that this ordering nodes belong to different organizations for example if this blockchain is spanning three banks then each Bank may actually provide one of the nodes in the ordering service ordering service is a replicated servers set of servers but each of them are coming from different organization and you are not trusting the other organization maybe they will not do anything because of their business it takes or whatever but you may not this you may disagree among each other at the business level that lets not trust each other let's have Byzantine for tolerance but if I am going to assume that two of you will behave rogue then I will have maybe seven servers to do ordering service if you if I assume one of them may be going rogue then I will have four etcetera etcetera they can make that decision now blockchains [Music] is more than just you know simple replicated steak machines because there is replicated machines at just one service like a database service or something running in in each of them it's a it's the servers associated with the database let's say but in blockchain there may be many many different services or applications running as I was saying that same ordering service may be used for one banking winter banking transaction here lock keeping another one for supply chain and etc all of them in the same infrastructure so the ordering service may be associated with all of them also applications may come and go as applications may be deployed dynamically and then the application code is untrusted and potentially even malicious which in this case in hyper ledger doesn't matter because ordering service does not run any of the application code but that's the reason why ordering service is separate so coming back to a picture similar to what you saw before being in fabric hyper laser fabric we have execute that is where the endorsers execute or simulate the execution of the transactions and create the readwrite sets so they create the readwrite set and send the endorsements the ordering service then only order based on the readwrite sets and do an atomic broadcast among each other and do a you know decide and then this ordering service is stateless in the sense that it doesn't keep this state at all it is totally agnostic of what application is running what data is being kept etcetera it only does ordering and then the nodes that are validators they will validate that they that a transaction has all the necessary endorsements and then the readwrite sets have the right versions of each of the piece of each of each piece of data and then it eliminates invalid and conflicting transactions and then they after that day they send it to every period and then every peer will persist the data by adding to the blockchain the block that was given by the ordering service and with a bit bit vector that has months and zeros one means that it returns the first term if it is 1 0 0 that means first transaction is valid second and third transaction is not valid etc so that information goes to every node and every node keeps the block with the with the bit vector so that later on when you retrieve the blocks and want to see which transactions were valid and and actually was persisted and which transaction was tried but it did not persist all that information there and this is very important for auditing especially security auditing so that's the basic idea of the execute order validate framework so fabric they have pillager authors they actually consider fabric more like an operating system which runs applications so why they are calling it an operating system like why isn't it theorem or Bitcoin not considering it as an operating system in operating system you have many applications running each application may be consisting of one process or multiple processes and these applications as they run they're the processes run their own address space so there is full confidentiality between between two processes so if what is happening inside this process what's in its memory etc you know unless there is a cyber attack based exfiltration of some kind buffer overflow etc these processes are silos in which the application runs or if an application is multiple processes they may exchange data with each other through shared memory or through you know RPC etcetera but all the other applications do not know what is happening there in ethereum this ability to silo multiple different that are running on the etherium is not done so every smart contract for every application on the blockchain every node sees them so therefore we cannot compare it areum as sort of like a operating system where if I create a hyper laser infrastructure I can have multiple channels running multiple different applications and and the chain code associated with each application will be confidential to each other so therefore it's more like an operating system which is enabling multiple applications with full silos and they are reusing the infrastructure such as the such as these so yeah you know identity service or the service that gives digital certificates be ordering service which which may be common between all the applications and the actual infrastructure may be all common the network and the and the actual servers but each server is running this applications the chain code in a in a way that you know the chain code runs in Dockers so they are siloed out from each other and also there is a common code that is called the system chain codes that basically does for example things like validation etc this are you know putting as libraries so it's very much like an operating system also in another sense it's an operating system is operating system can run applications written in any language and here also the same thing that they have chosen by design and then you can have the additional thing that execution history is kept in replicated ledger which is temporal resistant and so on but and it has no cryptocurrency ability so again the smart contract is called chain code which which basically implements the application logic and runs during execution phase the chain code is the main thing and fabric and there are also system chain codes as I said that basically are using managing the blockchain system maintaining parameters etc and they are quality system chain code so the endorsement policy is something that we talked a lot about but we never explained how this endorsement policy is set who sets the endorsement policy what exactly is the effect of an endorsement policy etc so engrossment policy is evaluated at the validation phase which is a pre commit phase and the endorsement policy cannot be decided by week chain code developers so let's say you are a bank and you are running a banking application on hyper ledger so and the code that is running in the application are designed by vendors right so you have you hired some coders they write the chain code in go or C or C++ whatever and they will put them in Dockers etc but every time you want let's say a transaction to be to be endorsed who will endorse the transaction whether it's just one node or whether it's three nodes and which specific three nodes etc is part of the endorsement policy and that's a that's the best way that's based on the business logic and business policy of the application and the a and the business that is running that application so they might say that for any transaction we below you know which which which has a which has an Associated value of say ten thousand it has to be endorsed by two nodes and to this kind of specific nodes if it is above ten thousand two hundred thousand it has to be endorsed by at least three nodes it's like check endorsement in a business and that decision is encoded in the application so endorsement policy becomes part of the application but it's not part of the chain code that does endorsement so so when a client let us say wants to do a monetary transaction let's say like internet banking he says that from my account send one lakh to this other account then maybe the policy is that it has to be endorsed by a manager node and and sub manager node and maybe a vice-president node or something so so any nodes that that is running on a chain code on behalf of the manager sub manager etc will actually be getting that so client would the client the program that is running on behalf of the client will know that for this kind of transaction I need these three endorsements so it will brought send this transaction info request or proposal to these three nodes these three nodes the chain code in there will will pre execute the transaction to see whether the balance is available on the users account and whether the and what would be the value after the after the transfer and what would be the value at the other place after the transfer and then it will create the read write sets and then it will digitally sign it and then the client gets enrollment back this endorsement will come from all the three nodes that are supposed to be part of this endorsement policy only then the client will know that well by client I don't mean the human sitting at the at the terminal you know logged into this application let's say through a web front-end but the application that is running on behalf of the client would know that now I have gotten my endorsement policy has been satisfied however then the client will send it to the orders and orders will order etc but as it goes to the validator nodes the validators will also check whether the endorsement policy has been satisfied for example for this kind of transaction so that so the validators know the endorsement policy for each type of transaction so they will check whether that has been met then they will check whether the digital signatures associated with each other Horseman's check out and then then they will check the readwrite sets I have the right versions etc so so that's what endorsement is all about and normally this endorsement policy is expressed by what is what is called monotone logic so like 3 out of 5 or it has to be either these two nodes or the this node may be a very high privileged node so if this guy endorses then we don't need these two nodes to do anything etcetera etcetera so this may be to some managers and this may be the manager so if two sub management nodes do it then it's fine but if it is one sub manager that's not enough but if if the manager is himself does it or program running on behalf of the manager does it then that's fine so the transaction flow here looks like this that you have T client so this is the client it invokes the transaction and then it sends the transaction to the endorsing pr1 endorsing pr2 endorsing pr3 endorsed endorsing peers will as I said created such etc and then send back endorsement all this endorsement said took send back to the client at that point the client will say when three all the three endorsements have come or maybe the investment policy is just two so as soon as it gets two of them then it will send it to the ordering service the ordering service is maybe made up of multiple nodes because of all that fault tolerant issues that we talked about and then ordering service will order them and then it will send it so it will then send it to the validated nodes so validator nodes are could be the same nodes as indoor cells but different chain codes so therefore you know they are running in different different dockets so same server start being used for multiple purposes but they are in silos so they don't talk to each other say see each other so therefore that is fine or it may be different different service it doesn't matter but in this case let's say this is the same the nodes as validators so then validators will send this to commit and then that and this commit will go to all the other nodes right so so the and then all the stuff will be done so here I want to summarize the hyper ledger fabric transaction flow so a client sends transaction to peers specified by the endorsement policy each transaction is executed by specific peers and its output is recorded but nobody changes anything in the database or or in the blockchain so we call it a simulation of the execution and this step is called the endorsement and there is will be no change of state in the terms of the state of the big blockchain or any of the data in the database after the endorsement the transactions will enter the ordering phase and the consensus protocol will produce a totally ordered sequence of endorsed transactions grouped into blocks now these are broadcast to all the peers with the help of a gossip protocol so gossip is protocol by which the a node who wants to spread the news to everybody he will tell his neighbors and the neighbors will then tell its neighbors and never will not tell back to the neighbor that told it right so this is how the gossip protocol works so so brought is the broadcast to all the peers each peers then validates the state change from endorse transaction with respect to the endorsement policy and then the consistency of the execution of the transactions by looking at the version numbers of the states of the data that has been that that is going to be R a is being read or written due to this transaction the ones not correct they will be marked as invalid transaction and then all state changes what the valley transactions will then be made and that's what we call the states are being updated and the validation process is deterministic because you know they will they know the endorsement policy so they will check whether the endorsement is being made properly according to the policy and they will check they read right sets for the validity of the transactions and then now fabric introduces a novel hybrid replication paradigm in the Byzantine model so so you can have passive replication or and you can also have active replication so passive replication is because pre consensus computation of state updates so there is no real replication happening here and active replication is happening when a post consensus when everybody replicates the state change and everybody replicates the new block added to the blockchain and as you can see that in this scenario there is no possibility of the blockchain diverging because after the auditing service creates a block the only that block is available to be added to the to the blockchain and be so so there is never will happen that there will be another block added to the last block and then there will be a race between two branches and then eventually one branch will win all that stuff is gone in this scenario and then other thing is that in blockchain in the Bitcoin and aetherium we saw that all transactions in a block must be valid right otherwise the block will never be accepted so when each node gets a block that has solved a proof-of-work puzzle what it does is that it then checks first that the proof of puzzles Ellucian given in the block is correct and then it will check whether the transactions are valid by executing the transactions and that means that if it finds one of the transaction is invalid then it will basically tell you that this block is invalid so then anybody else who has solved the proof of a proof-of-work puzzle that block will eventually come and then that will be accepted now since proof of work is so expensive nobody actually in their right mind will create a block with invalid transaction because they're also executing the transaction to check validating before they cut the block so if you have if I have put so much expense computational expense to solve the proof-of-work puzzle I better not put an invalid transaction because I know that piers will again execute the transactions and they will find that it's an invalid transaction right so that's the incentivization mechanism that works in case of Bitcoin and ethereum because if you cut a block with invalid transaction you are going to lose the money that you would have earned by you know your block being rejected since here there is no native currency there is no way to incentivize therefore the it the ordering service or consensus has to be done using standard distributed algorithm concepts and algorithms and also then you have to consider presenting for failure and how what happens how to solve the Byzantine failure problem so that basically brings us to the end of the hyper laser discussion in the next class what we are going to do is that we are going to show you two more different types of blockchain technology one is called iota iota is a blockchain that was particularly designed for IOT devices because IOT devices do a lot of transaction among themselves because smart home and smart transport and smart factory etcetera are supposed to have these IOT devices and they cooperate with each other so they have to do transactions among each other so iota is a infrastructure where they use a particular type of data structure called tangle and they have a very different idea of a blockchain it's in fact it's not really a blockchain in the sense of blocks it's actually a directed acyclic graph so we'll look at that you know not in as much details as we have seen this block chains but to give you a flavor of what the other kind of block chains that are being developed for very different purposes like we can discuss that second thing that I want to discuss is another block chain called coda which is again a business block chain so in some way it is more closer to hyper ledger but in some ways it is very different in purpose and design than hyper ledger but we'll discuss coda also to show you what the financial technology financial world the bank's etcetera they are thinking in terms of a blockchain based smart contract system where the contracts are actually the part of the design and language and there we are talking about financial business contracts not the contract in the sense that you know I if you give me this I will give you that kind of thing I mean it is kind of that kind of thing but but it is more formalized and the blockchain is designed with a much more formalization of business contract recording as well as business contract execution so these two blockchain examples will be given a lot more briefly than then we have been doing with this three these three major block chains because in this course we wanted to give you a very good conceptual understanding of what blockchain technology is about what where it is going what are the different types of blockchain is not all size fits all say size fits all so there are different types of solution for different purposes and they have very different design different intent and then so this two will give you some more exposure to this kind of block chain once we have exposed you to that those two of course there are many more right so they're at at least now about hundred probably different types of block chains now the question is once you have gotten the with this very basic ideas you would be able to choose based on your application needs and your business needs etcetera what is the right type of block chain that you might use finally we'll towards the end of the course we'll talk about some applications so we talked about applications in a very abstract manner like you know we talked about you know supply chain banking finance monetary system etc but now we'll talk about a few concrete examples of the blockchain technology being applied to non cryptocurrency applications and hopefully with all this you will be in a position to actually have a very conceptual knowledge of blockchain technology and applications and the ability to articulate what your problem requires if you want to have a blockchain solution also you know you should be able to articulate when your your application does not need a blockchain so we'll we'll discuss all that in the last week of classes so we'll see you next time [Music] [Music] [Music] 