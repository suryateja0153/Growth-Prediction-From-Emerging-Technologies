 Hello, everyone In this video we'll be studying about Hyperledger Fabric concepts and understand it's concepts the reason for making this video is because I realized a lot of people around me didn't quite know where to start when studying for Hyperledger Fabric. or what to do with Hyperledger Fabric Hyperledger Fabric has so many features and concepts to understand that even a lot of developers have a hard time understanding Fabric on top of that the documentation is not that great and through this video I would like to share my experience and hopefully this video can be of any help. Hyperledger Fabric is really hard it'll be difficult to understand and be proficient in a short time There are so many components Orderer, peer, CA, channel, etc etc following the developer tutorials can help you get started but not enough to start a real project or service If you want to use Hyperledger Fabric in a real life project you would need a deeper understanding of Hyperledger Fabric for example, if you want to increase the TPS, or increase performance and efficiencies you need to understand the architecture of Hyperledger Fabric. Without it you could end up coding your chaincodes in a weird and inefficient way and be unable to utilize some of the other Fabric's benefits And I hope this video can help you have a better understanding of Hyperledger Fabric Today's video is all about understanding this diagram this diagram is from the official documentation. By the time of this video the diagram has changed a bit not a big change, just the labels got removed. They removed the label for some reason and it's more difficult to understand now As for understanding Fabric, it's crucial to understand this diagram. And once you understand this diagram, the next step is understanding the ReadSet & WriteSet. For example understanding how a chaincode works. That should give you a better understanding of Fabric's architecture. Before we start, I would like to go over the fact that Fabric is a private blockchain. And I'll quickly compare Fabric with Bitcoin and Ethereum. As you know Bitcoin and Ethereum is the biggest public blockchain. If I have to pick out the biggest difference between Fabric and the Bitcoin, Ethereum blockchain is Bitcoin, Ehtereum blockchains run as a single program where as Fabric has many task specific components (programs) that work together With bitcoin or ethereum you only need to install one client program, such as the bitcoin core or the ethereum geth The installed client can run as a miner and a wallet. It also saves the blockchain to your computer or the worldstate (in case of ethereum) So in essence one program does it all. However in Fabric each task is a different program. For example, the Orderer is for creating new blocks the Peer is for simulating and storing the blockchain. Although the Orderer does store the blockchain as well but for simplistic sake I'll separate their functions for now I'll get into the nitty gritty details in later videos Going back to the slide Bitcoin's and Ethereum's Blockchain run from one program. Where as Fabric has separate programs for creating blocks, storing blockchains and simulating smart contracts. I think this is the biggest architectural difference between Fabric's blockchain and public blockchains such as Bitcoin, Ethereum. Another difference is the use of certification over private keys. Bitcoin and Ethereum uses a private key system which the user can create to send or receive money. Where as Fabric uses a certification system to interact with the user and between each components. (A very Korea specific example) Another way to explain the difference is private keys can be user created therefore being decentrailized where as certifications are created by an admin therefore being centralized. In Fabric the admin is called the Fabric Certificate Authority (also a program) The CA is responsible for issuing certifications to users or peers which can be used to interact with the peer, orderder, channels etc. And the last difference is that, in Fabric you cannot change the key value within a block multiple times. For example In bitcoin or ethereum, if you want to change a block’s value from 100 to 200, You just add 100 to the block. Then if you want to change it to 300, you add another 100. A block's value can change multiple times with bitcoin or ethereum In Fabric this is not as simple as it sounds. In Fabric you cannot simply add values to increment a block’s value. This is due to how Fabric’s architecture is built And because of this architectural difference, you need to think differently about how you would code your chaincode. And I’ll explain why Fabric was built this way. Fabric has 3 major components The Peer, the Orderder and the App (user) The Peer stores the ledger (the blockchain) and inside the ledger, the world-state is stored as well. The Peer also simulates transactions. The Orderer takes all the transactions and creates the block and only creates the block. and does not simulate transactions Again, the Peer simulates the transactions and the Orderer creates the blocks. The App will be the user end, like a wallet that creates the transactions which interacts with the Peer and the Orderer. Because the Peer and the Orderer are separated you would need to code your smart contracts differently from bitcoin or ethereum. Let’s take a look at this diagram to understand further. If you see the Orderer, it says “No Ledger” which isn’t completely true but for simplistic sake we’ll pretend for now it doesn’t have a ledger. When a User creates a transaction, that transaction gets sent to the peers. When a User sends a transaction to the peer, the transaction does not become a block just yet. The Peers will simulate the transaction to see if it’s valid. Once valid the peers will confirm the validity of the transaction to the User. This s Fabric's agreement system To simply put if 2 out of 3 agrees the transaction then the transaction is considered valid. 1. The User creates a transaction and asks the Peers for permission to give it to the Orderer. 2. If 2 out of 3 Peers agree, then the User is allowed to send the transaction to the Orderer. 3. Then the User sends the transaction to the Orderer and ask it to be put into a block. The Orderer collects all the User generated transactions and checks if they are really endorsed by the Peers. Again, the Orderer only checks for Peer endorsement and does not check the workings of the smart contract. Once the Orderer is happy with the transactions it will create a block and send the block to the Peers. The Peer will receive the block from the Orderer and create the chain while updating it’s world-state. This is the basics of Fabric’s transaction flow. Again, the User creates the transaction and asks for the Peers’ endorsement. This is called the endorsement policy. The policy can be 2 out of 3, 2 out of 4 or even 1 out of 3 to agree a transaction. The User then gathers the endorsed transactions and creates a Proposal Package which is then sent to the Orderer. The Orderer then checks the Peers signatures and creates the block which is then sent to the Peers. With Bitcoin or Ethereum, all this process is done by one program (one node). Whereas in Fabric the Peer, the Orderer are separate programs. Let’s take a look into the Ledger. The Ledger has 2 main components. The actual blockchain and the World State. World State being the current status of the chain. Only the Peer has the World State of the chain. Both the Orderer and the Peer holds the blockchain but only the Peer uses the blockchain. The Orderer only holds the blockchain for reference purposes. Endorsement, as mentioned before Fabric uses an endorsement policy to validate transactions. It’s a voting system where for example 2 out of 3 needs to agree a transaction. also known as Byzantine fault tolerance We'll skip the Channel for now and look at this diagram again "A" is the application The User connects to the peer Invokes chaincode and creates a transaction The Peer than simulates the transaction The Peer will run the smart contract and validate the smart contract. Which is called "Proposal Response" The User will gather the validations from other Peers and sends the transaction to the Orderer The Orderer will check the endorsements and create the block. Then the Orderer will send the created block to the Peers. The Peers will receive the block and update it's ledger. This is how Fabric essentially works under the hood. This is flow diagram of the a transaction and it is the same. The User creates the transaction. A transaction contains the chaincodeID (smart contract ID), the payload, the timestamp and the client signiture. this transaction gets sent to all the endorsing Peers The Peers simulates/Executes the transaction and sends an "OK" to the User. If 2 out of 3 Peers says "OK" to the transaction Then the transaction is sent to the Orderer. The Ordering Service is where all the Orderers are. The Orderer than stacks the transactions and create a block. That is sent to the Peers. Think of the endorsing Peer and the committing Peer as someone who can endorse and someone who can not. Again, this is the basic structure of Fabric. In our next video we will look into ReadSet and WriteSet. Thank you. 