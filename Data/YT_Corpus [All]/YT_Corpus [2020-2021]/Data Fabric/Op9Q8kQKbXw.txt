 [Music] hello everyone welcome to the next lecture of our blockchains architecture design and use case this course so in this lecture we gonna look at a very important aspect of block chains and it's also an aspect that has been seeing a lot of research activity lot of innovation which is really privacy if you look at block chains as such right it's about decentralization having multiple peers holding a replica of your data thus Matra smart contracts are also replicated and decentralized so the notion of privacy is really at odds of this notion of replication and decentralization so how do you ensure that your transactions are seen only by a certain set of people how do you ensure your data remains private and confidential so the notion of privacy and the notion of replication and decentralization are really at odds and there is a very interesting innovations that are coming up that allows you to achieve both notions right both privacy as well as decentralization and replication across multiple nodes in the network so in this lecture we look at what are some of those innovations that are all of these are very new concepts right within the last five years I would say so when we look at what we are storing on blockchain so there's really multiple things we are storing and the notions of privacy are also for that reason there are many notions of privacy so what do we really mean by privacy so first of all doctrine is going to store a set of transactions so there is a transaction privacy oops there is transaction privacy which means that I want to keep the inputs of a transaction basically what's not contracts I am executing what are the input parameters I want those to be kept private so that's the transaction data privacy there's also the state debt data privacy so this is the in turn state that is maintained by the smart contract and is recorded all that onto the ledger so we want that data to also also be private I note that the transaction data is just the inputs to the function write the state data is really what the function is actually computing and it could be more than just the input parameters that are sent in the third thing is the contract privacy itself which is the logic of the chain code which is really the code which is also going to be residing on the blockchain we got to keep that private right we won't only expose that code to a certain set of authorized entities and the final notion is you of that of user privacy which is the the fact that who is performing this transaction who is endorsing a transaction the user level credential details you want to keep anonymous and the other notion along with anonymity is that we also want unlink ability which means that when one user performs let's say 100 transactions no one should be able to say that these hundred transactions were really performed by one user right those 100 should appear as though they're they are really coming from from independent entities so it's that's the notion of unlike ability so we want privacy at the level of transaction details and in terms of state data in terms of the logic of the chain code is the smart contract privacy and also user privacy and none of these aspects of privacy are supported by the many permissionless blockchain platforms we have like including Bitcoin and aetherium they only provide the notion of pseudo anonymity which is to say that hi as a user I can assume a pseudonym people will know that that pseudonym is performing transactions but they really they can't link the pseudonym with the original user but apart from that it doesn't provide any notion of transaction data or state data privacy at all right and it's left to the applications to to explicitly handle these notions of privacy and these notions of privacy are actually very important for many of the enterprise use cases for instance if I'm restoring healthcare records on blockchain the healthcare records are sensitive so I want to make sure that the data I am storing is actually private it doesn't matter whether I'm storing it on blockchain or otherwise the intent from the the use case or the industry is that that data has to remain private and it can only be authorized for certain users on a need-to-know basis well let's say the other example is when a bank or banks are transacting all enterprises are exchanging money or assets between each other they want to ensure that that user information is private they don't want to know how much money is getting transferred between enterprises so we want that notion of privacy and when the authorized entities should be able to see our critical information so now in this lecture we look at various ways in which some of these notions of privacy can be achieved you know in a blockchain platform hype energy of fabric as a as a permission blockchain platform specifically targeting enterprise use cases has several constructs that all help provide different notions of privacy so then up to the application designer or the user to leverage the privacy in the right way right so we look at some of those constructs and we look at also some constructs that from from other platforms along the way so the first notion that typology of fabric provides is the notion of channels right so channels are really a partitioning mechanism whereby different subsets of entities in the network can all come together to form one channel and all data within that channel are only available to the participants of that channel so participants are not part of the channel will not be able to see anything about the channel they won't even know the existence of that channel so it's really a partitioning mechanism and in some sense the each channel maintains its own chain of blocks so the the ordering itself is independent across channels so you could have different ordering services for each Channel so a child can have its own ordering service and those transactions are treated separate so what are the things you cannot get is for instance you can't have a transaction that spans across channels so each transaction is restricted to a particular channel and that also means that if you want to do something atomic which means that I want two pieces to transactions to happen on two channels I can't make that happen atomically using the platform itself so the application will have to take care of that a diversity then the coming to channel creation who can create channels only authenticated and authorized users will be able to create a channel specifically the channel creator who is creating the channel has to be a network administrator the channel creation request is submitted and is evaluated by the ordering service the ordering service will check whether an authorized participant is trying to create the channel and along with that that requests to create a channel you also also specify how the participants are going to be right so it is going to be restricted to a subset of the organization's participles annotate the the participation is defined by three policies one is who are going to be the readers so the readers in some sense you can think of it as the ones who are just going to be committing data if they will be able to read data all they are doing is committing transactions they are not doing anything else the writer policies is who can write data into this into this channel right so there'll be the the writers and the admin policies are the ones who are able to perform administrative functions for instance only an admin will be able to install a change code or a sorry instantiate a change code on a particular Channel likewise only an administrator will be able to change the channel configuration parameters so all those are administrative functions youthere are of course readers and and writers onto that Channel and you can specify in a granular man or who can read who can write who has administrative privileges and so this whole notion of channel in some sense provides both transaction and data privacy to a subset of the members of the channel so all the members of the channel will have rights to see what transactions are there what data is being stored in the smart contracts but within a channel we don't have privacy in with this construct right it just allows you to partition transactions and data in the network and all members of a channel will see all the data within it note that the data privacy is not offered with respect to the ordering service so the ordering service for a particular channel will see the data within the channel and with just using channels you can't get data privacy with respect to orders so others will see the data and there are other constructs that have that will help you even of course obfuscate that from the orders so the second construct is of course you can use encryption right so this is a well-known technique for decades using encryption for ensuring privacy so you can encrypt the data and share the key only with authorized entities and that way only the authorized entities will be able to decrypt the data and see the see the original content everyone else will see just the encrypted data and with that they can't figure out what the version of extras so there's a well-known security primitive just using encryption but then the application will have to do this encryption at least in in most of the blockchain use cases otherwise you're you're you don't want to share the key on the blockchain that way then everyone will get the key right so then you lose in your your privacy so once you encrypt the data at the application layer the application now has to maintain these keys now even the peared will not see the unencrypted data all right but then if the chain code is also only going to get the encrypted data and all it will do is to store that data and I'll be able to retrieve that encrypted data now the disadvantages is that it's going to be very hard to manipulate or validate what that data is for instance I can't do arithmetic operations I can't do conditional operations yes there are constructs like homomorphic encryption that do allow you to perform certain arithmetic certain functions on that encrypted data itself but it's it's not it comes at a performance penalty and there are certain disadvantages to doing that alternatively you could store a private data off chain all right you can store it in an external data store ensure that the right parties have availability of the data and just have the hash and metadata information stored on the blockchain so that will give you the immutability so if someone goes and changes the external data store the data in the external data store anyone can actually check the hash on the blockchain and determine that something is wrong I think the hash doesn't match anymore so you know that at ease you can detect that someone has changed the data have tampered with the data so this gives you mutability but doesn't give you all the other advantages of smart contracts of being able to modify the data in a decentralized fashion on a blockchain network so that's that's about application layer encryption great the other thing you can do is with fabric you can actually send the encryption key to the chain code so now you want to let the chain code also see the decoded content so how does this work right so our chain codes have this field called transient data right so this is a data field in your chain code parameter so when you're invoking a chain code you can also add a transient field and send some secret information in the transient field right so when you send that information the chain code will be able to retrieve this transient field information but that information is not included in the transaction so if you see the transaction it will have the chain code that's invoked it will of all the parameters but the transaction itself will not have the transient field that's why it's called transient ok now what the chain code can do is you can it can use that transient key and store data encrypted on the field so that way the pure will not really have the decrypted content but the chain code itself can work with the decrypted content can encrypt and decrypt using that key right now this along with our leveraging let's say our trusted execution platforms such as Intel SGX or IBM's e secure containers it's possible to isolate the the chain code container from the pure so that way the chain code will execute in a trusted environment and even if the chain code is handling the encrypted key and as decrypting the content the pure will not get to see that content at all the data when it gets in the pure will in encrypted form and will be stored in encrypted form so it's possible to do that so this this picture just gives you the the flow of how that works right a blockchain user is going to use a client application to invoke a transaction on on the particular chain code so what you will do is they're gonna encrypt the transaction input parameters so all the input parameters it's going to go into the chain code they're gonna encrypt it and of course the transaction is going to be signed with the enrollment certificate so this enrollment the key there is different from the encryption key so the what the key you use for signing this is not the same as the key you use for encryption and you for different data parameters you can actually use different keys and what you're going to do is send that the send the keys to the chain code through the transient field and now the chain code can actually decrypt the transaction input it can perform certain whatever functions it means to perform it will then encrypt the state data and then store it onto the blockchain so when it gets to the pure and what you will see on the block itself on the blockchain will only be encrypted data so overall this whole notion can be used to encrypt the transaction parameters it can you be used for used to encrypt the chain code logic itself just the code itself is going to be part of our deploy transaction right so that can also be encrypted and the chain code state can also be encrypted what you're storing on the blockchain right so all of these are now are now possible with hyper larger fabric so the transient detail data itself it's it's not included in the endorsement method it's not including the inference in the transaction and it's provided to the chain code upon request right and how do you leverage it it can be used for sharing confidential data like key material it can also be used as a source of randomness right so typically chain codes you do want to want it to execute you know in a deterministic fashion how many of our peers executed right so even if multiple peers are executing the same code you want that to be the execution to be deterministic so you don't allow any you don't want any kind of randomness to come in but what you can do is you can send in a seed right so that all of these peers will generate the same random number but will be random for each transaction all right so that source of randomness can also be sent to the chain code using this transient field okay so the the next notion so we looked at how you love channels can help transaction data and prior transaction and data privacy now we looked at encryption and how the transient field notion and chain codes can actually give you different notions of encryption and em privacy the third thing is how do you ensure that the code itself is going to be remain confidential right so now there are two parts to this the first is there is a it's important to understand the deployment process and fabric so how do you deploy a chain code there are two steps to it one is the installation should step and the second is instantiation so the installation is really about being able to run hack the logic in a particular peer so this is independent of channels on the peers where the chain code is installed the the peer will have that logic of the chain code all right so this is just based on the peers so which peers have to run this code they will have the the chain code so that's the installation so the next part is a channel specific instance creation so based on for each channel on which you want to instantiate a chain code you will call an instantiation transaction and at that point you will say who are the authorized peers who need to execute this transaction and may act as endorsers for this transaction so that is the second notion so the fact that endorsers can be a subset of all the entities in the channel means that the logic only needs to the side with the endorsers so let's say my channel has ten participants I can say only five of these ten participants a specific set of five participants are going to be endorsers right so only those five will then have the chain code logic the remaining five will not have the chain code logic at all but will see the transaction data will see this chain codes data but they will not see they see the logic or the code of the chain code itself so when the endorsers will have the code and and within those endorses of course you can have the endorsement policy so you can say for a particular transaction three out of five and ourselves have to sign right but only the five people will have the code itself and so this ensures a smart contract confidentiality so only the peers for a particular channel that need to execute the transaction who are good actors endorsers will or can hold the smart contract code right and the endorsement model provides the resilience resiliency to non-deterministic chain code so given that multiple endorsers will endorse a particular chain code you can ensure that that code is deterministic right okay now coming to the next notion right so you're coming to the notion of user privacy no all right so right now there is this identity mixer which is a which is a really an open source project from a IBM it came from the crypto world but it's now being adopted by hyper ledger of fabric itself it's gonna come in the in the next release version 1.2 of fabric the development is already underway I think we briefly talked about this in an earlier lecture but identity mixer gives you a very strong guarantees on anonymity and unlink ability so let's look at how at least at our high level how this works right so there is a a blockchain user so as before they have to obtain a certificate from a certificate authority so there is a membership service provider that interacts with the certificate authority to issue certificates and there's a enrollment certificate as before but now the user is going to when they invoke spot contract transactions so when they invoke transactions previously we had mentioned that the the transaction is going to be signed by the enrollment certificate instead what is possible with identity mixer is that the user can generate per transaction certificates so these are specific one-time use certificates that the user can use for different each transaction and they can also have other one-time use keys that are generated suggest for encrypting data like I talked about before right so you can generate keys for signing you can generate keys for encryption and all of these the it's possible that the the user can actually prove that they were all all these keys were derived from their enrollment certificate right so that is really a unique ability where the user can generate multiple keys from an original ESAT but they can also prove to an auditor that these were all generated by by that he said so the auditor can come in and see that these were all performed by these transactions were all performed by the same user but no one else in the system will know that they were performed by the by one user so that's the difference with the research and the tea sets the transactions are terrific 'its will be one-time certificates that the user can generate to perform transactions on blockchain so now because all of these t-shirts look different right even if the user is performing 10 transactions they can all have n different keys so it appear as though these word up these were performed by 10 different users so that way you achieve unlink ability right so let's just compare the previous x.509 certificates that I talked about with identity mix-up so think of identity mixer identity makes our is really another fabric C and our fabric or membership service provider implementation which is distinct from the fabric CA that we talked about earlier the previous fabric CA was based on X file and certificates and we'll see how they are different right so on the left is how x.509 roughly worth is right so there is a certificate authority that is issue going to issue a certificate to to a user and this certificate can have multiple attributes so we've called out attribute and won and attribute new so now the user has one certificate with two attributes so they have these two attribute 1 and attribute to and whenever they perform a transaction they're gonna sign with that certificate so any anyone else who is seeing this transaction will see both their attributes so that way they'll know that this was performed by this user so there's no anonymity there and there's also no unlink ability so between these two transactions I know that these were both performed by the same user so in this model in the previous fabricc there was no anonymity or unlink ability so let's look at identity mixer and what it does right so the identity makes her the CA for identity mixer issues like before an enrollment certificate it has like before two attributes attribute 1 and attribute - now what user can do independent of having to talk to the certificate authority they can have a presentation policy so there can be new policies based on policy one it can choose to just disclose attribute one so it generates a transaction certificate that has just attribute one and policy two based on policy do maybe this is this can be even a different channel altogether where they are the users performing transactions it can be maybe a different chain code or just simply a different transaction within the same chain code for transaction a I want to disclose attribute 1 for transaction B I want to disclose attribute 2 so if you look at this attribute 1 is hidden here and only attribute 2 is shown and in this transaction only attribute 1 is shown so that is possible so you can have distinct transaction certificates each exposing different attributes that a user has any done you can present that and you can use that to sign transactions so these transactions will look completely different to an end user so this way the e set is also hidden so you get complete anonymity and you also get unlink ability across transactions so the the next thing that you can perform with these anonymous and unlink achill transactions I just sent edited before these auditability so what is possible to do is once signed these transactions I can also I can actually prove to an auditor so let's say auditor has a particular secret key I can prove I can basically expose this information only to an auditor and the auditor will be able to verify this transaction to say that this attribute indeed belongs to this user and this is a valid certificate the auditor will be able to determine that and not only that it's possible for it's not that one auditor will see all the data it's possible to have per data element auditor or per attribute audit so I can say only for this attribute this person is the auditor for some other attribute it can be a different auditor altogether so that's also a very unique capability that we have in appalachia fabric and it really gives you a very cool very fine-grained control on exactly what data elements you want to share with whom including with auditors so you can say okay this data element I will only share with this auditor and not with someone else right so that's also possible and when I say auditor it need not be just one entity that holds that key it's possible to share that key with multiple or dispute that key with multiple parties so only if all of them all of those parties come together will be will they be able to audit this thing so those are known capabilities and cryptography yes so that's the unique notion of audit ability that typology fabric can give you and of course there's certificate of vocation so this happens this is an important functionality provided by the certificate authority so it's going to maintain a certificate revocation list of these set of users user certificates that have been revoked so with identity mixer so there is a separate revocation Authority and what is possible is that the when some so basically whenever someone is verifying a transaction they're going to go back to the revocation or the vocation list and check whether this certificate is still valid or whether it's when if it's been revoked let so to do that it's so possible to do that in a privacy-preserving man so all non revoked users there will be more loss of privacy because of having this Nando vacation proof to show that this certificate has not been revoked can also be done in a privacy-preserving manner so right now the implementation for the integration of identity mixer with Appalachia fabric is going on and should be out in probably a month or so I think it's it's already in the roadmap for fabric 1.2 version right so so there are libraries written partly in go partly in Java and this is really a new blockchain crypto service provider interface that's being written so there is our client SDK there's gonna be a new fabric C and of course the membership service provider implementation that provides these functionalities ok so now I'm getting to another very interesting cryptographic notion which is zero knowledge proof so zero knowledge proof are really almost they seem like magic right so what they are is that I want to be able to prove that I hold a particular secret or that I have some particular private information and without revealing that information to you I want to prove to you that I actually have that private information for instance one of the things I want to do or one of the common cited examples is I have a driver's license the driver's license has my age on it typically when I go somewhere and present my driver's license you will see all the information on it right you'll see my date of birth my address everything right but let's say I'm I want to only prove to you that I am greater than 18 years of age right I don't want to reveal to you all the other details of my driver's license can I do that so there are ways with cryptography where without revealing my driver's license or my date of birth I can prove to you that I am greater than 18 years of age all right that's pretty cool isn't it so that's really the zero knowledge so you will once you have the proof you can be guaranteed that I am actually eighteen years of age or older but I have not revealed you really revealed I've given you zero knowledge about my private information I have not revealed my date of birth at all and there is no way for you to guess that another very important use case is my funds right for instance I don't want to reveal my bank balance but I want to prove to you that I have enough money in my bank account in order to make a payment let's say I'm go to pay you hundred dollars all I need to prove to you that I is that my bank balance is more than 100 I don't have to reveal my bank balance to you for that right so that's again a very powerful notion there's also our proofs about membership right so I want to prove to you that I am a legitimate user of the network I'm a permissioned user but I don't know anybody is my identity so that's also another place where there's zero knowledge is used where I don't reveal my identity but I prove to you that I have I'm authorized for access okay and of course asset ownership I want to prove to you that I own an asset without revealing to you what that asset is so there are multiple of these use cases for zero knowledge proof and this is actually in cryptography this started way back in the 1980s over a period of 30 years it's actually matured to a good extent and now with blockchain coming into play and privacy being an important aspect of applications being built on top of blockchain people are asking for these privacy notions zero knowledge proof have seen a resurgence over the last maybe three four years there's a lot of work going on in zero knowledge proof and let me give you a few examples all right identity mixer with the transaction certificates actually uses zero knowledge proof where the user can prove to you that this tea set was in fact generated from a particular assert without revealing that is up to you all right so that's in the identity space likewise hyper ledger in D which also focuses on the identity can prove to you certain claims about your identity so claims are issued by different people and I can prove to you that I have a particular claim without revealing that claim to you and it's also possible to integrated with transaction validation so this is with the state verification whether the inputs and outputs of a transaction it's possible to validate them so I'll come to that in the in the next slide and an important property of these zero knowledge proof is that the proof is actually I'm consuming to create and even with the private information it's going to be very hard it's actually takes it's computationally intensive for the owner of the information to construct the proof but verifying the proof is very simple so you can really the verification can be done by a large set of independent parties they can all verify it very quickly but construction of the proof is very very difficult so that's the the cryptographic property that that that they have and of course if I do not have the private information it is impossible for me to match a proof and to make you believe that I actually have that information so without the private information I can't fool you so you can be guaranteed that it's impossible for me to generate the proof without the private data okay so let's look at a few other examples where we're zero knowledge proof are employed in a very nice way okay so zero cash is a very nice example so they what they have is zero knowledge proof for providing full anonymity of users right so remember that Bitcoin and aetherium only provide pseudo anonymity right they don't give you a full on anonymity all right so what they can do with zero knowledge proof is that they can prove that they can ensure that the user identity is never revealed when someone looks at a transaction right they can also conceal the asset value so in Bitcoin for instance everyone who is looking at the network can see by just looking at a particular transaction they know exactly how many bitcoins got transferred from one Bitcoin address to another so that bitcoin value is not private but what zero zero cash allows you to do is to conceal that value right also though the water the weight now we'll talk about how does that in the in the next slide and the other thing we can also do is conceal the UT EXO graph so basically the list of unspent transactions that can also be kept private so 0 coin was was it was introduced as the cryptocurrency has an extension to Bitcoin so they actually forked from Bitcoin and they created a new car occurrence cryptocurrency based on zero cash and is called zero coin and in 2013 they actually showed that a 98 percent smaller proof sizes so they dramatically improved the complexity of these proofs the size of the proof became very suction and the time taken but the time taken is still a concern right so there is still this still takes a significant amount of time and computational effort to construct these proofs so that is still a concern and it's act it's an active area of research and this whole 0 coin notion has been integrated now with etherium and corn so it's possible in ethereal to conceal the transaction information right so who is transferring how many ethers to to someone else and the ability to verify these zero knowledge DK Snorks as they are called on chain is now inbuilt into into aetherium and quorum so we look at a theorem in quorum later in this lecture but this has been incorporated there so let's quickly look at how this works right so in any Bitcoin transaction or a aetherium transaction basically any utx so there are a certain set of input inputs and a certain set of outputs and what we are doing when we win this chain when we change these transactions together is that every transaction needs to prove that the inputs are all unspent so if they have to be unspent outputs of other transactions so there are these links in some sense and what we want to hide are the following right we want to hide the amount of value that is getting transferred the in and out all right how much is the value of the transaction we want to hide the identity so I talked about hiding the identity and we also want to hide the new tech support now if you look at the validation logic or the prevention of double spending what we want to ensure is just that the outputs are not more than the inputs in some sense we are not generating new assets or new money out of this right the outputs have to match the inputs all we have to prove is that property right we don't have to reveal exactly what the inputs are what the outputs are so those values can be hidden but I prove to you that outputs are not more than the inputs so that proof is sufficient for you to ensure that there is no double spending right so that is provided through a zero knowledge proof so someone who is submitting this transaction has all of these inputs and outputs of the obfuscated they along with that they submit a proof saying outputs are not more than inputs right anyone in the network all the peers let's say Bitcoin or etherium peers they can all verify that outputs are not more than inputs so it's a valid transaction and they can admit it and what is also great is that the set of unspent transactions can also be kept private so no one at any point of time even the peers will not know what the set of unspent transactions are but what they can verify his membership right I can verify that this particular input is a non spent transaction at this point it is part of this private set in some sense that set is kept private even the peers don't know it but I can prove that I belong to that set so isn't that cool that's really a very cool property this very involved mathematics in this all of which I myself do not understand but the properties are very very useful in many enterprise applications right and these are becoming reality today so we are actually starting to use these very complex cryptographic primitives for providing privacy in in blockchain platforms ok with that we've come to the end of this lecture we will look at a few more exactly is one more privacy primitive in hyper ledger fabric in the next slide but in the meanwhile there are a few interesting reading right there's a lot of witnessing work going on in the space as I said the scan is a great topic for research if you are looking for like a thesis topic so let's go over what some of these things right so there's a nice TED talk huh TEDx talk on using the Bitcoin blockchain to detect fraud so this is really from like a lawyer in the US where they actually monitored transactions on the blog on the on the Bitcoin blockchain to detect people who are doing some fraudulent transactions so I won't go into the details but it really tells you two things right one is how Bitcoin actually doesn't give you the privacy but at the same time because of the fact that blockchain immutably records all transactions that have happened it's actually possible to go back in the past and know exactly what happened who did what so the provenance is great for detecting fraud but at the same time there is privacy concerns in the Bitcoin blockchain so that's a very interesting about 20 minutes I think it's a very interesting guarded talk identity mixer so you can find out more details of if you are into security into cryptography I would encourage you to take a look so this is completely open-source identity mixer itself is open-source there's a lot of material for you to do look into the details there's a nice overview set of the overview overview article and there's a link to the github itself including including documentation and if you're interested in zero-knowledge proves in particular the Wikipedia is a great place to start it gives you a nice overview of concepts and the zero cash project itself is a very interesting project so I would encourage you to read that they have a research paper in the I Triple E symposium on security and privacy which is also a very good read so I'd encourage you to dig deeper into this topic if that interests you and with that we'll get to the next lecture we will we look at one more construct for for privacy thank you [Music] you [Music] 