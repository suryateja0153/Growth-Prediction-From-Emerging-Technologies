 A few reminders for- just for the course in general. So I'll be sending out the project guidelines very soon, as well as different suggestions for projects if you're still looking for different project topics. Uh, a reminder that the homework is due- Homework 1 is due next Wednesday, and then Homework 2 will be coming out on the same day. Uh, for the presentations today we'll have around 20 minutes for each presentation, uh, and people can ask questions and discuss the papers throughout the presentations, uh, just like during lecture and we'll, uh, we'll try to sharply cut off the presentations, uh, at even increments so that we can get on to the next one. Uh, also for those of you that are presenting, pre- if, uh, if there's an audience question, please remember to repeat the question. Uh, this isn't necessarily for the purpose of the room, but for people watching the recording, then they'll be able to hear what the question was. Um, either repeat the question or answer the question the way that, uh, that the question is apparent from your answer. Um, yeah. So those are all the, uh, the reminders and information, and we'll start with the first presentation in a couple of minutes once we figure out the, uh, the Internet. Yeah. Hi all. So we're just starting the paper review session. So the first one is meta-learning for a low resource neural machine translation. It's by. So over to you. Sweet, thank you. [APPLAUSE] [NOISE] Hi, everyone. Please use the microphone. Okay, awesome. Hello. [BACKGROUND] Hi, I'm Sabri. Hi. I'm Ryan. I'm Manurith. Cool. We're going to be talking about meta-learning for low resource neural machine translation. Awesome. So to start off, um, to give like a brief introduction on the history of like, um, NMT progress. So historically, like neural machine translation, um, was first based off like statistical methods for language translation, um, and then over the last few years, as deep learning has gotten a lot better, uh, models have moved towards, um, NMT basically using deep learning for NLP type tasks, and those have outperformed statistical models on the vast majority of, uh, like trans- multilingual translation pairs. Uh, and then there's the issue that still exists that for low-resource language pairs, uh, statistical models are still outperforming because deep learning is very data hungry. So basically, neural- neural machine translation first started off as just targeting like large monolingual, uh, corpora, so like, targeting just like English to German or like, just like English to French or something of that nature. Um, slowly over time, different papers came out basically treating, uh, multiple languages at the same time, uh, and the context of a single task learning prac- uh, learning, uh, procedure, and then after that they applied like direct transfer learning methods. So initially, like training a model on like English to German, and then fine tuning on like a different dataset for like English to French or something of that nature. So the idea here was that we could use neural machine [NOISE] translation methods and like meta-learning for optimizing fine-tuning on low resource pairs, so that classification learning would go much faster and much more efficient. So the way the authors first set this up, uh, as a meta-learning problem, is that first they have to define the tasks. Um, so they divided into two sets. One is the high-resource language translation tasks and then the low-resource language translation tasks. So each task is essentially a translation between two languages, whether it's like Spanish to English, or French to English, or in the low-resource case, Turkish to English. So the idea is during meta-training phase, you sample your tasks from these high-resource language translation tasks, uh, and then you train on these and during meta-test time, you fine-tune on these lower resource, uh, language trans- translation tasks. Now, um, it's important to note that these low-resource languages are lower resource than the high-resource languages, but they're still not true low-resource languages. So the authors had to sub-sample in order to mimic a- a low-resource setting. So typically, um, if you are doing meta-training, your- during the gradient updates, would first occur, uh, on your training dataset for your task, right? So you're gonna update your parameters theta to theta prime using your training dataset, and then you compute, uh, the predictions on the test dataset and then you take the derivative of the loss with respect to the original parameters theta to update the original theta. But what this involves is a second derivative, and because these guys are using transformers for NMT, transformers are larger models, um, so this is going to be computationally very expensive. So instead, what they decided to do is a first-order approximation. So instead of taking the derivative of the gradient of the loss with respect to theta, they take the gradient of the loss with respect to theta prime, and- but they still do the update on theta. Now, the authors show that these are roughly equivalent, and even in Dr. Finn's MAML paper, she talks about how, um, they are roughly equivalent, uh, and the intuition behind this is that the ReLU neural networks locally are linear, so the second order derivatives tend to be 0 in many cases. Uh, so that most of the gains actually happened from these post update parameters, which are the theta primes. [BACKGROUND]. Cool. Okay, so we've got this cool idea. We're gonna be using meta-learning for neural machine translations that we get these low-resource languages, in this case like Turkish and Finnish, and we'll be able to kinda perform better by first meta-learning on a bunch of high resource languages. So just kinda to recap the- the setting is, we're going meta-train on some language, right? So for example, here we have a Spanish sentence, we're gonna be translating that into English, right? Um, and then we're going to also be then meta-testing on a low-resource language like Turkish in this case. Um, and kinda one of the main issues or kind of the central issue that the- the author has kinda tried to overcome with applying meta-learning to this particular problem, is that the, uh, the meta-train and the meta-test input spaces, aren't aligned or they are not in the same space, right? And so that is to say, if we have a sentence like Spanish, in Spanish, right, and then we wanna take the word nombre and look up its Spanish word embedding and that Spanish word embedding is gonna be trained on some monolingual corpora in Spanish. If we look up that embedding, we'll get some embedding for nombre, but then if we do the same thing in another sentence in a low-resource language like Turkish, we look up adim, right? That means name roughly in Turkish, right? But when we look it up, right, we're gonna get another embedding and there's gonna be no correspondence between those two different word embeddings, right? And so we want the embeddings, you know, in the meta-train, uh, languages and the embeddings and the meta-test languages to be sort of in the same space so that we can really get the most out of meta-training. Cool. And so the idea that the- that the authors had to kind of address this issue was what they call a universal lexical representation, and the idea is that they're going to have sort of one set of word embeddings that they're going to share across all of these different languages, both the meta-train high-resource languages and the, um, low-resource languages at meta-test time. Okay, so the way that they kinda go about constructing this universal lexical representation, is they first train word embeddings independently for all the different languages. So all of the low-resource languages and all of the high-resource languages, they get a set of word embeddings and they can do this using monolingual corpora and then like Word2vec or whatever they wanna use. Cool. So we get word embeddings for all these different languages. And what they're gonna do is they want to create this set of universal embeddings that all the languages they're gonna share and so what they do actually is they just take the English embeddings, right? But then they also had this set of what they call universal embedding keys, and the idea is that these are going to be like lookups to look up values in the universal embedding values, right? So if a word embedding is close to one of the keys, that means that the corresponding value in the universal embedding values probably like has a lot of weight. So getting pointed that to put this in my- in my shirt. Okay, cool, awesome. So how do they actually go about using this? So going back to this example with the word nombre, we take the word nombre, right? We look up the Spanish word embedding, just like before, except now what we're gonna do is we're gonna pass that Spanish word embedding through a linear transformation, and then we're going to compare it to all of those different keys in the universal word embeddings keys, right? And what that's going to produce is going to produce this vector, right? That gives us like a match value, like or how well the Spanish word embedding match with all the different keys and we're going to call that vector alpha, right? So each of the keys now has this one scalar value telling us how much it matched with the word embedding in Spanish. Then what we can do is we can multiply that alpha by the universal embedding values. Remember, those are the universal embeddings that we're sharing across all the different languages, and that's equivalent to doing sort of like a convex combination or like a linear combination of all of those different embeddings in the universal embedding values. Cool. So the idea is that the words, the word nombre in Spanish, is going to now be a combination, some weighted sum of all of the different embeddings in the universal lexical representation, and the cool thing about this is now we can do the same thing with adim, right? But the advantage is that, so while adim kinda means name in Turkish, in Turkish we decline nouns and so that means that adim kinda means more like my name and so maybe you could imagine that when we do this linear combination, we're going to get a little bit more wor- weight to also the word like I or the word my, right? So this is kind of this flexible way of having this one universal representation, and then at train time, they hold they- they freeze the weights for the Spanish word embeddings. They also freeze those keys which are just English word embeddings, and then they allow you to train those universal word- the universal word embeddings and they also train that transformation matrix, um, going from Spanish to the universal embedding keys. Cool. So one of the first experiments they ran was to show, um, how does this perform versus a multi-task setting? So in both the meta-learning case and the multitask case, they first, uh, trained their model on all the high resource tasks, um, and then they fine tune on the low-resource tasks. Um, so what we- the first thing that we do see is that um, the meta- the meta-learned ah, model outperforms the equivalent multitask model, uh, across all categories. So across all of the, uh, low resource language tasks. And now it's interesting note in their diagrams the way they split this out. So they have all, uh, embedding plus encoding and then just embedding. So what's going on here is that they're not- in the all case, they're fine tuning all the parameters while in embedding plus encoding, uh, the encoder they're just fine tuning that portion and then they also just fine tune the embedding. So, uh, over here what's happening is that most the gains happen when you fine-tune both the embedding plus the encoder as opposed to, uh, fine-tuning the entire model. And this is interesting to see because, um, the decoder typically in an NMT model, ah, you're going from one language to another language. Here all the tasks are translating to English. So the decoder is taking the encoded representation of some language and then translating that to English. So it's better not to fine tune that portion because that's not- that shouldn't- that part shouldn't change. It's mainly the encoder and then the embeddings. Cool. Okay. I think I'm getting pointed at to use this. Hello. I'm not sure. Okay, uh, so- one of the- one of the- one other thing to mention here um also, so they also- ah, when you're doing meta-learning, it can also be useful, like, to have actually like a validation meta test task, right? To determine when to- to early stop during your meta-training. And so what they do is they actually just compare different options of which meta lea- which of these low-resource tasks that uses that validation meta-learning um, task. And so they kinda showed that, that choice is actually significant and that the performance varies depending on which, uh, which validation and task you choose. Yeah, and then the next experiment they do is they try and vary the amount of training data they have in order to compare between the multitask and the meta-setting- meta-learning setting. Um, and as the hypothesis, um, suggests, um, when you have lesser training examples, like in the zero shots setting or a few shots setting, um, the multitask models or the meta-learning model is gonna do a lot better. Um, but as you keep increasing the size of your, uh, training examples, um, slowly the gap between the multitask and the meta-learning model ah, the gap reduces. So both perform equ- almost equivalent. Okay, cool. And so then here they also kinda asked this question of how does our performance vary after fine tuning, uh, depending on sort of which languages we used during that meta-learning phase? And the main takeaway of the idea was basically, the more languages, the better, right? So the more languages we used during meta-learning, the better our performance after fine-tuning was, but kind of an interesting study to do there. The other kind of interesting takeaway from- from this ah, from this table is that last row right there which is fully supervised. So one thing that we mentioned at the beginning was that these aren't real low-resource languages or I guess like Turkish for example, is a lower resource language than French, maybe, right? But it certainly isn't like the lowest resource language. So compared to like real low-resource languages, like Berber, or like Basque or something, right? These are actually pretty high resource languages. And so to simulate this setting of low-resource languages, what they do is they sub-sample the tokens in these low-resource languages like Turkish and Finnish, right? And so when they actually do like fully supervised training on that full set, they get blue scores that are way higher than what they were getting with these sub-samplings, which is to be expected but it also begs this question of like, "Well, why didn't you also validate this method on- on like real low-resource languages, right?" Uh, I think it would have been be cool if they had, for example, like, yes, some case study for a really, really low resource language-like Berber, and then push the state of the art on that particular language um, as opposed to just like doing the simulated setting where they're, uh, where they're kinda under-sampling from- from these different medium resource languages. Yeah, I mean, I think what Sabri is saying makes a lot of sense because, like, if we were going to build a product to do language translations on low-resource tests, um, at least for languages that they show, it doesn't seem like the meta NMT model is what you would use, um, because it's clearly not the best performing model. Any questions or? Yeah. [inaudible]. Got it. Okay, so I think the question was um, how does the universe lexical representation get around the low resource problem? And I think that the way that I see it's like the universal lexical representation doesn't directly address the low-resource problem. What it does is it creates the setting in which all of these different languages that have totally different vocabularies, often different orthography also, right? What it allows you to do is, it allows you to, kind of, embed all of these languages into a similar space, which then makes meta learning more effective. And the meta learning is what's really addressing the low-resource issue. Sure. Well like- like are the embeddings for the low resource languages, like, [inaudible] Well, so the- the key thing here is that while like for a low-resource language in neural machine translation, we're usually talking about low resource in the sense that we don't have a lot of parallel corpora, right? So that is to say we don't have a lot of texts where we have like, you know, Turkish texts and then also English text. Um, but you might have like a lot of modeling of corpora that you can train those word embeddings on. So those word embeddings could actually be like kinda decent, I don't know. I think that's kind of the idea here. What makes you think that languages are linearly related? So like, sorry, the- the idea that like oh, like in the- in the- in this sense, sorry, the question was, what makes me think that that [LAUGHTER] languages are linearly related? Um, I don't know if I think that languages are linearly related, but I think that's kind of like a- a question about like sort of this part of their- this part of their approach. Um, yeah. I mean, I think the idea is that basically like each one of these rows in the universal lexical representation doesn't represent like a specific word as much as it represents like some of, like semantic notion, right? And that different words could be combinations, like, a linear combination of different semantic, like ideas. Kind of like yeah, like- with like adim, it means like my name. And so it's like, yeah- yeah also- Um, yeah, so yeah, we didn't mention this during the presentation, but one of the critiques that we were thinking of while reading through this paper is, this transformation matrix A, is shared across all the different, um, languages for the embedding keys. And so there is an implicit assumption there that along these- along the same sub spaces that these keys belong to that they are undergoing the same transformation. So that was like an implicit assumption that they could have gone around by using different transformation matrices for the different keys look ups. During the meta training, uh, with, uh, the languages that have a lot of examples, do they sub-sample those examples to sort of simulate, um, these low-resource languages? I remember- remember in like er, what we were talking about last lecture, we would, you know, simulate handing five pictures over to a measuring algorithm and then teach it to then classify a small number. So, like, is that this same idea being used here? Yes. So yeah, um, I- l think when we meant sub-sampling what that actually is during the fine-tuning phase. So for example, like when they're comparing against the multitask model, um, they don't fine tune on all the available data. They only fine tune on a sub-sample of the data, uh, in order to simulate the low-resource comparison. Yeah. [NOISE] [inaudible] Sorry. We need to switch laptops. So you guys, you can answer the question [OVERLAPPING] Cool. Sure, sure. Did you want to say something? [inaudible]. Is a question of the meta test? [OVERLAPPING] I still don't quite understand what the test based measures [inaudible] So, yeah, if you're talking about specifically during the- so both during meta train and meta test, we're gonna be doing the language translation task. Uh, so any of the embedding lookups that happen during meta train will also happen during meta test. Right. Yeah. I think here maybe- I think maybe the- We had one slide up there which was like we've kind of freeze, like froze some weights, uh, maybe with that kind of gave the impression that we were freezing them after meta-learning. Actually what we're doing is we're freezing them for both meta training and meta testing, right? So the other weights were just like learn, they were like learn in unsupervised way. They were embeddings mostly. And then we're learning all the other ones like in both meta train and meta test and then getting the number, yeah. Cool, cool, thank you. [APPLAUSE] Yeah. Ah, so the next talk is, uh, on few-shot autoregressive density estimation and it's been presented by Rohan and Varun. Hi everyone. I'm Rohan and this is Varun and we'll be reviewing this paper on towards learning to learn distributions. Uh, to get started, uh, we wanted to talk a bit about the motivation. Uh, so why would you want to learn distributions? So generative models in general learn distributions and you could use it in many ways. You could use it to enlarge your dataset, maybe for some data augmentation. You could- let say you have some missing pixels in that Obama image there. You want to fill those pixels, you could use a generative model for that, or you have a specific application like a capture thing and you want to generate certain images, you might use this learned distribution for that. And, um, I guess the main theme of this paper is that, uh, we as humans are able to like, uh, if you are given a few images, we are able to generate a new image or understand the latent structure of what is happening in that image. Uh, and the hope, like the idea in this paper is basically to do the same, can you learn to learn these distributions in a few short setting? So the learning setup would be this, uh, a task would be defined as something like given a support set of few images, can I generate a new image which looks similar to the support set? And, uh, for that, uh, like we will have some training tasks. So for- in this case, you have an image of a bicycle or you have an image of, uh, ima- a few images of cups. Uh, and you have a test task where you are given these few images of like a sewing machine. And you- the hope is that you want to generate a new image which looks something similar to the sewing machine. Uh, and the authors in this paper rely on two major techniques, one is the neural attention and one is meta-learning. So, uh, we wanted to take a step back and talk a bit about some prerequisites which will help us understand the models that the, uh, authors talk about. The first is the auto-regressive models. These are types of generative models which are basically use this assumption that there is a sequential ordering when you factorize a joint distribution into a set of marginals. And PixelCNN is, uh, is an example of an auto-regressive model. By, by that I mean that I will be generating these pixels in a sequential fashion. So over here, if I am talking about generation of pixel xi, I would use all the pixels that I have generated so far, which are shown by the blue, like all the blue boxes here. And, uh, what would- I, I have an architecture which is like, uh, very big deep architecture of lots of convolutions and some residual connections and so on. But the idea is that I would do a feed-forward, generate a new pixel, and then do it all over again, and so on, so forth. Uh, this is the third concept which we'll be using. Uh, this is called- I mean, attention. Most of you might be aware of this, but, uh, basically there is, uh, a query vector and a set of keys and values. And in this case, you have a sequence to sequence architecture where you are using the hidden states of the encoder, uh, as keys and the hidden state of the decoder as values and you get, uh, a weighted average as your attention vector. Uh, so in order to solve this problem, the baseline model that the authors talk about is called as conditional PixelCNN. Now, what do you mean by- before going into conditional, what do you mean by conditional PixelCNN? Uh, the, the architecture that they use is called as the gated PixelCNN instead of the normal PixelCNN. Why do they do that? It's because, uh, PixelRNNs were shown to perform better on generation tasks. And why that is the case is because they have some multiplicative units which are modeling some complex interactions. And the authors basically change the PixelCNN architecture to a gated PixelCNN architecture where they're having these like, uh, gating, uh, of mechanism by having that sigmoid which acts as a gate and the tanh, which acts as an activation. Uh, the conditioning here is basically, let's say I'm given, uh, some information about the image that I would like to generate, maybe it's a description. I can convert that into an encoding. For example, something like h here, and I condition on that. So my generation is conditioned on that as an, uh, input. In our case, uh, like going back to the our task which- where we had a set of support images and we would like to generate a new image which looks similar to the support set, we could potentially say that the support set acts as a given information to me, and I could encode it by this function, f of s. Now, f of s is some convolution function which does like some encoding. And you apply the gated function and you condition based on these, these set of equations. So, uh, this acts as the baseline model for generation of images. So, uh, given some support set, I'll be able to use this model to generate an image. Uh, but there is no some sort of like a concept of learning here, like, uh, there is learning per task, but then you are not- you won't be able to generalize that well. So the authors proposed two models. The first model is called the attention PixelCNN. And, uh, the key idea here is that as in when I'm generating these pixels, I want to focus on different aspects of my support set. So my support set is let's say 10 images. I want to- let say I am generating the 10th pixel, I want to focus on different pixels from the support set as compared to gene- like generation for the 11th pixel. So how do they model that is via this CNN based architecture, which is computing some keys and values, and then they have an attention mechanism where they do this transformation and learn their attention weights. And there are two major important points to note here. One is that the authors augmented the support set with some additional features which represent positional data. And the second is that you are learning these weights, but you are not- like for a test task, like a given new task of like, let's say 10 new images, you will not learn the weights or update the weights, you will use the weights that you have learned before, so there is no gradient steps happening here. Um, the next model that the authors proposed is called as the Meta PixelCNN, uh, which is basically using the concept of, uh, meta-learning in a slightly different fashion, uh, where, uh, it- the framework remains the same, but the key distinction is that the, the, they had this notion in- in like meta-learning, you have this notion of the outer loss and the inner loss. The outer loss is modeled as the normal, like negative log likelihood. But the inner loss is something which is learned. So, uh, the g function here represents the inner loss, which is basically taking in the output of the fixed PixelCNN and generating a scalar value, and that scalar value acts as a loss. Uh, and now I would let, uh, Varun talk a bit about the results and the takeaways from the build. Hey, everyone, uh, so yeah. So some of the tasks, uh, some in the experiment section, they perform three different tasks. In order of increasing difficulty, uh, they first performed image inversion, then character generation and then finally image generation. The datasets that they used were ImageNet, Omniglot, which is basically, uh, 50- characters from 50 different languages and Stanford online product dataset, which basically for each product, there's, uh, a variety of, uh, images that correspond to it. So some of the evaluation metrics that they used for, uh, this paper were, uh, qualitative and quantitative. So qualitatively they would look at the output of the model and determine if it looked good or not. And quantitatively, they use nats per them. So as a review, uh, nats is a effectively a unit of information or entropy based on natural logarithms in powers of e. So one nat would correspond to the negative natural log of 1 over e. And, uh, in this paper, um, basically they looked at the net- the negative, uh, log likelihood and, uh, averaged it across all the pixels. So, uh, for the first task, they perf- performed one-shot image generation where the support set was this dog, and basically, they try to invert the dog. Um, as you can see, the conditional PixelCNN and the Meta PixelCNN didn't perform as well as their proposed attention, uh, PixelCNN. And quantitatively, we can see the results reflect the same thing. Um, one of the things that they noted from, uh, the attention PixelCNNs performance was that the attention had learned to effectively, uh, move left to right while the output was writing- sorry, moved to have learned right to left, while the output was writing left to right, which is a naive approach of inverting the image. Um, the next, uh, task that they did was a few shot character generation. So if you look at the first two rows, um, you can see that the support for, for support images, uh, they were able to generate characters using three different models. Um, quali- qualitatively, we could see that the attention in Meta PixelCNN, uh, outperformed PixelCNN. These are some of the quantitative results. Um, they tried it on different, uh, support set sizes, um, overall the attention PixelCNN outperformed the conditional PixelCNN and even out- outperform the current state of the art- at the time. Um, in addition, um, they tried a different- a new model, which they didn't really talk about in their, um, in their, uh, model section, which is the attention Meta PixelCNN, which is, uh, unique and, uh, but unfortunately, it didn't perform as well as just the attention of PixelCNN, we'll discuss about it later. Um, so in addition, they even perfo- uh, they provided basically, um, how the samples are generated and, uh, basically, where the attention weights are, uh, with respect to the support images as they're generating, uh, each, uh, character. Finally, the third test that they performed was a few shot image generation. So given few images, they wanted to understand latent- the latent structure of the image and try to generate a similar product and substance. So they compared with attention and without attention and the results, they argued that the attention mechanism is better, but it's questionable and they even- and if you look at it quantitatively, it's like the difference is marginal. They argued that maybe there needs to be a better metric to do this sort of task or to measure this sort of task. So some of the takeaways, we will break it down into strengths and weaknesses. The strengths, attention is great for flipping images, especially in the one-shot generation case and this seems to be one of the- this is one of the first papers that we've seen that where -we can use- we can apply meta-learning. Okay. So I'll just continue. So the meta generative, yeah, so the meta generative models. Um, so basically some of- one of the, another strength is basically they can apply a meta-learning framework, [NOISE] awesome, er, around generative models, um, to generate unseen characters and then another cool thing was that they were able to learn the inner loss function in the meta-learning framework. [NOISE] Some of the weaknesses. Um, basically, few shot image generation needs a new model. Um, from just the result, it seems that, uh, this approach probably doesn't work well and, um, didn't provide an analysis of the inner loop gradient steps versus performance. Um, it would've been nice if we had seen that. Maybe it would have helped a meta-learning algorithm, er, perform better. Um, and then finally, the -I'm sorry, they added -they had some naive combination of meta-learning and attention. Um, this is also a strength in some sense because this has never been done before, um, but it would have been nice if they explored this idea further. Maybe there's some- there's a model out there that could perform incredibly well. And finally they had inconsistent experiments, specifically with the meta-learning and attention-based model. Um, they only applied it to one task. It would've been nice to see it on all three tasks. And, uh, with that, um, I'd like to open the floor for discussion, um, and any questions, if you have any questions, please feel free to talk about them. But, um, just to start, I guess some discourse. Uh, yeah, sure. [BACKGROUND]. [inaudible] Right, that's a very good point and like, uh, I mean, we were also thinking about there's no- so, uh, the question was that, uh, this loss that is learned, is not, uh, constrained in any manner. So it could just be learning to be emitting out a 0 but, uh, uh, I mean, we were also thinking about the same and there's one of the points here, the last point here about, uh, whether this loss function should be constrained in some fashion, uh, but we asked the authors and we'll talk about that a bit later and it turns out that, uh, I mean, the loss- the- the- the- the network G in itself is differentiable and also you are minimizing over that and because you have some bias terms and stuff like that, you could prevent it to be 0. So you- it, it might be possible to constrain it to be 0. Yeah. So, uh, but if, if the inner loop actually become 0 then there is no update in the build. The parameters don't get updated in the inner loop. Yeah. So that would mean that in the outer loop also you have very high likelihood which will lead to high loss. Right. But But then if you have some bias terms and those bias terms are not 0 in the network, [OVERLAPPING] then you wouldn't have a zero loss. Yeah. So yeah, so basically that's the down, uh, that's the disadvantage of having of learning a zero loss because it would prevent your parameters from getting updated in the inner loop [OVERLAPPING] which leads to a- Right. Yeah, yeah, that is another point. Yeah, I mean, the outer loop will not see any updates and that's why I like, yeah [OVERLAPPING]. So that would force the- [OVERLAPPING] Inner- inner loss not to be 0. Not to be 0. Right, yeah, that could be another intuition. Yeah. We hadn't thought about it from that perspective. It's a good point. Thank you. Uh, any other questions? Yeah. So in element sharing, it has generating a completely new image, uh, what's preventing this network from just copying the example like this one? Right, but, uh, I mean, you could potentially- You wanna take that? He is asking you. [BACKGROUND]. So the question was, uh, what prevents the network from some just copying this net- the images from the support set. Um, because you have this notion of like performance across tasks, uh, you wouldn't like get a, a very good performance. Or like the loss function would not go down if you are just copying. I mean, copying for example, uh, if we go back to the, uh, site of, you know generating like bicycles from, from example, a bicycle was made [OVERLAPPING] for- for the last ones. Yeah, yeah. Right. This slide. Right, so what was preventing it from just copying the source, that's what I mean? Yeah, I mean- [OVERLAPPING] For- for the inversion task, it's, it's learning like an algorithm, right? Right? So why is that, you know, the case it has stopped learning like to copy. [OVERLAPPING] Right, but that's a good point. But then if you see all the images, all the images are slightly different from each other. So if it just copies like one thing from one image, another thing from another image, the final generated image would not make sense at all. So that's why it has to- it's learning- in- in our opinion, I think it's learning a proper distribution of the objects that are sort of important in that image because they- all the images are slightly different from each other. You can't just like pick and copy one of them. And also, uh, an interesting, uh, point was that, um, that Ron made earlier was that in the, um, in the attention-based PixelCNN, uh, they augmented the dataset to include the positional information. Um, and we're- and basically augmented for, I guess the meta PixelCNN and also the, uh, um, the conditional based PixelCNN. So we think maybe the attention learned basically, uh, how to flip the images by looking at that augmented component, which is basically the positional, um, dimensions, if that makes sense. [BACKGROUND] [APPLAUSE] So this one is one-shot imitation learning. It's by Sean and Dan. Yeah, thanks, cool. Yeah. Okay. Uh, hello, my name is Sean, uh, and this is Dan. We're gonna present the paper, One-Shot Imitation Learning, um, to kinda describe the problem setup a little bit and motivation. Um, Imitation Learning is pretty commonly applied to isolated tasks, um, to kinda reproduce, um, you know, demonstrations we see of different things. Ah, but we have this desire to learn from a few demonstrations, um, if we're gonna try and learn, uh, a new task and instantly generalize to those new setups that we might see. Um, in this specific paper, um, the authors ask us to consider this case where there are infinite tasks to learn, each with various instantiations. However, in the paper, they have this kind of like narrow scope of that, which is, um, this like robot- robotic arm that, um, is given like two pairs of demonstrations. Um, and it- uh, where- where each task is to stack blocks that are on this table, um, in a different, um, permutation and a different, um, numbers of towers. So here, it's trying to stack, um, various blocks on top of each other in the policy, which is, um, kind of like our test time to match what's going on in the demonstration. Um, and- um, oh, sorry. Cool. Um, to- to kinda like go over how it splits up into train and test. Um, in the- the train state, you know, we get this- we get a pair of demonstrations. Ah, we have one full demonstration that we look at, uh, with it- with attention. And then from the other demonstration, um, we sa- we have one state from it that we sample. And we compute this optimal action for that state, And we compare it, um, to like the optimal action for that state, um, for the- the unseen kind of policy. That's how we compute our loss. And then during test time, we are also shown a new demonstration for a new task. Um, we- it- I mean, the-- the task will be something we haven't seen before. So some new permutation of blocks that we have to stack in some different order or in some different number of towers, um, and we get some state, we compute some action for that state, and then we'd run this loop multiple times until we achieve some terminal state. Um, to talk about how we implement the architecture or how the authors implemented the architecture of this. There's three neural networks, um, that are, you know, computing these- these different embeddings and taking different actions. So there's the demonstration network, the context network, and the manipulation network. Um, to go through them one by one. In the demonstration network, um, it receives as input some, um, trajectory, some demonstrations directory, which is a sequence of frames taken from the camera of the robotic arm, or is some embedding from the neural network that analyzes the images coming from that robotic arm. Um, its output is an embedding of the demonstration, um, to be used by the subsequent neural network in this architecture. Um, the size of this embedding depends on the se- the number of time steps in the demonstration, as well as the number of blocks on the table. Um, so the way that, um, we kind of, um, capture info of- or the- the way we make this problem tractable, um, in this neural network is we- we use temporal dropout because we might have like thousands of- of time steps within, um, our observation. We throw away 95% of them, um, randomly, and then, um, we use a dilated temporal convolution to capture information, um, from the past, but focusing more on the more recent time steps. Um, we then use neighborhood attention to map these- um, these like variable dimensional input into, um, an output, um, representing the number of query hits, um, in- in the context of attention, um, that have the same number of outputs as we have, um, inputs. So, um, it's really important, I guess. Um, the next network is this context network, which takes in, um, the current state, the observation from our camera, as well as the embedding produced by the demonstration network. Um, and it produces a context embedding, um, which kind of will tell our manipulation network, um, like what context is to a form and what action we have to take. Um, so it is important for the- the final network that its input is a fixed dimension. So the- basically, the context network traps, um, all of the contexts that we have in this, um, variably sized dimension input, um, into a fixed size output. And the way we do that is temporal attention, um, which produces a vector whose size is proportional, or basically, it removes the dependency on time in our output vector. So, um, we're only dependent on the number of blocks now, um, and then when we apply attention over a current state and we produce fixed dimensional vectors that are no longer dependent upon the number of blocks in our state. Um, and the intuition behind, um, like why we're able to, uh, remove kind of like a lot of information in these like variably sized dimensional vectors, um, is that the number of relevant objects is usually small and fixed. For instance, um, if we have this robotic arm, we're trying to pick up blocks, we probably only care about the block we're trying to pick up and the block trying to put it on top of. And finally, the man- the manipulation network is the simplest network of them all. It's a simple multilayered perceptron. Um, basically, it takes in some context embedding and produces some n-dimensional output vector representing the action for this robotic arm to take. Uh, one of the- the things that the authors leave open is the potential for modular training here. So if you have some, um, specialized, um, task where you can effectively train this manipulation network, um, it doesn't need to- necessarily need to be trained in parallel with the rest of these networks. It can be more highly specialized. Um, and that's a solution for one of the problems they noticed later on, which is where a lot of the errors they encounter in training are just because there's a result in mis-manipulation. So it will knock like some block off the table and it'll be like some irre- irrecoverable failure. Um, so you go through like just broadly, um, we have some demonstration. Um, we- it's a series of frames. We've applied temporal dropout to it. Um, we apply this temporal convolution to it, um, to- to kind of attract the mos- uh, to folks on most the recent steps. Um, we apply neighborhood attention, um, such that, ah, we can produce this like, uh, variably sized, um, embedding. Um, we apply our context network to this embedding to remove dependencies on time steps and, um, the number of blocks on the table. And then finally, that context embedding is passed into our manipulation network, which takes actions, um, to move the robotic arm. Um, to kind of stop here and briefly summarize and discuss. Um, one of the questions I had about- once I read this paper, was that like stacking blocks on top of each other, um, to me might not necessarily be a Meta learning problem, if the only like, um, difference is, um, like the order in which- or the permutation which you're supposed to stack the blocks or the number of tabs you're trying to create. Um, what do you guys think? Is this a- a Meta learning problem or not? [NOISE] So I guess I feel like some of the Meta learning problems that we, you know, talked about, like for- for example, last, uh, April, we talked about inverting an image, which is basically like you- after you've learned an- an algorithm, you're basically done, right? So I guess that could come as Meta learning. And also, if you had different number of blocks, that's like a significant difference in the things you're observing. And on the other hand, you have like potentially [inaudible] restricting yourself to like two blocks at a time. So I guess I just [inaudible] Yeah. Thank you. That's a super good answer. Um, so yeah, I think there's a potential for- for that kind of thing here too. Um, if you guys have any thoughts on, you know, whatever, I look other kinds of tasks this could generalize too [NOISE] this problem setup, I'd be, you know, curious to hear. If not, we can go into the experiments and results. [NOISE] All right. Cool. All right. Um, so the question then becomes, does- how does this model perform? So the authors tried to devise experiments that could answer the following questions, uh, listed here. So the first thing they wanted to answer was, what happens if they changed their training scheme? So the two training schemes they take- that they tested was, uh, behavioral cloning and DAGGER. And for those of you who are not familiar with the terms, by behavioral cloning, what we're doing is we're just literally directly learning- trying to learn to policy using, uh, supervised learning. But by DAGGER, what we're doing is we have an expert that is demonstrating these trajectories, which we initially tried to learn from. And then after that, we also gathered trajectories that our agents, that our learned policy is performing, and then we check those states and ask the expert to perform to like give the good actions, to like label them. And then we're gonna add that to our data so that we're like interacting with the expert as we're learning. So that's, uh, what's going on with DAGGER, uh, repeatedly aggregating, uh, data. So these are the two training schemes that we wanted- uh, that the authors wanted to test. The second one they wanted to answer is, what is the effect of conditioning on different data? So if you, uh, remember back to our network, what we were doing was looking back to the whole demonstration and use that as the input. So what happens if we just look at the very last frame or what happens if we are allowed to look at only key frames, which the, uh, authors manually selected? So how does that affect our results? The last thing was, of course, how does this generalize, does this network learn to generalize? So, um, this is the setup. They had different training and test tasks, each with 2 to 10 blocks of different layouts. And then they collected about 1,000 trajectories per task using a hard-coded policy. And they compared four models. Uh, the first two were using the same architecture that we introduced, but using two different training schemes, uh, behavior cloning and DAGGER. And, uh, the third and fourth one is- uses a slightly different input. Um, the third one only looks at the final state of the trajectory, while the fourth one, um, looks at different, uh, key, uh, snapshots of the whole trajectory. So, um, I just wanna stop here a bit and ask, uh, if anyone has any idea on like expe- expectations on how these models would differ or like how would they perform? Any guesses? If not, [LAUGHTER] I can just proceed and, uh, report what happened. But, uh, just looking at these definitions, what we could guess is, for example, um, because of the third one and fourth one, we are looking at only a subset of the whole trajectory, that's probably gonna be faster, right? And also, um, we might expect that if we only look at the final state, which is the final end image that we want to achieve as compared to the whole trajectory, maybe the performance will not be as good. On- on the other hand, if we know what are the key steps that we have to follow, maybe it's gonna be using, uh, the data efficiently that the model actually performs better. So those are some of the, uh, guesses that the authors made before they proceeded with experiments. And these are the actual results of the experiments. There's kind of a lot of colorful bars here, um, but the x-axis is the number of stages required to achieve the task at hand, uh, the number of stages. So for example, one is just- you just need to put a block on top of the other, and so on. So it's- it corresponds to the difficulty of the problem. The y-axis is the success rate. So how successful the models were in performing these tasks. And in terms of the policy, from left to right, we have the hard- hard-coded policy, behavior cloning, DAGGER, uh, only looking at the snapshots or the key frames, and the last one is only looking at the final state. Uh, yes, uh, you can make a few observations. The first observation is that behavior cloning and DAGGER actually seems to perform pretty much equally. Sort of there was- hasn't been too much benefit from human intervention or the hard policy intervention, uh, with DAGGER, the authors assumed that this might be because, um, we're already adding noise, uh, to the data. Uh, they did not really specify what noise was, but [LAUGHTER] they're adding noise to the trajectory. So they assumed that this might be what's, uh, what- why we are able to learn well. And, uh, another point that we can see is that the snapshots and final states, they're actually performing not too well, uh, which is a bit surprising for snapshots. And the authors, again, assumed because, uh, re- uh, if you remember, we were doing those temporal dropouts, we were dropping 95%. Uh, so we're doing some kind of regularization already when we're training, so that, um, when we actually get the data, we kind of know how to deal with it. Um, so those are some possible explanations. And the- this one was for the training task and this one is for the testing task. As you obviously would imagine, they perform much worse. Um, but the story is about similar here, um, the intuition that you get from the results is about the same. And another fun chart here is how- looking at how attention, um, differs across the blocks. So on the x-axis, we have different blocks, A to J, and from the y-axis, starting from the top, we have the time steps across the policy. So like as the policy carries on, which blocks we are paying more attention to. And the one- and the configuration that we want to achieve is ab, cde, fg, hij, which means that we want block A on top of block B, uh, block C on top of D, which is on top of E, and so on. So if you look at this plot, it's actually kind of interesting because they're actually blocked into blocks. Um, so, uh, in the beginning, we're looking at A and B because we have- we know that we have to put block A on top of block B and so on. So these are actually kind of well-separated and kind of well demonstrates intuitively that the model is looking at the right blocks at the right time, that it knows what to do. [NOISE] So this- um, if you- uh, recall what we were talking about. So they had two attentions. One attention was looking at, uh, different blocks. They had another attention looking at different time steps of the demonstration. So this is what we're doing here. So on the x-axis, now, instead of blocks, we have different time steps of the demonstration of, uh, BI that was shown to the model to learn, and our y-axis is the same. So here we see that again, we have the separations. Um, in the beginning, we have- we are focusing on this beginning time steps and that might be because the model demonstration actually moved AB in the earlier time steps and so on. So this is kinda interest- interesting in that they show what these attention values are and it makes intuitive sense when you look at the- uh, the, uh, plots. And they also broke down what kind of failures they had, uh, in term- because none- none of the models are perfect, including their hard-coded policy. So they have three types of failure. The wrong move, manipulation failure, and recoverable failure. A wrong move is when the final result is just wrong. The second one is manipulation, uh, failure, when, uh, the- robot basically, for example, drops the block on the ta- on- on- from the table, so it just doesn't know what to do. And the third one is recoverable failure, which is they make a mistake, uh, which they could have fixed if they were given time. [NOISE] So one example was they have been building a tower and they were trying to pick a block up and they just crashed the tower. And over time, they would fix it, but they did not finish it on time. So those are some different, uh, failures that they kind of ran into. And you see, uh, there are actually not that many wrong moves, um, uh, it's- the plot is very hard to see. But [LAUGHTER] the summary is, uh, there weren't actually that many wrong moves, except the case of when we conditioned the final state. Um, and a lot of them were manipulation failures, so they just need to manipulate the arm better. So in terms of takeaways and strengths, um, it seems like learning a family of skills actually make learning/performing relevant tasks easier, in this case, stacking the blocks. And it had an interesting breakdown of modular structures. If you remember, there were three modules. Um, some results just like that attention one was very intuitive and clear. And the neighbor attention, uh, which they introduced allowed them to translate, uh, input of variable size to weights of variable size as well. And single-shot result is actually rather impressive of, uh- you can look up the videos in your own time if you feel like it. And while not presented in this paper, the data was actually collected using simulations, not real-life images, and the person was demonstrating using VRs. So that was actually kind of cool as well. Um, some weaknesses, um, that we could think of was this is kind of the weakness of imitation learning itself, is that we have to assume that there are successful demonstrations that we- that the model can learn from, and that is not necessarily always the case. And if the demonstration is not optimal, it- if it's just running around, fooling around, then that's what our model might learn. So that's some limitation just innate in imitation learning. And as we've asked before, the tasks are quite similar, so it is a little bit questionable if you can say, "Hey, this is meta-learning." Um, it's definitely a- a step in it, um, but it is still arguable. And the algorithm just doesn't know what to do when we have a block just under four and things like that. Um, there were some other assumptions. And in terms of the actual paper itself, um, if you read through the paper, there are actually not that many equations and descriptions. So there are a lot of natural language descriptions that it's kinda hard to comprehend what the network is actually doing unless you read the actual algorithm, which is like a full page in the appendix. Um, and they only discuss a single experiment, which is stacking the blocks. Uh, so it'd be nice to see what other tasks could have been carried out using this scheme. [NOISE] And also, they actually never really defined what action is, uh, in this paper, at least we could- um, from what we could read. So that was, uh, kind of sad. Um, so these are some further questions that we could think of, um, and we have some discussions as well, and, uh, we could go into discussion questions, but as we're almost done with time, if there are any questions, we'll be happy to accept them right now. So is this super clear? [LAUGHTER] So how did the artist [LAUGHTER] take care of the different task which has different blocks? Sorry. So how did the artist take care of different task each having different blocks? So how is this case entered when the project has to have different number of blocks? Right. Um, so [NOISE] that'll depend on, uh, the- the network structure as well as the neighborhood attention mechanism. Um, so that's what allowed us to have like variable length of inputs. And so, for example, like a- at the attention of a demonstration, at that stage we'll have still variable length, but after context network, then we would end up in as an aggregated fixed size dimension that they could like process and go with the action like- choose an action. Yeah. Okay. Let's [inaudible] Okay. [APPLAUSE] [NOISE] Yeah. So the next presentation is massively multitask networks for drug discovery and it's being presented by Andrew, Weston, and Justin. Hi, I'm Andrew. I'm Weston. I'm Justin. Er, we'll be presenting on the paper, massively multitask networks for drug discovery. Uh, so the first question that we have when reading this paper is what is drug discovery, uh, as that we're not in, uh, pharmaceutical engineering or anything like that. Uh, so the goal for pharmaceutical companies is going to be something like, um, they have different drugs that are testing out, um, in an effort to find some attractive molecules for further optimization. Um, but the problem with this, um, is that there's a lot of different compounds and their interactions are pretty complicated. And so one of the ways that they try to go about doing this is by automating the process using machine learning. Um, and the goal there is to predict the interactions between the different targets and the small molecules that are present within, um, their compounds. So for example, in this dataset, like the dude-inha, um, the target might be to, um, find which of the active molecules, uh, might be targeting the enoyl reductase. So, um, for studying this as a machine learning problem, one of the motivations is that the datasets are extremely imbalanced. Um, in fact, only 1-2% of the screen compounds were active against a given target. Um, and we know that these kind of extremely skewed, um, distributions can cause our machine learning algorithms to have problems. Um, the second is that they're very disparate sources of experimental data across multiple targets. And so there's 259 datasets altogether, uh, with 249 tasks. Um, but as you can see here, there are different classes of tasks that we have. Um, and there's not perfect overlap, um, across these different datasets with the different tasks. Um, and so it becomes an interesting, um, case of like what kind of information is present in each dataset and each task, uh, such that the algorithms are able to, uh, profit from multitask learning. And finally, uh, at least in the domain of drug discovery, uh, prior work is unclear whether as to multitask learning is actually beneficial in drug discovery. Uh, so there was a Kaggle competition in 2012, um, but wit- one of the criticisms, um, to the model that was the winner in this competition was that they had too small of a sample size and the gains in predictive accuracy were too small. Uh, another paper by Unterthiner, uh, was that the performance gains, uh, were positive. But then there was a different paper in 2006 by Erhan, which said that, uh, multitasking networks did not consistently outperform single task networks. And so this paper tries to add an extra data point in, um, this literature of multitask learning, oh, at whether as to it actually is better than single task networks. So to give an overview of the method, uh, the first thing that's necessary to do this task is to figure out a way to featurize molecules as that's what our datasets are, there are molecules with whether they're active with a specific target or not. And it turns out prior work has done this before the paper. And there is a way to featurize molecules by looking at different points on the molecule and looking at what it is connected to and have an embeddings for different molecule pieces. And then, sort of hashing them together into a fixed length vector. And the way the method works is it takes as an input layer, this fixed length representation of molecules, um, using the embedding we talked about in the previous slide. And it feeds it through several hidden layers, 1-4, with a variable number of nodes. The, um, the paper tries several different architectures with the different variable number of nodes in each hidden layer. And the last layer, it's a very simple multitask network. It's just a different softmax node for each particular dataset. So, um, most of the parameters are shared, and it's only at the last layer where you have task specific parameters. All right. So they tried to, uh, understand how their models are working through a number of experiments to answer a bunch of questions which are: "How do you know multitask neural nets perform relative to baselines? How does adding more tasks affect the accuracy on a held in set of tasks? Uh, would we rather have more tasks or more examples? How does adding more tasks affect pre-training accuracy? And then, when do datasets benefit from multitask training?" Uh, so Experiment 1, how do multitask neuron- neural nets perform relative to baselines? Basically, they're just training a bunch of simple machine learning models on each of their tasks and then compare their, uh, multitask networks to those baselines. So the first five lines here are four simple baselines, logistic regression, random forest, and two simpler neural nets. Uh, and then the max here is just, uh, the like task Y's max. So taking the best model for each task and evaluating those. And then, they train two multitask networks and showed that these multitask networks do better. Um, the first one just has a single, uh, hidden layer of length 1,200. And they note that this is not the best design because if your final hidden layer is 1,200 long, then each of your softmax nodes needs to have 1,200 parameters. Whereas if you have a, uh, two hidden layers where you have 2,000 in the first one and then 100 in the second one, then you only need 100 parameters per softmax layer. And so that allows you to avoid overfitting, uh, to individual tasks in those softmax layers. Um, so then, in Experiment 2, they ask, "How does adding more tests- tasks, excuse me, affect the accuracy on a set of held-in tasks?" So they set this up as, they trained a bunch of models on the same 10 tasks, and then, uh, add a variable number of additional randomly sampled tasks, and observe the accuracy as a function of the number of additional tasks. So the things that can happen as you add, uh, more tasks to your model are either you kind of increase your accuracy, uh, continually as you add more tasks, you plateau as you add more task and you don't really get any gains in accuracy, or you go up for a while and then back down and some amount of tasks begins to hurt you. Uh, so they run it on some held in set of 10 tasks and they find that on average, uh, the accuracy continues to increase over time. Uh, but notably, for many of them, the accuracy initially decreases with addition of some tasks. Yeah. Sir, I think you guys have said this before. What- what's the definition of a task? Great. So a task is, uh, something like this. So you have a- uh, basically, you wanna know whether something [NOISE] will interact with some target. Uh, so you have a bunch of different input mol- molecules and you're asking, will it interact with this thing? [BACKGROUND] Um. So yeah, so each of these colored lines is an- different individual, uh, interaction. And then the black line with the confidence interval in the middle is the average. So on average, it continues to increase over, uh, with the addition of additional tasks, but in many cases, it actually hurts the accuracy at first and then goes up. And in some cases, it continues to hurt the accuracy and it doesn't really recover from that, no matter how many tasks you add. Uh, and they only really addressed the average case here. They note that sometimes it decreases, but they don't offer any explanation of that, which I really would have liked. Um, [NOISE] and they also choose these 10 tasks, but don't analyze any of the other tasks, uh, which I, I think that this result is probably sensitive to the task that they chose, uh, and I would have liked to see it on all of the tasks, kind of different types. Uh, so then in Experiment 3, they asked, would you rather have more tasks or more examples in our dataset? Uh, and so here, uh, the x-axis is the addition of new tasks, the y-axis is accuracy, and then these different colored lines are additional examples in the dataset. Uh, and basically, they both help kind of orthogonally, uh, and you can see there's trends in, uh, in both directions as you add data points and as we add tasks, which is what we'd expect. Uh, unfortunately, the confidence intervals here are really wide, and I think that's because they did the same setup as here where they chose these just 10 held out, uh, hel- held in, rather, uh, tasks and evaluated on those rather than evaluating on all kinds of different tasks. Um, and so I wish that they had done that, uh, to have some more, uh, general- generalizable results to all of their tasks. Uh, and then finally, Experiment 4, they asked how does adding more tasks affect pre-training accuracy? So if you pre-train a model on a bunch of tasks and then, uh, use those ways to initialize a model- a single task model for a new task, how does that affect the accuracy? Uh, and again, they said that on average, it continues to increase a little bit, but in some cases, it hurts a lot. Uh, and this time they actually point that out and say, "We hypothesize that the extent of this generalizability is determined by the presence or absence of relevant data in the multi-task training set." Uh, and this is the only analysis they give of this, which, uh, I feel like this is kind of an obvious statement, that if you're pre-trained on something that it matters how relevant the data you're pre-training is, uh, and really I'd, I'd like the whole paper to kinda be addressing this point, that how do we decide if data is relevant or not? Uh, but they don't. They just say that sometimes it'll hurt you, uh, and that's it. Um, cool. You're gonna talk about the last one. Yeah. So the last experiments, um, or the last set, set of experiments they do is to try to figure out when specifically do datasets benefit from multi-task training? So uh, first way we going to test this is they create this metric called active occurrence rates, which is basically for a specific dataset and a specific molecule. They measure the number of other datasets that that molecule is also active in, and they sort of want to see if a molecule is active in a lot of datasets, um, does multitask learning help that, um, train better for a specific task than it would if it's only active for like a small number of tasks? And as you can see, um, this graph sort of shows what the active occurrence rate is versus how much it helps the specific tasks problem for doing multitask learning. And, um, well, it's a- it's a very noisy graph. You can see [NOISE] there's clearly a positive correlation between what the active occurrence rate is and how much it helps to do multitask learning. And in this vein, another thing they want to figure out was, is there a specific class of target molecules for which, uh, multi-task training is more beneficial than any other task, um, or any other category of tasks? So they put them in these categories, and ones that didn't fit an obvious category, they just put in a miscellaneous category. And, um, each black dot represents a specific target, um, dataset. And it appears there's like, not much difference in what kind of benefit you can get from being in a different category, although some of them do have like marginal variation, uh, but in general, it appears this, um, the benefit for multi-task learning isn't really that dependent on which category it's in. All right. And uh, to give an overview of what we thought the strengths of the paper were. Um, primarily, we thought one, it's a very detailed empirical analysis on real-world data, which is always a good thing in a machine-learning paper. Um, they're able to tackle a challenging problem with an extreme data skew where you're doing a binary classification, but only 1 to 2% of the input data is actually active, uh, which is a very difficult problem in general and they do it well here. They use a simple network which enables for very detailed and simple analysis. And they're exploring under what conditions multitask learning produces positive and negative results and have very thorough experiments on the specific real-world problem. And they also achieve results using a multi-task network that outperformed any other baseline that they could come up with, which, um, is a positive showing that this multitask learning is actually beneficial for this particular type of problem. [NOISE] Um, but at the same time, there were some weaknesses, um, as are there in any other paper. Um, so the first weakness is that there was a huge correlation between the data size and the number of tasks. Um, just because for any given dataset, uh, you might find that it only has five tasks or something like that. And so, you know, if you have 40 tasks but each dataset is only able to have, uh, five tasks in each, um, then there's not going to be as much overlap. And so, um, that was a big limitation that we saw in one of the, uh, quite a few of the experiments, uh, where if you actually wanted to see, um, what is the difference when you have 20 tasks versus 40 tasks, um, the amount of data that you can actually have in the, um, 20 task case is going to be very different and very much smaller. Um, the second is, um, while they gave us some good intuition, um, there wasn't much, uh, theoretical justification when or when to not use multitask learning. Um, obviously they draw upon some, uh, a level of, um, like domain knowledge and saying that, uh, perhaps these things are categorized as certain types of tasks, uh, or maybe there is some relationship between the size of the dataset and then, um, the variety of tasks that are employed. Uh, but again, I think as an empirical paper, um, it does give us intuition, but not so much a strong theory to go upon. Um, and lastly, uh, whereas we did praise the simplicity of the network, uh, for this analysis, uh, we all do also wished that they could have explored all of the architectures, uh, given that, uh, this is a real-world problem. It could be interesting to see, okay, how far can we go with this drug discovery, um, as an automated process. Cool. And then potential improvements which are related to weaknesses. Uh, so both more theoretical and more empirical results on task overlap, uh, and how that is going to affect our accuracy, um, maybe something like an analysis of how covariance between classes is going to, uh, help classes learn from each other, uh, or something simpler, just like saying, "So we have these different categories of tasks. If we train a single model that does all of the tasks in one category, does that give us better accuracy than mixing all these tests together?" Uh, and I think you probably could have gotten some more, uh, fine grained results from doing that. Uh, controlling the training set size versus the number of tasks. So it would have been good to say like, uh, control the number of like fixed X-Y pairs that are going- being fed into the model during training time, whether they are on different tasks or the same x value rather- the, the same x-value on different tasks or the, the opposite. Uh, also comparing different architectures like we said, um, they only do this one very simple, uh, embedding and the one, uh, multi-layer perceptron, uh, setup. And they do say that their results are kind of dependent on using these smaller second hidden layers, but they don't offer any analysis of how it changes, uh, as they change their architecture. Uh, and then finally, they could have bench-marked against, uh, models from related papers. They say, basically, that, uh, it's hard to do, so they didn't do it. But I feel like there must have been some result that they could have said compared to some other model or some other method that people are using. Uh, takeaways. Yeah. So, um, as, um, machine learning researchers and not chemists, we're interested in what can we take away from this in our own modeling. Um, so first is, uh, what seems to be the thesis of this paper that multitask learning can yield superior results to single task learning. Um, and that there- second, there's limited transferability to task not contained in the training set. Um, they say limited because they saw it in some cases and not others. Um, third, multitask affects stronger for some datasets than others, so it is pretty heterogeneous and, um, it seems to require some level of domain knowledge if you're going to employ multitask learning. Um, fourth, the presence of shared active compounds moderately correlated with multitask improvement. Um, again, this, uh, this was in relation to the fifth experiment, um, where they saw that, like if a molecule was, uh, in 30 task versus only in 5 tasks, then it would, uh, benefit more from multi- multi-task training. Um, and lastly, the efficacy of multitask learning is directly, uh, related to the availability of the relevant data. Uh, again, pointing to the fifth experiment, um, looking at just how many tasks each data point is associated with. And that concludes our presentation. Are there any questions? [NOISE] Then thank you. [APPLAUSE] So hopefully, some of the limitations in those papers will inspire some good final projects for the class, uh, and I'll see everyone on Monday. 