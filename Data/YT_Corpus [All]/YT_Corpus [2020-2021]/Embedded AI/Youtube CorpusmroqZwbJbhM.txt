 [Music] this lecture we'll talk about what a protocol stack is really define that term we will go into a little bit of detail a little bit information about how a protocol stack is defined now remember though that in practice certainly in this specialization in practice you're not going to be writing a protocol stack making a protocol stack but you can use a protocol stack so you at least we want to know what this term is because it gets thrown around right if you want to make a new embedded system you say well i need to be networked you know internet which protocol stack am i going to use right which implementation of the protocol stack will i use you need to know what that term means because it gets used a lot when you're actually coding things you should know basically what it means so not all the details that i'm talking about will be important in the long run but you should see it all once because you will it'll give you a better context about what you're using so osi layer concept so the idea about taking these protocols and making a stack different layers of protocol is that you've got these multiple layers different tasks different networking tests you have to handle these tasks are associated with different layers of the protocol stack and each layer is implemented usually in software actually some of the lower layers are implemented in hardware so some are hardware somewhere in software that doesn't the difference doesn't matter too much to us right now certainly the top layers are in software but the idea is that a message say you want to send a message okay so you make this message and we got our picture up here this message.m m is our message and that's just that's maybe just the payload okay that is what the data that we want to send so then that is basically an input to the to a layer let's talk about the first layer layer r let's say is the first layer the top layer so that goes into it into the the code so that code takes the message it makes some kind of a decision uh whatever decisions are made at that layer and then it puts the results of that decision into the header of the message producing a new message m-prime down there which is now bigger it has whatever was inside m and it has additional header on the outside of that right so that's so at every level that happens so the first level so for instance here let's say this this level is performing routing okay so the goal lev this level is to take a message and figure out a sequence of machines that it will hop through to get to its destination so at this level it takes a message it finds the route it says okay you need to go through machines a b c and d right that's sequence so it could take that sequence that whole sequence of mess of uh nodes put that into the header of the message and then output this new message m prime which is the same old message but now with this extra with this routing information contained inside the header so that's the general idea that at every level at every layer uh the code or the hardware whatever it is that's implementing the protocol will make some decisions like routing information arbitration information flow control information and then the results of that it'll put into the header or some of the results it'll put directly into the header and you'll get a new message out which is bigger than the original one right which now has this new header data this is on the sending side so this is the idea and you have a stack of these layers so that's what they mean by protocol stack you have layer after layer and they call that a stack now encapsulation is used to mean that that the protocols they are they're separated from one another in some sense so each layer each protocol layer is separated so all these these um these different tasks that need to be formed say routing right that is mapped to a particular layer that is performed by the protocol information stack at this layer and other layers do not have to deal with it so it is encapsulated it's separating the different layers and the whole point of that is to make it simpler to understand and also to write code right so as a programmer if you're dealing with the layer that deals with routing then that's all you have to think about you don't have to think about flow control because flow control is dealt with at another layer so that's what encapsulation generally means and a protocol stack is the implementation of all the different layers put together so at transmission when you want to send a message basically the messages start at the top layer and then they go down right so you put the message into the top layer protocol it makes its decisions adds to the header passes it to the next layer which adds makes some decisions adds to the header and continues until you get to the bottom layer now the bottom layer is called the physical layer and that that layer it actually takes the data and puts it onto an electrical uh electrical mechanism a transmission mechanism some kind of medium so that means one of two things either wires so physical layer it encodes the data onto wires physical wires or it encodes it onto onto wireless broadcasts radio broadcast so one of the two so always at the bottom layer there's this physical layer which actually transmits the signal either by wire or by or through the air through um through radio now at the receiving end uh the message comes in uh remember it's sent physically right so it's on wires this bunch of electrical signals on wires or sent through the radio so at this end the messages go up through the same protocol stack so that means when it's received it's received at the physical layer right because it's physical signals either wired or wireless they come in and then they have to get deep get basically recoded back to the original data right so so now at the receive again these messages are going through the protocol stack up from bottom up and so the uh the opposite of what happened on transmission happens here so at every layer the message gets received the header appropriate header information is read and used and then the new message that's produced is actually smaller than the first message minus that header information right and then it goes up to the next layer which takes the uh the header information at that layer dot uses that and then sen you know produces a new message which is smaller and so by the end at the top all you have is the actual payload and all the header information has been stripped off so that's what happens at the receiving end and it's the reverse of what happens at the transmission side thank you you 