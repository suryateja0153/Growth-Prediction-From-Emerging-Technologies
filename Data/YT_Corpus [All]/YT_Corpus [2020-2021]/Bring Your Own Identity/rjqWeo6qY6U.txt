 Next up, we actually have Mark Chmarny, who's going to be talking about identity management in distributed applications using Dapr. As I mentioned before, oops, sorry, my screen share here, you can always find information of all these sessions at aka.ms.TheLaunchSpaceKurbernetes. I see Mark's here. Thanks for joining, Mark.  Hello.  Welcome for the session. Please take it away.  My name is Mark Chmarny. I'm one of the product managers working on Azure here at Microsoft. So far, if you follow the day over TV learning here, a lot of the things being focused around the infrastructure and operational side of things. I want to make a slight switch and focus a little more on the developer experience and building applications. I'm going to share today about Dapr specifically as far as building applications or microservices with Dapr, and then using identity for the different microservices to manage the access control and the different things that the applications can do. Let's jump into this, a very quick intro in case you're not familiar with Dapr. It's hard to reduce an entire project to a single sentence, but it's a portable, event-driven runtime for building distributed applications. Portable, we're going to talk about fair amount of that. There's a lot of content already online about it. The project that was created by Microsoft about a year ago in open source. Since then, it has grown pretty quickly. There is close to 10 million image pools every month. There is also about 450 or more than 450 different contributors from broad number of different companies. If you want to learn more about Dapr itself, Dapr.io is a good place to start. Let's go very quickly into the logical layers of what would make Dapr in a form of an introductory into the project. Dapr is agnostic with regards to the language you're using, so polyglot. I mean that you can bring whatever language you're already developing and you're familiar with, whether it's JavaScript, Python, C-Sharp, Go, Java, Rust, or whatever else you want to bring in there, and use that language to accelerate or speed up how quickly you develop different services, and make sure that you can use the best practices that are available for that particular architecture. What Dapr does, is it creates this runtime that you can execute. It runs on any application or any kind of platform that you want to deploy to, so obviously runs on top of Kubernetes, which we are focused on today, but it also runs on your laptop during the development and can ran on a bare metal VMs as well as an Edge devices all the way down to Raspberry Pi even. Because it's a framework, Dapr exposes these two set of APIs. That API have parity between them, so there's no difference of features, but they're exposed through different protocols. We have an HTTP API and gRPC API. Depending on which language which your comfort level with different one of those languages and its protocols, you can leverage them in different applications, and you can mix and match. For example, if you're building a microservice application that includes three different microservices, one of them could be in gRPC, another one would be HTTP, and Dapr can actually help you with a lot of the translation between communication across those. The part that I want to spend a little more time about is talking about the building blocks or these kind of middle layer in here. Because I think this is what really distinguishes Dapr from a lot of other runtimes, or frameworks, or platforms out there. If you've developed applications over the last, let's say 10 years in modern Cloud-Native applications, you probably have noticed that a lot of the patterns that you're using to build this applications are very reproducible. Every one of your application has some notion of a service invocation or pops up. What Dapr does is it codifies these best practices or the common practices and makes them into reusable in a form good building block, so your application can actually externalize these dependencies outside of its code and focus only on the business logic, which makes you much more effective, allows you just swap these components a lot easier, and obviously increases the overall portability of an application because you're not bound to a specific implementation. These building blocks or these common patterns are just a facade or APIs that are exposed by Dapr. But the actual implementation behind them can be done through a number of different solutions out there. I'm going to talk about those in a minute. Let's very quickly go through each one of those. For service to service invocation, which is basically, if you're building an application that includes multiple microservices, you're going to have to be able to discover these services and invoke each other from each one of the services. Data provides a service discovery, it provides a mechanism for invocation regardless of the protocol that you're supporting, as well as allows you to obfuscate the location and the number of instances that this application runs. The invoking application only needs to know the ID of the application. There's a fair amount of sugar that Dapr adds on top of that around retries and commonality of error controls across different protocols, and throttling, for example, that allows you to focus, again, purely on a develop. Now, if you're building microservices and you think that direct servicing invocation is actually anti-pattern and you don't want to do that, Dapr provides asynchronous pattern for pops up that allows different microservices in your application to communicate asynchronously using messages. What that means is that the publishing application doesn't need to know anything about the backing application, the subscribing application, the consuming application, and vice versa. That increases the overall decoupling and flexibility of the overall application, allows you again, focus only on writing the business logic that you need to do. For pops up, for example, there's 10 plus different implementations or different components permutations you can use, whether it's something like a Kafka, RabbitMQ, and NATS, also, a managed service like Event Hub on Azure. After that, if you're writing anything nowadays, you're pretty much going to have to have a durable state. Meaning that as the session of the user expires and the user comes back again, you don't want that user to be just treated every single time as a new request. Dapr, in microservice world, the idea of saving that state to the local disk could be a very much no-no, so Dapr provides a distributed state management, which means that you can rely on this key value store to be durable, means your services, even if they're restarted, they can come back and retrieve the state. We provide implementation for state building block like Mongo, Red Hat, Postgres, as well as something I manage like a Cosmos DB on Azure. Next one, if you're building applications and have a dependency on different external resources or even storing anything sensitive, you going to need to manage secrets. Managing secrets in a distributed dynamic application tends to be very complex, and that's why we see from page announcements all the time about yet another set of secrets that had been leaked, either by committing to GitHub repository or by somebody accessing incorrectly. What Dapr does, it tries to generalized the way you consume secrets, both inside of the user code as well as inside of the configuration that you describe your application with, and provide a pluggable mechanism by which the different implementation for where you manage the secrets can be pluggable. So obviously, HashiCorp Vault, Kubernetes secrets natively if you're running inside of Kubernetes. But as well as managed services like Azure Key Vault, you can do those without changing the actual application, because, again, the applications just consumes the very common and standardized set of APIs. Now, these four first patterns being very generic and you had a very common way of dealing with this things. The implementations are totally different, but the actual way you consume those are pretty common. But eventually you get to the point where you need to consume something that's very specialized and external. We call those resource binding, and provide an interface inside of Dapr that allows you to interact with those external resources even though they're very specific. So something like a Twitter API, or Twilio API or Kafka, whatever that may be, but still have a consistent way of assuring the configuration of those resources and defining of secrets inside of these resources, or even tracing around and logging around the access to those resources. Resource binding allows you both interact with resources that you want to invoke from your application, which we call those outbond bindings, as well as inbound binding, which trigger your code, for example, based on external event, let's say a tweet was published and were going to costume that, you write a logic that only is responsible for processing the tweets, all the binding of those resources to your application is done automatically by Dapr. Now, because of the way the Dapr is implemented, and we're going to talk about this a little more, Dapr has a full knowledge of the entire knowledge graph or the call graph that it's implemented to your application, which means that it can provide a very detailed observability around both the logs and metrics that you normally would do, but also as well as traces. That means that without creating any special spans inside of your application, whatever code you're using, you can actually get a visibility around the invocation and the duration of the invocations and counts and so forth. It's a very powerful feature that's automatically enabled inside of Dapr, and you don't have to do anything inside of your code. Again, the focus is on helping you writing the logic that actually makes your application unique. Then finally, we have Actor model. If you've followed either the Orleans framework from Microsoft or Akka, you might be familiar with the concept of Actors. Dapr generalizes that concept to the point where the logic and a state is actually combined together. It's a single threaded model for allowing the application to define a specific functionality. It's very common in IoT devices or something like that. It is single threaded, so if you're looking for a high IOPS and that's probably not the solution because it is going to be locking, but there is lot of use cases where that approach works. You can gain a high density of workloads, thousands and thousands of Actors in something that normally would have been just one pod. So that's basically Dapr at its high summary. Let's go a little deeper. When you start to using Dapr, and we're going to talk about how that is accomplished, you're creating a Virtual API, a site card that sits next to you, whether your running on a local machine or whether you're running on a Kubernetes. I know Kubernetes has this construct of a sidecar, we are using that same exact approach, whether your running a local machine during the development or on Edge devices, or on a bare metal, because what Dapr does, it created this sidecar that sits next to you and provide you that API. Like I said, that API exposes this consistent way of invoking all the other resources. We talked about state and pops up in binding, but also what Dapr does is, when you start invoking another service within your application, it provides a secure communication using MPLS across those automatically. So your application doesn't do any secret management, and it doesn't do any certificate management, it just focuses again on the actual logic. How do you get that magic sidecar we just talked about? First of all, in doing the development, you run it in launching your normal application into pattern that you already do, so let's ignore AppJS or something like that, you're launching it using Dapr. Dapr run, there's a few additional parameters you have to provide, like the name of the application you want to use that's going to be known for all other applications. The protocol you're going to be using, a couple other configurations around the components that you're going to be using. That configuration is specific to that one instance of the application, which means that in a single application, you can use some components that are specific to that in another one [inaudible]. Now, I wasn't going to list all the examples, but the exact same thing you can do in Python. Eventually you can actually compile your application running as an executable, whether it's a Windows executable or Mac or Linux, it really doesn't matter whatever platform you can run. Dapr compiles into, obviously the three different platforms, Mac, Linux, and Windows, but it also compiles into RM and MD architectures, whenever somebody requests a new one, we keep adding that. There's probably eight different distributables at this point. Now, in Kubernetes, what we want to make sure is that this is very idiomatic, meaning if you are already building application or Kubernetes, you are already familiar with deployment. Deployment is a unit of workload definition for your application. What we are doing in this case, we're actually just using the annotations to allow you to define additional parameters. The very same parameters you were using to launch your application using Dapr run, you can define them as annotation attributes, and those are just launched with your application that allow your application now to create that sidecare inside of Kubernetes and get the exact same API that you had on your local machine. Different mechanism, exact same API, everything works exactly the same. This was super quick overview of Dapr. There is a full-blown webinar we've done recently that goes through each one of those much more in depth. I encourage you to take a look at that. Let's go into the microservices. I talked about this little as part of the initial invocation, but I want to go a little deeper into this. If you have something like a Front application that's using the Card application on a back-end, and your Front application is developing HTTP or exposes HTTP protocol, and the backend Card application uses gRPC, which we can actually do is not really even worry about it. What Dapr allows you to do is just use that same exact consistent API, invoke that application. In this case we're calling the Invoke Card, and then specify which method you want to invoke on the other service, and Dapr will translate that protocol, invoke that service, take the information and send it back all the way back. So front-to-back dealing with the entire discovery invocation. For example, the Card application would be overloaded or something didn't work. Their retry would be automatically handled. It's configurable how you do it. The throttling between the invocations as well as error translation, for example, you've thrown in a gRPC error. The error was translated and communicated back to the Front-end using HTTP. Because Dapr is so easy, day 2 or day n, you start having these number of different applications that are all over the place because it was so easy to build us up microservices. So how do you create a mechanism to make sure that these services are able to talk only to the right set of services. If you're deploying into soft multi-Tenant environment, let say inside of your company, maybe using namespaces or maybe crossing namespaces instead of Kubernetes, how do you enable this to be much more declarative and controlled so that you have guarantees around who can access your application at any given time? We've talked about this slide, that Dapr has this notion of a sidecar. These applications are defined by their IDs, so we have app 1, app 2, we talked about the fact that Dapr uses MPLS automatically to communicate between those. What we actually do inside in addition to that, Dapr is leveraging a specification or a protocol that defines the identity of the application in a URI format. What that means is that we have that SPIFFE identity, say unique identifier for the application that's combined with the trust domain within which that ID was defined. Dapr use that identity to then identify the applications, both the calling from as well as the invocation policy for when that application is being called. That identity is actually encoded into the TLS certificate. So you have no new way that you have to look into, but Dapr automatically packages that certificate in the SPIFFE ID into the TLS certificate, and it decodes it on the other end, so the policy can be simple and plain to write. SPIFFE is quickly growing in popularity. You've heard already the open mesh presentation before this one talked about integrating this in the future. Hopefully we'll have much deeper way of communicating between different projects that it's agnostic to the specific technologies that we're using. Now, when you come into Dapr using the SPIFFE identity, you have a deep knowledge of the application, one being invoking application 2. You can use access policies to control who the application is and which type of functionality that invocation can be performed, because it's all done inside of a trust domain. Let's talk quickly about demo. It's usually good when we talk about this abstract technologies to provide some real-world example. This is pretty fully-functional application, we're going to share a link later, too. A place where you can fully reproduce the entire thing. There is no magic in here. You go in and you follow the steps to reproduce the entire application. But what are we going to do is a simple application that exposes account API that can be invoked externally. It also persist the state across the invocation, so if you come back that count obviously the increments. Also does some back process processing invocation using pops up that allows application number three to process their submitted events. It has secrets. The components are defined in a different name space. It has external ingress. What are we going to do during this demo, because there's going to be a lot of moving parts. Let's go through this quickly. First of all we're going to daprdies the ingress itself. Allow the ingress, in this case NGNX, to be able to be part of the larger solution inside of dapper. We'll have its own identity and we can trace the information, the calls that are being invoked on the Ingress. The Ingress is going to expose SSL endpoint. What we also are going to do is internally, we're going to define this cross-domain that allows us to treat these three applications that are individual as one unit and make sure that they can talk to each other at any given time. We're going to make sure that these two application that actually you need to have access to secrets are the only two applications that can access secrets, and only that one specific secret that they depend on, the Redis secret. We also want to make sure that the state component is only accessible from application number two, and that the pops up is accessible from application two and three and that application two can only publish and application three can only subscribe. Very hardened environment that tightly define only the things that can be done. First of all, it says nothing can be done and then it explicitly define what can be done. Enough of slides, let's do actual demo in here. For that, what I'm going to do before we get to command line, I'm going to quickly go through VS coding here and just show the deployments. Let's see if I can make this little bigger. At some point, this is going to be too big. But what we have here is the actual deployment. You should be able to follow this. Again, a few annotations in here. We define that yes, please, give us the Sidecar from Dapr, the application number one and all the other configurations. But one of the things in here as we're defining is that the configuration for the application is actually going to be managed in this configuration object. Let's focus on that. A couple of things in here. We say that we would like to have a sampling rates for our tracing application 100 percent. This is a number between one and zero, one means actually everything, every single call is going to be traced. We're going to say that we want to deny for this first application, it doesn't need to have any access to Kubernetes. I'm going to say deny everything. This application should not have access to any secrets. We also going are to say that this application is going to be part of a trace domain. We are going to deny every invocation except the NGNX Ingress, who itself is going to be denied everything except this one method called Ping, which only can be invoked over post and that's the only one we are going to allow. We're going to go through these one by one. But in application number two, you will see exactly same thing, saying we're going to allow only access to one secrets. We're going to allow only invocation on a counter over post. The one thing I want to do focus on is these components that we've defined before, they are very generic. You've seen us talking about the pops-up component. In this case we're using a Redis pops-up component that has secrets. Obviously we using the connection string and passwords in here. But the one thing I want us to talk about is that to define these complex policy that allows only these two applications to be able to use this component, you simply define the scope for that component that can be only accessed from application two and three. You can't make policies any simpler than this. Similarly, for publishing to limit which application can publish to a topic and which can subscribe, you do the exact same thing in here. Let's quickly go to our console in here. I've deployed this entire stack before because it actually takes a minute to deploy it. But what I want to do is actually demonstrate. Hopefully you can see this. What are we going to be doing is simple curl command against the external https endpoint that we're going to be invoking the application number one with a simple Ping request. For demo purposes this application doesn't have to be any more complex. When we do that, the entire call stack was traversed and everything we wanted, we got back from this. There's account, as you can see, I've been doing a lot of these demos, this returned. Now what I want to do next though, is show you what would happen if I, for example, try to access the second application externally, which we know we've prevented this from happening. What Dapr will do automatically is recognize that the policy is not allowing for that to happen. It will send you pretty detailed error, but actually the http 403 is all we need to know here. We've been preventing to access. Now, you might be saying, hold on a second. You've just shown me an external Ingress. Why would I want to do that? Maybe I don't expose my application this way. What are we're going to do now is I'm actually going to forward local ports to the second application because now we are inside of the cluster, I want to show you here what would happen if I actually use the exact same invocation from the SEC application number two upstream to application number one, which clearly is not part of what we enable. You would get exactly same error, because the context of the invocation is not physical layer, is how you got there, but the actual real identity of that application. That exact same principle doesn't work only for service invocation. Here, we're going to try to publish to a topic that wasn't part of our policy, again, from inside of application two. Application number two is actually allowed to publish to pubsub. But it can only publish to this one message called count. Test doesn't get, we get the error saying that you're not allowed to publish to this one. It works exactly the same way for secrets and all the other APIs that Dapr expose. In retrospect, you've seen this, the logic of the application is pretty simplistic, we're doing simple counts. It is a representative of what you would see in real life here. They stayed, you have pubsub, you have secrets, you have invocations from outside for only one service. For example, directly invoking application two or three was prevented. It should be pretty real. Here's the link, daprdemosaka.ms. You should be able to go in and follow those steps to reproduce the entire demo, including compiling your own images for this application. In closing, dapr.io is the single place if you've forgotten everything else about the presentation I've given today is the place to go. The actual project itself is on GitHub and under MIT licenses all open source. You can take a look at github.com/dapr. There is a pretty robust community of different areas of the interests around Dapr on discord that you can access Twitter, daprdev, and there's a bunch of videos that go in depth into specific areas or components or the ways of dealing with deployments in different environments. If you can't find anything else, mchmarny@Microsoft.com is how you can get hold of me and I will connect you with the right people. Hopefully, this was helpful.  Very helpful. Thank you. I just want to say I have posted some of those links in the chat as well, so you can access them right now. Otherwise, you can always go to our page which is aka.ms/TheLaunchSpaceKubernetes. If you share my screen here I can show you a couple of those different things that you've just highlighted actually. Mark's session is here. I've got a couple of links to Dapr site and the demos on GitHub. The Dapr site is here as dapr.io, as Mark mentioned, and you can see the actual repo with his demos as well on GitHub at the link in the chat. That concludes. Thank you very much Mark, that was wonderful. I do have a few questions for you actually, before we go. A couple of questions, you mentioned before, different languages that Dapr supports, what about frameworks that Dapr supports, like Spring Boot or.NET.  Absolutely, yeah. Dapr has in addition to these very raw protocols like HTTP and gRPC, it has actually set of SDKs that you can use to interact directly with, that obfuscate the protocol plumbing and so forth that are available in C Sharp and Java, Python, Node.js, Go, as well as integrations with framework, like you mentioned, Spring Boot for example has a nice integration for Dapr as well as.Net itself, and there's a working project on a Python integration into some of the frameworks there too. Much deeper than just language itself, actually providing integration into that plumbing of the framework itself.  Absolutely. Great. Thanks. Hey, we've got a couple of questions from attendees as well. The first one is, what are the components and configuration for Dapr? Yeah, go ahead. Sorry.  Yeah, when Dapr has some primitive set of objects, inside of Kubernetes itself, it depends on the deployment for the deployment which is the native Kubernetes object, but in addition, when you install Dapr into the cluster, it configures two additional or three additional objects in there, two additional CRDs with few objects. The configuration itself, it has additional ones around the actors and few other ones, but pretty much that's all. It's pretty light on the integration and tries to use whenever possible the native objects inside of Kubernetes.  Okay, great, thanks. A little more involved question. In case of spiffy identity, what will context of the SSL with regard to, I believe, domain name and ID? Let me ask it again. Spiffy identity, what's the context of SSL with regard to domain name and ID? There's a couple of spelling errors there, I lost him.  Yeah, I would have typed it just as bad. Dapr automates the generation of the spiffy ID. In case of Kubernetes, it will use the namespace plus the trust group that you've defined to create the identity of that particular application. It's almost guaranteed to be unique. If you're deploying Dapr outside of Kubernetes, you can actually specify a fully qualified domain or the domain that you want to use for that custom certificate. Dapr also supports your own certificate. Instead of relying on Dapr to generate the NTLS certificates, you can bring your own certificates and Dapr can use those. Including integration with service meshes. Obviously, you would have to disable NTLS because the encryption would be provided by the mesh itself, but can work inside of Istio or Open Service Mesh or any other kind of integrations there.  Wonderful. Thanks. Last but not least, is Dapr under open governance? I know we did some policies a bit, but yeah.  Yes, we actually publicly announced our path to get there. I don't have a timeline at this point. There's a blog post. I will include a link here in a minute, where we talked about this. It's very much the next step. I think we are preoccupied right now with the 1.0 release that's going to be lending pretty soon. We are on the milestone to in a couple weeks, I think or next week, the release candidate number two. Once the 1.0 is out of the door, I think that's going to be pretty much the first thing we're going to be focusing on. Stay tuned. We've publicly acknowledged that that's what we want to do. Despite the governance, there is already a pretty broad external number of contributors. There are contributing not only to code, but also to the direction of the project. Many of the hygiene of an open governance, we already are following those principles to make sure that this is ingrained into the project itself.  Great. Well, thank you very much. Thanks for your time today, Mark. That was wonderful. That is the last session in our show today. Thanks everybody for attending. Just before we go, I do want to share the screen one more time just to show the links that you need. We covered Brendan Burns. We talked about Kubernetes innovation. We talked about the recent announcements with AKS. We covered Azure Arc, some info on Azure Stack, HCI as well. We checked out open service mesh with Philip Gibson, and we've wrapped up with identity management using Dapr. We will have sessions that had a few streaming issues rebroadcast a little bit later, but for now I just want to say thanks to everyone for coming. For more information, go to https://aka.ms/TheLaunchSpaceKubernetes. That takes you to a GitHub page which has all the information here. When we have videos ready, we'll be posting them there. You can also find them on the YouTube Microsoft Developer channel. Just search YouTube Microsoft Developer, and you'll find that. Thanks for joining this learn TV show. It's been great hosting. Hopefully, it was useful information, and please do get back to us with any feedback. Thank you. 