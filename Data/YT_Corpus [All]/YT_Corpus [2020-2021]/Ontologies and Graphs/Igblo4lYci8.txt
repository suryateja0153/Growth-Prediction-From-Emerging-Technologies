 [Music] you [Music] you welcome to fundamentals of artificial intelligence within knowledge representation and reasoning we have looked at first order logic resolution as an inference mechanism resolution refutation proofs and answer extraction having looked at resolution refutation proofs and the success we have had with resolution derivation x' one should not be mislead into thinking that resolution provides a effective reasoning paradigm within first-order logic one needs to remember that until men in first order logic is semi decidable that is algorithms exist that can say yes for every entire sentence but no algorithms exist that can say no for every non entailed sentences resolution is refutation complete that is for an unsatisfiable set of clauses some branch would contain the empty class a breadth-first search is guaranteed to show that the class set is unsatisfiable however for a set of satisfiable clauses the search may or may not terminate for many applications in resolution one is interested in having derivations where it would be possible to eliminate unnecessary steps this is what is done through certain strategies and simplifications which are refined of the resolution process we will wind up our discussion or knowledge representation and reasoning looking at such strategies and simplifications we start our discussion with looking at an infinite resolution branch here is a small example let us suppose our knowledge base consists of a single formula here this formula is showing that the relation R is transitive one could think of R as a relation that defines relative so R XY could mean X is the relative of Y now if X is a relative of Y and Y is a relative of jad then we know X is a relative of chat that's the rule in our knowledge base let us now look for the existence of someone for everyone who is not a relative that is let's have a query like there exists an X for all Y not R of X comma Y now to remind ourselves we will negate the goal and convert it into clausal form so if you look at the clausal form here and the only available rule you could see that the knowledge base does not entail the query nor its negation so a resolution should fail problem is if we pose it as a resolution we end up generating an infinite sequence we never get to the empty clause so let's look at the resolution derivation so here are my clauses one that comes from the rule in the knowledge base and the other that's the negation of the goal we have a substitution effects for y and that resolves into the resultant that's here now if we resolve this further we get an expression which says R of Y of F of F of Y once there further resolving it we will have a disjunction and when this disjunction is resolved farther remember there are only two clauses in the data set to start with so when it is resolved again to the negation of the goal I have an expression which is now R of Y of F of F of F of Y so if you take a minute and focus your attention on these two subsequent clauses that we have obtained the resolve ins that we have obtained you could see that after every second step this would keep on repeating and this suggests that we cannot use a depth first procedure to look for the empty clause we may get stuck on such an infinite branch question is is there a way to detect when we are on such a branch so that we can give up and look for alternate ways to the empty clause unfortunately the answer is no we are not in a position to say which of this path will take us to the empty clause and then we should give up looking for an empty clause in a given path for first order logic there is no way to detect if a branch will continue indefinitely now this is because first-order logic one needs to realize is a very powerful language in fact it can be used as a full programming language therefore just as there is no way to detect when a program is looping there is no way to detect if a branch will continue indefinitely this is quite problematic from a knowledge representation perspective there are no procedures that given a set of clauses returns satisfiable when the clauses are satisfiable resolution however is refutation complete that is it returns an empty clause if the set of clauses is unsatisfiable and when clauses are satisfiable the search as I had mentioned before may or may not terminate now that's why resolution is not a panacea resolution does not provide a general effective solution to the reasoning problem in first order logic decision are which two clauses to resolve that is which resolution to perform are made by the control strategy now determining the satisfiability of clauses may simply be too difficult computationally so we need to consider refinements to resolution to help improve search one option is to explore a way to search for derivations that somehow eliminate unnecessary steps as much as possible and that is what we will focus on today look for strategies that can be used to improve the search in this sense in fact the most important way of avoiding unnecessary search in first-order derivation is to keep the search as general as possible and this is achieved in the unification step by taking help of what is called the most general unifier so we are looking for substitutions that are not overly specific the substitution need to unify without making an arbitrary choice that may preclude a path to the empty clause tradition that we are looking for is through the most general unifier we can limit resolution to most general unifier without loss of completeness now let's recall what we meant by most general unifier when there exists multiple possible unifies for an expression e there is at least one called the most general unifier which is G here that has the property that if s is any unifier for e yielding s then there exists a substitution s prime such that Y s is equal to e G of s Prime and then G is said to be the most general unifier let's take an example to understand this so here are two expressions P a comma X and P Y comma Z now if you are looking for an unifier here then a for Y and X for Z is a most general unifier this is because I can always have a substitution s prime which is B for X and then we get s which is a for Y B for X and B for Jeb now if we apply G and then apply the second substitution s Prime we will get the substitution s note that the reverse would not be possible and therefore G is called the most general unifier now when I have a most general unifier the most general unifier preserves as much generality as possible for a pair of formulas and using a most general unifier we are actually leaving maximum flexibility for the resolving to resolve with other clauses so the idea is that having a general search would lead me to the empty class one needs to however remember that the most general unifier is not necessarily unique the most general unifier helps immensely in search as it dramatically reduces the number of resolve ins that can be inferred from to input classes now there exists procedures including linear time algorithms for efficient computation of most general unifier for a pair of literals most general unifier greatly reduce the search and also can be calculated efficiently consequently all resolution based systems that have been implemented today use the most general unifies let us now focus on the control strategies that could be used for better search during resolution so the first of them that we will look at is the breadth-first strategy now the bread first strategy is complete but is grossly inefficient we will then look at a strategy called the set of support strategy the set of support strategy have the flavor of a backward reasoning step and we will see that it explores or it generates less number of resolve ins the unit preference strategy is actually an ordering strategy and it selects a single literal clause to be a parent and takes a very interesting decision on which clauses to resolve next the linear input front strategy that we will discuss next is one in which at least one parent belongs to the base set then we will look at a strategy called the ancestry filtered form strategy where the parent is either in the base set or is an ancestor of the other parent we will then mention about a couple of combination strategies let us take an illustrative example to understand these strategies now this illustrative example is a worked out example from the book by Nelson on principles of AI chapter five pages 162 to 163 these are the sentences number one whoever can read is literate dolphins are not literate some dolphins are intelligent we need to prove some who are intelligent cannot read let's first make our choice of predicates so I have a predicate Rx to say X can read a predicate LX x is literate D of X X is a dolphin I of X X is intelligent now whoever can read is literate I could write this first-order sentence for all X R X implies L X and here is the clausal form of that sentence not of rx or LX the next statement is dolphins are not literate so this could be written as for all X Dolphin X implies not literate X and the clausal form is not D X or not L X now in order to keep the variables different in all the clauses I would write not of D Y or not of ly some dolphins are intelligent is written as their is an ex dolphin ex and intelligent X now the clausal normal form of this would be that I would introduce our skolem constant a and there is a conjunction end so I would have two clauses da and IA some who are intelligent cannot read that's the goal so we have the goal here saying there exists an X intelligent and not read now in order to prove this using resolution refutation I would take the negation of the goal which is not there exist X I of X and not R of X and I would finally end up having the clausal form not I of Z or R of Z so we have five clauses and now let's look at the refutation proof for this so here are my clauses I then start with resolving from the gold well form formula itself the clause that's come because of the negation of the goal and I have R of a that resolves with this clause here to give me L of a which then can be resolved with the clause not dy or not L Y to give me not D of a and now once I have not d of a and D of a in my original clauses I have the empty clause and therefore the statement is proved now with this illustrative example let us try to look at the different strategies that we have identified for discussion here today and try to understand how does one arrive at the empty clause in each of the strategies now one needs to realize when I'm using this proof that the proof of this example had taken me from the original clause to the first level resolve ins to the second level resolve ins I generated the third level resolve ins and I got my empty clause only at the fourth level let us now look at the bread first strategy in bread first strategy all of the first level resolve ins are computed first then the second level resolved ins are computed thereafter the third level and so on and so forth a first level resolving one between two clauses in the base set in fact I define something like the iith level resolving and eyuth level resolving is one whose deepest parents is an I minus one at level resolving so the bread first strategy is complete but is grossly inefficient now one needs to understand that when I say a control strategy for a refutation system is complete it is in the sense that its use results in a procedure that will find a contradiction whenever one exists so let's take our original problem with this five clauses and look for the empty clause but while doing so we would love to generate all of the resolved ins at every level so we first have the original classes we resolve them to generate our first level resolved ins so here are our four first level resolved ins I a resolve it not of either or our Z so I have an RA then here I have a complementary pair RZ and not RX so i could resolve them resolve this and this to generate my second resolving at the first level i generate my third resolving at the first level and my fourth resolving so I have my first level resolve ins once I have generated the first level resolve ins I then try to resolve these with other clauses in the knowledge base and get my second level resolve ins as marked here so one thing that needs to be notice here is that for each of the resolve Lucian that I am performing at least one parent is from the first level resolve and set so these are my second level resolve ins and then once I have my second level resolve ins I start generating my third level resolve ins so one interesting thing that now we can notice is that I get an empty clause in a breadth-first search in the third level resolving set itself whereas if you remember in the proof of the illustrative example the refutation tree that I had had to at least move to the fourth level resolving to get to the empty clause next let us focus our attention on another of the strategies called the set of support strategy now a set of support refutation is one in which at least one parent of each resolving is selected among the clauses which result from the negation of the goal well form formula or from their descendants so in fact it has the flavor of a backward reasoning step because you are resolving with clauses that results from the goal well form formula or from descendants of the goal well form formula so each of the resolve ins might actually correspond to a sub goal let us look at set of support in our illustrative example and the five clauses now in set of support I should resolve using clauses that results from negation of the goal well form formula or its descendants so I have to start resolving from this which is the negation of my goal so in the original class set I start resolving from there and resolve with I of a to get RFA now the next is that this statement which is a descendant of the goal well-formed formulas resolution step is to be used or the goal well form formula itself could be used so I take the well goal well form formula and resolve with its second possibility here and then I resolve array with not of our X or n X so I have an LA now I resolve this descendant that has come from the goal well form formula with a clause from the original class set and have nots of I Y or not of dy and then I could resolve this with the original closet to have not to have la I have my second level resolve ins and then I can think of generating my third level resolved ins which is not of DA now one thing to observe is that in the bread first strategy that I had shown immediately before this we had arrived at the empty clause while we were generating our third level resolve ins but the set of support strategy was unable to get to the empty clause in its third level resolution so third level resolve ins did not generate in this case the empty clause in contrast to the breadth-first strategy so let's see which was the path taken by my initial proof of the illustrative example so the darkened edges are the one which have been a part of the initial refutation proof now if you focus your attention only on the set of support and the proof that I have obtained you can see that the set of support produced the empty clause at the fourth level was unable to get to the empty clause at the third level for this problem however it did produce fewer classes at each level then the unconstrained Bradford strategy now let us look at them ordering strategy like well I was looking for the modification of the set of support instead of filling out each level in breadth-first fashion what if one could try and select a single literal clause that's a unit to be apparent in a resolution every time such units are used resolve ins would have fewer literals then do their other parents so using a unit clause together with a clause of length K would always produce a clause of length K minus 1 and then you could focus the search towards producing the empty clause so the original refutation tree that has been produced for this illustrative example has the flavor of unit preference strategy let's select a unit literal class first so it could be my I a that's a single literal class a single unit you resolve with the complimentary at this point and generate our of a our of a is again a unit so you select our of a and resolve with its complement in this class so you have L of a you resolve with this class which is a complement of L of a and you arrive at a da now da also is a single literal clause and in the base set you have a da and you could arrive at the MP clause now the unit preference strategy every time the units are used you could see that the resolve ins have fewer literals then do there are the parents and by just having an order on which class to select and making a very interesting rule that you will select only the single literal clauses could take me to the empty clause without generating number of clauses as was required in breadth-first or set of support the next strategy that is our focus here is the linear input form strategy the linear input form strategy is one in which each resolvement has at least one parent belonging to the base set the first level resolve ends therefore are same as a breadth-first search at subsequent levels are linear input form strategy does reduce the number of clauses produced now one interesting thing to note about gleam your input form strategies are that they are not complete like in the sense the bread first strategy is complete so here are my clauses from the illustrative example and let's try a linear input from strategy here recall that the first level resolve ins because everything is in the base class I will generate as good as the bread first strategy but thereafter I would generate fewer clauses because I would have to have parents which are in the base set so I take R and here is a clause in the base set that has a complement of are so I have L of a thereafter I have I of Z or L of Z and I look for a complement which is I of a in the base set so I have my second level resolving here there is a compliment of L in the base set so I have not of I or not of DZ and here I have a complement of our here is not our in here is our so I would have here not of I Y or not of D Y so these are my second level resolve ins and then I look for third Ravelry solvents by looking at again the process in the base set now if you recall the original proof for this illustrative example here the darken edges is a part of the original proof now one needs to understand that there are cases in which a refutation exists but a linear input from refutation does not exist so this makes linear input from strategy not complete in order to understand that let's take an example here so here I have four classes Q of U or P of a not Q of W or P of W naught Q of X or not P of X Q of Y or not P of Y now if you look for a refutation of these set of clauses you can see that you have the set of clauses clearly unsatisfiable the refutation tree on your right shows that I could arrive at the empty clause and therefore the set of clauses is clearly unsatisfiable but then one needs to realize that I cannot have a linear input form resolution for this example now for a linear input form refutation of this example one of the parents of these empty clause that I have here need to be a member of the base set for that to happen one must either resolve two single literal clauses or two clauses that collapse to a single literal neither of these conditions are met by the base case members and therefore this example even if it has a refutation does not have a linear input form refutation and is enough to show that linear input form strategy is not complete however in spite of their lack of completeness linear input form strategy is used because of their simplicity and efficiency let us now focus our attention on the last of the strategies that we are discussing which is called the ancestry filtered form strategy in this form of refutation each resolving has a parent that is either in the base set or that is an ancestor of the other parent so this is much like the linear form strategy control strategy is guaranteed to produce all ancestry filtered form proofs is complete so completeness is preserved in ancestry filtered from strategy if the ancestors that are used are limited to Marge's now recall that March is a resolving that inherits a literal each from the parent such that that literally is collapsed to a singleton by the most general unifier so let us take the example that we have used for the linear input from strategy and look at the same refutation proof towards the empty clause now you could see that the refutation tree on the right is produced by an ancestry filtered form strategy because here this clause not of P of X could be considered an ancestor while I am resolving for PA I am looking for the parent of Q which is P of X and therefore the class P of X is used as an ancestor and this is the ancestry filtered form strategy now there could be strategies that are combinations set of support with either linear form or ancestry filtered form is a common option you can view that as backward reasoning from goal to sub goal to sub sub goal and so on now occasionally combinations can be led to slower growth of the class set than would either strategy alone one interesting point to note at this time is that the ordering strategies of which we have only discussed one the unit preference can prevent the generation of large number of immediate clauses so order in which resolution is performed is crucial to the efficiency of the resolution system and therefore the unit preference strategy has its own importance now let us look at a couple of simplification strategies we will discuss two simplification strategies one the Clause elimination and the other procedural attachment the clause elimination strategy the idea is to keep the number of clauses generated as small as possible without giving up completeness so we exploit the fact that if there is a derivation to the empty clause there is one that does not use at least three type of clauses one the pure clauses to the tautologies and three the subsume clauses so we could eliminate this and still be able to reach the empty clause procedural attachment on the other hand is about evaluating or interpreting a literal by attach procedures and coming down on the size of the clauses let us look at Clause elimination first so we have two very important eliminations one is the illumination of tautologies and the other is elimination by subsumption any clause which contains a literal and its negation that is a tautology may be eliminated now this is because any unsatisfiable set which contains as tautology is still unsatisfiable after removing it and conversely so you could eliminate tautologies to reduce the on search elimination by subsumption is more interesting we look for a clause li we subsumes a clause mi if there exists a substitution s prime says that L of s is a subset of M let's take a couple of examples to understand this here is P of X it subsumes py or Q Z P of X subsumes P of a P of X assumes P of a or Q of Z P of X or Q of a subsumes P of F of a or Q of a or R of Y so if you have some clauses that subsumes another class in the set then it can be eliminated without affecting the unsatisfiability of the rest of the state so these eliminations lead to substantial reduction in the number of resolutions to find refutation procedural attachment is another possibility in fact a more convenient one where the idea is to evaluate the truth value of literals rather than to include these literals or their negations in the base set now here evaluation refers to interpretation of the expression with reference to a model so for example I could have a expression saying equals 7 comma 3 now this can be evaluated by attaching a procedure that somehow computes or checks the Equality of two numbers so given such a program for the above predicate equals 7 comma 3 evaluates to false so it is possible to attach procedures to function symbols as and then one needs to establish connection or procedural attachment between the executable computer code and the predicate calculus expressions how does the cross set get simplified by such evaluations there is a two-step process if a literal in a clause evaluates to true then the entire clause can be removed if the literal evaluates to false then the occurrence of just that literally in the class can be eliminated for example P of X or Q of a or equals 7 comma 3 can be replaced by simply P of X or Q of a as equal 7 comma 3 evaluates to false this is what is procedural attachment other ways and means of reducing search includes a technique of using sorted logic now sorted logic involves associating sorts with all terms for example a variable X might be a sort female a function like mother may be of the sort person map to female then one would keep a taxonomy of sorts like one could say woman is a sub sort of person the idea is to refuse unification between literals PT and PS if SMT are from different sorts now this is under the assumption that only meaningful with respect to sorts meaningful unifications can lead to the empty clause and this is how sorted logic can be used to reduce down search there is another trick of using what is called a connection graph if I am given a set of clauses I can pre-compute a graph with edges between any to unify bond literals of opposite polarity label with the most general unifier now resolution procedures that can be used involves selecting a link computing a resolving class and inheriting links for the new class from its input clauses one needs to realize that there is no unification at runtime this if you give us bit of thought can realize that can be seen as a state space search problem where the idea is to find a sequence of links that ultimately produces the empty clause now any techniques that I can use for improving state space search can be applied here as well we have so far in these couple of lectures discussed knowledge representation and reasoning argued why logic is the first choice for knowledge representation and reasoning we have examined first-order logic as a knowledge representation formalism now one needs to understand that first-order logic is not the only choice however first-order logic is simple and convenient to begin with we have looked at resolution and resolution refutation proofs we have particularly looked at resolution derivations symbol level operations leading to knowledge level logical interpretations we have warned through answer extractions and today we have covered strategies and simplifications leading to refinement in resolution to help improve such this is where we wind up knowledge representation and reasoning thank you [Music] you 