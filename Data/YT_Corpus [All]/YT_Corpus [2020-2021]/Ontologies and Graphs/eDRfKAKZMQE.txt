 we're going on on full screen so i i can um uh yeah the the topic that we had chosen for today because it's something i've been spending quite a bit of time is is uh is rdf linked data ontologies and how neo4j integrates with all all these technologies i i was i was asking maxim before if he was familiar with rdf let me let me replay the question is it is it something you guys have come across i mean are you are you familiar with the whole you know semantic technology stack like uh rdf et cetera et cetera or are you completely new to it it's just you to for me to understand where i'm starting from and and not to say things that might be irrelevant for you koji um i'm very uh unfamiliar would be my answer okay perfect no problem at all that's that's great because what about koji hi are you are you familiar with rdf koji um not so much okay okay perfect no problem at all so i can that's great because i i was planning and uh um i was playing this as an introductory session so it's absolutely fine so then let me start spending you know a few minutes uh explaining what rdf is so i'm going to go on full screen mode and um well that's me i guess you can you can reach me on twitter but also you know through my email or many other channels in the in the neo4j community as well but um yeah the i mean rdf is uh what you see there is kind of uh of the definition from the w3c so it's a w3c standard obviously 3c is the is the w3 uh consortium is the the standard i mean the body that defines standards like you know like uh html like xml like css etc and and some others so uh rdf is a um is a is a model uh for for data exchange in the web so what's what's interesting about it and the reason why we're talking about it today is because it represents the data as as a graph and and and that aligns very well with with neo4j so you can you can establish the analogy with something like xml so xml represents the data in a hierarchical way well rdf uh we're going to see in a little bit of detail today it's uh it's a way of exchanging data pretty much in the same way you do with xml or other form json or many others but it happens to represent data in uh as a graph as connected entities so at the basis of it there's um there's the notion of a triple a triple and we're going to see some of them in a minute but a triple is a statement right is uh they describe it as a subject predicate object statement for example uh jesus works for neo4j so you have an entity which is jesus where it's four would be a relationship and neo4j would be another entity right jesus is friends with kareem so karim is another another entity and we have a friend relationship between each other right so you see that this way of of representing the world in terms of triple statements ultimately forms a graph because every triple is an edge in a graph so if you combine all these triples that forms that forms that from the graph like i was saying so um it's uh it's a standard so it's been around for a few years uh and you may not have come across it it can be uh serialized in many formats so the the the notion of triple can be can be expressed in xml it can be expressed in in uh in in json there's there's many i'll come back to them in a minute but uh it's a standard also has a uh um a query language so you can query a set of triples using a standard query language which is called sparkle and it's based on on triple patterns as well it would be the equivalent of cipher um i understand you're all familiar with cipher of course um but uh but it's based on on on triple triple graphs or triple models right there's an additional element which is the notion of a uri a uri you know is a unique identifier in the web and and that's the way rdf uh represents or identifies things so now if we um try to establish the analogy with the the property graph that we know that we uh are used to which is uh uh the property graph neo4j we're going to see that there's a direct match and i was thinking uh let me use the probably the one the the first graph that you see when you download neo4j which is the movie database right so uh this is just a little fragment with the matrix and and you remember that in in these graphs there were uh notes representing movies and notes representing people right and people could be either actors or directors or producers so uh if you think of this fragment we're seeing there a note representing the matrix and another one representing lydia wachowski and there's a direct uh relationship i mean he's she's the director of uh of the of the movie right and then movies also have uh attributes and you see them here at the bottom right things like the release date uh the tagline title etc etc so what would that graph that we are used to look like in serialized as rdf in terms of triples and i'm going to superpose it here and and that's that's actually all the effort you're seeing there so first thing you notice is that uh things are represented with your eyes as i was saying so for example uh here i'm using a a a naming that i've made up but uh individual one would be the the note representing the the matrix the move right so for this individual we have a number of statements a number of triples and the first one i'm saying is that this individual this node has a property called title which is the matrix it also has a release date which is 1999 has a tagline has a type which is the movie and it is connected to other resources resources the terminology and rdf to to identify things think nodes in in the property graph world and we see that individual seven which is as you can see down here lady wachowski is connected to individual one which was our uh node representing the matrix through a directed relationship right we see that there are other nodes other resources that are also connected to the matrix in this case individual six i don't know who that is probably you know one of the actors so anyway but you see that there is a um a way of expressing exactly the same information that we had in the in the property graph but in the form of triples and this um this representation that you see which is essentially a list a sequence of triple after triple in a text based format uh is it's what's called an n triples format so it's one of the possible serializations of uh of rdf and back to the serializations and i'm probably not not going to spend too much time on that you see that there's many more so because um rdf and it's important just a little bit of context rdf was conceived as a way of exchanging data in the way so it was all about interoperability so if you've been around for long enough like i have uh you probably remember in the early uh early 2000s probably here actually 99 2001 uh this notion of uh of the semantic web that uh people like berners-lee or jin handler were you know talking about and this this was an idea that they came up with which was essentially let's uh let's um express the information in the web in a in a structured way you know in a well-defined manner so that it's uh easier for um let's say agents for for for for software to make use of it instead of having it only in web pages which are basically for human consumption so that's where where it all came from and so rdf was the the kind of the building block for this vision of the semantic web i'm not saying that semantic web had a lot of adoption but there are there are there are things in in that space but uh rdf persisted as a way of exchanging graph data so all these to say that it's all about interoperability and therefore you have multiple uh serialization formats depending on what your parser preferences or what the purpose of your data exchange and you see one uh the one that we're seeing is here at the bottom the n triples one where you see just a sequence of triples but that you can basically express the same in a json format json ld which is pretty popular these days as well as a way of encoding metadata and web pages um there's uh rdf xml which is an xml based realization pretty similar and there's an another one which is more kind of human readable which is turtle that's the that's the name any let me take a pose here and see if we are following does that does that make sense any questions so far very good i'll take that as a as a yes you can also you guys can also use the chat room too if you prefer to do that yeah no that's that's pretty clear okay perfect right so um just very briefly i mentioned that um rdf has a standard query language which is called sparkle and you see at the left on the left side of the screen a uh an example query and to derive the equivalent in in cypher so the the question essentially is uh you know in an imaginary model in a kind of think of a social uh social uh network a model who likes a person named stefan so liking as in i i hit like on a tweet or i hit like on a picture that you post or whatever so um so in cypher uh i guess you're all all familiar with it so it's easy to see that we we're looking for a simple pattern where we have a note we can specify the type or not but basically we're trying to find a likes relationship right so something that likes something else that is a person and uh and we want to filter by name and saying that we want to find who likes that person called stefan well the same thing in um in sparkle would look as you see here in the left it's basically decomposed again in triples so the way you would say that someone is a person and that someone likes uh someone's name is stefan is in in in a number of statements in a number of triples so we have here uh a which is a a variable it's an it's an alias which would be the equivalent of of the a alias that we're using in cipher so we say that the type of this uh node is a person right same as as we're doing here um that the name uh contains uh the world stefan that's using regular expression notation as you can see so but essentially it's pretty much the same and then once we identify this node that has a name of stefan then who likes that so uh the the the first uh thing as you can see is that uh rdf is essentially an uh pretty much an atomic the composition of every single bit of information in a graph so in a graph we have it a bit more uh it's a bit more compact in the sense if i go back to that um to that slide let me come back to the triple the composition of these i mean if you see the matrix the matrix is an entity in the graph that has internal structure it has properties it has attributes in in rdf it's kind of broken down in a list of statements in the list of triples and that's that's the the basically the the essential difference between property graphs and and and rdf so there is a query language because there are specialized stores there's data stores that are uh focused are specialized in storing rdf data uh and these are these were called originally still are called triple stores not very original but uh triple stores recently some of them are like to call themselves more like semantic stores or or some anti-graph databases but uh in this space you probably have heard about um companies like star dog or um there is um craft depot grab tv i think it's called onto text there is smart logic uh neptune uh also have both a property graph and an rdf so there's a number of vendors that offer support and storage specific storage for these type of graphs and if we look at we've looked at the difference between the property graph how neo4j stores data and how audio stores data but we can look at it also from the point of view of the of the data store and if you think of it what would a data store that stores triples look like triple is three elements so it would look pretty much like a table with three columns right it will probably have one or two additional ones for context etc etc but that's exactly what they are so they are um it's a big column store uh which is strongly index based of course so it's uh uh it's uh in that sense uh it has some of the limitations or well i wouldn't call it limitations but some of the problems that relational state relational databases have so i understand you're familiar you probably have attended some of the previous ninja sessions and i think max max demarci or you know also emphasizes in this aspect how we how our uh data storage which is essentially different from from index based ones so we as you know in neo4j we persist the connections between data points we keep a pointer between a node that's connected to another node and that way we make it lightning fast to to be able to navigate from one node to another whereas in index based stores you have to scan an index to find what you've seen what a triple looks like if you say that jesus is friends or friend of karin then you have to find uh do another scan to find karin and all we know about her what her name where she leaves etc etc so it's a lot of uh when you navigate the graph there's a lot of index scanning behind the scenes so that's absolutely fine it's just different to what we do but the reason for that is that um and if you think where it comes from uh um rdf was uh typically used for uh mostly you know additive and or slow changing data stores and and some common ones that we're going to be looking at are the wikidata or the dbpedia so these big communities sort of community maintained data stores where it's more about adding information than exploring it in a transactional way in a fast way in in real time so it's typically used for more analytic workloads so that's um these are some sort of common characteristics of rdf audio stores whereas uh as you know efj is focused more on on not more but not only we can cover the analytics side of things of course but we also have the possibility of being a a transactional story both read and writes and deletion also is is important so integrity is key and and performance is also also also significantly improved compared to the to the index strongly index-based stores good so now uh where does i mean i i'll stop here with an introduction so what we're going to do now is look at well how do we uh how does that link with neo4j and what's uh how you can uh essentially import export rdf data out of your graph database neo4j and uh so i'll i'll say that's enough as an intro and we just take some examples of rdf and use them with with neo so um um yeah the what we're going to be using is this extension that's part of our on fj labs so you might be familiar with the labs um kind of incubator so there's a number of projects in in our labs initiative which are developed mostly by uh by the dev real team but also by some other members like like me uh but basically from someone within neo4j but it's uh it's fully open source and it's still not part of the main product of neo4j but it's uh um it's kind of in in in this middle ground and and eventually will make it as part of neo4j or disappear if there's no adoption from the community and in this space you're probably uh familiar with uh things like the kafka connector or with the apoc a library of procedures or the etl tools so there's a number of extensions to neo4j that help you going beyond what the product does out of the box and and neo semantics in particular uh will help you integrating with uh with uh rdf data uh in a number of ways that we're going to see so this is the uh the url there at the top that you can go to and it will take you to a page that looks pretty much like the one in the center and i i mentioned this because from there you will have access to everything so you will have access to the source of the of these of this module you will have access to the to the documentation you will also have access to a number of videos tutorials examples a blog post of of how to use it and you will also have access to the to the graph app that we have created and adam cowley has created which is another member of the devrel team uh that makes it very very easy to to to use to use these extensions so that's your kind of home page for for new semantics good so what does it do uh well new semantics will help you doing uh have you do a number of things so the first one is uh be able to import and store rdf data in neo4j so we said that rdf was typically stored in in triple stores that is one possibility but the reality is that rdf does not impose any any way of of storing the data so rdf is a is a data exchange model and and how you persist your data is your is your business and neo4j is one possibility so we can uh consume rdf and persist it in a lossless manner by lossless what i mean is that we can then regenerate exactly the same rdf that we had imported after being persisted in neo4j you can also export on demand your your property graph let's say uh uh any graph that you have in fj can be presented as as rdf so you can exchange you can publish you can you can expose your graph as rdf for rdf consuming applications you're going to see how to do that and we can do some some other interesting things like mapping models so you may have um a graph in neo4j and and you want to make it public as rdf but you want to publish it according to a specific vocabulary so you want to use a particular terminology and there are some specific uh public vocabularies out there that are pretty common things like schema.org you've heard about it schema.org is a defines a a set of of common terms in different domains so you may want to publish your data according to that standard if you're in the finance industry there's things like the fibo ontology you might have heard about the notion of an ontology anthology is a is a in a way a vocabulary is a set of terms and how they relate to each other so you can use that as a as a way of publishing your data in a standard manner so you can define this mapping on the fly so you can say okay i want these nodes my my nodes in my graph i want them to be presented as node type x type y according to these uh to this public vocabulary so that's something that you can do also in semantics and you can do something quite interesting which is model validation so one thing that you can do well you know that in neo4j you can you can define constraints right so you can you can say for example uh there is uh these property that is required for nodes of this type let's say every every person node needs to have a name for example and then when you define this kind of constraint uh well neo4j will not let you create instantiate a node of type person without creating that property property name it will consider it a violation but there are more sophisticated constraints things around for example the the types at both ends of a relationship or the cardinality of a relationship how many uh things i can connect from a node or this type or what's the the data type of this property or what what's the specific format of a string in a particular property so all these things can be expressed in um in a um in another w3c standard called shackle which happens to be serialized as rdf so that's something that we can also use and leverage in neo4j through neo semantics so i'm going to give you an overview of some of these features with some some simple examples does that make sense is that something that i mean are we following okay does that sound um useful you know it's like that is a it's a yes if not this could respond yeah if if you're not happy you have to complain if you don't then i assume you're happy with what happens i definitely agree with that okay okay right so first thing we're talking about uh importing rdf into neo4j so there's plenty of uh of public audio data sets out there so i've mentioned dbpedia wikipedia so it could be wikidata which is the the kind of structured rdf um structured version of the of the wikipedia plus many other data sources but there's there's lots more i mean i i've i've worked with uh again depending on which sector you're in but if you're in the finance space you might have to use the thomson reuters uh um data set with the perm id data set where you have information about organizations you know stakeholders who are the managers of certain organizations et cetera et cetera so there's plenty of of these that's published as a as all the apps so you i'm going to use a very very simple example for this uh for this session but nothing stops you and and in the um the examples the the the videos and the blog posts that i mentioned before you will find more more advanced examples with larger volumes and with bigger data sets and and in particular the ones that i've mentioned so let's say we have a public rdf data set and we want to import it in the infj so pretty much what we see in this diagram so we have a uh a document expressed in rdf and i'm going to import it in fj so um what i'll what i'm going to do is let me stop my um my deck here and i'm going to bring up our desktop neo4js desktop so what i've done is i've created a uh i've installed 405 i mean you can work on on any full version of neo4j that was and i've already installed new semantics so i'm sure you've been to that process before so if you go to uh to manage you can um you can either install uh some some plugins from here so you can install apoc uh or some some other um plugins or you can uh go to the open the plugins directory um and that should probably bring oops yeah let's open it in a different window let's let me bring that to where we were to desktop too here we are so and i've already copied that uh apoc and new semantics so new semantics you can download it again from the the page that i mentioned before it will take you to the to the github repository and all you need to do is download the jar with the latest release so i've just copied that restart the database and and you're ready to go so i what i have and you should have if you give it a try is something like this so you have an empty neo4j database by default or with your uh neo4j um default database so um i was saying that i'm going to try to import some some rdf data and one thing that i'm going to do as well is is bring up the documentation so that's the link to the documentation that i mentioned before and if you've got section on importing uh it can take what's this simple example so there's a number of ways in which you can do that so uh here is a fragment of rdf now that you are rdf experts based on after my my introduction you probably see what's going on here so i'm describing um uh something that's called neo semantics it's a no acronym that used to do which i'm saying that is of type neo4j plugin it has a number of properties called version release date and runs on and runs on is a relationship that connects it to something else which is neo4j355 this neo4j 355 is this unique identifier that i was talking about before so if you see it matches this one down here so basically i'm establishing a connection between this thing called new semantics which is a plug-in and we're saying that it runs on this other resource which is uh called neo4j and it has two labels it has two types graph platform and awesome platform because we all know that it's an awesome one and it has a version as well and like that's like that we have some others we have apoc also some of the older versions and we have the the graphql neo4j graphql plugin so this that that fragment of rdf describes three plugins and and they're all three connected to to neo4j three five five right so that's what we have here so uh what i'm going to do is i'm going to create a database for input so for example let's do import rdf we're going to use this database here there you go so we're in this database it's empty at the moment but what i'm going to do is i'm going to try to uh import uh audio i can do that from uh directly from here using stop because in the end i mean the the extension is implemented as a set of procedures so i could i could call them from here and say uh called any semantics and then s is the acronym and oops that's not let me reload because sometimes it doesn't pick up when it's in your database let's go again to rdf because i want the auto completion there you go so we have ntns and we can do rdf import and there's a number of methods there fetch inline but rather than going through them like these what i'm going to do is i'm going to use the the graph up there i was mentioning before this that was created by adam cowley and it's a it's a great one that we're going to use to you can start it if you're in a mac from here or if not you can um go to the to your installed apps uh in in the in the desktop and you can just uh run it from here you can say let's run neo semantics so the first thing um it's missing the plugin i think no it's already there maybe it's wondering why it's not there but it is there let's connect to the active graph well the first thing is i have to sell which database i wanted to connect to and i'm going to use the import rdf and like you can you can see that it's going to i mean it's telling me that this constraint is required so i'm going to accept it all i'm doing is creating a unique constraint and saying that every resource that we input will have a ui property and that will be unique so that's the unique identifier that we were talking about before so i'm going to create this constraint that does not obviously add any data to the graph it just creates the constraint um what are we going to do so we want to import some data right so uh before i go there we have to do a an initial setup we have to configure the graph we have to tell the graph how we want to deal with rdf and and there's a number of options that we can look at but for now i'll keep all the all the defaults so you can see there's a number of properties that you can configure here but i'm going to uh just leave the defaults and you can see that every uh every action that i do through the app is showing me the the the cipher code that i need to run if i wanted to reproduce it programmatically so i'm going to create this configuration and this is just created an object in the graph saying how am i going to deal with the different options when importing rdf let's ignore that for now i'll come back to it in a minute so we were about to import some data right and we had this example here so we can either copy paste it or we can access it also you can see it's published in this url so we can either access it by url or we can copy paste it let's copy the url as a first attempt so before going to the input i'm going to go to preview because that's uh that's an interesting thing that we probably will want to do before actually importing i want to look i want to be able to see what my data is going to look like before i actually persisted in neofj so you can import uh rdf in a number of ways i mean you can you can retrieve it from uh from a url which is what we're going to try first but you could also um do copy paste i mean if you have a fragment like we were saying you can just literally copy it there and and have it parsed and imported you can um you can upload it from a file or you can uh or you can run a sparkle query we mentioned before sparkle sparkle has a type of queries that can return rdf as result so i could run an rdf sorry sparkle query on on a data store and consume the results of that query directly in neo4j if we have time we might be able to try the others but for now let's say i'm going to retrieve it from a url and all i'm going to do is copy this url here and i need to specify what's the the input format because like we mentioned before there's a number of different serializations this one in particular is turtle so that's what we saw before it's more sort of human readable so that's the one i'm using and uh so i select the type and i'm going to uh preview the data so if i select the table view all i'm going to see here is every single triple that has been parsed so this is all the information when i'm when new semantics has tried to read that file uh from from this url that's okay that's not very uh probably not the nicest thing we can do because we want to see it as a graph so if i do that and i do a preview now i see it as a in a nicer way as a as a graph representation let me make that a bit bigger and we see a number of things well as expected we have uh three entities representing three plugins so one of them was new semantics the other one was uh nifty graphql with the properties that we saw right the release date the version etc and and the other one was apoc and and we see that they're all connected through runs on with a central node which is uh the awesome platform uh the graph platform neo4j well the first thing that you see is that everything is prefixed with this ns zero and why is that well uh we mentioned before that in rdf everything is uniquely identified with your eyes so that means that not only things but also the the names of things for example when i give a name to a property or when i give a type a name i have to uniquely identify it with a uri and and you can see that here we're saying that that neo4j down here is a graph platform but this graph platform is prefixed with neojvoc which has a definition up here which is this one so if you're familiar with the notion of namespaces in xml that's essentially it so we're defining a prefix for a namespace but the real name of this graph platform is all these uri right this followed by graphplatform right so i mentioned before that we want to be able to regenerate the rdf once we persisted in neofj so if we want to make that happen we can do several things so we can either name things like that and it might look a bit horrible so let me show that to you quickly so if i go back to my config and i say hang on i want to uh keep the url because that's that's one option so keep your eyes your eyes and change so if i change my config and i use this one and i come back to preview uh when i do my preview look at the names of things so that's keeping all the names with the long identifiers if you think what would look like to query that with cipher it would be pretty horrible can you imagine the kind of query that you'll be writing if you have to specify that the type is named like that not very nice i mean it's an option i'm not saying no one will ever use it but it's it's not the idea of it so one thing that we can do again if we want to be able to regenerate that is to uh to use this sort of prefix notation so i'm going to replace the the namespace part by uh defining these these prefixes so this is what the the default option does the shorten option does so i'm going to change that and come back to the preview and then we're going to see exactly what we're seeing before so if i haven't defined a prefix myself new semantics will generate ns namespace 0 namespace1 namespace2 and so on and so forth but i can i can use my own my own terminology and i can say okay let's take these two and go to the namespaces definition and i can copy them all here and say extract them from there and we see that it's picked up the two and it's defined the the the prefixes uh that i've named i mean i could have called them differently but like that i have control on on how these namespaces are are are used if i go back to the preview and i've rerun my preview now you see that things are prefixed in a much more much nicer way right so that way it's probably easier to identify which things are which but you know both are optional now you can say okay that's fine if i if i want to be able to regenerate because of course uh um i need to either keep the whole uri or a reference to some index which will be able to then regenerate it what if i don't care about it what if i just want to use public data i want to query wiki data just to get a a taxonomy of viruses which is something that i work with uh with mark needham for another blog post or i want to to get some geographical data and but i don't care about being able to regenerate it afterwards i just want to make it nice and usable in neo4j well of course you can do that too and you can go to the uh to the option where i can say ignore and say i don't care about unique name spaces because i don't i have no intention of regenerating that so i'll update my configuration and if i go to preview and i do exactly the same now we see that things are named pretty much the way we would name it in a neo4j graph right so you see that a plugin you know we've completely stripped out the namespace and we're just keeping the the the part that's kind of human readable so that would create the typical uh neo4j graph that we used to deal with so all this was to show that you know the preview uh methods are useful because they can you can take a fragment of rdf you can modify you can change the configuration options and there's many more that i'm not going to go into today because have limited time you can try different things until you say okay that's how i want my graph to look like and when you're happy with it then all you have to do is go to the input section and just click import so as you can see here i'm using the same uri when i uh click input what i get is a summary of the execution okay it's terminated successfully uh 19 triples have been imported and and there's no additional information uh like i mentioned before uh you can do it similarly by copying this uh fragment of cipher and pasting here in the in the browser excuse me but uh as you can see uh we now have uh data stored in the in in our graph and and if i look at what's in in it some nice coloring but you see that it's pretty much what we were seeing except that now it's already been persisted in the fj right good so that's uh that's kind of the import part right so we've uh we can um we can get any any any data set imported in neo4j depending on how we're going to use it afterwards any any questions on these no that makes sense cool okay so let's look at the other the other way around let's let's look quickly at and i'm going to create another database for this let's say i'm going to create the movies database movies all right and i'm going to use um so i have an empty database what i'm going to do is uh was that a question sorry i was making a joke i was going to say if there are movies early about cows didn't hit that one he was joking he said if they're moving ah movies oh you know there is there is a recommendation engine that's called something like movies with with uh and yeah and the dog is a cow of course but right so uh um yeah we this is the movie's database so i'm going to just play it just to show how would it happen in the other i mean the other way around so i have a graph a simple or simple a property graph it doesn't come from rdf it's not the result of importing any rdf data it's just the the the typical neo4j graph that you would have and i can see for example people acting in movies etc etc so that's that's the uh a graph that you i'm sure you've played with let's say we want to expose it as rdf we want to make it public we want to publish it as rdf for rdf consuming applications so i can i can try from here but i can also use the app which is going to make my life a lot easier so i i can go to interesting it hasn't picked up what if i reload there we go connect to the active graph and i'm going to go to the movies database now i'm going to create the constraint as usual it's not going to be useful here because i'm not importing any ivf but doesn't hurt to have a constraint so i'm going to go straight to the export side so like you can see export is implemented as a as an unmanaged extension so we can uh [Music] query these endpoints to http requests and you see that it's mounted on a i didn't show that but i can quickly show that to you how that's done the only only configuration element that's required if you go to manage and you go to settings uh you probably have done that before but when you deploy an unmanaged extension all you have to do is where to mount it so the an app is uninstalled it i mean i've said it you know rdf as the as the the endpoint but you can you can use whatever term so what that means is that i can i can send my requests to rdf then i have to put the name of the database that i'm using in this case it's movies so it's that one and then all i have to pass is the unique identifier we don't have uris as unique identifiers but we still have a way of uniquely identifying things in neo4j which is their internal id so for example if we take kian ribs here we see that it's id or interestingly is number one okay so that's quite convenient because that's exactly the one that i was seeing here so if i click export here we see that uh we see the information about keanu reeves serialized as rdf right so um if i copy this i can run it as well and uh let's add this white space here but you can also run it in the in the browser you can see the the result of the execution we mentioned before that there are several um a format several civilization formats so we can uh we can override the default which is turtle as you can see and we can use n triples instead this is the one that we looked at before so this is like a sequence of of triples the same information but just in a different different format or we can use the the rdf rdf xml format or i mean whichever you want the other one is json od ld there we go and and all basically contain the same information it will require different parsers on the consumer side but that's the ads so pretty straightforward nothing to do you just need to hit that endpoint and and you can immediately see what uh you know the data you have you can you can query the data in a number of ways so it's not only by id so you can if you go to documentation again um whereas the exporting section so you can uh you can do it but by id like you see here which is the one that we've just seen or you can also uh run um a search for example by uh let me find an example down here uh you can run cipher query so you can you can execute a cyto query and the result of your cipher query would be serialized as rdf that's another possibility or you can do a combination of label and properties so if you use this this syntax you could get something like uh you know all the matches for a particular combination of of um let me give it a try for label and label and property value so for example if we uh want to get a was it it was not described it was what was it sorry uh so it is uh describe find so instead of described oops too many jumps so instead of describe find and then you would do for example movie and and you can get a i don't know we can do a search by all the movies released in 99 so if we do a movie release and we do 99 uh no much oh i think by default it does um um it does um string but we can pass the the value type as integer with the syntax yeah that's the thing with live coding but you can say parasite as an integer and then we will get all the movies that were released in all the matching movies that were released in 99. so that's so yeah there's a number of ways of query to query the graph and you can uh you can extract the data and as uh stream the results as rdf and cipher will be the the obviously the the richer option because it lets you do whatever you do good so that's we've covered kind of input side of things copy the export and and very briefly i want to have a look at them at the model uh validation part of the constraint validation that i described and for that i i have a couple of examples uh but again i'm going to drive from the from the from the app because it's going to make it all a lot easier so let's create yet another another database so quickly go to system and say and we're gonna do uh by days for example and we're going to use it it's an empty one and um well we can um we can do the same same thing we did before so that's not the one i was looking for let me where did i put there is a github type github it was in one of the repositories i think is in the data sets rdf yeah i have an example here there you go so we have another simple uh fragment of rdf this one is about music bands so we have i believe the beatles and the rolling stones but what's interesting here uh because importing this is pretty much what we did before is that we can define constraints uh like i explained before so and these are called shapes in rdf i hope you can you can really hear but what we're doing uh here is defining um yeah in a way the shape of the graph that you that you're building and the kind of structures that you want your graph to keep so in in this particular case we're saying that uh this shape we call band shape applies and that's what we mean by target class to to instances of uh of band so nodes labeled as bands and what we're saying is that they have to have a name so a bank will have to have a name and it has to have one and only one name so the cardinality has to be one so you can have bandwidth let's say you can in the real world but that's uh that's what we're expressing here and the data type for that property is also a string right so we can be a bit more granular that the typical constraints that we can express in neo4j out of the box we can also say and that's again a silly example but we can say that a band will have members so it will be connected to what the nodes representing the members the individuals and we're saying that a band for some reason has to have between two and four members so we can we can use this mean and max also to control the cardinality of a relationship so and like these we can define some some more right and uh how can we leverage these in in in efj so let's uh let's try it quickly so first let's load some data and the data is is here in this file so i'm going to go to the raw version of this file and i'm going to import by uri let me go with my guide and i have to of course reload because this one doesn't pick up the new databases so connect to the active graph and go to the validate database i create my constraint and i go straight to input i know what i'm doing i actually have to configure first and let's say for example that i don't care about the the uri so i want to ignore them so that's done and i go and import my bands so that's the url and it's again in total format so all good let's import the data it's all done a few 50 53 triples in we can go and check them here so we have now oops a number of a let's see for example if we look uh the member relationship we see the two bands the beatles with the four members and the rolling with five okay there you go there's also information on on on albums and tracks and more and so on and so forth we'll we'll skip that for now so um i showed the these constraints uh the constraints that i was um explaining before which we call music shapes and we can access them on this url so this is a formal definition of these of these constraints so i'm going to import them and i'm going to use the app for that as well i just need to go to the um validation section and it's pretty similar so i'm going to pass the url of the file containing the shapes i could copy-paste them i could do all the other options that i mentioned before but i can say okay load these constraints and the constraints have been loaded and we see them in a kind of human readable form here so we're saying that uh nodes of type band the name has to be a string the name has to have a minimum and maximum cardinality of one and so on and so forth everything we saw there so the the constraints have been loaded now so uh what i can do is i can run the validation and remember that every single thing i'm doing here you can re reproduce it uh in the in the browser and actually i'm probably gonna do that here in the browser now so i can i could reload that's not gonna change but if i uh reloaded the the constraints let's go we see exactly the same result but once i have them i can say okay let's run the validation and i'm going to do validation uh let's validate so if i run this method what is what i get is a single single sort of violation of the constraints and what this is telling me is that there is a band which id is nine and the only way of identifying it is with the internal id because we don't have your eyes and and the the constraint that it's violating is a max cardinality constraint and basically we can see here is that it's an acceptable cardinality of five so we can go and see who's these uh this band identified by nine although we kind of suspect which one it is you see that id9 here is exactly the rolling stones and of course the the the issue we're finding is that it has more uh members than we have defined as acceptable but i guess that's i mean what's interesting this is a silly example but you can define uh richer constraints that can be applied to your graph and you can get a report of the violations but what's interesting is that you can also run this in a transactional mode so there's some some other i mean you can register a trigger that essentially what we'll do is every time you write to the graph uh it will make sure that your transformation what you're writing to the graph is not goes doesn't go against the constraints defined in the in our in our constraints document shapes document because if that's the case the transaction will be rejected and and roll back and and like this you can guarantee transactionally that the consistency of your graph is kept so um right so uh well that's uh there's been a lot of talking and and probably just just coming from me to you and not not much interaction but uh i i guess at least that has given you an idea of how you know how easily how how how powerful in a way that the interaction with rdf and semantic technologies is so um input export and we've got validation we didn't cover the model mapping or the ontologies but i guess we can do that in another session karine what do you think any questions any any comments i was just asking the same thing in the chat room if he has any questions just a quick question so right now you're saying okay you you implemented this constraint um to limit the number of band members yep um so now my question is does so if you tried to add another member to the beatles yeah right now would it reject that or does it only reject like an entire incoming banned transaction no no no it will it i mean the way the way it works and and as it is right now you would not reject it because you have to register this this trigger it's all described here in the document you can you can see that if you go to the validation section of validating fj against there you go so um that's the that's the process here that's validating the whole graph which is what we did but you can um you can select the set notes that you want to validate but this is what we're looking at so what you have to do is you have to register a trigger and for that there is a method in in apoc so it's as simple as that so you just give it a name and you have to pass this uh literally hard copying that just copying this line so you copy this to the clipboard and run it and um i mean you have to enable triggers as well in the configuration because that's kind of an optional element but once you've registered that the way it behaves is in a right transaction you can modify as many elements in the graph as you like so what this uh trigger will do is analyze every single element that has been modified by your transaction whether it's a van whether it's just a let's say you've modified the property of a member but you haven't you've not removed it anything you've uh you touch will be analyzed and checked against the constraints so is your whole transaction that will be either passed or failed as a whole so if your transaction introduces any violation then it will be rejected if it doesn't it will be committed and persisted what is the whole the whole set of changes whether that's a band and individual or or multiple ones because you could be writing many of them in the same transaction does that make sense yeah absolutely that's that's great behavior so it's not it's not one or the other it's going to catch on exactly and it's uh i mean it will try to be clever in the sense that uh i mean in in if you're familiar with transactions in neo4j so you can you have sets of basically of elements that you've changed so you may have added labels to nodes you might have created nodes remove nodes so you can get the type and the and identify which rules which constraints you need to check and which ones you don't because if you think of these in a let's let's let's say we're talking about a graph with millions of nodes or or or a set of constraints with hundreds or thousands of constraints well it can be pretty heavy and if you want to run it transactionally you want to make sure that you you you're fine grain then you only check the constraints that apply to your transaction but that's uh yeah that's the way it behaves and yeah i think that's a pretty cool one yeah good question okay that's very nice because i mean you know the the built-in baked in constraints within you where jay have yeah of uh shortcomings and that that covers quite a bit of it that's that's true and um yeah they're pretty limited at the moment i i i guess this is something that will be extended over time but there are things that um i mean you may or may not want to you know yeah i mean things like i mean here you can can go as fine and as as deep as data types or or regular expressions i mean let's say i i want the the the name of a person to not include invalid characters depending on which language you're using or whatever so you can be very fine-grained and have these validations applied so that's yeah it's it's a good extension to to what you have out of the box with me so it's good still not 100 coverage of the whole shackle language but it's enough to be to be useful i would say good so uh that's where we're really using that excellent thanks so we're over the hour now i don't know if you i'm gonna stay a bit longer there are some questions yeah if anybody has any questions we can ask for it oh paul joined i didn't even uh yeah so uh koji asked the question in the chat oh sorry let me bring the the chat uh oh i was not reading sorry because i was in oh that's okay there wasn't any i will let you know if there's any questions that are and hello paul yeah hello i'm just realized that there is some time zone uh makes up for my end oh sorry yeah no prob i thought it was just about to start but it's about to finish i just guessed well if case just doesn't have a hard stop you could probably no we can we can stay up and we i might actually i have a i have another presentation in like an hour but i can i can stay a few more minutes but but you can see it's been it's been uh it's been recorded so we'll yeah i will check the recording instead but but you know i can i can stay a bit and um on the on the question from koji uh can i compare to rdx and um i mean the way you would do it i mean uh that's that's a good question is um i guess you no no you can't i mean there is not a a function that uh that helps you point at two data sets uh two rdf data sets but i guess you could um i mean the question here is whether you want to compare them before or after you persisted them in neo4j but you could of course import them separately and then and then do the comparison uh or in important separate graphs and then do a structural comparison in the graph but it no it's a good one it's not it doesn't but that would be relatively easy uh to to implement because uh uh the library that we use uh has this capability and it's something that i use extensively in the unit testing like doing the delta between two datasets so do you have any any any example or or type of use case where you would find these useful because um i'm making a note of this because uh well i i mentioned before that this is part of the of the new semantics labs project and in here it's all about hearing how the community is using these these uh this project so things like these are are are extremely useful so oh yeah so you mentioned code version yeah that's um the the thing is typically you know with rdf uh you would um i mean they would be typically additive data sets because uh i mean if you if you're coming up with a new version you would probably give this new version different uh uris so you've seen that um resources are uniquely identified with your eyes and if it's a new version of a document or if what you want is an incremental load i mean what what you can do definitely is let's say you have version one and then version two if you load version one and then you load version two which is the same plus some additional triples that will not duplicate the existing ones it will always uh you know just take the the added ones precisely because of the of the unique identifiers in in rdf now if what you want to do is identify the delta between the two files that's uh that's probably a function that would fall in i would see in the in the preview category but um yeah i mean that's that's an interesting one i'll make a note of it uh but at the moment there is there is no no delta capability in the you would need to like i say either persistent and then find the difference so um yeah rdf good one you're welcome what's um any any other questions paul if you have any specific questions you can feel free to ask no no no i haven't no i was interested in the subject so i will watch the uh the recorded session and and go from there okay i could always use go ahead sorry you know i i was i was curious chris you know what uh hang on i can't see your your name uh paul right uh you said that you were specifically interested in rdf or is that something that you work with or is just uh you're more on the neo4j side i am absolutely 100 on the neo4j side but there are a few projects which are in rdf world and right sort of communicating sometimes with people evolved with that so i was just more of an personal interest on uh see how their lingo works and and what i can do with it in in the scope of neo4j yeah yeah yeah that's that's well it's a shame that we've uh missed you but uh but yeah i mean what i've done essentially what we covered is i i did a quick introduction to to what rdf and how what what rdf is and how it relates to the to the model that you know implements the property graph yeah and then i i spend most of the you know second part say 75 of the session running hands-on examples of the type of interactions the type of integrations that you can that you can so i will be watching your session record a session sure yep excellent but yeah i i did cover you know the you know importing rdf uh from any public data source into neo4j and persisting it uh we covered exporting so when you have a property graph and you want to present it you want to publish it serializes as rdf you can also do it and and we did a just a little bit at the end of validation you might be familiar with uh shackle which is one of the uh standard w3c standards for defining constraints on a graph so it's a way of defining uh you know the shape the structure that your graph uh needs to have and you can use it to detect inconsistencies in it so that's uh another feature of the of this um rdf plugin that i was presenting today it sounds interesting i'll be uh i'll be screening it excellent cool thank you jesus thank you no hold on thank you guys for coming and helping the community um paul did i have a question for you did you get the calendar invite or did you find out about it different way is that why because i did get an email and i sort of did a calculation on when the the new york time zone uh the eastern time new york was related to to the time zone honeymoon and just now i found and if you click on the on the on the link then you will get the right translation because i mixed up i did a miscalculation in my head okay i yeah i was trying to uh put it in the calendar so that way there wouldn't be a discrepancy so i'm like i don't know what else i could do that would because it's going to be better for that kind of stuff yeah perhaps i should rely more on the links which are presented in the mail instead of doing it from the top of my head yeah i mean i do it that way too sometimes so it's you know but i was hoping that it was gonna be a little bit clearer but yeah well yeah that doesn't matter i mean you can't put it in all the time zones everybody is in so it's just uh something i will be aware of next time okay um is there anything that you guys want to see like coming up in the near future 