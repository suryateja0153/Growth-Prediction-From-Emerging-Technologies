 hey everyone good afternoon welcome to the nfga twitch channel my name is adam um and today we'll be continuing on um our journey of learning how to build web applications with uh chain typescript um so what we'll do is we'll we'll carry on from from last week's session um and in last week's session what we're doing is we're looking at this uh this real world example uh and what we're trying to do is to build a an implementation on neo4j and so in this case uh because we're looking at neofj we're looking at typescript looking at um using nestjs for that and then our our own goal really is to come up with a a back end which we'll work with uh with one of these front ends uh so for example the react example um so hopefully by the end of this uh this session we'll we'll be able to um to power this uh this application but the the tldr of the the situation is uh we've created a uh application um and uh basically uh based on the um the netflix example i've been working through in the last few weeks um so if you haven't seen that that project you can go to my github and go to twitch.project and then this will this gives you an example of uh an application and how to integrate nfj with that with an sjs and with uh with typescript so using the nifty driver with that with typescript i've taken all of the useful parts of that um that repository and then put it into its own um package assess this uh this nest neo4j uh so if you run npm install add nest neo4j and then register the uh the module in your app module then this will give you access to the neofj service and allow you to to run queries through that if you're interested in the code itself then you can head to the nfc nest js real world example app repository and this may move at some point but for now it's on my on my github um and basically this is uh this uh where we've got two so far um so the uh the real-world example gives you a set of tests inside of postman collection so uh what i've done is i've started to work through all of these and implement the the code for that and so we've gone down we've got the um the authentication there so i can run run the tests if i start the server i can run the tests and basically we've got the the authentication there so the same as the the new world example um so basically what we're doing is uh inside a user module we've got a an auth um an auth service and that handles all the authentication so that passes on some information to the user service in order to create a user and then we can validate that that user as well uh so if for example we take the um the register root and we follow that through from from start to finish um so we have this api url and then we have slash users so that goes through to the user's controller so anything that is uh sorry the users controller the only thing is slash users will will go into uh to this uh this place um and then we have a a post request to get users so it'll be the index so in this case if we post it here and then we get this uh um this root handler which handles everything so we've got validation pipes which will validate this create user dto to make sure that the for example the email is um is not empty and it resembles an email address and username is not empty password is not empty etc uh we then use the or service to sorry we use the user service first to create that create the user inside the database so it creates inside neo4j for us and the way it does that is it uses a cipher statement to to run a create command against the database so we use this nfj service which is part of that nest neo4j um package um and then we create that return that and then return a new instance of this user entity and then we can use that user entity to then create a jwt token that jwt token contains certain claims about the user and it's all encoded using a um using a secret key so for example we we have certain information which which we can use in the in the ui in the front end and so for example we have the username there we have the email the bio and the image and then we return that information and so if i run this again i get all this information which is basically the the result of that that root handler and then those those services so have these information there and then we have the the token there as well so if i take a look at this uh this token in uh jwet.iio and if i copy it correctly um so you can see there we've got the um the username is twitch and we have the email address twitch at nfc.com uh we have an image at the issue that time and then the expiry time which is of the same information we have on there on the user uh so we can say you use the the the same classes to log the user in and so you can see the information there so that if we look at the um the login uh there so we basically use a a local auth guard which uses the local strategy which will find the user um fund users information and use your service to validate that user so that will go away and that will find the user in the database so it uses the user service to run a cipher query for that user back and then we use an encryption service there which is basically underhood a wrapper for bcrypt which will check the password that user is supplied against the encrypted password that we saw in the database if everything is fine then uh that user entity gets returned otherwise it uh undefined is uh is returned and then we use that like user so that user gets appended to the request and then that we then use that to generate a token and then we return that information which is basically the information we've got there um so we can use that token then to get the user so if we go to the slash user use the user controller rather than users controller and we find that the user there and then we can update the users as well using a uh request uh so one thing we didn't really look at in in the previous episode i don't think we've got to was the was the articles um so as as you would do with any efj application um all of your interaction to um to nifty goes through the fj uh driver and essentially what we've got inside an sjs is just a wrapper that will take care of that for you um so for example um we we go down to for example the user service to create the user we're using this neofj service and then there's a write method on there for for writing um and then we can use the read service to pull the information um so the read method on the fj service to pull that out um so we have a um an article uh module here and that's basically a wrapper there that um that allows you to register the um everything that revolves around the um the article into the the next gs application uh so we would then register that inside the inside the app module so this will provide a an article service and then the article service is basically the interaction uh that would use inside the application so for example to create an article so if we look at the uh create article root it's basically a post request to slash articles with a body so it's got a title there description um a body and then a list of tags and basically what we do is we take that um that request via a dto for validation and then we um we then create the the user um so this uh this service is an injectable service but it's got a particular scope on there so it's a scope of request so basically what that means is that for every single request that comes into nest then a new instance of this uh this article will be this article service will be that will be created so what we can do is we can inject the request using this uh this magic string um from the sj's core uh to inject the request in and then from there because the the roots are guarded by a particular um middleware and in an auth guard so in this case the jwt auth guard we can we can pull that straight from from the request so for example here this request.user and then we can use the get id um method to to get the the user id and then we pass that through as a um hey here one where it does that um yeah so we pass that through as a parameter so everything uh inside these these braces is a parameter that we can we can reference using the uh the dollar uh so for example the uh user id we're referencing that there so that user id with the dollar in front of it is the parameter that gets passed through um here inside the um so the second argument and basically what that means is um we're protected against any sort of escalator injection or sorry um cipher injection and similar to escrow injection so for example if we were hard coding a string here and we said the the id was was adam for example um or we used some um some sort of interpolation so we could say you know um some var um this could be okay um but for example if it was um a string which had something and then uh you know delete everything um so that's a way of being able to hack into the the but because we use parameters and those parameters are sent separate to the query itself um it means we're protected against any sort of injection like that so we first we find the user in the database so the the user should always exist because we've passed them through the authentication process we then create a random uid using the random uid function and then use that to create an article and so the reason for using that with step is it means that i can use the the same random uid in the id and i could i can also encode it into the uh into the slug as well um so i mean i didn't get two different things there so that will basically ensure that this slug is always uh always unique um so what i'm saying there is basically is create an article and give it a an a list or a variable of a and so by default that should have these uh these values so it should have a an id which is our uuid uh it should have a create that date and an update of that date and then basically in this part i'm just being a little bit lazy so the all the information on the the article is passed through into the function so we have the title the description uh and and the body and i just use that basically to create a new object and then pass that through that as a parameter of article and then i use the the mass sign so the plus equals will append anything from this article object uh on into the the nodes of that um the article node um so everything here will be added there and then i've got the the tag list so if you look at the um the payload the tag list is an array of strings so check these as the the ids or the names of the tags so i'd use a the forex function to iterate through those for each of the the names in that uh tag list so give it a variable of name and then inside the second half of that so after the pipe uh i then find the the tag so i merge it based on the name um and then what i say is if i'm creating this for the first time then create an id for that as well so random you id and then also assign a slug so i use the the apoc uh text dot slug function uh to um to encode that so instead of having for example um how to train a dragon i think it was um basically what what the slug function will do is it will it will convert it into um slug format uh so for example it would take all of the um all of the strings and then convert those um into a dash uh so it's kind of more url friendly you don't have to to encode anything with uh with percentage trends or something like that and then once that's all done i then return that back in um so return all the information back that i need from from the query so i need the user uh i need the article i need a list of all the tag notes so i use a patent comprehension there to pull that information out i then um use the exist function to work out whether there's a um a relationship between the the user and the article um and then basically return that as a as a boolean and then for the um account of the the number of people that have favorited that um that article then i use the size of that and so basically take a degree count rather than querying through the nodes to find the value uh that information then gets pulled out so i'm always going to have one record from this query so um i use resident record zero to get the first record and assign that to row and then from there i can use the get function to get the values from the query so a is the article this bit here um so the user is always going to be the request user so i can use that in the hydration method um row. um get tag list will get me this tag list up here uh favorites count we'll get the favorites kind of favorite so we've got the favorited and then this gets added into a a class so call this like a an entity class um and then i have this two json function and what that allows me to do is is that just allows me to and guarantee that the the values are going to be um going to be correct and then inside the the article controller i then call that to json function to actually return that to the user uh so this is the final output you get so i've got this this article which has all the information on there um it has the the user and has the tag list and we can see from the the test results that all of the tests here are passing so in theory this should now work with the with the front end cool um so if we look at the the articles so the the get uh endpoint for the articles so there's a few things that we need there we need the the articles counts we know account of all of the articles in the uh in the database and any the articles um or lists of the articles so like a paginated list of those articles and so the way i do that in the article service as i use this this list function um so this will return an article response so that response is the article count and then the article so we're adding the the the typing to that and then all of the the um the request information is pulled from the the request uh so there are a few different things that we need to to support them uh so for example we need the articles by a particular username and then we need the um so the articles that are favored by a particular person you know and a particular user and then we also so we have two types of method here so we have the um the well so it's all supported by the same service but we have the same request twice um so for example if the um if the user is logged in then we want to know whether they favorited it or not otherwise we you know we don't really care there um but the the request needs to handle both of these uh um both of these uh outcomes so basically i use the the request that's injected into the uh the article service to pull that information out there so for example uh from the query i look for the author and then this satisfies the uh the author request it says support all of the articles and basically all the articles written by uh these that i've created created using the the test suite and then what i do basically is i start to build up a string there so i've got this uh this where array and then i'll what i do is i use that to create a an array of all of the um the where clauses and so in this case we want to find all of the articles where they were posted by a user with the username of the author value which i then add to the params there same thing for for the favorited and so i want to find everything which is has a favorite relationship to a user which has a username of favorited as this gets added to the to the params and then for the tags um so basically i uh take the the um the value and then split it by comma so you can support multiple tags in there um but i'm basically saying that all of the uh tags in the the tags array and so that that split string there where the article has a relationship to a tag with that name and since this then gets run through the the neo4j service so what i say is find me all of the the articles then i apply the the where clause there so i say where um so if the length is is more than zero so if anything has been appended to that that where clause then combine all those where clauses using and and then prepend it with a with a where otherwise just do nothing um and then i basically use this this intermediate steps with step to work out the the counts there so we take this for example this this article account um before we we get the the articles so for example if we had 100 articles then we'll want uh 10 by default that'll be the the limit um so if we did a a matching aware and then we did all this this processing uh below and then it would be kind of a inefficient query but what that basically allows us to do is to aggregate everything up uh into a collection and we take a account of the the articles there um and then um unwind those articles again so we've got the uh the article count we've now got all the articles spread onto their their own rows again um with that article account and then each of the articles and then we apply the uh the ordering and then the the pagination so the skip and the limit um so then we have our list of ten articles basically um and then we basically return that article count um for every row and then for the um each of the articles we return the article uh we turn the author so we're using again a patent comprehension to get the first user or the first u node on the end of this uh posted relationship for the article um for the tags we go out through the hashtag relationship to the um to a tag node and then return the t and then this is this is a kind of kind of a bit of a hack really um so if the the user is is uh is logged in uh then we'll get the uh the user's user id using the get id function so if um this request.user is is truthy then we will assume that it's an instance of the user and then we'll pull the id of that otherwise that we know um so we use that inside the query to say that if the user id is not null then we check for a relationship affective relationship to a node with an id property of the user id but if that's false then we don't need to check that so we just say else false and then we can use the again the the the size um function to get the size of the and the number of relationships from this article to any node through the the relationship type favors did and then for the uh for the value uh once we have the the response returned we use the um the response so if there's red stock records that length is is more than more than zero and then we can take that article count from from the first row and if there are no articles returned then it's basically a basically zero and then for the articles themselves we use the um the records array uh which is against the um the response and we map that so each of those rows we get a new article returned so we um use the article node uh we pull the uh the author node and then we um create a new instance of the user entity and then pass that through and then we have the the array of tags and other the favorite account and the uh the favorite two observations whether it's true or false uh so that's the value there um so that all that information is stored just temporary uh temporarily in in memory for for the uh for the duration of the request and then all the information is then um basic spout through this uh to json method uh so if the article is not found for example in this delete slug then we could throw a not found exception otherwise we use the the two json method um cool so if you're if you're interested in how all of these these tests are implemented then then then feel free to to take a look uh in the in the repository uh so everything is uh basically the actions uh sits under source and then either article or user at the moment and there's also this this postman collection which i put in the in the root of the repository and so what you can do is you can just download that and then add that into um into postman so you go to import and then you could drag in the file and then drop it in there and you'd have the same test available cool but we're going to going to skip out a little bit um so um i've i think i've done most of these tests i've done the uh the auth i've done the articles and i've done the articles favorites and comments there and so for example if we do a post request to slash article slash slug or a slug and then slash favorite then it will create basically a relationship between the um uh between the user and the article so we take the article and find the article by the slug the user by the the user id which it comes from the request again and merge a relationship between the two um if that is being uh created for the first time then we set a a time stamp there so just we could just tell basically that the date and time that the uh that the user is uh liked that or the favorite to that that article cool so let me see if these all run so your favorite we can unfavor that and create a comment for the article you can find all of the comments for the article okay that's not working so let's double check this so we've got the get request to slash comments which is this one here so we use article service to uh get the comments and then the error is at the moment it's can't map on undefined so this comment is is undefined at the moment okay so if we take a look at the environment variables and can find the id so there's no idea now at the moment so we've got an id there so okay so it's for the slug so i think that should be our slug that should be what we want cool because we've got that the data is in there so thanks so much so let's see what we can do on this one um okay so if we double check that slug see if that's correct yeah that's good um so what we can do is we can test this in the browser so if i set the param to be that value and then we can basically copy this again those query and run it in the browser that should give us the results okay so let's double check that so that should be all right so let's try and create that comment again perfect so i think that everything looks good if i look at the the comment we have the user commented i'll comment okay so it's not on it's got the relationship type in there um cool so if i delete that node again and then run the query hopefully it should now work cool so we've got the comments there so this is the comment and then we have the author there so actually one thing we probably want to do is order it by c dot created out in descending order so then we'll get the the comments all in order perfect file and delete that can't delete because it's not found just in case any of these aren't being added to the environment variables oh we haven't got the method actually implemented there so if i delete and then param id should be string you can delete comments so that should take the slug and should also take the comment id so there's only one there and so basically what i'm going to do if we actually want to return okay we don't really want to return any information about the comment that was deleted so for run again internal server can't use get id of null okay so what we need to do is we need to use the guard on that one as well because that user needs to be logged in so if we don't have that guard then the user isn't going to be appended to the to the request common id okay ah that's what it is so it's so the divide that you put inside this parameter then it gets um it basically looks for the value inside uh inside there so if i now again nothing should be fine so they're both in there's no nulls i'll run that again okay perfect so if we look back in the database now then if we look for comments we have this one here which i don't think is the one that we only created a couple now let's double check the id so it's a9c and i see it okay four not one there's no way this is going up on youtube user commented before cool keep the comments coming by the way it's uh distracted me from how horribly bad this is going so fast um right let's see what's going on so we've got the user id there and then we want this slug as well um so that as a slug and the comment id should be that time it's the user id so that is the common id so i try and slow down the the transitions and so common id is that and then this is our user id all right if we see if they exist commented it's not comment that's commented right always helps when you get your your query all right cool so everything's gone now it's perfect so what i guess one thing we could do is um we're returning true or false there so if resolute records.length is one um then we return true otherwise we return false and so what we can say is kind of like we've done here so i guess that would be like the outcome so if the outcome is false then it throws a not found exception um so if i run that again yeah so 404 not found so that kind of guides us towards the um the error cool okay right so in theory they all work um let's look at these uh these profile ones now then um so we've got one one article in there basically um so it looks like what this test does is it runs a post request to to users and then it creates a new user so it's basically using the same environment variables and so for example the username there is twitch and but it's put in a celeb underneath it and it looks like the goal of that is um because you want the you want to follow that and that user later on down the line so you want to follow the user based on their their email a bit strange there we go um so if i run that request then we should get everything okay yep so we've got that celeb so celeb twitch and we can use the uh the get um to get that person and so that's slash profiles so i think i might i need to be users okay let's go for it right so the first bit proper development so um if i so basically i want to create a new a new controller now so it's all part of this kind of this user module it's part of this this user sort of sub domain um if you're going to ddd terms um so if i generate a controller and i say user slash profile control that should now create me a this profile so the profile controller there cool so any request to slash um profile will get rooted through to uh to this bit um so it's automatically registered for me so i've got that profile controller which is registered as a controller so nest will know to to register that on anything that implements this this user controller cool so the method is um get profiles slash and then the name so it should be the profiles controller um so it's a get request and then we want that to be uh so it gets um index to make that async so we can use the methods there and so we want the the username there so celebtwitch if we double check the article controller so we want to do the same thing so we want to get the parameter out of that out that url um so the parameter is the first of that so i will call that username let me use the param decorator username username so if i just return that username for now cool so now we've got this uh this test is kind of running so it's returning about the user so it's slab twitch um but right now the test results are um some the tests are failing basically um so it's because i'm not returning any uh any json at the moment it's trying to convert that into json so if we take a look at the tests uh we want a 200 okay response which is uh which is getting uh and i guess it's failing on this line so it's trying to pass the response as json because that's not adjacent value then it's not working um so basically we want a profile um value and then that profile should be an object it should have a username a bio an image and then a following so i'm guessing that should be like a boolean true or false uh based on whether the user is logged in or not so for example if i say profile and then we just pass that through for now so it should pass a couple of tests uh yeah it says past three of the six tests so the response is okay um we've got profile there we've got a username there but we don't have the rest of the information so what we should be doing is uh finding this this user based on the um based on its username and so if we look in the user service so we've got a create method there we've got find by email we've got update user so what we want to do really is we want to copy that into a find by username function so username should be a string and then it should be it should return a promise which should be a user or undefined cool so we want to use the the nifty service so let's start an fj service we want a read query and basically what we want to do is say um find me a user where the username is equal to the username parameter and i want it to return the user node so again i say that the the result is um what gets resolved from that promise and then we basically call the same thing again actually so um so if res.records.length is is truthy so it's only one or zero so if it's one then return a new user based on the u so this u here otherwise it will return undefined so we can handle that in the controller cool so what we can do is we can inside the constructor because we want to use that that user service we can inject that in so private read-only user service spend too much time right in java cool to import that in and then we can say that the user is this dot user service dot find by username and password username and we want to wait that as well because that will return a promise um so if the user is undefined so if it's falsy then we can throw um a not found error i'm not found exception using otherwise we'll return that profile and that profile will be the value there so what we want to do is say that that is user dot to json so logic is it's kind of done for us already um all we need is the profile cool so 5.6 are passing at the moment that's there's no following property at the moment so what we want to do is we want to find um whether the the user is followed by by a particular user um so what we can do is we can create a new um a new method so we can call that so is following um so let's call it the target user and then i don't know if that's a good example or not and then we can say the um you want the following user so what we want to do is find whether the um there's a relationship between that user that is following and then the the target so again we want a um a read query so let me just copy this down again and so because these are both users and then we can say um target id will be target dot get id and then following id would be following dot get id um so basically what we want to do is we want to find um from the the user so based on the id of target id and we want to find so the current user um so following following id and then we want a relationship between the the two um so we basically want um so target follows that following cool so what we can do is we can just turn that into a single statement and following and target that's a match query um actually so what we yes that should be fine um so return count style let's count and basically so if it finds both users and everything is fine then um it will return one row and that will have the count of one otherwise other account is zero so this should return a promise which would resolve to a boolean and then we just want to return reds.records.length because just the the fact that that that result has been returned um should be good enough for us um we don't really care how many times that's been there has been followed and we just need to just need to know that it's there basically right so if we go back into um into here so we can say um so this dot user service dot is following and then we want the user and then we want request.user so what i need to do is i need to use the middleware now to um to work out whether that whether that user um exists and if it does exist then i can just append that to it um so the example will be in um the article controller so we're using the jwt health guard for these that's just fine cool so this will ensure that the if the user is logged in then that is then um passed through to request.user so that's always going to be user and then we want that to be the request choose that guy there and so if we take a look at postman so it wants the following profile a following property on the profile cool so what we can do is we can convert that so we want all of the information from the user.json to use the spread operator for that all right what was it called it was called following and we want to wait that and to get the response back we can just add that on there of course i've run that so again we've got a profile um has a following property now so we'll take a look at the body uh so the following is true sure don't think it should be let's double check what's going on with that query then okay so it's giving me an account so it's finding i don't know what that's finding that should be it should be nothing says take a look at these cool so what i can do is because i've got these these values in an object um i can say params and then pass the value through and then that should so that used to work as it were no okay let's do the old-fashioned way so target id should be that um and following id is that is that good cool so if i copy the query over yeah actually yep you're right so i was expecting it to not find because it didn't find this value and so it it won't find this relationship between the two so i was expecting zero rows um but for some reason it is give me a row but it's giving me give me none but if i just return star it gives me no rows so that's a kind of i guess kind of weird quirk of neo4js is it's doing that um so yeah we have to check the count uh because we're doing a return of the count but if we return the row then the row count will be zero so kind of weird but okay so red.records zero dot get count let's try that again cool following is false that's exactly what we want yeah yeah absolutely team yeah yeah it makes sense here so no rose means counting zero um if you return account then there's one row but with a um account of zero on that makes sense cool okay so um i was hoping i get all these things done because uh it seemed like such an easy thing to do but um i haven't got that done in an hour so um not good but i'll carry on i'll do the uh the following the the unfollow um feel free to stick around um if you um if you want to drop off in there then feel free to to drop off as well right okay so following a profile so we want a post request to this uh profiles and then a username and then slash follow so we want this to be in the um in the profile controller and then it was slash follow wasn't it um so the user's always going to be logged in so we use that auth guard again and we want this to be a post request rather than a get request and to username and then follow and so we'll create a method for that so a handler and we want this to be so call this post follow we want to get the username again and so what we're going to do is in the the user service want to create a new method for following that for a second so async follow um so we want the username of the user that we want to follow and then the user that is going to be doing the following basically um so switch shows right so that kind of makes more sense and if we check the response so we want a 200 response uh so based on the the um the profile again um but we want this following to be true on the end of that so it's basically the same response but that following should be true cool so we want to find that that user again um so to follow without a user uh actually let's stick to where we are um cool so the user and we want to call this dot user service and then we want to um follow um it will be the request user and at some point it probably makes sense as well to create like a a decorator for injecting the user rather than just doing request or user the whole time and then the username that we get from the request if that username is not found then we throw a 404 otherwise we'll return the information on the user and then it's following should just be true and this returns a promise of user or undefined of course this is a write query and so we want this dot neo4j dot right gonna match the target user where the username is a username we'll pass that through as a parameter and the user id as well the current user so match the current user where the id is user id i'm going to create a relationship so we're looking for follows inside here and so the current user follows the target that we'll give that an alias and then we'll say on create so there'll only be one relationship between the the user or the two users um so we use the use the merge and then on create our.created acts to be datetime cool so that looks good and then we want to return um the target user so then take the response and then we want so res.records zero get target to want to return basically a new instance of the user cool and if res.records.length zero then return undefined so if it would either have not okay so we've already got the user so it wouldn't have found that that current user so if that um that current user hasn't been found then it will be um we'll throw this not found exception otherwise we'll we'll then we'll return um the details of the user and then following to be true so if i check that so everything that's good said that i mean typescript's complaining there but i think that's just a problem with [Music] so conversion type promise user to use okay so we need to weigh in cool so it looks good so we're we're finding the the target user the current user uh we're merging a relationship between the current user and the target user if we're creating that then we created that property then we return the target user which then gets hydrated out cool so fingers crossed okay so something's done but something's failed um so we want a response 200 so i'm guessing that's returning then yes so it's gonna get returned 201 um so by default nest will return a 201 um on a post request to be honest i don't agree with that i think that should be a 201. um so i'm going to change that to b201 just sort of the test path because you're you're creating the relationship between the two like you're not um it's it's not just an okay response broken now two two one two one two one so i do i'll just 201 perfect so all seven pass now so we've got the profile which has got an image it's got the buyers got the id email username and then the following is set to true so it's always going to be set to true if we send a post request to this um to the showroom yeah so if if the username is uh is invalid uh so then that would be like a it would be a 400. sorry a 404 because the the user you're looking for isn't it doesn't exist it's not the the uh the resource hasn't been found um so yeah it should be should be either a 404 it should be a 201 for created um in this case so i mean that's that's my opinion anyway if you've got any um uh any opinions on that then yeah then then shout i guess um cool yeah um and yeah so i mean the the the test that i got so i basically just pulled them down from the um the real world um a repository so they they encourage you to create your own implementation um so they provide you with a with a spec um so you've got the front-end spec and then the back-end specs as well so for the back-end specs uh they give you um all of the the different endpoints and what they should should look like and then they give you the the postman collection as well so you can just download that and then import that in so i've included it in in the root of of uh not in that in the the root of this and this repository so yeah you just just download that and then you go to import add the file in and and then job done that's all you need to do cool okay yeah there's there's always like a weird lag um cool okay um so that's that's done now it's good so unfollowing um so i guess we're kind of doing the same thing and so what's this one so it's a delete request to the the same um same url so it should be delete and then we want delete follow and then we'll call the the method unfollow and then everything else should really be the same so it should return false um always so and that doesn't need to be async actually and so i'm gonna follow so we're basically doing the the same thing again so we want the user and then let's that's easier than explain it again cool so we um we want to find the relationship so r follows and between those two and then we want to delete r and then return the target cool so i've removed the um the variable from there because we just don't we basically don't need it um we're using that inside the query we don't need it um anywhere else so it just saves a little bit of memory um in terms of the the way these these two were written so in this first query we've got like match target user first and then we match current and then we create the current follows target and so um the the the direction of the um of the the relationship is important um because we're basically like it's kind of like if i'm following like a supermodel they're not gonna follow me so that kind of like i follow them they don't follow me um type relationship is uh is there so the actual direction is important um but the way that you write the query isn't important um so basically um when you run a query like this like a match query um when the the query first hits neo4j you get a um it's like a few milliseconds where it works out a uh a plan um so if i just show you for example um so if i put profile up front and username whatever and then run that again um so actually this is kind of a bad thing so i'm using like a node by label scan but in theory what what the neo4j will do is it will look at the the pattern in the query and then it'll work out the best way to to run that query and so i mean in this case it will it'll always be the same thing so you're kind of looking at the um the carnality say for example we had uh we had one user in 10 articles and we were matching from user to an article it would always start off at the user end first because of the lower cardinality of the numbers so that's a really cool thing um so actually what i want to do on this one actually now i've got this uh is that it's a um a node by um label scan and so basically what will happen is um right now the the queer will go through every single user until it finds um one with the property um with the value that we're looking for so that's okay over eight nodes but if you do that over eight million nodes and it's to take a long time so basically you can create an index or a constraint on the on the user um and the username property and then base that mean it will use the index rather than looking for everything so it's a lot more efficient when you're running the the query and then the the selectivity of the index also um also influences how that that query is profiled um cool so what we can do is i mean i could just run like a create constraint on user udot username is unique so i could just run it there and then that would be that'll be fine um obviously this is like a typescript and a nest thing and so probably we should put it in there in the application instead um so what we can do is in the so in the user module and what we can do is we can implement something called um on on module in it and that's basically like a hook that you um that you can add to any module and so when um when you have a um like a module that the nest um registers that has this on module in it um it will basically um run a method so the error here at the moment is that the um property or module in it is missing from from type user module so i can what i can do is i can create that as a function and i can say for example like console.log user module and then if i fix this and then you see it's got there the sort of the user module has been um has been registered it's been created and then that method is being called so what i can do is i can use the um the fj service to create that um create that constraint inside nest instead so as i add new modules to the application i don't need to run any migration scripts because nest will take care of that for me and so i can in the constructor again i can inject the neofj service and so private read only nfj service ufj service and i can say this dot neofj service dot right so it's not a read query to write query um create constraint on the user assert that the username is unique and then so constraint created so it doesn't look good um okay so i've tried to to create this now and then i've got i've got two users with the username of twitch which isn't good so if i just take a look at these yeah so what two records there um so let's just delete the first one so you can't delete a node that has relationships on it so instead of delete i can use detach delete which will detach the relationships and then delete the node itself cool so if i run this again it's all good so the constraint's been created um so the one caveat to this uh this method um is that if i run this again because i've already got the the uh the constraint the fj will throw back an error and so it doesn't doesn't just um yeah doesn't um yeah it doesn't doesn't fail silently but i mean what we could just do is just say like you know catch if there's an error then whether do nothing um and then that'll be that'll be fine um so then if i run um so if i've run for example this this query again i run a profile on that then i'm using a node unique index uh seek so she's in the unique index to to find that the user based on that like username so that's going to be a hell of a lot quicker than doing the the node scan cool and again we can do so we've got loads of um loads of things that we're looking up so i guess we could do that for for the user id we could use it for the um for the articles and things like that um whether it's a good practice or not i yeah i don't know um i think it's it's probably a good thing that it's it's there um so in terms of it being um initialized it's only initialized when the application restarts so for as many queries that come in that that query is only going to be started once so say for example you've had like a load balancer that had um three application servers on there then in theory that would be run three times and then when you run the next upgrade or you know you you auto scale the the group then you'll you'll get the next one um i don't know i mean i'm i'm happy to be convinced either way i think it's i think it's okay um but yeah i mean people people might have a different opinion you know some people may think well actually we want to create that outside of the application we want to create that in the during the data import process and that's fair enough that's that's fine as well um yeah i don't say it's fine um cool okay um so we've got that in there right so what we're looking at um so param username is um celeb twitch cool so let's try that request use a sled twitch not found so do we have the user in there so we've got username slow twitch we've got twitch so have i done that on the wrong and the wrong property so the target with the username of the username the target user would use name the username followed by easy writing does that come off okay yep slip twitch so in theory i should be able to turn style maps nothing there okay uses that okay so it's in uh it's in our controller so the profile controller um so i'm guessing it'll be this this bit here um so so what we want is for this request um what we want to do is um we don't really well we always want to want to return a user um because we always want that user detail um so we can say that we'll find that user and then we can say that for each of the rel in and we use a patent comprehension there so target follows user and we'll delete that route and return the target so if if the user isn't currently following them then i mean we don't really want to complain too much about that cool so there's the value there and then the following there is false awesome so we can now follow somewhere we can unfollow them so i'll just create that relationship again and the one thing left is tags um so let's take a look at the test so we want a 200 okay and so we want a tags property which contains an array of the tags so the tags are so these nodes here so they've got a um an idea name and a slug and so i guess so in hindsight if i was going to create this again i would instead of having this um article module i would have a like a content module and then the articles and tags would sit inside there so i guess i'll just i'll just stick that in there for now um so i want to generate a new controller um for the tags so let's call it article tags and then i want to generate a new service nest generate service and then article tag service and what i want to keep want to keep that's fine weather don't want to worry too much about that um so this is a basically a list of all of the all of the tags um so in the in the user service um my in the article service i created this list function which basically has all the info in there so it doesn't look like there's any any pagination there's no no hints as to what's there it's just a pure list um so and we just call that list and then that will um will be return a promise which will resolve to um list of tags so i'll create a tag um export class tag so i want the node let's start node node i'm gonna implement like a two json method on there as well and then for this i'll just return this dot no dot properties so node i need to import from nifty driver and cool because there's no i mean with like the the user for example the whole reason i went for this with this pattern is that i wanted to hide things like the password i wanted to to manipulate the the bio or the um or the image to return like a default image um but yeah i mean it's just like a nice wrapper i guess cool so i want to import that tag in um and then so i need the nifj service so private read only fj service which is a fj service on fjservice.read tag return to rare so i want to return res.records.map row new tag row.get cool save the tag controller i want to inject the tag service i want a private read only tag service and get list that's a get query and then just return this dot tag service dot list and then that should be inside a tags object so let's take a look at that so tags there so it's a an object at the moment so i guess it's not being hydrated properly um so i can say map tag to json um oh no actually so um tags is a wait so it's a the function returns a promise so i just need to await that and basic it should be okay now awesome so we should have two tags in there uh yes we've got the id name and the slug of each of each one of those cool okay um so that is all of the the test passing and there may be one or two that i've missed inside there but in theory that should all work um so um i guess in another session what i'll do is i'll hook up this uh this ui to um to the back end and just make sure everything works and then and then clean up around that and yeah so like i say everything is up on on github so i'll push the the changes this in the next next half an hour or so um to this new fjsjs reward example app and then we will we'll go from there um yeah so i guess like in terms of this next steps um so the um the entities and things like that so um i mean we could um we could use something like um like neod um we could use um something like like driving some sort of ogm orm and to hydrate the results and write the queries for us you know could use like a dsl to run the queries into to auto generate the queries for us at the moment and there's nothing really for typescript which is uh on that level at the moment um so yeah i think we just have to um have to play it by ear on that one um but yeah so in through that should all be working um if anyone um all the few people are watching so if there are any questions um feel free to to reach out um i mean you can if you have any questions on on the neoflex or twitch project or if you'd like to build a front end then feel free to reach out um and uh yeah we'll create an issue or something like that um or yeah um i'm adam cowley on twitter um or yeah otherwise i'll uh i'll see you next week cool thanks everyone take care you 