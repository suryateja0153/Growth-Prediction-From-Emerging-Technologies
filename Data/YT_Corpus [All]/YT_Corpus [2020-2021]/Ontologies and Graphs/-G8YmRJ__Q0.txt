 good morning or good afternoon my name is Ian Neal I'm an ASP asp.net web developer who's used neo4j for a few years I'm a visiting researcher at the University of Mainz in Germany and I'd like to thank you for the opportunity for talking about codecs and text as the graph approaches that have been exploring I might turn over to screen share so we can look at our our slides so what is the codecs the codecs is a text as a graph solution with the aim of achieving the deep integration of text and data what that is exactly the deep integration I'll go into in the course of this talk sounds a bit grand but basically I'm trying to leverage the power of the graph to bring insights into entities within a text and more importantly between hundreds of thousands of texts so the approach that I take is yen yes probably stop and start your screen sharing again because it's not showing all right now okay just attempted again much better cool excellent thanks thanks mark so the approach I take is to manage what I call standoff proper standoff sound off property documents linked to graph entities and as you can see in the graphic below is an example of a text that I've entered within a specially built editor that enables visualization of complicated annotations and interaction with the graph so behind all this is a graph metal model where entities are built up and defined by composition from a collection of statements and meta relations the whole system is easily extensible you can add annotation types to the editor and you can add you can build entities separately from the editor so it's it's equal to bi-directional and as you can see in this this text example here and in further ones I'll show text annotations a high resolution and multi-dimensional so by multi-dimensional I mean that they overlap basically it means that you can look for connections between entities which overlap the same region of Texas not just in the single dimension so the technology behind this well obviously neo4j is the driving factor it's what enables us to find any insights into these these documents and these entities on top of that I use the linear for J client API this in the OPI was developed by ratify and maintained by Chris garden were great near for J contributor and on top of that I've built a number of extension methods and other methods which create a kind of almost a mini domain-specific language it's to ground a term but it kind of helps me deal with some some of them will visually complicated cipher expressions and this is all connected to a speed on NBC the UI interface the V modal's and forms a drum by knockout and a custom standoff property text editor which which I've created now these are the main entities in codex for this talk I'm only going to be looking at the ones highlighted in red and these are the the main properties on them so we essentially have our texts which is a text node we have a standard properties which are stem of property nodes and these data property nodes are our interface between our text and our graph entities now the text is a graph approach there are various ways of doing this but essentially at this point in time it usually deals with a text which has been broken up into into word tokens or into tokens and these tokens are then represented as a linked list and the graph annotations are nodes which link to to either a single word or a to a range of words I've taken a different approach with standard properties using standoff properties you can map not to the token that way you can map to a single character you can map to between a character but you can still represent you can still have multi-dimensional overlapping annotations like you can with with text as a graph so the point of texts the graph is to two fully annotated text the idea is that you don't the XML which is a format used in the humanities for representing manuscript documents for for for capturing annotations for capturing meaning this is fine for many cases but when it comes to annotating the full meaning of a text you find that texts aren't hierarchical in the way that XML is hierarchical there are meaning crosses boundaries across these lines it crosses paragraphs and so you need a system which can easily map across you know across these boundaries so I thought here I would illustrate very quickly just with a series of screenshots here of what happens when you try and annotate something with with XML in XML and HTML a range is represented by a node or an element within a document object model for example so when you want to cross something cross those elements you have to split them so we can see here that we take this example text here this is fairly understandable as HTML or XHTML we've got a text we've got various annotations of bold annotation and italics annotation and we can see that the text lines up in a kind of containment way you can see this this is understandable what this means there's no overlap there's nothing complicated but then if we we can we can annotate within the bold tank here we can so within the bold tag we can make something italics now we're starting to lose some of the readability of the text stream but it's still fairly manageable but then when we start to cross our annotations so we cross our streams then we get into really broken I'll call this XML because this is not not far different from what would be represented in a TEI XML or text encoding XML document this XML would would require special handling to to export it as a readable text stream for further use in say natural language processing text analytics effective semantics that kind of thing it was also not very manageable within your own system if you wanted to search within your texts if you wanted to compare things within a text you're now having to write complicated XPath XML expressions to make sense of this fragmented structure which has been created by quite a simple years case so I came across the solution to this it's a very simple data structure called a set of property and essentially a standard property contains a start index and end index and a type and the these indexes are character positions within the text and the type is the name of the annotation itself now if you think about we saw before how we had bold and italics those are stylistic annotations so that would be the the annotation type the the beauty of set of properties is that they're stored externally from the text string which is left in a plain format so you have your plain text with no markup no XML no no markdown absolutely nothing completely readable by human beings you can submit it to a natural language service but the annotations are represented as an array of standard properties because you're dealing with indexes character positions you can annotate your annotations can can annotate inside a word which you can't do with Texas graph because as I mentioned before text as a graph is at the level of the word token you can annotate a single character you can even annotate between characters to insert say a footnote number for example so this ability this is quite quite a powerful ability to address a text with annotations the annotation layers themselves can be filtered so you can export a single layer if you could define a layer say as all italicized text or everything mentioning people or places syntax information so each any of these things from using a simple JavaScript filter you could decide or psychically or you could decide but - I'm only interested in a particular slice of these annotations this would be quite difficult to do in Unix and of course it supports what's called multi-dimensional queries so we can now if we can represent this construct in cipher in in the graph we can do graph queries across multi-dimensional annotation so we finally have a bit of cipher so this is a representation of what of the schema for a stand off property graph so I've described what a stand off property is which is the description of an annotation within certain indexes in a text but we still need to use this in a graph so we have on the left a text node which is which for the most part just contains the raw text it's got a field called valley it contains the raw text then we have a stand of property node which contains as I mentioned a start index and end index a type it has a few other properties which we can look into later such as attributes and so on but these are mostly so essentially non optional properties so we can see that there's a relationship between the text and the stand of property simply what a simple one of ownership the text has a stand of property and we can see as well that the stem of property can refer to something else so I have a node in my system called it called an agent which is the term I used to mean any kind of entity the person place concept well if you like and we can see here that our style of property can optionally refer to an agent and once we get into the agent we're getting into the into the graph metal model these other relationships show that you can you can use standard properties in a graph way within themselves for example you could you could say that a stand of property is a subset of another stand of property so if you wish to have xml containment where one element contains another element you can represent these ideas within standoff properties as well so what I thought I might do I might actually switch to the codecs interface and look at a practical example so this is a letter from Michelangelo the sculptor to his nephew Leonardo and there's a lot of stuff going on the screen but the main thing like to focus on at the moment is this display here with the the text this is a read-only display showing the annotated text if we click into various parts of the text we can see something happens in this area down here I call the monitor basically this shows you the annotations which overlap this position of your cursor so I've built this this editor basically you can interact with your annotations and the text and then we can see a whole bunch of other things which we will look into shortly but the first thing we might do is actually just open up this document so what we have is something that I've tried to make as much like a basic text editor as possible and thing I didn't mention before was that while Stan of properties sound like a very nice way of getting around overlapping problems of extracting markup from text they do have one big downside and that is if you change a single character you delete or add you threaten to invalidate all of those character indexes that you've created so that what that means for example this this property here is red underlined a it's team this agent if I add something to this point if all those indexes are going to be off because I've added a new character that's what's traditionally held backs the standoff property approach because it's very fragile it's very rigid however I thought of another way of approaching this and that is to treat the text itself as a linked list so in a way a kind of graph so we are here directly changing a text graph in JavaScript so I can type in something here and again yes it's still showing your slate for me okay thank you my apologies about that okay can we see the Codex screen I'm having it go sir I thank you okay thank you very much yep my wife called Isabella and so I I'm assuming if we didn't see this section here so basically what I've done is I've created an editor using a linked list model that allows you to insert or delete text without affecting these indexes so I'll just type in something here and visually we can see they aren't affected but actually at this point in any case we might not actually see anything but we can do a export of that using the unlined button and when we the unbind button we can see our new text here and we can see our properties the ultimate proof is to rebind that if I hit the rewind button we can see there are new textures there all of our annotations are still there there's been no expensive recalculation of indexes because of use the linked list to insert items and calculated the indexes at the final point so this solution has worked for me so far enables a kind of real-time text editing annotation experience there are a few other things you need to do implement with a an overlapping annotation editor you have to to handle how to display these things how to connect to them you also what happen you have to solve questions what happens about if you if you delete text that contains annotations halfway through text all this kind of stuff but I've got to a point where it's quite stable I just really like this every change that you make toward every time you save a document a version is kept of that so you can jump back to a previous version necessary so the interface here looks rather like a text a little book with these kind of strange buttons these buttons bring up windows which allow you to either reference neo4j entities or to create them on the fly so let's say for example we wanted to link to a particular entity here we click this button it pops up a window it hasn't found anything with that particular name we can search for any textual references to it if we don't find something that we we in the system already we could check the inline tab which shows us all the entities in this particular document pre-populated for you or you could find something that's been recently created or you can create something brand-new a very basic version so we might say this entity is kind of a concept of a fool and we can hit save and select and we now have a new entity in the system we click one of the little arrows here and we get a whole bunch of options for dealing with this entity we can move our annotation around which is useful and also kind of fun you can make it B or a smaller the main thing is that you can make these Corrections once you've created them and you can also you can switch you can change to a different reference you could clear this and find another entity if you annotated the wrong thing but I can see here that the the link is correct and we've got it there so at this point I'll save this document what happens at this moment which seems quite simple is that that text is unbound from the editor that as a JSON object it's sent to the web server the web server then constructs a standoff property graph like the screen I was showing you and it tries to make as minimal changes as possible to the graph but essentially it rebuilds a graph and reattaches any references from the stand of properties to your to your graph so in short we added a new annotation and now we can click through to that entity itself if we look at the entities tab here this visualizes our entities we can click through to our brand new entity we've created we can see where it came from what letter it came from we can see how it was mentioned in the text and so forth so we pop back there for a moment and I'm going to attempt to load the slides get us back into there we should be on the sly screen the okay so I'll just briefly cover some of the other chief entities we have an assistant and because they are kind of principal there they are the glue that holds these these texts together so one of the concepts we have is a matter of well what I call a meta relation and a call that because it is a relationship like a standard near forge a relationship in some ways but it takes a different approach and it's a little bit like the realized later it's a bit like the the Marvel Comics approach of dynamically create an entity creating relationships but there's a one other component to it so I met a relation is is something it's a kind of relationship which the user themselves can create within code X and that's primarily how relationships are built within code X you can create it from within the text document itself if you see a relationship for example we have here Michelangelo is a dear friend of Giorgio Vasari that was a relationship I saw mentioned in the text itself I could create that in line using one of those modal windows and when you create a meta relation you specify the two sides of it the parent say for example parent of four child of and you do that because you both dynamically created but also the way that is represented in the graph model there are no there is no parent of child of here we have simply an agent being related to a metal relation hyper node so this means that we can have a parent or a child here that both related to the same thing and we can but we can retrieve them both at the same time we don't have to know what direction the the the arrow is going we simply can say I'm going to get the parent-child situation more complex and the other thing that we can do is because we're now dealing with with the graph here we're dealing with an agent related to a metal relation and this meta relation comes you know empty node is related to this what's called a a meta relation type which is where you define both sides of this relationship you know parent parent I love child child or we can also define also link this meadow relation type or schema to a concept which is a hierarchically organized collection of tags in the system so I don't want to call it an ontology because it implies a sort of top-down structure but it's a very free-floating way of building up hierarchical structures within codex so you could say simply you have a Java programmer is a subset of a programmer for example and so both of those nodes would be concepts related by a subset of so here we could say for example that this meta relation type is a type of parent-child relationship we can then go further than that we can say this this concept parent-child is a subset of family relationships and that's a subset of genetic relationships or something like that and the power of this is that you can now query the graph in a higher-order way so you think about all the different kind of relationships where actually grouped you have parent and child sibling or marriage son-in-law mother-in-law etc you can start to think of them as you know as higher-order relationships a family set of family relationships a set of friendship relationships so you can imagine how useful this technique might be when dealing with say historical documents where you're looking for all of Michelangelo's family all of his professional connections all of these friends you can run a query which would get you back that information one got it I'll attempt to switch back to codex now what we can see when we have that information we can see a listing here of Michelangelo's relationships but more interesting Li we can start to bring that back into the into the text itself so we can start because we've created these entities and these entities have these relationships we can ask the graph can you find me for example sentences where Michelangelo and any of his brothers I mentioned and I've created a view here where each entity is color coded so we can see easily a sentence where Michelangelo and four years before his so someone is these brothers I mentioned you know Leonardo barato Johan Simoni and singers one day we can also flee because we have that information I've built a very rough and ready version of this but basically we essentially have this graph information which we can extract from a text I've just started playing with Sigma J s to visualize rough relationships this is a visualization of the relationships of all the entities within this this letter from Michelangelo and how they're connected and I intend to build a more functional interface where you can click through and connect other texts which are linked to these these entities here the other important element is statements which I'll pop back into this slide for a second they enable you to create relationships between multiple entities within a text a simple we're thinking about this is an event so you would have say Michelangelo went to Rome with Leonardo his nephew not DaVinci so you would say you have Michelangelo you have Leonardo you have Rome these are agents which are all related around a central activity which is arriving at a place you might have a time as well so you can represent that below the statement schema allows you to capture in in a simple way but quite an extensible way we can capture quasi grammatical relationship so we can see here we've got a subject object but we can also have things like at with according to so if we come back to our text here okay Michelangelo's probably a better example just wanted to find an example of an event but we're seeing lots of examples of traits here which is interesting but the next part okay so for example we can see here that Michelangelo in this text here he says I used to consider that sculpture was the Lantern of painting so we can represent an event in this case a thought is a kind of event so using this property here on the roll we can say that according to Michelangelo who was in his letter he had a thought that like Michelangelo's thought that sculpture is the Lantern of painting so we can establish either quite simple relationships or we can build more complicated ones once we have those statements we can we can represent them in our text and we can we can go to any one of these particular parties so we could go to the statement screen can see a breakdown of what's in the statement we could go to we could have our chi here we could see from his point of view how he's connected to this statement so we can start to capture the discrete events within history and these events don't have to be just actual events they could be thoughts they could be qualities of things as well so for example here we have using we're using the statement in a slightly different way to represent a trait of somebody so for example the trait of being of being famous so if we pop back to our slide here we can see that we normally represent the the ontology of something or it's it's classification by a type so in my say in is a relationship so we say seven enroller who was a Renaissance preacher was a is a preacher is a man but this leaves have a lot of interesting stuff that we have in historical documents that we can break down into traits so I've reused this statement concept to represent every statement about seven a roller is represented as a discrete trait you can think of this I call this an aspect oriented ontology you can think of it in Java or C sharp as being an aspect on the method or an interface that which is descriptive and each of these things is an aspect or a trade so we can see here that seven roller is you skip according to land uchi is given the trait of a man of holy life and so on and so forth so if we go into codex we can actually query our entities on the basis of specific traits so for example we could look at what are all the Florentine things in our system and logically you're going to get back a lot of people florentine people but we can also see that we get back things like florentine corn this might be interesting if you're a historian of agriculture you're looking for you're looking for you know food consumption you can actually see you can you know we've got worthy citizens we can attach whatever traits we like we can take things which are a little bit more abstract like the concept of many having more than one we can see that something is described as the many nuns and the memories of pressure so we've given them the trait of being many so I call this an aspect oriented ontology and it's something that I'm implementing with the complete letters of Michelangelo and the diary of Medici is contemporary and I'm hoping to find some interesting connections here on this is aspect level so we're just about done I wanted to talk a little bit as well about the technology side of it in terms of the C sharp or demonstrated the use of the editor the the graph models at least just a very small number of the graph models but this is another tool which I've added to the system which has helped me iterate fairly quickly so near forge a client is a c-sharp API that sits on top of the near forge a driver it allows you to switch between rest and bolt seamlessly it gives you a cypher expression builder which we can see here mostly the the functions of keywords it handles safe safe safe parameterization values and it has a very powerful DC realized at turning and the results into complex objects now this already is quite powerful in useful but I found as I was working with it I wanted a little bit of distance from dealing with hard-coded text labels so I created set of extension methods which I call mere forge a client vector which is get up and to do this I created a vector generic class where you can represent a path in the system so I'll start learning and end node in a relationship and basically what it does is it generates the naming for you so it generates the soft the cypher expression with the label names and relationships and so on and you can see here that you don't have to worry about what direction the arrows are going in because that's all contained within the vector class it knows what direction the relationship goes we don't have to put any labels in here for any text or other relationships and in some case where we have a transitive kind of relationship here text however has a property the property has an agent we can even represent them without any relationships in between because it understands that you'll focused on the nodes here so I find that this kind of these extension methods for me have helped me iterate fairly quickly over it I can rename relationships and labels which I've done I can rename them within the vector class without having to rewrite any cipher I can I find myself dealing simply with the cypher node patterns I don't have to worry about the visual we called the visual noise of all the other aspects here and there's a couple other useful very simple additions to this which allow me to build these dynamically driven form inputs where we have for example searching by name by children of code and so on rather than doing a complicated set of if statements we can control all of this within these extension methods here and on top of that I built a simple pagination library as well which will take the cipher query and it will automatically skip and limit for you and with a bit of reflection it can work out you know the names of of notes and so on it also has a way of dealing with the order by statement in for me which is a more natural way of dealing with it by using for these these parameters so that's kind of the the C sharp side of things I think we might be running a bit over time I mean there's certainly a lot more I could show if we had we had the time but I don't want to to take out more than my allotted period so I'll just ask Michael if should we hand over to Hunger Games questions yeah I think that's one question from John directly what percentage of the annotations of a document would you consider automatic and what is menu in other words would you be able would we be able to give codex a volume of documents and food forget at least some basic attributes from that already okay that's an excellent question to some extent I can answer that here for example we have something I didn't mention is the natural language integration its critics is integrated with the Google Google Cloud central language API so for example if you click the named entity recognition button you get back a bunch of of candidates so they're not all automatically assigned I find with historical texts that all of these entities don't appear on Wikipedia they're not out there in the knowledge graph they're very specific to to the context but what what I found useful was to say well can you identify all the all of the nouns for me can you find who they are so for example if we we've got the entity of Rome here I can very quickly find Rome in the system if it exists already I can also create that I can select it the turns gray it's been it's been acquired I can then copy in place any references to Rome and so Rome any anywhere else in the text gets updated as well so that's not a full system it's it's I mean it is possible to plug in to the rest of the big Google NLP with the entity named entity recognition and to get for example to go through to Wikipedia but I prefer to do a combination of assisted to the a machine assisted and and hand annotated annotations because it gives you more control over that and this this button as well we'll do pronouns if there's any that haven't been annotated it's only showing ones that haven't been annotated at this point but the other aspect to it is you have as well the ability to call out to Google's syntax API which you click this button it will generate syntax and sentiment because all of those things syntax and so on if it maps back to text can be represented as annotations themselves so these are statically static annotations generated by Google this is a sentiment analysis of this text we can also look at the syntax of that text as well we can use that information that syntax information for example we can say we could use that this is whether multidimensional querying comes in we can say for for a particular entity like Luke Allen do Qi find me anywhere where he is in the third person and it will bring you back a sentence where that occurs and automatically highlight those references for you we can even raise that to a higher level and say looking at the morphology or the dependency tree of that syntax tree bring that information back as well I think maybe there wasn't one found in that case just very quickly review as well we can see here with that syntax information we can see entities which are syntactically linked to land uchi in the tech so we're they're linked by the grammar tool and uchi so this gives you an overview of every text that land uchi is in what is grammatically linked to lambda chi or who is in the same sentence as lambda chi thanks too near for J is an incredible index free adjacency these queries run very quickly we can see every entity which appears in every text in every sentence with lambda chi or if you do it at the text level as well we can query other parts of speech within the same sentence and so forth but that's basically where you have some of that integration there between generated information like syntax and between hand annotated information a crisper Christophe has no question if you have any mechanism to deal with metaphor or other non literal text its mapping to literal state of affairs I don't have anything to do that automatically I am I've been talking with Dean over zeti the Italian digital humanists about applying vector semantics he's very interested in vector semantics so we're going to see if it's possible to generate vector semantic analysis of a text corpus and to bring that back into codex and some in some way but on a manual level I have been looking at actually creating a clone of annotation like a metaphor or what I call they a a connotation or a Association where you could say that something has a connotation of something else in the text the the stem of property editor which is the the text editor I showed you that is totally open source and on github right now with a certain amount of documentation and and a demo the Codex mbc side i've got to basically put up on to up to github and make public I'm still cleaning off the kinda bit and adding some features but it is it is intended to be open source 