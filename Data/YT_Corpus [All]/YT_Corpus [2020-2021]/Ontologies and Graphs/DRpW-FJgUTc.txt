 so well first of all a bit of an introduction so my name is jesus barraza and i've been with neo4j for the last uh five years or so and one of the things that i've been working on is in this plugin called new semantics that makes it possible to integrate with uh with rdf from neo4j the kind of things that we're going to be seeing today and the new that new semantics make possible is things like importing rdf data exposing your graph in neo4j as rdf um things like model validations based on on shackle for example and some other things but i guess the focus for today is to give a bit of an overview of some of the new features that we've included in 4.1 which was released last week so before i get started just a couple of pointers so what you see on the screen uh is uh the neofj labs page where you see a number of projects very interesting you might be familiar with some of them so there you find a link to new semantics so you can get from there um access to the manual some examples help on on installation and and so on and so forth so that's probably your best point of access to all the all the materials that i'll be i'll be sharing today so um my plan is to have a totally hands-on session so i've not prepared any any slides so what i'm going to be showing you is me writing code and writing cipher and uh and showing some of these uh features in in new semantics i'm also be going to i mean i'm trying to monitor the um chat in case there any questions feel free to interact and and anything that's unclear or anything you want me to cover please let me know so uh starting point like i said is a completely empty database so uh all i've done uh is just install the plugin is like any other plugins you might have seen before so you just need to copy the jar file in the plugins directory and off you go so um i'm going to start by probably the simplest example of of import rdf just to give some context for those of you who might be less familiar with it and what the example that i'm going to use is a is a simple rdf file that i've created on and i've put on on a github repository so i hope you can see it but basically it's a simple uh turtle uh file uh where i describe a i mean the beatles uh band right so there's a description of i understand that most of you probably are familiar with rdf so um you see that i'm describing a resource that i identify like details using a namespace ind which i define here and i'm stating things like you know the beatles is a music band it's also an artist and it has some properties like the name and it's connected to the members right and for each one of the members there's a small description so pretty straightforward there's nothing special about it there's information also on um on one of the albums and and what are the tracks one of the songs in the album but it's and and then something similar to the rolling stones but it's a pretty simple and straightforward uh fragment of of rdf so what i'm going to do is show the basics of how this input uh happens right so uh and in order to do that i'm going to just grab a little fragment of this file uh just the the first bit here where i uh describe uh the band and the connection to the to the members and i'm going to go to my neofj browser and show you how can i use it so um neil semantics is implemented as a set of stored procedures and as an extension that we're going to be having a look at as well but the procedures can be accessed uh from the browser from your code um and um you get access to them by typing uh you can write ntns which is uh the acronym for neo semantics and and you get uh the whole list of procedures is a long one so what i'm going to do first is is a preview uh so one of the things that you can do is um to rdf preview so before i actually run the the the input and persist the results uh uh in uh in the database i can see what it's going to look like and that's what preview do for me and you will see that preview has um two flavors and that's common to all the procedures that you'll find one is called fetch and the other one is called inline so the inline is uh created to take a fragment of rdf as a parameter whereas the fetch will take a url a pointer to a location where we can retrieve the rdf and that can be a static file like the one i've shown you it can be a service it can be a sparkle endpoint that produces rdf it can be anything so for this example i'm going to use the inline mode right so if i go with inline all i have to do is pass the the fragment of rdf and specify the serialization that i'm using because this is turtle and to make it more readable i'm going to introduce some line breaks there and i'm literally pasting the the fragment that i had taken from from the file right so this should be a bunch of triples one two three four five six seven approximately and i can i can see what they would look like when i import them in neo4j so if i go ahead and run it run this i'm going to get an error and this error is telling me that before i carry out any any input or even any any preview i have to create a config and and a config is basically an object in our graph which describes how this transformation from rdf into into neo4j graph into property graph is going to happen i can go with the basics with the defaults so i can do something like um init and this is the method that initializes it and i can like i say go with all the defaults and this is going to create uh this basic configuration for us so i won't go into all the elements but you can define things like for example how to deal with your eyes as you know in rdf all the elements are uniquely identified resources but also properties relationships types so that's important of course and but when i import into neo4j i may want to keep it in case i want to regenerate it or i might want to just ignore it right so um that's one of the things that i can i can specify by default they're going to be kept but they're going to be shortened i'm going to use a a a kind of a prefix annotation to make names more usable from from neo4j instead of having to handle the whole urls but there's many other things that you can configure things like for example how do i deal with multi-valued properties right do i want to again ignore it and just keep one single value do i want to combine them all in an array neo4j there are many options there how do i want to deal with types types can be mapped to labels in neo4j but they can also be represented as a separate node so there's a number of options but for now i'll like i say i'll go with the defaults and and now go back to the attempt uh to um to do this uh preview and hopefully now i should be more lucky and i get something that looks like a graph it's exactly what i was expecting right so we see a node at the center representing the beatles and we see that it's connected to the four members right so the there's been a kind of an automated translation from rdf into the property graph and essentially what's happened is that um data type properties uh properties that has uh in rdf that have us object a literal will be transformed into uh node uh attributes so you see that here this node the beatles has a property called name which is the beatles right and it has a uri as well your eye is a unique identifier but you can see that what's happened and i'm going to close this bit here uh if we go back to the rdf when i say that the beatles have a property called name with this value this is uh stored in neo4j as a property of the node uh but on the other hand uh the object properties in rdf the ones that connect to other elements and these other elements will be other resources like john lennon paul mccartney etc etc are transformed into relationships in neo4j so we see that it's a connection of type member that connects to something for which i don't know much yet i only have it's uri i know it's not representing ringo but i still have not imported uh the the attributes and the rest of the information because i just pick the header so that's that's basically it i mean you you notice that things are being prefixed with this ns zero so uh the reason for that like i was saying is that by default we're going to try to keep the the namespaces and we do that with these prefix and which are going to be generated dynamically and as 0 1 2 3 etc etc unless we want to define them ourselves to make the graph more readable so that's that's pretty much uh the mechanics of the input at the moment nothing has happened because this is a preview like i was saying but the moment i replaced preview with input this is going to be persisted in the graph so um good so like i was saying i don't like this uh ns 0 and s and s1 et cetera et cetera so i want to define my own prefixes and i want to use the ones that are are being used in the rdf document so there's a method that we have in new semantics that will do that for us uh is ns prefixes we can add them manually we can list them at the moment there should be none because we haven't created any or we can import them from an rdf fragment which is this add from text that basically will take a fragment of rdf in any serialization and we'll try to extract namespace definitions so what i'm going to do is again take a fragment in this case this is just a two but i could take any random fragment and and if i do that it's detecting that there's two namespaces and if i now rerun the input that i did before it's going to look slightly better because now um the prefixes are aligned with the ones in the document that's just pure uh uh more useful user-friendly but it's it's it's exactly the same so the rdf is preserved so enough about previews so we can maybe just uh uh uh we'll we'll go ahead and run the input of this data set so we're going to now do an rdf import and this time we're going to fetch it directly from the url instead of me copying a fragment and pasting it i'm going to put the url and again i'm going to specify that it's a turtle format so um remember one thing so if i take that url it's not going to work because this is actually html we have to go to the raw format because that's what's going to actually return turtle serialization so if i do this interestingly i'm going to get another error but let's try oh what's saying it's telling us that it didn't work we had a ko uh because uh there's a constraint there's something that's required before we can actually persist uh some rdf uh in the in the graph and that's a uh basically a constraint so we have to and it's quite handy because i just need to copy this and paste it but essentially what we need to do before we persist any any rdf is create a constraint in uh uh on the resource label any resource rdf resource is imported into neo4j as a node and it's labeled as resource and it's given a uri a unique uri because we want to be able to uniquely identify we want to be able uh to incrementally import rdf and things merge uh uh um transparently without us having to do anything else and that's all done based on the uri so this uh will make will guarantee that we don't have duplication we will never have two nodes with the same uri which is the whole point of of your eyes and it will also uh implicitly create an index which will accelerate some of our our queries and and operations on the graph so if i rerun what i just did this time hopefully it will be more lucky okay so 53 triples were imported these are the name spaces that have been used and there were no additional params because i use all the defaults so um if we now have a look at the graph um hopefully let me refresh because sometimes it doesn't pick it up there we go so now we have a number of labels here for example i can see some albums let's change the style so we can make it more readable so we have the two um albums one is the the the white album from the beatles and out of our heads from the rolling stones but you see that we've created a graph just by importing the rdf right so uh and we have tracks we have uh the artists members and so on and so forth so you know successfully import um good so that that's not new that's been there from from the very beginning so it was just kind of uh some some context but what's new in uh uh in um in photo one is that now we can uh we can use rdf star raf star as you may know is uh one it's kind of an extension of rdf that makes it possible among other things to serialize uh things like uh um properties of relationship is there is a way of uh doing a much nicer rarification so without having to do actual verification so um and that used to be one of the traditional uh limitations right so that you can set properties on relationships in the property graph but then you didn't have an easy way of serializing them as rdf so that's one of the things that we've included and i want to show that to you now so uh we've shown how to import rdf now i'm going to export show it uh how we can uh present uh the content of of of the graphing neo4j as rdf and like i mentioned before we have um a an http extension that i can invoke from the browser using a get that generates an http get request on this browser so i'm running it locally so that's 7474. all this is in there in the manual but basically i've mounted the this extension in the rdf url then i have to pass the name of the database because i'm using the default one is neo4j but if you're working on on any other database you know that we can have multiple ones in in from neo4j 04 you have to use the name there and one of the first things that i can do is do a describe to do a describe i have to pass the unique identifier of a node right or an element in the graph so let's say i'm going to take the beatles for example so what i need is uh to take its uri so let me copy the address and i need to basically the problem is i need to url encode it to pass it um let me do that um actually if i paste it i'm going to get an error if i do that now let me reduce this so uh but i can url encode it just by calling well there's a number of ways you can do it but we can use eight book for example uh text url and code it's just to pass the the parameter i mean you can use any any url encoding utility on the on the web but if i take this uh url encoded a version of the of the identifier of the node hopefully that should produce um an rdf serialization and by default is using uh turtle which is the default of course and it's interesting that you can probably see here that we're reproducing exactly the same url you know rdf that we imported and that's why uh preserving the uh the namespaces is sometimes important sometimes important so you see that the these prefixes that we're using here are being translated into the actual uris in in in rdfn and of course you can do things like uh change this realization format you can do it in a couple of ways so you can say i want it in rdf xml for example and again to realize rdf xml or as popular these days json ld you can get it as json ld um and uh well you can you can do more things that this is just uh exposing an element based on its uri and typically a node but you can also run a cipher query and and export the result as uh as rdf so that's um yeah probably one thing that i'm going to try now so let's let's yeah let's write a simple a simple query here so uh you can see what the graph looks like so maybe i can say okay find me a a band for example oops a music band that is connected maybe to a member right so has member that would be them to remember this would be an individual we can uh say that this typically will be an artist uh and what else um so like these were navigating this uh sequence and then the artist um maybe we can have them connected to track so sometimes when they're uh they're the authors of one of the tracks there's a connection uh called writer so i can say for example writer so is the writer of a uh song right so this would be a song okay so that well that that would be a pattern for example and and i may uh want to do it for example where the band is the business and i can return well one way easy way of returning is putting it this all in a path and return the whole the whole path so if i do that and i have made no mistake b contains um of course b doesn't entail b dot name right that's uh i think that's the name of the band that's the property that uh there you go music name perfect so if i rerun it now i get two paths actually starting at the beatles and uh one is for paul mccartney and the other one is for john lennon and they both connected to uh one track which is how to scout well that's that's one possible uh example of query so what if i want to serialize this as rdf so i can um oops i can take this uh cipher fragment and copy it and i'm going to do exactly the same this time i'm going to do a post request actually i have here this uh rest client which is going to make my life a lot easier so um right let's um start a new one um oops so i had a previous one what i want to do is uh call instead of describe i'm going to be calling um a cipher endpoint right and in the cipher endpoint let me remove this for now uh i need to put to pass the authentication of course uh i can skip the authentication from the browser because it's already authenticated but when you run it from a client of course you have to uh to pass your credentials uh and the body uh is going to be uh um yeah a json structure so we can um add for example uh the query which is what i've just written paste it and uh well that should on its own produce some results hopefully here we go so we're getting the result of that query basically what we saw visually here but now serializes rdf so we get the hell to skeletal song with the length the name etc etc and the link to the beatles and join poll so oh good so far pretty much like we did before you can change the the the format and say well i've done turtle by default let's say json ld uh and just the same query should produce a different serialization this time in json only so that's some the kind of the flow the input and the uh input and output now um yeah i was mentioning before that one of the things that we can do now is uh use rdf star so how can we uh simulate that well this data doesn't because it's the result of importing rdf it doesn't have any any attributes in relationships but we can we can do that pretty easily so we can say for example uh i don't know let's um let's say when we have a uh a song and a writer we can have some sort of role or the level of involvement of the of the musician in that uh so i can do something like and and we can encode that in the in the right relationship saying that this is the writer but he wrote the lyrics so he wrote the music for example something like that so i'm going to do an expression that finds a song and the song will be connected to the authors through the writer relationships so these will be the author and i'm going to specifically say that for this is um held skelter i'm going to say hs dot name contain skelter and also and the author um the name is for example uh uh or contains as well i can use equals but uh it's sometimes i you need to match the let's let's say for example john lennon we can get the the the name from here so i can say what the name of the author is exactly john lennon let's see if i'm matching it right so good so i'm getting them what the reason why i was doing this is because i want to add an additional uh property in a relationship so uh this is the the writer and it's alias with a w uh relationship and i'm going to say um okay i want to set a property saying that the involvement of john lennon in health scouter was for example and we can name this relationship let's use the same uh namespace so that it's consistent uh let's say roll i'd like calling it role but you can you can name it the way you want or according to your schema to your anthology i'm going to say that john lennon's role in that song was he was the author of the lyrics i'm making this up so if you're a beatles fan and i'm saying something ah that doesn't make sense don't angry with me uh right so if i've written my cipher correctly now this should be setting a property so the model hasn't changed significantly i can refresh this query and now we'll see that in hopefully in the relationship that connects uh john lennon to health skelter we see now that there's an additional property one property called music role and it says that he's the author of the lyrics right good so let's go back to our our um query so if we uh run this let me remember yeah that's that's uh uh our query that in the case let's use turtle which is actually we can use n triples which is also pretty readable so if i run this no not much has to be smaller let's go back to turtle um right so uh if i use turtle we see well how to skeletal and and one of the things that we're saying is hang on um there is a relationship between um health skelter and john lennon but we're losing this information right the the fact that his involvement in the in the writing of the song was writer of the lyrics and that's because you know the traditional uh civilizations of rdf do not uh have this possibility you have to find workarounds like i mentioned before like serialization and and all those but now one of the good things that we can do is say okay i want to see related as rdf sort of turtle star which is one of civilizations uh by uh rdf available for rdf star and if i just rerun this hopefully we should see something slightly different and you see that there's an additional triple here at the bottom so all the rest is exactly the same but we have an additional statement which is a statement about the statement so uh it says that uh effectively john lennon is linked to his health scouter through the writer relationship but um in addition to that we have an extra statement which is that his role was author of the lyrics well that might be a small thing but it's i think it's pretty significant it's important because it's a um a great and simple and intuitive way of of serializing things like uh uh relative properties in in relationship let me have a quick check uh see if there's any any questions so far um good no no question so well that's that's that's the the the first um one of the ways in which you can uh leverage this um this new feature of course you can you can import it as well so let's say uh and actually we can probably eat our own dog food in a way so i'm going to use this example to show you how we can import rdf rdf star and turtle star in particular so one thing i can do here is i'm going to empty my database everything and hopefully um yeah that should be empty now we still have the index in resource which is good so what i'm going to do now is i'm going to um well let's initialize otherwise we're going to have same error so we have to call uh the config in it so i'm going to use the basics and i'm going to try to input this rdf star so all i have to do as i did before we're going to import via inline uh i'm going to pass the rdf itself and i'm going to say that the format input format is turtle star so i'm going to take here the rdf that we had generated i'm still holding here and i'm going to copy it so let's copy that and paste it here which was one of the modes of operation we can uh um do this inline or a fetch so if i run this uh it successfully imported 15 triples right and because i removed the namespace definitions now it's using ns0 which is the default mode of operation but what's interesting and what i want to show you is that we have let's again reset style we have a song held skelter connected to john and paul who are also connected to the beatles as a note but let's have a look at this writer relationship and we see that as you can see we have successfully imported this attribute of the relationship so simple example it was a rather small one but it kind of proves the the the two-way trip right so you can expose uh properties uh attributes if you want in your relationships as rdf star and and you can also import them right so um there's another i mean here we started with this uh uh approach of you have some rdf i'm going to import it but sometimes and and this is some one of the questions that i keep getting sometimes is you know i have a property graph i have not imported it from any rdf source can i still you know export it as rdf and leverage these kind of capabilities and the answer is of course yes let's do this again so let's empty the graph empty my graph and uh let's take the most uh popular um sample date set which is uh uh the movie database if you do play movies that will bring up this guide and you can uh quickly imported and it's a pretty simple uh dataset so we can for example get um people uh representing either actors directors producers and movies and there's connections between them so we have for actors we have the acted in relationship so for example hugo leaving uh acted in in the matrix and uh and this data set does and of course the matrix will have all the other actors directors etc etc so um this data set already comes with a number of uh um properties in relationships and in particular we use that to model the um the role that an actor played in a movie so for example uh hugo weaving and the matrix was agent smith as you can as you can see down here right and and that's similar to others so um yeah that's a great candidate to uh this is not the result of importing rdf but still you know rdf is a model for data exchange so i can still uh serialize my graph in a in a kind of automated way applying the same sort of transformation by invoking exactly the same the same mode as i showed before so i can do a get request and i can also show that on the um rest client but here i'm going to do http local host again oops sorry localhost 7474. uh rdf is the endpoint my database is neo4j and i can use like 80 before describe which is the simplest one now the problem is i don't have uris because these items just uh uh are not the result of importing rdf but they have a unique identifier which is local to neo4j and that's its internal id i know it's not ideal you know we shouldn't be using the internal id as uh but it's it's it's one possible way i mean we see that that can that can be used in another in another uh way but for now we're going to use the internal id and the internal id of nodes for you weaving you see it's 27 so that's a numeric identifier that's unique for every um node or relationship in the database so if i do that that's going to return a civilization of that actor so what's happened i don't have a formal definition of um of the schema right i did not define a proper namespace i didn't create an ontology in other words for my schema so i know my uh um i think we can get it uh is that uh schema for visualization so we can see our schema we can say well uh our schema is pretty simple it's a form let's change again my browser is a bit silly with the presentations uh but uh yeah we see that schema is pretty simple we have two types of notes two categories two classes would be the equivalent in in rdf uh which is movie and person and there's a number of types of relationships between them but this is this has never been formalized in an ontology so i don't uh i don't have a specific namespace so when i serialize and that's what's happened just here i have to take one by default and and uh and that's the one that neo semantics uses so it creates a a basic one for schema elements and another one for uh uris for identifiers for individuals right so we get that this is their unique identifier of hugo weaving and we have the the rest of the elements um serialized as properties or relationships so uh again if i use the default which is uh turtle i'm not getting uh things like the properties in relationships so when he acted in movies here i know that you know there's a connection but i'm i'm losing the the information about the role he played but again like we did before i can say let's use the format turtle star and hopefully that should produce just like happened before a bunch of additional triples where we have okay for each involvement in a movie so we know that hugo acted in this movie called 32 i don't know which one is this but i could write a cypher query to return it uh well he we know not only that he played a role in that in that people we know which role that is so in uh 32 in particular down here he played agent smith sorry so that's obviously the matrix or maybe one of the different releases maybe one of them but yeah that's um that's uh how we can uh serialize rdf star out of um of neofj in a pretty straightforward manner good so i hope that was that was useful i don't see any any questions uh but if there's any feel free to write there so that's that's i would say the main the main feature that we've included for the one i think that's um that's an interesting one so one uh one i was looking at uh conversations in the rdf star um distribution and list and and people were asking for data sets so here you have a an easy way of generating um data sets um from neo4j i mean you load data that you may have and you can just export it as uh if you can serialize the whole graph of course you can write a simple cipher query that returns everything and you can use that pretty much the way i i explained before um good what else can we do so um um that's um about rdf star so one of the thing that was included in four is support for shackle right shackle is a is a vocabulary it's a way of defining constraints shapes as they call it in your graph which is a convenient way of defining what how you expect your graph to be what you expect it to to be structurally like and be able to run automated validations and and detect uh violations of these constraints so that's one thing that we found really interesting and and was included in in four and we've added some uh some extra coverage because uh um it was not uh full in in the initial version so i'm going to show another example uh one example based again on the on the details beatles dataset on how we can use it in um in neo4j so uh yeah let's uh refresh that so we get a clear browser i'm going to also empty my database of course i have to use the same variable so we have an empty database now and um right so let's see what that looks like um so in my repository the one where i show you the data set about ethels if you go i'll share all these links at the end of the session with with you all uh but uh in the folder there is a um in the audio folder this what's called music shapes so you have a shackle again shackled it serializes rdf so uh this is a definition of some constraints on that model so it's essentially different from from an ontology for those of you for those of you who are not familiar because those of you who are familiar you probably know this but it has a completely different semantics if you want an ontology does not constraint constrain your model it's not built to enforce a structure as traditional constraints in relational databases do but it's more like an inference-based definition so what the information in your ontology will make it possible for you to derive additional information or even detect inconsistencies uh semantic inconsistencies on your data what shapes do is exactly the the traditional thing is like oh when you create a band let me read this first example when you create a uh an instance of of a band right that's what i'm saying uh by target class band so when we create an instance an individual of type band uh you have to make sure that you comply with these constraints and and the one we're defining here is a constraint of type uh cardinality right so it's telling you uh that property uh name right which is one of the properties that a band can have will have a minimum cardinality of one and a maximum cardinality of one in other words what we're saying is that a band can have only one name i don't know if there are exceptions to that rule maybe there are but that would be a a an invalid uh case in our database so that's the type of constraints and there's many more so for example you can apply also to uh to relationships not just the property so you can say that a band can only have a certain number of members that's a that's a silly one but it's it's it's an example right so it's telling us basically that uh uh the member relationship uh these two constraints here will connect to an individual of type artist right so it has to be of that type as opposed to the ontology meaning where you would say well if if a band is connected through something to something through the member relationship then you can derive that it's an artist in this case we're saying the the element at the other end of the member relationship has to be an artist if not that would be considered a violation of this constraint and again i'm i'm setting some cardinality constraints saying that uh the number of members in the band have to be between two and four which just uh as you can imagine to to generate some some errors and be able to pick them up in the example now that's more right so you can define things like uh constraints on data types you can find constraints even on regular expression based uh uh constraints to to define the station the the the yeah the shape of a string value or a numeric value so um i won't go into the details of what can be done but this is just one example and like i did before i'm going to use the raw format to import it in fj so one thing i can do uh is um right so um is import these shapes so um that's uh like we saw before there's an input and and as usual there's the fetch and the inline so i could uh i'm going to use the fetch in this case it's again serialized as turtle and the url is the one that i just got right so i should get an error of course and as usual oh what's the um unrecognized yeah wrong civilization turtle but the arrow that i was expecting no it's not that's good do i have a oh i already had a config good let me um actually to again add detach delete and rerun it to make it more clear actually maybe what i should do first right so let's uh let's create the config initially because um well not that it's critical because it's it's um actually not um uh as you can see we can import it before defining it but i'm going to rock to go with the same approach as before but with slight difference and let me show you what i mean so one of the things that i can do uh is uh ignore the uris and i'm going to use this example to to show you how to do that so i can pass some i can override the defaults when i create a configuration and for example say that i don't want uh the namespaces your eyes to be shortened like happened before but i want to go with the ignore option which essentially means that i i don't i don't want the prefixes i don't want the uris just keep the local name and ditch the rest so uh yeah if i said that we see that this has been updated to ignore and now i can both import my constraints and my data let's run that again when i import the constraints um right so we have um as you can see a listing of all the constraints in in the document that i just showed you before this one here and well it's more kind of a more human readable uh version of it so we say that there's a constraint on on the album where the date has to be of type uh date right so we can specify the data type of a particular property uh also the cardinality the mean and the max have to be one and only one uh the the track from album has to connect to a class of type song well you see that that's kind of a tabula a listing of the of the the constraints that we have created now i'm going to import the data uh and we i'm going to do exactly the same way as i did before uh rdf input fetch and i'm going to use the same url and the realization let me get back to my beetles and rolling stones file which is this one here again i need to get the raw format of it and pass it here hopefully yeah that imports the 53 triples and you will see that when we look at the graph that it looks slightly different than before so now we have a band but it's uh there's no prefix like we saw before and uh yeah we've lost that piece of information which is fine in some cases maybe not so much in in others but just for this example to show that both are possible i i went with that one right so um good so um i have data and i have a set of constraints that have been imported and in the process of importing they're kind of compiled in a kind of in a way that can be uh run against my my graph and the way to to run this validation is by calling um a shackle validate method that one at the top and what this method will do is we'll take all the rules and apply them to the existing data set and produce a summary a listing more than a summary a listing of all the violations and we said there's one one that applies to this particular node and and it's a band and it's uh breaking on the maximum count constrained component that's uh you know the shackle kind of precise term but essentially what's happening is that the property of the relationship in this case member uh is uh connected to too many uh individuals so it's a cardinality that's not accepted according to our constraints so if i release them if i click list list my shapes we saw that a band could have uh and this is these two here oops i didn't mean to do that mack is being so there's a minimum count of two and a maximum of four as you can remember and of course we have the the rolling stones who are five so that produces a uh violation now that's uh kind of a a batch if you want an after the fact validation that you run on on your graph which is fine it's uh it's useful actually let's let's um let's do uh let's show how how this is completely dynamic so this validation is run on the fly so i could either either create additional constraints or i can fix the problem and i can say well let's let's cut uh i don't know i don't want to be mean but let's take for example bill uh wyman so let's take him and let's remove it from the graph right so we can say that there's an individual which is an artist uh actually we can do it like that where a dot name contains what let's see if i'm doing it right good so i'm going to just rather than returning i'm going to remove it i could disconnect it from the stones actually would be uh also possible actually let's do that rather than deleting it so we'll see that the artist will be connected to something relationship and actually this is the po predicate object since we're talking about rdf um and we can say uh delete p delete all the relationships that we may find basically that's going to leave if i made this right it's there was only one so we should still have uh the node representing charlie watts so it's still there but now it's an orphan node so it's not connected to anything else which is probably good because uh that was the constraint that was uh failing so if i rerun it i have a clear list of um validation uh violations so there you go so that's um i think i'm gonna stop here because it's uh most of the time that i had assigned let me see if i have any questions uh good um nothing uh specific about this so um yeah i will probably not going to show it now because it takes a a a couple of minutes to set up and i'm not sure gonna have time but and do and i've shown how to run the validation um well let me show some functions um you can um you can validate a specific set so you can uh select a bunch of nodes and just apply the validation to those nodes right so you can have it as part of this would take a list of notes here so you can have in your cipher you can have a previous match expression where you decide how to uh select some of these notes you pass them into a variable and then you can then apply your validation to just the subset of your graph that would be a way of working in in large larger data sets that said uh it's pretty performant so i i suggest you give it a try with large datasets because it's the the engine the validation engine tries to be clever and um and identify the bits of the graph that are affected by the validations by the constraints in shackle and um yeah so i think performance is quite decent the other thing that i wanted to mention is that not only you can define the subset of elements to which you want to apply the the validation you can also also have it run and applied transactionally and let me show you what i mean by that because um i'll go to the documentation of for the zero and if you go to the validations in shackle this pretty much goes over what i just said so it shows you an example how to import the rdf uh how to import the constraints and then how to um how to run the validation so that's exactly what i i just did right so and this is the result in this particular example and how you can constrain it just what i was saying this works on the movie database so you can take it as an example and run it but the interesting one is validating transactions so what i want to do and what i want these transactions these validations to be applied is not after the data has been persisted in the graph but as it's written to the graph so i want it i want my transaction my right transaction to be validated on the fly and only if no constraints are violated then i commit my transaction and i persist the data in the graph if there's a violation the transaction is rejected it's rolled back and no changes are applied to the graph guaranteeing consistency so in order to do that you have to combine uh neo semantics with apoc apoc has a capability which helps you defining triggers right so what all you have to do is literally copy that line here um and as is so this method exists already in your semantics and what will happen uh is that when you write uh to to the graph and that will be a normal write operation it doesn't need to go through new semantics it can be a simple creation of a relationship for example in this case here i'm i'm saying that emil is acting in a play but i had said before in my constraints that acted in has to connect to a movie because it's my movie database so that throws an error a transaction error and then you can get the details pretty much like we saw before but in the uh as a detail of why the transaction was failed so i'm not going to do that now because we're running out of time but uh that's uh definitely one very interesting way of using it in a more transactional fashion good so um there seems to be a couple of questions let's go through them so uh you can import lw with new semantics and have uh drivers to work with j or you could call the new semantics functions yeah absolutely yeah one of the reasons one thing um now that i'm one method that was included um uh do we have um is uh let me write here is uh spo so that's an export um let me see i can't remember that was the way yeah that's uh so basically that's the traditional way the triple pattern base to access the data so it's a it's a way of serializing as triples uh but uh using uh uh you know this subject predicate object spo way of of constraining my uh my my results so i can say give me all the results where the subject is the beatles right so i can set the subject and i will get a subset of these triples but only the ones where the subject is the beatles or where the object is the beatles right so we can and and the reason why this was included is because this is enabling so there's only one where the white album is and i was saying that this is useful because this will enable interoperability with other other drivers so i've done a lot of work with rdf4j and probably if you write java code using rdf4j you will want to not necessarily know that neo4j is behind you want to interact in in this in this kind of mode and that's that's something we're working on at the moment and the same for rdf lib i don't know if i can show a simple example here but uh i hope that's readable so if you're familiar with uh rdf lib which is a python library to to work i think it's the most popular out there to work with rtf so you can write rdf lib native code uh but defining uh your graph as backed by neo4j so we've created a store rdflip store based on neo4j and you can if you look at the code you can write to the graph as you would in a normal with rdf lit but behind the scenes this is sending write requests through new semantics into neo4j so uh probably that's uh just a a very uh quick mention of it i'll talk more about it in in in future sessions but that's uh that's one of the reasons why uh we included this uh spo way of interoperating with the with the graph more questions um uh is the uh would it be possible to import owl in fj uh embedded in java applications yes i mean because uh from java applications and this i invite you to go to uh this um repository i mean it's more python java but um yeah from java you can interact with um with uh with neo4j using the the java driver you can get from our downloads page and and you can communicate pretty much in the same way we did today so you can uh you can write uh uh cipher fragments and pass the you know the owl if you want from your um java applications and same with python i was going to refer you to a repository that i created with some python examples the problem is they're based on um on 3.5 but a few python examples here we are so if you go to jbarasa which is my user and you will find a repository called new semantics python examples so they're based on 3.5 so there might be small changes in the syntax um but you have a bunch of examples there when that shows how the kind of things that you can do from python code interacting with the with the neo4j driver that's again interacting with neo4j with the neo4j python driver the approach that i mentioned before based on on rdf lib is completely transparent so you would be writing rdf leap code and behind the scenes it will be persisted into neo4j good another question uh can uh database oh yeah i didn't mention uh there is a graph a graph app today all the session was based on rewriting code in the browser but we have a very cool app let me bring it quickly here so these i'm running my uh nifty instance from the browser so and one of the things you can do is start the new semantics app so these um will help you doing a lot of things that we've done today so for example it will help you defining namespaces right you can do it from a nicer ui you can define mappings which we didn't touch today you can import your your validations you can do previews like we did we can do uh input and it will generate for every request it will generate the cipher in case you want to copy it and reuse it so it's a very didactic application it's oriented to people who are starting with new semantics and and yes i totally recommend that thanks for mentioning it does neo4j implement an owl reasoner no it does not i intentionally stayed away from implementing a full general purpose inferencing engine there are some basic uh elements of of for inferencing and and it's based on on subclass of type of relationship so kind of transitive closure type of influencing so i would recommend you go to the manual again and uh the it's very limited but might be worth having a look so you can uh figure out how you can derive uh types uh based on on subclass of hierarchies and and things like that but it's pretty limited and and that's something i want to listen from the community on what would be useful because i want to um yeah i i think we want to be prudent on that i mean there's uh i think there's a lot of value in what we have and and uh and there's uh general purpose reasoning engines out there uh there's one by a partner company called derivo that can connect to neo4j and run i don't know if it's full or owl or rdfs so some variants of it where you can leverage that but at the moment no new semantics does not implement a full owl reasoner where to find the libraries for developers i'll what i'll do is probably i can't reach out to the attendees or maybe this video will end up i guess either in twitch or in youtube so what i'll do is i'll paste all the links to all the elements to the libraries uh the examples the manuals and all the relevant information so i'll i'll do that what else um what language do you use um oh yeah that's a question for uh yeah i think uh we've covered i know if i missed any question but if i have uh of course i would strongly recommend you come to the community uh site because we have a section a very active section on um uh where is it is it integrations down here there you go link data rdf ontology etc etc so there's uh lots of interesting questions that i'm sure will help you but if you have any that we haven't covered today uh i'd love for you to to share with us here in the community side and we'll we'll answer it there so i think we're we're done for today thank you very much for the interesting questions hope it was useful and and see you in the next one sometime soon thank you very much 