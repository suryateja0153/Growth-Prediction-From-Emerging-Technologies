 Moving along. Our next talk is from probably a familiar face. It is Dr. Kate Compton AKA galaxy Kate. KATE COMPTON: My shirt has cats on it. EMCEE: I would normally yell let's see the Cat but we can see this. Long time inventor and programming and artist. She wrote the first paper on procedural platforms levels, generateded the plan for spore and created the language tracery and invented an early phone base AR system and currently works as an Open Source researcher. Her mission is to design artificial intelligence to augment human creativity and create tools that bring AI into the hands of poets, artists, kids and weirdoes which I think is so in line with what Roguelike Celebration is all about. Cannot wait for you to share this talk with us. KATE COMPTON: Today -- if you like the slides for this, there are a lot of cat pictures -- EMCEE: We don't have slide yet. KATE COMPTON: Sharing the screen is important. EMCEE: It is important to share the screen. We like sharing here. There you go. There is a kitten. Take it away. KATE COMPTON: There is a kitten and a tiny URL and I would like to call out a thanks for the center for research and Open Source software which funded me for the last year and a half on the stuff I will be presenting today or the second half of the stuff I will present today. The first half is about programming languages in general. I am Kate Compton. I made the planets on Spore and tracery.js which runs a bunch of Twitter bots and stuff at this conference. I do a lot of outreach and creative computing. If this were a normal conference I would have a bunch of stickers and shoving them at people. And I recently got my PhD from UC Santa Cruz and actually the bio I gave Alexei is slightly out of date. I am now an assistant professor of instruction at northwestern university where I am going to teach a lot of students how to make weird generative things and they are not going to know that's weird. I know there are a couple of them in the audience so hi. There is my website and GitHub if you want to folk around in those. Kind of my Speciality is I have been thinking about this a lot. I have a motto. I think everybody should have a motto and I have workshoped mine and it is bringing AI to the people that AI doesn't deserve which is very important to me. One thing about it is I am not bringing people to AI. I am not demanding people come and learn AI. There is a book called unlocking the club house which is all about how computer science has often locked people out. That suggests that the right thing to do unlock the club house and bring everybody in but a lot of people are actually perfectly happy where they are so I am trying to progress the takeout model of AI and computer science where people come to AI and computer science, grab what they want and go back to their daily lives. And people that AI doesn't deserve, I just think that people are awesome and AI is somewhat a bit of a trash field so really trying to do that work. My Speciality seems like figuring out the 95% of the fun you can do with only 5% of the required knowledge. Knowledge is fractle and there is too much of it to learn. If you can get a lot of fun without taking seven years of a PhD that's pretty good. I have given lots of talks on things like how to do practical low effort PCG. I was at the Roguelike Celebration four years ago and was like how do you do a lot of setup stuff without trying too hard? How do you do triple A content generation? I did a talk on muppets and ballroom dance and I know this much about muppets and this much about ballroom dance. I gave a talk on Thursday about sociology and how hanging out online is making us become more creative together. My talk today is about to get you to 95% of the fun programming languages with only 5% of the knowledge. These are super weird programming languages people have come up with. If you Google what are the weirdest programming languages there are a lot of stuffy one. There is cat speak one and one that is programmed entirely in colored pixels. One that is just different amounts of the word chicken. And there is things like if you want to really see somebody at the top of their game, Martin Clapet gave a wonderful talk at JS Conf Iceland a few years ago. Those are symmetrical programs and he talks about how he made them. There are a lot of languages you have been exposed to and why would you write more? We have Java, JavaScript, C++ and you write a four loop and does the world really need another four loop? The nice thing about programming languages is not all of them have to have four loops. Languages don't have to all be trying to do the same thing. On the right is an example of a program and you can argue about whether or not this was a program. The gist of this talk is this is a program and this is a program -- I can't read this but I think this is a program for some amount of sims hacking. It turns out the Sims had a bunch of their UI and a bunch of their AI stored in external files or files you could get access to. Even from the Sims 1 people were able to take these programs, which they were, hack them, edit the programs and reupload theme the Sims. This got people hacking tiny programlets which was great because otherwise -- especially back in 2000 it was very difficult to edit a program on the fly. Domain specific language making, the point there is you can do languages to make four loops but you can also just make a language that expresses how Sims object work. The Sim language object had a whole thing about what it was advertising versus what it would provide. There was a cigarette table somebody made that would advertise to you that it would make you less lonely but it didn't actually do it. People would go smoke forever at the cigarette table. But domain specific language making is kind of addictive. I have made or ammaking tracery, tracery 2. Chancery which is fairly well developed in greenery which is mostly a glimmer in my eye and speculative syntax stuff. All these languages are a way to think deeply about a subject. When I I am working on greenery I am thinking about what is an idle game and what word do I need to represent and what are the unit operations of an idle game or a Roguelike that I can't express in Python? Like what are the things that should be first-class words in my language? These are all under instruction because every time where get close to finishing a language I start a new language. You may already be writing a programming language. If you have written Roguelikes you have probably written the following things. If a computer uses a file to control program flow that file is a programming language. If you have come up with your own weird safe file format you have constructed a programming language. It might be a special programming language that only represents things in your weird game like this is a programming language with the first class function for the number of eggs you have or certain macros that make things easier but that programming language is a meditation on what your game needs and what your game is about. So you have decided to make a programming language or realize you are making one. The sensible person would ask a trained programming language person. I tried this. They are nase nice people and mostly talk to other experts. When you say I am working on a programming language what should I do? They will info dump on you with a lot of terms that don't actually represent the hard thing you are dealing with. This talk is really a delataunt teaches delataunts about programming languages. It is hard to find non-ableist word for people who have a lot of other stuff going on but you still want to talk about a programming language. Welcome to the five minute very raw certificate course. By the end of this you will have your very own certificate. What's in a language? What is a programming language? If I say JavaScript what is that? There are things like programs. You have programs in this language. It is code although we can talk about what code is and we all know what code looks like. It looks like that except a lot of times it looks like this. This is JavaScript from the U.S. tracery. It can also look like this. This is actually a tracery program or what we would call a grammar. This is a program. It is not what's called a turing complete program for a turing complete programming language but it controls the computer in some ways so it the program. More specifically it is the kind of program that controls how things are expanded which is what I want a tracer to do. Here is a program. This is the HTML for the Roguelike celebration. HTML is also a program. It is technically turing complete but nobody cares. It is still a programming language. I would normally ask you to raise your hand if you recognize this. This is star view value configuration files. This is how you get custom content in your star view value. These are also programs. And sometimes it can be XML, JSON, or custom weird text formats or they could even be binary code. There are things like Alan Key's grail and Max MSP and twine. These are also graphical or visual programming languages. These have been going on since I believe 1968. You can write programs in these weird formats. You may have played with Scratch which was another visual programming language. When you go to save these, some you can't download from the original program and if you download it looks like the thing on the back and it is meaningless garble. A parser is another one. It will chalk that up and turn it into basically a tree of structure. This is very similar to like having a sentence diagram. And you often have to deal with trees of nested syntax. Like the lower line X plus F hashtag test foois a nested tracery syntax that I am currently dealing with having to parse that and turn that into a tree. It is like an expression with a string inside which contains some hashtag syntax for tracery which contains another expression. There are things like compilers and interpreterss and these turn the parse tree into something else. What else we don't know. It might be another language or something digestible or runable by a lower level system. You might have thing like you can run all these new programs in your web browser. Something called enscripten takes these older programs and translates them into what is you JavaScript and you can run it in the browser. I forget if that is a compiler or what but we are taking code and digesting it. And engine. You need to do the thing. Flash player has an engine. If you have a web page each major browser has a possibly couple engines it uses for rendering. V8 is what Chrome uses to render JavaScript and it is considered very good. You will have an IDE which isn't considered part of the language but this is where people write the program. You can have things like processing where people are writing the program in the same place they run the program. This is an IDE and engine alltogether. Often IDEs have a bunch of cool functions. They have linting which is like checking for errors dynamically, autocompletion, code coloring, modern IDs may have things like if you rename a variable it will go through the code and rename the variables out or more. There are a bunch of other cool things IDEs do we don't notice. Things like social sharing. Cat Manning, I have been teaching her coding on glitch and we are having a lot of fun but this is an IDE we can edit the code at the same time and share the code and look at other people's code. GitHub is an IDE speak of fight me. We deal with the Unicode standard commonly. This is a specification of what emoji are there and how do we construct new emojis out of old emojis. There are talks about getting a dumpling emoji into the process. How do you find the room with the guys on the right and tell them yes, we need a dumpling emoji. And tools. You can host tools anywhere. They might be code, might not be, might be tutorials. There are APIs. There are tool integrations. So the bottom right is a spreadsheet bot I created on art.club and it loads a Google spreadsheet from a JSON end point and slurps that up into my website and parses it out and uses that to create the grammar. Here is the stuff in a language. Depending on your language different parts might fall into different parts and different programs. If we are talking about HTML, I might edit and it might be a text editor. The specification is controlled by the W3C and my engine and parser and compiler are all in Chrome. There might also be other parts of this ecosystem. I might edit things in dream weaver which compiles whatever the dream weaver format into an HTML page and my engine might be new at this. I might feed them into neo pets web page. Things like processing you have specifications. Controlled by processing and the processing IDE and the processing engine. This is all controlled by one group even though they are open standards and things like regular expressions which are a very small language. Sorry, I am running behind so I am going to scoot through this fast. Yeah. Like there are different places that regular expressions are and in fact because regular expressions are so common people have made engines in every other language. Every other language embeds a tiny engine for regular expressions. What's a language? There is a bunch of stuff. Who is in control of this? Maybe the original source author, corporations, volunteers, it is made out of a bunch of stuff because it is an ecosystem of connected components. A language is all this stuff. You have had my five minute raw certificate course. Now we will talk about how to make all that polite. Languages have formal properties. This is something if you ask a programming language person they will get excited to tell you the formal properties of languages. Most of it is important but it is not important so much we do it now. They have a lot of informal properties like is this a good language? Do I like this language? Does this language play well with others? It is hard to prove things about that. Things you might want to say are like this language is easy to write. I remember what my program does after I have written it. I can use the language in strange places. If you learn Lua it was originally made for Brazilian power plants but it is also in roadblocks so you can use it in a lot of places. This language can run on my machine. That may seem obvious but if you only have a bad cellphone that may not be true. Here is the Compton completeness theory. You can construct in an hour using device you had on hand and connect oo a platform with meaning. Tracery is not complete. However, tracery with artbot.club or the spiral editor and with Twitter and with cheap bots done quick all those help complete the ecosystem. There are programming languages and the way we write programs. We always have to consider the environment. Yeah, a programming language and importantly its ecosystem can be more or less polite. I am going to quickly tell you a couple properties of polite ecosystems and things to get you toward Compton completeness or to have the language people pick up. The first one is and there is lots more about this in my dissertation if you like to read lots of stuff. The first one is scaffolding. What does mean to have a scaffolding language? Often if you start a language you might open up, say, the vy editor and nothing is telling you what to do. You don't know what you are supposed to do or if you are doing something wrong. Scaffolding can be showing you all of the parts and code completion or code coloring. You have typed a line and it auto indents so you know that line was actually right. There are things called structure editors which are really interesting and these are things that are so scaffolded like scratch that you literally can't get an error. You cannot in fact make a scratch that doesn't compile because not only do you only have access to the pieces that will work those only snap together in ways that will work so it is a really great entry level for people who don't want to deal with errors right now. Maybe scratch programmers will deal with errors later. That's not the problem now. They will make princess elsa do a cool snowflake thing. Tracery. I have made a bunch of tracery editors but I also want to move on to unfoldables. An unfoldable language you might recognize as in HTML you can type plaintext and say this is my web page or bold web href page. If you imagine each unfolding takes 5 minutes to learn or years to learn. By the time you get to the one at the bottom you might be getting fairly involved with HTML. Tracery works like this where a lot of people write hash tags but I am getting complicated syntax. This is how you see in a lot of idle games. Caves of Qud is not currently very unfolded. Little languages can squish in anywhere. If you have a spot this language can squeak in there. We have used the base version of tracery as a thing students can learn to port to C which is an awful language as an introduction assignment. Can you call it asynchronously? Can you run user provided code safely? Tracery is mostly safe. Cheap bots done quick relies on that. This is something someone made where SVG code and if you have a bot you can get it to load exciting stuff from the internet. I want to go over tracery journey to modularity in the last 10 minutes. It starts off on JavaScript and moved to a section of tracery that parsed stuff. It parsed the syntax. The code was a JSON file which was great. I gave a talk on how much I liked JSON. I broke things out into an engine. George buckingham could use it to make cheap bots done quick. You run the tracery grammar and get grammar stuff. I made a bunch of tools. Some needed a compiling step and some didn't. Most of those were never that useful but I got good papers published out of them. I did a whole bunch more parsing and I wrote these things at the bottom which are called and I don't know if you can see my mouse but these are called railroad diagrams and they are ways to explicitly model what your program syntax is. This is like getting towards a tracery specification and completely not done that because I keep iterating on the overly complicated diagrams. I did a bunch of cool parsing up in this corner. I did cool compiler visualizations of when the tracery grammar is compiling and running and this is what's going on. I tried to write the parser and that took a long time but you can feed it in what your tracery like language is. Why should I write a tool for tracer which I could write a tool for all theoretical tracer like languages. This outputs generative data. Generating programs in a recently generated language which I can automatically create an editor for. This was way overly complicated and probably not that useful until I changed directions after this. Then I deducted a bunch more parsing and some more parsing and really, I just did too much parsing because parsing visualizations are really -- like I have gotten to a place where I am happy and need to start writing more parsers. You can combine all these things into one web page. These are art bot club which is the tight -- site I am working on to make a nice non-Twitter hosting place for bots. I have my parser in the middle and an IDE on either side. It has browsing tools so you can browse other's people stuff and edit examples. It has a lot of pretty cool stuff going on. And chancery is something I have been working on recently which is a chatbot making language. You can see the IDE I published at Google. It was open source by Google while I was working for the Google Assistant. It has a simulator and a diagram of the state map and it has got some other interesting visualization stuff. This is again a language IDE all smashed together. It was too smashed for anybody to pull anything out saying I just want the simulator and now I have broken it into further sections that now you can get the engine where it stimulates a chat. There are cool things you can plug in. Again, this is all talk to me after the chat because like a lot of the stuff is free as in mattress. Free as in beer, free as in mattress and yes, you can download and play with it. This is all documented inside my head. You can write things that have attachments to somebody chatting and posting images. And yeah, just as a final last thing. There is a case study and I also use this to do a contract gig for a Swedish ambient album where there is a mid century poem that some Swedish ambient musicians wrote about and made a character and I made a virtual character that hooks into chancery. I will talk about how it does that in just a moment. You can go here and go to this website. This is a virtual character using chancery which also uses tracery to generate text. Why does this work? Because Blackboards which are a concept of AI which mean a space that every program can read from and write to in their own way. EMCEE: Just because we are running short on time. So sorry, Kate. KATE COMPTON: You can also hook up your MIDI controller to a Blackboard and have that control the puppet who is being controlled by chancery. That is my slide. Sorry for running a little long. You can go artbot.club and I am giving an exercise next Tuesday where we will program a bot together. If you want to join that, please do. EMCEE: Thank you so much and yeah, I hope that we can get a bunch of those links and tweet them out because that's a lot of great stuff. Just wonderful as always. There is quite a few questions and no time to get in there.  I will be in chat. 